-keep class apple.laf.JRSUIConstants {
	*** getConstantName(java.lang.Object);
	*** getHit(int);
}

-keep class apple.laf.JRSUIConstants$AlignmentHorizontal {
	*** CENTER;
	*** LEFT;
	*** RIGHT;
	*** alignmentHorizontal;
}

-keep class apple.laf.JRSUIConstants$AlignmentVertical {
	*** BOTTOM;
	*** CENTER;
	*** TOP;
	*** alignmentVertical;
}

-keep class apple.laf.JRSUIConstants$Animating {
	*** NO;
	*** YES;
}

-keep class apple.laf.JRSUIConstants$BooleanValue {
	*** NO;
	*** YES;
}

-keep class apple.laf.JRSUIConstants$Direction {
	*** DOWN;
	*** NONE;
	*** UP;
}

-keep class apple.laf.JRSUIConstants$DoubleValue {
	*** equals(java.lang.Object);
	*** getTypeCode();
	*** putValueInBuffer(java.nio.ByteBuffer);
}

-keep class apple.laf.JRSUIConstants$Focused {
	*** NO;
	*** YES;
}

-keep class apple.laf.JRSUIConstants$Key {
	*** getConstantPtr();
}

-keep class apple.laf.JRSUIConstants$Property {
	*** encoding;
	*** ordinal;
	*** value;
	apple.laf.JRSUIConstants$Property(apple.laf.JRSUIConstants$PropertyEncoding,byte);
	*** apply(long);
	*** toString();
}

-keep class apple.laf.JRSUIConstants$PropertyEncoding {
	*** mask;
	*** shift;
}

-keep class apple.laf.JRSUIConstants$Size {
	*** LARGE;
	*** MINI;
	*** REGULAR;
	*** SMALL;
	*** size;
}

-keep class apple.laf.JRSUIConstants$State {
	*** ACTIVE;
	*** DISABLED;
	*** INACTIVE;
	*** PRESSED;
	*** PULSED;
}

-keep class apple.laf.JRSUIConstants$Widget {
	*** BACKGROUND;
	*** BUTTON_BEVEL;
	*** BUTTON_BEVEL_INSET;
	*** BUTTON_BEVEL_ROUND;
	*** BUTTON_CHECK_BOX;
	*** BUTTON_COMBO_BOX;
	*** BUTTON_COMBO_BOX_INSET;
	*** BUTTON_DISCLOSURE;
	*** BUTTON_LIST_HEADER;
	*** BUTTON_LITTLE_ARROWS;
	*** BUTTON_POP_DOWN;
	*** BUTTON_POP_DOWN_INSET;
	*** BUTTON_POP_DOWN_SQUARE;
	*** BUTTON_POP_UP;
	*** BUTTON_POP_UP_INSET;
	*** BUTTON_POP_UP_SQUARE;
	*** BUTTON_PUSH;
	*** BUTTON_PUSH_INSET;
	*** BUTTON_PUSH_INSET2;
	*** BUTTON_PUSH_SCOPE;
	*** BUTTON_PUSH_SCOPE2;
	*** BUTTON_PUSH_TEXTURED;
	*** BUTTON_RADIO;
	*** BUTTON_ROUND;
	*** BUTTON_ROUND_HELP;
	*** BUTTON_ROUND_INSET;
	*** BUTTON_ROUND_INSET2;
	*** BUTTON_SEARCH_FIELD_CANCEL;
	*** BUTTON_SEARCH_FIELD_FIND;
	*** BUTTON_SEGMENTED;
	*** BUTTON_SEGMENTED_INSET;
	*** BUTTON_SEGMENTED_INSET2;
	*** BUTTON_SEGMENTED_SCURVE;
	*** BUTTON_SEGMENTED_TEXTURED;
	*** BUTTON_SEGMENTED_TOOLBAR;
	*** DIAL;
	*** DISCLOSURE_TRIANGLE;
	*** DIVIDER_GRABBER;
	*** DIVIDER_SEPARATOR_BAR;
	*** DIVIDER_SPLITTER;
	*** FOCUS;
	*** FRAME_GROUP_BOX;
	*** FRAME_GROUP_BOX_SECONDARY;
	*** FRAME_LIST_BOX;
	*** FRAME_PLACARD;
	*** FRAME_TEXT_FIELD;
	*** FRAME_TEXT_FIELD_ROUND;
	*** FRAME_WELL;
	*** GRADIENT;
	*** GROW_BOX;
	*** GROW_BOX_TEXTURED;
	*** MENU;
	*** MENU_BAR;
	*** MENU_ITEM;
	*** MENU_TITLE;
	*** PROGRESS_BAR;
	*** PROGRESS_INDETERMINATE_BAR;
	*** PROGRESS_RELEVANCE;
	*** PROGRESS_SPINNER;
	*** SCROLL_BAR;
	*** SCROLL_COLUMN_SIZER;
	*** SLIDER;
	*** SLIDER_THUMB;
	*** SYNCHRONIZATION;
	*** TAB;
	*** TITLE_BAR_CLOSE_BOX;
	*** TITLE_BAR_COLLAPSE_BOX;
	*** TITLE_BAR_TOOLBAR_BUTTON;
	*** TITLE_BAR_ZOOM_BOX;
	*** TOOLBAR_ITEM_WELL;
	*** WINDOW_FRAME;
	*** widget;
	*** apply(long);
}

-keep class apple.laf.JRSUIControl {
	*** cfDictionaryPtr;
	*** changes;
	*** currentEncodedProperties;
	*** flipped;
	*** nativeJRSInitialized;
	*** nativeMap;
	*** priorEncodedProperties;
	*** threadLocal;
	*** disposeCFDictionary(long);
	*** getCFDictionary(boolean);
	*** getNativeHitPart(long,long,long,double,double,double,double,double,double);
	*** getNativePartBounds(double[],long,long,long,double,double,double,double,int);
	*** getNativeScrollBarOffsetChange(long,long,long,double,double,double,double,int,int,int);
	*** getPtrOfBuffer(java.nio.ByteBuffer);
	*** getThreadLocalBuffer();
	*** handleBufferOverflow(java.nio.ByteBuffer,int);
	*** initJRSUI();
	*** initNativeJRSUI();
	*** loadBufferWithChanges(apple.laf.JRSUIControl$ThreadLocalByteBuffer);
	*** paint(int[],int,int,double,double,double,double);
	*** paintChangesImage(int[],int,int,long,long,long,double,double,double,double,long);
	*** paintChangesToCGContext(long,long,long,long,double,double,double,double,long);
	*** paintImage(int[],int,int,double,double,double,double);
	*** paintImage(int[],int,int,long,long,long,double,double,double,double);
	*** paintToCGContext(long,double,double,double,double);
	*** paintToCGContext(long,long,long,long,double,double,double,double);
	*** set(apple.laf.JRSUIConstants$Key,apple.laf.JRSUIConstants$DoubleValue);
	*** set(apple.laf.JRSUIState);
	*** setEncodedState(long);
	*** sync();
	*** syncChanges(long,long);
}

-keep class apple.laf.JRSUIControl$BufferState {
	*** ALL_CHANGES_IN_BUFFER;
	*** CHANGE_WONT_FIT_IN_BUFFER;
	*** SOME_CHANGES_IN_BUFFER;
}

-keep class apple.laf.JRSUIControl$ThreadLocalByteBuffer {
	*** buffer;
	*** ptr;
}

-keep class apple.laf.JRSUIState {
	*** derivedEncodedState;
	*** encodedState;
	*** prototype;
	apple.laf.JRSUIState(long);
	*** apply(apple.laf.JRSUIControl);
	*** createDerivation();
	*** derive();
	*** getInstance();
	*** isDerivationSame();
	*** set(apple.laf.JRSUIConstants$Property);
}

-keep class apple.laf.JRSUIUtils {
	*** isLeopard;
	*** isSnowLeopardOrBelow;
	*** currentMacOSXVersionMatchesGivenVersionRange(int,boolean,boolean,boolean);
	*** isCurrentMacOSXVersion(int);
	*** isMacOSXLeopard();
	*** isMacOSXSnowLeopardOrBelow();
}

-keep class apple.laf.JRSUIUtils$Images {
	*** shouldUseLegacySecurityUIPath();
}

-keep class apple.laf.JRSUIUtils$TabbedPane {
	*** shouldUseTabbedPaneContrastUI();
}

-keep class apple.security.AppleProvider$1 {
	*** this$0;
}

-keep class com.apple.eawt.AboutHandler {
	*** handleAbout(com.apple.eawt.AppEvent$AboutEvent);
}

-keep class com.apple.eawt.AppEvent$FilesEvent {
	*** getFiles();
}

-keep class com.apple.eawt.AppForegroundListener {
	*** appMovedToBackground(com.apple.eawt.AppEvent$AppForegroundEvent);
	*** appRaisedToForeground(com.apple.eawt.AppEvent$AppForegroundEvent);
}

-keep class com.apple.eawt.AppHiddenListener {
	*** appHidden(com.apple.eawt.AppEvent$AppHiddenEvent);
	*** appUnhidden(com.apple.eawt.AppEvent$AppHiddenEvent);
}

-keep class com.apple.eawt.AppReOpenedListener {
	*** appReOpened(com.apple.eawt.AppEvent$AppReOpenedEvent);
}

-keep class com.apple.eawt.Application {
	*** menuBarHandler;
	*** getApplication();
}

-keep class com.apple.eawt.ApplicationEvent {
	*** isHandled();
}

-keep class com.apple.eawt.OpenFilesHandler {
	*** openFiles(com.apple.eawt.AppEvent$OpenFilesEvent);
}

-keep class com.apple.eawt.OpenURIHandler {
	*** openURI(com.apple.eawt.AppEvent$OpenURIEvent);
}

-keep class com.apple.eawt.PreferencesHandler {
	*** handlePreferences(com.apple.eawt.AppEvent$PreferencesEvent);
}

-keep class com.apple.eawt.PrintFilesHandler {
	*** printFiles(com.apple.eawt.AppEvent$PrintFilesEvent);
}

-keep class com.apple.eawt.QuitHandler {
	*** handleQuitRequestWith(com.apple.eawt.AppEvent$QuitEvent,com.apple.eawt.QuitResponse);
}

-keep class com.apple.eawt.QuitResponse {
	*** performQuit();
}

-keep class com.apple.eawt.QuitStrategy {
	*** $VALUES;
	*** CLOSE_ALL_WINDOWS;
	*** SYSTEM_EXIT_0;
}

-keep class com.apple.eawt.ScreenSleepListener {
	*** screenAboutToSleep(com.apple.eawt.AppEvent$ScreenSleepEvent);
	*** screenAwoke(com.apple.eawt.AppEvent$ScreenSleepEvent);
}

-keep class com.apple.eawt.SystemSleepListener {
	*** systemAboutToSleep(com.apple.eawt.AppEvent$SystemSleepEvent);
	*** systemAwoke(com.apple.eawt.AppEvent$SystemSleepEvent);
}

-keep class com.apple.eawt.UserSessionListener {
	*** userSessionActivated(com.apple.eawt.AppEvent$UserSessionEvent);
	*** userSessionDeactivated(com.apple.eawt.AppEvent$UserSessionEvent);
}

-keep class com.apple.eawt._AppEventHandler {
	*** aboutDispatcher;
	*** currentQuitResponse;
	*** defaultQuitAction;
	*** foregroundAppDispatcher;
	*** hiddenAppDispatcher;
	*** instance;
	*** legacyHandler;
	*** openAppDispatcher;
	*** openFilesDispatcher;
	*** openURIDispatcher;
	*** preferencesDispatcher;
	*** printFilesDispatcher;
	*** quitDispatcher;
	*** reOpenAppDispatcher;
	*** screenSleepDispatcher;
	*** systemSleepDispatcher;
	*** userSessionDispatcher;
	*** access$000(int);
	*** cancelQuit();
	*** nativeOpenCocoaAboutWindow();
	*** nativeRegisterForNotification(int);
	*** nativeReplyToAppShouldTerminate(boolean);
	*** obtainQuitResponse();
	*** openCocoaAboutWindow();
	*** performQuit();
	*** setDefaultQuitStrategy(com.apple.eawt.QuitStrategy);
}

-keep class com.apple.eawt._AppEventHandler$_AboutDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt.AboutHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_AppEventDispatcher {
	*** _handler;
	*** handlerContext;
	*** this$0;
	com.apple.eawt._AppEventHandler$_AppEventDispatcher(com.apple.eawt._AppEventHandler);
	*** dispatch(com.apple.eawt._AppEventHandler$_NativeEvent);
	*** performDefaultAction(com.apple.eawt._AppEventHandler$_NativeEvent);
	*** setHandler(java.lang.Object);
	*** setHandlerContext(sun.awt.AppContext);
}

-keep class com.apple.eawt._AppEventHandler$_AppEventMultiplexor {
	*** listenerToAppContext;
	*** nativeListenerRegistered;
	*** this$0;
	com.apple.eawt._AppEventHandler$_AppEventMultiplexor(com.apple.eawt._AppEventHandler);
	*** addListener(java.lang.Object);
	*** dispatch(com.apple.eawt._AppEventHandler$_NativeEvent,java.lang.Object[]);
	*** registerNativeListener();
	*** removeListener(java.lang.Object);
	*** setListenerContext(java.lang.Object,sun.awt.AppContext);
}

-keep class com.apple.eawt._AppEventHandler$_AppForegroundDispatcher {
	*** this$0;
	*** createEvent(boolean);
	*** performFalseEventOn(com.apple.eawt.AppForegroundListener,com.apple.eawt.AppEvent$AppForegroundEvent);
	*** performTrueEventOn(com.apple.eawt.AppForegroundListener,com.apple.eawt.AppEvent$AppForegroundEvent);
}

-keep class com.apple.eawt._AppEventHandler$_AppReOpenedDispatcher {
	*** this$0;
	*** performOnListener(com.apple.eawt.AppReOpenedListener,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_BooleanAppEventMultiplexor {
	*** this$0;
	com.apple.eawt._AppEventHandler$_BooleanAppEventMultiplexor(com.apple.eawt._AppEventHandler);
	*** createEvent(boolean);
	*** performFalseEventOn(java.lang.Object,java.lang.Object);
	*** performTrueEventOn(java.lang.Object,java.lang.Object);
}

-keep class com.apple.eawt._AppEventHandler$_HiddenAppDispatcher {
	*** this$0;
	*** createEvent(boolean);
	*** performFalseEventOn(com.apple.eawt.AppHiddenListener,com.apple.eawt.AppEvent$AppHiddenEvent);
	*** performTrueEventOn(com.apple.eawt.AppHiddenListener,com.apple.eawt.AppEvent$AppHiddenEvent);
}

-keep class com.apple.eawt._AppEventHandler$_NativeEvent {
	*** args;
	*** get(int);
}

-keep class com.apple.eawt._AppEventHandler$_OpenAppDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt._OpenAppHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_OpenFileDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt.OpenFilesHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_OpenURIDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt.OpenURIHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_PreferencesDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt.PreferencesHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
	*** setHandler(com.apple.eawt.PreferencesHandler);
}

-keep class com.apple.eawt._AppEventHandler$_PrintFileDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt.PrintFilesHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_QueuingAppEventDispatcher {
	*** queuedEvents;
	*** this$0;
	com.apple.eawt._AppEventHandler$_QueuingAppEventDispatcher(com.apple.eawt._AppEventHandler);
	*** dispatch(com.apple.eawt._AppEventHandler$_NativeEvent);
	*** setHandler(java.lang.Object);
}

-keep class com.apple.eawt._AppEventHandler$_QuitDispatcher {
	*** this$0;
	*** performUsing(com.apple.eawt.QuitHandler,com.apple.eawt._AppEventHandler$_NativeEvent);
}

-keep class com.apple.eawt._AppEventHandler$_ScreenSleepDispatcher {
	*** this$0;
	*** createEvent(boolean);
	*** performFalseEventOn(com.apple.eawt.ScreenSleepListener,com.apple.eawt.AppEvent$ScreenSleepEvent);
	*** performTrueEventOn(com.apple.eawt.ScreenSleepListener,com.apple.eawt.AppEvent$ScreenSleepEvent);
}

-keep class com.apple.eawt._AppEventHandler$_SystemSleepDispatcher {
	*** this$0;
	*** createEvent(boolean);
	*** performFalseEventOn(com.apple.eawt.SystemSleepListener,com.apple.eawt.AppEvent$SystemSleepEvent);
	*** performTrueEventOn(com.apple.eawt.SystemSleepListener,com.apple.eawt.AppEvent$SystemSleepEvent);
}

-keep class com.apple.eawt._AppEventHandler$_UserSessionDispatcher {
	*** this$0;
	*** createEvent(boolean);
	*** performFalseEventOn(com.apple.eawt.UserSessionListener,com.apple.eawt.AppEvent$UserSessionEvent);
	*** performTrueEventOn(com.apple.eawt.UserSessionListener,com.apple.eawt.AppEvent$UserSessionEvent);
}

-keep class com.apple.eawt._AppEventLegacyHandler {
	*** blockLegacyAPI;
	*** initializedParentDispatchers;
	*** legacyAppListeners;
	*** parent;
	*** blockLegacyAPI();
	*** checkIfLegacyAPIBlocked();
	*** sendEventToEachListenerUntilHandled(com.apple.eawt.ApplicationEvent,com.apple.eawt._AppEventLegacyHandler$EventDispatcher);
}

-keep class com.apple.eawt._AppEventLegacyHandler$EventDispatcher {
	*** dispatchEvent(com.apple.eawt.ApplicationListener);
}

-keep class com.apple.eawt._AppMenuBarHandler {
	*** aboutMenuItemEnabled;
	*** aboutMenuItemVisible;
	*** instance;
	*** prefsMenuItemEnabled;
	*** prefsMenuItemExplicitlySet;
	*** prefsMenuItemVisible;
	*** getInstance();
	*** installDefaultMenuBar(javax.swing.JMenuBar);
	*** isFrameMinimized(java.awt.Frame);
	*** nativeSetDefaultMenuBar(long);
	*** nativeSetMenuState(int,boolean,boolean);
	*** setPreferencesMenuItemEnabled(boolean);
	*** setPreferencesMenuItemVisible(boolean);
}

-keep class com.apple.eawt._OpenAppHandler {
	*** handleOpenApp();
}

-keep class com.apple.laf.AquaBorder {
	*** painter;
	*** sizeDescriptor;
	*** sizeVariant;
	com.apple.laf.AquaBorder(com.apple.laf.AquaBorder);
	com.apple.laf.AquaBorder(com.apple.laf.AquaUtilControlSize$SizeDescriptor);
	*** createPainter();
	*** isFocused(java.awt.Component);
	*** setSize(apple.laf.JRSUIConstants$Size);
}

-keep class com.apple.laf.AquaButtonBorder {
	*** fBevel;
	*** fDynamic;
	*** fToggle;
	*** fToolBar;
	com.apple.laf.AquaButtonBorder(com.apple.laf.AquaButtonBorder);
	com.apple.laf.AquaButtonBorder(com.apple.laf.AquaUtilControlSize$SizeDescriptor);
	*** doButtonPaint(javax.swing.AbstractButton,javax.swing.ButtonModel,java.awt.Graphics,int,int,int,int);
	*** getBevelButtonBorder();
	*** getButtonState(javax.swing.AbstractButton,javax.swing.ButtonModel);
	*** hasSmallerInsets(javax.swing.JComponent);
	*** isSelectionPressing();
}

-keep class com.apple.laf.AquaButtonBorder$1 {
	*** getInstance();
}

-keep class com.apple.laf.AquaButtonBorder$Dynamic {
	*** ALTERNATE_BEVEL_INSETS;
	*** ALTERNATE_PUSH_INSETS;
	*** ALTERNATE_SQUARE_INSETS;
	*** getStyleForSize(javax.swing.AbstractButton,apple.laf.JRSUIConstants$Size,int,int);
}

-keep class com.apple.laf.AquaFocusHandler {
	*** isActive(javax.swing.JComponent);
}

-keep class com.apple.laf.AquaFonts {
	*** lucida11Pt;
	*** lucida12Pt;
	*** lucida13Pt;
	*** lucida13PtBold;
	*** lucida14Pt;
	*** lucida14PtBold;
	*** lucida9Pt;
}

-keep class com.apple.laf.AquaFonts$1 {
	*** getInstance();
}

-keep class com.apple.laf.AquaFonts$2 {
	*** getInstance();
}

-keep class com.apple.laf.AquaFonts$3 {
	*** getInstance();
}

-keep class com.apple.laf.AquaFonts$4 {
	*** getInstance();
}

-keep class com.apple.laf.AquaFonts$5 {
	*** getInstance();
}

-keep class com.apple.laf.AquaFonts$6 {
	*** getInstance();
}

-keep class com.apple.laf.AquaFonts$7 {
	*** getInstance();
}

-keep class com.apple.laf.AquaIcon {
	*** getIconFor(com.apple.laf.AquaIcon$JRSUIControlSpec,int,int);
}

-keep class com.apple.laf.AquaIcon$CachingScalingIcon {
	*** height;
	*** image;
	*** width;
	com.apple.laf.AquaIcon$CachingScalingIcon(int,int);
	*** createImage();
	*** getIconHeight();
	*** getIconWidth();
	*** getImage();
	*** getOptimizedImage();
	*** getProgressiveOptimizedImage(java.awt.Image,int,int);
	*** setSize(int,int);
}

-keep class com.apple.laf.AquaIcon$SystemIcon {
	*** caut;
	*** computerIcon;
	*** desktopIcon;
	*** documentIcon;
	*** floppyIcon;
	*** folderIcon;
	*** hardDriveIcon;
	*** openFolderIcon;
	*** selector;
	*** stop;
	com.apple.laf.AquaIcon$SystemIcon(java.lang.String,int,int);
	*** createImage();
	*** getCautionIcon();
	*** getComputerIconUIResource();
	*** getDesktopIconUIResource();
	*** getDocumentIconUIResource();
	*** getFloppyIconUIResource();
	*** getFolderIconUIResource();
	*** getHardDriveIconUIResource();
	*** getOpenFolderIconUIResource();
	*** getStopIcon();
}

-keep class com.apple.laf.AquaIcon$SystemIconSingleton {
	*** selector;
	*** getInstance();
}

-keep class com.apple.laf.AquaIcon$SystemIconUIResourceSingleton {
	*** selector;
	*** getInstance();
}

-keep class com.apple.laf.AquaImageFactory {
	*** eastArrow;
	*** eastArrowIcon;
	*** northArrow;
	*** northArrowIcon;
	*** southArrow;
	*** southArrowIcon;
	*** westArrow;
	*** westArrowIcon;
	*** getAppIconCompositedOn(com.apple.laf.AquaIcon$SystemIcon);
	*** getAppIconCompositedOn(java.awt.Image);
	*** getFocusRingColorUIResource();
	*** getGenericJavaIcon();
	*** getPathToThisApplication();
	*** getSelectionBackgroundColorUIResource();
	*** getSelectionForegroundColorUIResource();
	*** getSelectionInactiveBackgroundColorUIResource();
	*** getSelectionInactiveForegroundColorUIResource();
	*** getTextSelectionBackgroundColorUIResource();
	*** getTextSelectionForegroundColorUIResource();
	*** getWindowBackgroundColorUIResource();
}

-keep class com.apple.laf.AquaImageFactory$IconUIResourceSingleton {
	*** holder;
	*** getInstance();
}

-keep class com.apple.laf.AquaImageFactory$NamedImageSingleton {
	*** namedImage;
	*** getInstance();
}

-keep class com.apple.laf.AquaImageFactory$SystemColorProxy {
	*** color;
}

-keep class com.apple.laf.AquaKeyBindings {
	*** commonTextEditorBindings;
	*** defaultKeyTypedAction;
	*** instance;
	*** moveDownMultilineAction;
	*** moveUpMultilineAction;
	*** pageDownMultilineAction;
	*** pageUpMultilineAction;
	*** getComboBoxInputMap();
	*** getFormattedTextFieldInputMap();
	*** getListInputMap();
	*** getMultiLineTextInputMap();
	*** getPasswordFieldInputMap();
	*** getScrollBarInputMap();
	*** getScrollBarRightToLeftInputMap();
	*** getScrollPaneInputMap();
	*** getSliderInputMap();
	*** getSliderRightToLeftInputMap();
	*** getSpinnerInputMap();
	*** getTableInputMap();
	*** getTableRightToLeftInputMap();
	*** getTextFieldInputMap();
	*** getTreeInputMap();
	*** getTreeRightToLeftInputMap();
	*** instance();
}

-keep class com.apple.laf.AquaKeyBindings$AquaMultilineAction {
	*** proxyActionName;
	*** targetActionName;
}

-keep class com.apple.laf.AquaKeyBindings$BindingsProvider {
	*** getBindings();
}

-keep class com.apple.laf.AquaKeyBindings$LateBoundInputMap {
	*** mergedBindings;
	*** providerList;
	*** getBindings();
	*** mergeBindings(java.util.ArrayList,java.lang.String[]);
}

-keep class com.apple.laf.AquaKeyBindings$SimpleBinding {
	*** bindings;
}

-keep class com.apple.laf.AquaLookAndFeel {
	*** initClassDefaults(javax.swing.UIDefaults);
	*** initComponentDefaults(javax.swing.UIDefaults);
	*** initResourceBundle(javax.swing.UIDefaults);
	*** initSystemColorDefaults(javax.swing.UIDefaults);
}

-keep class com.apple.laf.AquaLookAndFeel$1 {
	*** this$0;
}

-keep class com.apple.laf.AquaLookAndFeel$2 {
	*** this$0;
}

-keep class com.apple.laf.AquaMenuBarUI {
	*** fScreenMenuBar;
	*** useScreenMenuBar;
	*** clearScreenMenuBar(javax.swing.JFrame);
	*** getPrivSysProp(java.lang.String);
	*** getScreenMenuBar();
	*** getScreenMenuBarProperty();
	*** isScreenMenuBar(javax.swing.JMenuBar);
	*** setScreenMenuBar(javax.swing.JFrame);
}

-keep class com.apple.laf.AquaMenuBorder {
	*** getEmptyInsets();
	*** getItemInsets();
	*** getPopupInsets();
}

-keep class com.apple.laf.AquaMenuPainter {
	*** instance();
	*** paintMenuBarBackground(java.awt.Graphics,int,int,javax.swing.JComponent);
}

-keep class com.apple.laf.AquaMnemonicHandler {
	*** altProcessor;
	*** isMnemonicHidden;
	*** getInstance();
	*** repaintMnemonicsInContainer(java.awt.Container);
	*** repaintMnemonicsInWindow(java.awt.Window);
	*** setMnemonicHidden(boolean);
}

-keep class com.apple.laf.AquaPainter {
	*** boundsRect;
	*** control;
	*** state;
	com.apple.laf.AquaPainter(apple.laf.JRSUIControl,apple.laf.JRSUIState);
	*** create(apple.laf.JRSUIState);
	*** create(apple.laf.JRSUIState,apple.laf.JRSUIUtils$NineSliceMetricsProvider);
	*** create(apple.laf.JRSUIState,int,int,int,int,int,int,boolean);
	*** create(apple.laf.JRSUIState,int,int,int,int,int,int,boolean,boolean,boolean);
	*** getGraphics2D(java.awt.Graphics);
	*** paint(java.awt.Graphics,java.awt.Component,int,int,int,int);
	*** paint(java.awt.Graphics2D,apple.laf.JRSUIState);
}

-keep class com.apple.laf.AquaPainter$AquaSingleImagePainter {
	*** paintFromSingleCachedImage(java.awt.Graphics2D,apple.laf.JRSUIControl,apple.laf.JRSUIState,java.awt.Rectangle);
}

-keep class com.apple.laf.AquaPanelUI {
	*** instance;
}

-keep class com.apple.laf.AquaRootPaneUI {
	*** fCurrentDefaultButton;
	*** fTimer;
	*** sRootPaneUI;
	*** sUseScreenMenuBar;
	*** stopTimer();
	*** updateComponentTreeUIActivation(java.awt.Component,java.lang.Object);
	*** updateDefaultButton(javax.swing.JRootPane);
}

-keep class com.apple.laf.AquaTableHeaderBorder {
	*** alternateBorder;
	*** doPaint;
	*** editorBorderInsets;
	*** fHorizontalShift;
	*** painter;
	*** selected;
	*** sortOrder;
	*** getAlternateBorder();
	*** getListHeaderBorder();
	*** getState(javax.swing.JComponent);
}

-keep class com.apple.laf.AquaTableHeaderBorder$1 {
	*** getInstance();
}

-keep class com.apple.laf.AquaUtilControlSize {
	*** getUserSizeFrom(javax.swing.JComponent);
}

-keep class com.apple.laf.AquaUtilControlSize$SizeDescriptor {
	*** mini;
	*** regular;
	*** small;
	*** deriveMini(com.apple.laf.AquaUtilControlSize$SizeVariant);
	*** deriveRegular(com.apple.laf.AquaUtilControlSize$SizeVariant);
	*** deriveSmall(com.apple.laf.AquaUtilControlSize$SizeVariant);
	*** get(apple.laf.JRSUIConstants$Size);
}

-keep class com.apple.laf.AquaUtilControlSize$SizeVariant {
	*** fontSize;
	*** h;
	*** insets;
	*** margins;
	*** size;
	*** w;
	*** alterMargins(int,int,int,int);
	*** generateInsets(java.awt.Insets,int,int,int,int);
}

-keep class com.apple.laf.AquaUtils {
	*** OPAQUE_SET_FLAG;
	*** cImageCreator;
	*** enableAnimations;
	*** getJComponentGetFlagMethod;
	*** access$000();
	*** animationsEnabled();
	*** classExists(java.lang.ClassLoader,java.lang.String);
	*** enforceComponentOrientation(java.awt.Component,java.awt.ComponentOrientation);
	*** fillRect(java.awt.Graphics,java.awt.Component);
	*** fillRect(java.awt.Graphics,java.awt.Component,java.awt.Color,int,int,int,int);
	*** generateLightenedImage(java.awt.Image,int);
	*** getCImageCreator();
	*** getCImageCreatorInternal();
	*** isWindowTextured(java.awt.Component);
	*** resetAlpha(java.awt.Color);
	*** shouldUseOpaqueButtons();
}

-keep class com.apple.laf.AquaUtils$2 {
	*** getInstance();
}

-keep class com.apple.laf.AquaUtils$5 {
	*** getInstance();
}

-keep class com.apple.laf.AquaUtils$6 {
	*** getInstance();
}

-keep class com.apple.laf.AquaUtils$RecyclableSingleton {
	com.apple.laf.AquaUtils$RecyclableSingleton();
	*** get();
	*** getInstance();
}

-keep class com.apple.laf.AquaUtils$RecyclableSingletonFromDefaultConstructor {
	*** clazz;
}

-keep class com.apple.laf.AquaUtils$Selectable {
	*** paintSelected(boolean);
}

-keep class com.apple.laf.ImageCache {
	*** getImage(java.awt.GraphicsConfiguration,int,int,int,apple.laf.JRSUIState);
	*** getInstance();
	*** setImage(java.awt.Image,java.awt.GraphicsConfiguration,int,int,int,apple.laf.JRSUIState);
}

-keep class com.apple.laf.ScreenPopupFactory {
	*** OPAQUE;
	*** TRANSLUCENT;
	*** fIsActive;
	*** _getHeavyWeightPopup(java.awt.Component,java.awt.Component,int,int);
	*** getWindow(java.awt.Component);
	*** setActive(boolean);
}

-keep class com.apple.resources.LoadNativeBundleAction {
	*** mBaseJavaBundle;
	*** mFilenameOverride;
	*** getPathToBundleFile(java.lang.String);
}

-keep class com.apple.resources.MacOSXResourceBundle {
	*** getMacResourceBundle(java.lang.String);
	*** getMacResourceBundle(java.lang.String,java.lang.String);
	*** setItsParent(java.util.ResourceBundle);
}

-keep class com.barchart.udt.CCC {
	*** initOk;
	*** log;
	*** initNative();
}

-keep class com.barchart.udt.EpollUDT {
	*** $assertionsDisabled;
	*** id;
	*** isActive;
	*** log;
	*** socketUDT;
	*** add(com.barchart.udt.SocketUDT,com.barchart.udt.EpollUDT$Opt);
	*** destroy();
	*** id();
	*** remove(com.barchart.udt.SocketUDT);
}

-keep class com.barchart.udt.EpollUDT$1 {
	*** $SwitchMap$com$barchart$udt$EpollUDT$Opt;
}

-keep class com.barchart.udt.EpollUDT$Opt {
	*** $VALUES;
	*** ALL;
	*** BOTH;
	*** ENUM_VALS;
	*** ERROR;
	*** ERROR_READ;
	*** ERROR_WRITE;
	*** NONE;
	*** READ;
	*** UNKNOWN;
	*** WRITE;
	*** code;
	*** from(int);
	*** hasError();
	*** hasRead();
	*** hasWrite();
	*** isValidInterestRequest();
	*** values();
}

-keep class com.barchart.udt.ErrorUDT {
	*** USER_DEFINED_MESSAGE;
	*** descriptionFrom(int,int,java.lang.String);
	*** errorFrom(int);
	*** getCode();
}

-keep class com.barchart.udt.ExceptionUDT {
	*** errorUDT;
	*** socketID;
	com.barchart.udt.ExceptionUDT(int,com.barchart.udt.ErrorUDT,java.lang.String);
}

-keep class com.barchart.udt.FactoryUDT {
	*** clazz;
	*** doClose;
	*** doInit;
	*** doOnACK;
	*** doOnLoss;
	*** doOnTimeout;
	*** log;
}

-keep class com.barchart.udt.LingerUDT {
	*** LINGER_ZERO;
	*** timeout;
	*** compareTo(com.barchart.udt.LingerUDT);
	*** intValue();
}

-keep class com.barchart.udt.MonitorUDT {
	*** byteAvailRcvBuf;
	*** byteAvailSndBuf;
	*** log;
	*** mbpsBandwidth;
	*** mbpsRecvRate;
	*** mbpsSendRate;
	*** msRTT;
	*** msTimeStamp;
	*** pktCongestionWindow;
	*** pktFlightSize;
	*** pktFlowWindow;
	*** pktRcvLoss;
	*** pktRcvLossTotal;
	*** pktRecv;
	*** pktRecvACK;
	*** pktRecvACKTotal;
	*** pktRecvNAK;
	*** pktRecvNAKTotal;
	*** pktRecvTotal;
	*** pktRetrans;
	*** pktRetransTotal;
	*** pktSent;
	*** pktSentACK;
	*** pktSentACKTotal;
	*** pktSentNAK;
	*** pktSentNAKTotal;
	*** pktSentTotal;
	*** pktSndLoss;
	*** pktSndLossTotal;
	*** socketUDT;
	*** usPktSndPeriod;
	*** usSndDuration;
	*** usSndDurationTotal;
	*** appendSnapshot(java.lang.StringBuilder);
	*** isNumeric(java.lang.reflect.Field);
}

-keep class com.barchart.udt.OptionUDT {
	*** Custom_Congestion_Control;
	*** Epoll_Event_Mask;
	*** Flight_Window_Size;
	*** Is_Address_Reuse_Enabled;
	*** Is_Randezvous_Connect_Enabled;
	*** Is_Receive_Synchronous;
	*** Is_Send_Synchronous;
	*** Maximum_Bandwidth;
	*** Maximum_Transfer_Unit;
	*** Protocol_Receive_Buffer_Size;
	*** Protocol_Send_Buffer_Size;
	*** Receive_Buffer_Available;
	*** Receive_Timeout;
	*** Send_Buffer_Consumed;
	*** Send_Timeout;
	*** Status_Code;
	*** System_Receive_Buffer_Size;
	*** System_Send_Buffer_Size;
	*** Time_To_Linger_On_Close;
	*** UDP_RCVBUF;
	*** UDP_SNDBUF;
	*** UDT_CC;
	*** UDT_EVENT;
	*** UDT_FC;
	*** UDT_LINGER;
	*** UDT_MAXBW;
	*** UDT_MSS;
	*** UDT_RCVBUF;
	*** UDT_RCVDATA;
	*** UDT_RCVSYN;
	*** UDT_RCVTIMEO;
	*** UDT_RENDEZVOUS;
	*** UDT_REUSEADDR;
	*** UDT_SNDBUF;
	*** UDT_SNDDATA;
	*** UDT_SNDSYN;
	*** UDT_SNDTIMEO;
	*** UDT_STATE;
	*** code;
	*** format;
	*** log;
	*** name;
	*** type;
	*** values;
	*** NEW(int,java.lang.Class,com.barchart.udt.OptionUDT$Format);
	*** appendSnapshot(com.barchart.udt.SocketUDT,java.lang.StringBuilder);
	*** code();
	*** name();
	*** type();
}

-keep class com.barchart.udt.OptionUDT$Format {
	*** $VALUES;
	*** BINARY;
	*** BOOLEAN;
	*** DECIMAL;
	*** DEFAULT;
	com.barchart.udt.OptionUDT$Format(java.lang.String,int);
	com.barchart.udt.OptionUDT$Format(java.lang.String,int,com.barchart.udt.OptionUDT$1);
	*** convert(java.lang.Object);
}

-keep class com.barchart.udt.ResourceUDT {
	*** DEFAULT_LIBRARY_LOADER_CLASS;
	*** PACKAGE_NAME;
	*** PROPERTY_LIBRARY_EXTRACT_LOCATION;
	*** PROPERTY_LOADER_CLASS_NAME;
	*** getLibraryExtractLocation();
	*** getLibraryLoaderClassName();
}

-keep class com.barchart.udt.SocketUDT {
	*** $assertionsDisabled;
	*** INIT_OK;
	*** TIMEOUT_NONE;
	*** listenQueueSize;
	*** localSocketAddress;
	*** log;
	*** messageIsOrdered;
	*** messageTimeTolive;
	*** monitor;
	*** remoteSocketAddress;
	*** socketAddressFamily;
	*** socketID;
	*** type;
	*** accept();
	*** accept0();
	*** bind(java.net.InetSocketAddress);
	*** bind0(java.net.InetSocketAddress);
	*** clearError0();
	*** close();
	*** close0();
	*** connect(java.net.InetSocketAddress);
	*** connect0(java.net.InetSocketAddress);
	*** epollAdd0(int,int,int);
	*** epollCreate0();
	*** epollRelease0(int);
	*** epollRemove0(int,int);
	*** epollUpdate0(int,int,int);
	*** epollVerify0(int,int);
	*** epollWait0(int,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer,long);
	*** getErrorCode();
	*** getErrorCode0();
	*** getErrorMessage0();
	*** getLocalInetAddress();
	*** getLocalInetPort();
	*** getLocalSocketAddress();
	*** getOption(com.barchart.udt.OptionUDT);
	*** getOption0(int,java.lang.Class);
	*** getReceiveBufferSize();
	*** getRemoteInetAddress();
	*** getRemoteInetPort();
	*** getRemoteSocketAddress();
	*** getReuseAddress();
	*** getSendBufferSize();
	*** getSignatureJNI0();
	*** getSoLinger();
	*** getSoTimeout();
	*** getStatus0();
	*** hasLoadedLocalSocketAddress();
	*** hasLoadedRemoteSocketAddress();
	*** id();
	*** initClass0();
	*** initInstance0(int);
	*** initInstance1(int);
	*** isBlocking();
	*** isBound();
	*** isClosed();
	*** isConnected();
	*** isOpen();
	*** listen(int);
	*** listen0(int);
	*** receive(byte[],int,int);
	*** receive(java.nio.ByteBuffer);
	*** receive0(int,int,byte[]);
	*** receive1(int,int,byte[],int,int);
	*** receive2(int,int,java.nio.ByteBuffer,int,int);
	*** receiveFile0(int,java.lang.String,long,long,int);
	*** selectEpoll(int,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer,long);
	*** send(byte[],int,int);
	*** send(java.nio.ByteBuffer);
	*** send0(int,int,int,boolean,byte[]);
	*** send1(int,int,int,boolean,byte[],int,int);
	*** send2(int,int,int,boolean,java.nio.ByteBuffer,int,int);
	*** sendFile0(int,java.lang.String,long,long,int);
	*** setBlocking(boolean);
	*** setDefaultMessageSendMode();
	*** setMessageIsOdered(boolean);
	*** setMessageTimeTolLive(int);
	*** setOption(com.barchart.udt.OptionUDT,java.lang.Object);
	*** setOption0(int,java.lang.Class,java.lang.Object);
	*** setReceiveBufferSize(int);
	*** setReuseAddress(boolean);
	*** setSendBufferSize(int);
	*** setSoLinger(boolean,int);
	*** setSoTimeout(int);
	*** status();
	*** stopClass0();
	*** toString();
	*** updateMonitor(boolean);
	*** updateMonitor0(boolean);
}

-keep class com.barchart.udt.SocketUDT$1 {
	*** $SwitchMap$com$barchart$udt$StatusUDT;
}

-keep class com.barchart.udt.StatusUDT {
	*** $VALUES;
	*** BROKEN;
	*** CLOSED;
	*** CLOSING;
	*** CONNECTED;
	*** CONNECTING;
	*** INIT;
	*** LISTENING;
	*** NONEXIST;
	*** OPENED;
	*** UNKNOWN;
	*** code;
	*** log;
	*** from(int);
	*** values();
}

-keep class com.barchart.udt.TypeUDT {
	*** $VALUES;
	*** DATAGRAM;
	*** STREAM;
	*** code;
}

-keep class com.barchart.udt.lib.LibraryLoader {
	*** load(java.lang.String);
}

-keep class com.barchart.udt.lib.LibraryLoaderUDT {
	*** log;
	*** loadAll(java.util.List,java.lang.String);
	*** loadRelease(java.lang.String);
	*** loadStaging(java.lang.String);
	*** loadTesting(java.lang.String);
}

-keep class com.barchart.udt.lib.PluginPropsUDT {
	*** OS_ARCH;
	*** OS_NAME;
	*** log;
	*** props;
	*** currentDependencyLibraries();
	*** currentNarKey();
	*** currentNarKey(java.lang.String);
	*** currentNarKeyCppCompiler();
	*** currentNarKeyJniExtension();
	*** currentNarKeyLinkerDependency();
	*** currentNarKeySharedPrefix();
	*** currentNarPath();
	*** currentReleaseLibraries(java.lang.String);
	*** currentStagingLibraries(java.lang.String);
	*** currentTestingLibraries(java.lang.String);
	*** formatMainLibraryName(java.lang.String);
	*** formatMainReleasePath(java.lang.String);
	*** formatMainStagingPath(java.lang.String);
	*** formatMainTestingPath(java.lang.String);
	*** formatNarKey(java.lang.String,java.lang.String,java.lang.String);
	*** formatNarPath(java.lang.String,java.lang.String,java.lang.String);
	*** formatTestingDependencyPath(java.lang.String);
	*** isSupportedPlatform();
	*** narARCH();
	*** narLINK();
	*** narOS();
	*** property(java.lang.String);
}

-keep class com.barchart.udt.lib.ResourceManagerUDT {
	*** log;
	*** ensureTargetFolder(java.io.File);
	*** extractResource(java.lang.String,java.lang.String);
	*** fileConnection(java.io.File);
	*** isSameResource(java.net.URLConnection,java.net.URLConnection);
	*** systemLoad(java.lang.String);
	*** timeStamp(java.net.URLConnection);
}

-keep class com.barchart.udt.lib.VersionUDT {
	*** BARCHART_ARTIFACT;
	*** BARCHART_GROUP;
	*** BARCHART_NAME;
	*** BARCHART_TIMESTAMP;
	*** BARCHART_VERSION;
	*** JAVA_VENDOR;
	*** JAVA_VERSION;
	*** JAVA_VM_NAME;
	*** OS_ARCH;
	*** OS_NAME;
	*** OS_VERSION;
	*** UDT_VERSION;
	*** log;
	*** append(java.lang.StringBuilder,java.lang.String);
	*** asText();
	*** barchartName(java.lang.String);
}

-keep class com.barchart.udt.net.ExceptionReceiveUDT {
	com.barchart.udt.net.ExceptionReceiveUDT(int,com.barchart.udt.ErrorUDT,java.lang.String);
}

-keep class com.barchart.udt.net.NetInputStreamUDT {
	*** $assertionsDisabled;
	*** socketUDT;
	*** read(byte[]);
	*** read(byte[],int,int);
}

-keep class com.barchart.udt.net.NetInputStreamUDT$1 {
	*** this$0;
}

-keep class com.barchart.udt.net.NetOutputStreamUDT {
	*** socketUDT;
	*** write(byte[]);
	*** write(byte[],int,int);
}

-keep class com.barchart.udt.net.NetServerSocketUDT {
	*** socketUDT;
	com.barchart.udt.net.NetServerSocketUDT(com.barchart.udt.SocketUDT);
	*** bind(java.net.SocketAddress,int);
}

-keep class com.barchart.udt.net.NetSocketUDT {
	*** inputStream;
	*** log;
	*** outputStream;
	*** socketUDT;
	com.barchart.udt.net.NetSocketUDT();
	com.barchart.udt.net.NetSocketUDT(com.barchart.udt.SocketUDT);
}

-keep class com.barchart.udt.nio.ChannelUDT {
	*** isConnectFinished();
	*** kindUDT();
	*** socketUDT();
	*** typeUDT();
}

-keep class com.barchart.udt.nio.KindUDT {
	*** $VALUES;
	*** ACCEPTOR;
	*** CONNECTOR;
	*** RENDEZVOUS;
}

-keep class com.barchart.udt.nio.SelectionKeyUDT {
	*** channelUDT;
	*** epollOpt;
	*** interestOps;
	*** isValid;
	*** log;
	*** readyOps;
	*** resultIndex;
	*** selectorUDT;
	*** assertValidKey();
	*** assertValidOps(int);
	*** channel();
	*** channelUDT();
	*** compareTo(com.barchart.udt.nio.SelectionKeyUDT);
	*** doRead(int);
	*** doWrite(int);
	*** epollUDT();
	*** from(int);
	*** interestOps(int);
	*** isSocketBroken();
	*** isValid();
	*** kindUDT();
	*** logError(java.lang.String);
	*** makeValid(boolean);
	*** selector();
	*** socketId();
	*** socketUDT();
	*** toStringOps(int);
}

-keep class com.barchart.udt.nio.SelectionKeyUDT$1 {
	*** $SwitchMap$com$barchart$udt$StatusUDT;
	*** $SwitchMap$com$barchart$udt$nio$KindUDT;
}

-keep class com.barchart.udt.nio.SelectorProviderUDT {
	*** DATAGRAM;
	*** STREAM;
	*** acceptQueueSize;
	*** maxSelectorSize;
	*** type;
	*** from(com.barchart.udt.TypeUDT);
	*** openRendezvousChannel();
	*** openSelector();
	*** openServerSocketChannel();
	*** openSocketChannel();
	*** type();
}

-keep class com.barchart.udt.nio.SelectorProviderUDT$1 {
	*** $SwitchMap$com$barchart$udt$TypeUDT;
}

-keep class com.barchart.udt.nio.SelectorUDT {
	*** epollUDT;
	*** log;
	*** maximimSelectorSize;
	*** readBuffer;
	*** registeredKeyMap;
	*** registeredKeySet;
	*** resultIndex;
	*** selectLock;
	*** selectedKeyMap;
	*** selectedKeySet;
	*** sizeBuffer;
	*** terminatedKeyMap;
	*** wakeupBaseCount;
	*** wakeupStepCount;
	*** writeBuffer;
	*** cancel(com.barchart.udt.nio.SelectionKeyUDT);
	*** doCancel();
	*** doEpollEnter(long);
	*** doEpollExclusive(long);
	*** doEpollSelect(long);
	*** doEpollSelectUDT(long);
	*** doResults();
	*** doResultsRead(int);
	*** doResultsWrite(int);
	*** epollUDT();
	*** logSocketId(java.lang.String,int);
	*** select(long);
	*** wakeup();
	*** wakeupIsPending();
	*** wakeupMarkBase();
}

-keep class com.barchart.udt.nio.SelectorUDT$1 {
	*** $SwitchMap$com$barchart$udt$TypeUDT;
}

-keep class com.barchart.udt.nio.ServerSocketChannelUDT {
	*** log;
	*** socketAdapter;
	*** socketUDT;
	*** accept();
	*** providerUDT();
	*** socket();
}

-keep class com.barchart.udt.nio.SocketChannelUDT {
	*** connectLock;
	*** isBlockingMode;
	*** isConnectFinished;
	*** isConnectionPending;
	*** log;
	*** socketAdapter;
	*** socketUDT;
	com.barchart.udt.nio.SocketChannelUDT(com.barchart.udt.nio.SelectorProviderUDT,com.barchart.udt.SocketUDT);
	*** isConnected();
	*** providerUDT();
	*** socket();
	*** write(java.nio.ByteBuffer);
}

-keep class com.barchart.udt.util.HelpUDT {
	*** log;
	*** checkArray(byte[]);
	*** checkBuffer(java.nio.ByteBuffer);
	*** checkSocketAddress(java.net.InetSocketAddress);
	*** constantFieldName(java.lang.Class,java.lang.Object);
	*** newDirectIntBufer(int);
	*** ungrowableSet(java.util.Set);
	*** unmodifiableSet(java.util.Collection);
}

-keep class com.barchart.udt.util.UngrowableSet {
	*** set;
}

-keep class com.barchart.udt.util.UnmodifiableSet {
	*** values;
}

-keep class com.codahale.metrics.MetricFilter {
	*** ALL;
	*** matches(java.lang.String,com.codahale.metrics.Metric);
}

-keep class com.codahale.metrics.MetricRegistry {
	*** listeners;
	*** metrics;
	*** append(java.lang.StringBuilder,java.lang.String);
	*** buildMap();
	*** getCounters(com.codahale.metrics.MetricFilter);
	*** getGauges(com.codahale.metrics.MetricFilter);
	*** getHistograms(com.codahale.metrics.MetricFilter);
	*** getMeters(com.codahale.metrics.MetricFilter);
	*** getMetrics(java.lang.Class,com.codahale.metrics.MetricFilter);
	*** getOrAdd(java.lang.String,com.codahale.metrics.MetricRegistry$MetricBuilder);
	*** getTimers(com.codahale.metrics.MetricFilter);
	*** name(java.lang.String,java.lang.String[]);
	*** notifyListenerOfAddedMetric(com.codahale.metrics.MetricRegistryListener,com.codahale.metrics.Metric,java.lang.String);
	*** notifyListenerOfRemovedMetric(java.lang.String,com.codahale.metrics.Metric,com.codahale.metrics.MetricRegistryListener);
	*** onMetricAdded(java.lang.String,com.codahale.metrics.Metric);
	*** onMetricRemoved(java.lang.String,com.codahale.metrics.Metric);
	*** register(java.lang.String,com.codahale.metrics.Metric);
	*** registerAll(java.lang.String,com.codahale.metrics.MetricSet);
	*** remove(java.lang.String);
}

-keep class com.codahale.metrics.MetricRegistry$MetricBuilder {
	*** COUNTERS;
	*** HISTOGRAMS;
	*** METERS;
	*** TIMERS;
	*** isInstance(com.codahale.metrics.Metric);
	*** newMetric();
}

-keep class com.codahale.metrics.MetricRegistryListener {
	*** onCounterAdded(java.lang.String,com.codahale.metrics.Counter);
	*** onCounterRemoved(java.lang.String);
	*** onGaugeAdded(java.lang.String,com.codahale.metrics.Gauge);
	*** onGaugeRemoved(java.lang.String);
	*** onHistogramAdded(java.lang.String,com.codahale.metrics.Histogram);
	*** onHistogramRemoved(java.lang.String);
	*** onMeterAdded(java.lang.String,com.codahale.metrics.Meter);
	*** onMeterRemoved(java.lang.String);
	*** onTimerAdded(java.lang.String,com.codahale.metrics.Timer);
	*** onTimerRemoved(java.lang.String);
}

-keep class com.codahale.metrics.MetricSet {
	*** getMetrics();
}

-keep class com.csvreader.CsvReader {
	*** charset;
	*** closed;
	*** columnBuffer;
	*** columnsCount;
	*** currentRecord;
	*** dataBuffer;
	*** fileName;
	*** hasMoreData;
	*** hasReadNextLine;
	*** headersHolder;
	*** initialized;
	*** inputStream;
	*** isQualified;
	*** lastLetter;
	*** rawBuffer;
	*** rawRecord;
	*** startedColumn;
	*** startedWithQualifier;
	*** useCustomRecordDelimiter;
	*** userSettings;
	*** values;
	com.csvreader.CsvReader(java.io.Reader);
	com.csvreader.CsvReader(java.io.Reader,char);
	com.csvreader.CsvReader(java.lang.String,char);
	com.csvreader.CsvReader(java.lang.String,char,java.nio.charset.Charset);
	*** appendLetter(char);
	*** checkClosed();
	*** checkDataLength();
	*** close();
	*** close(boolean);
	*** endColumn();
	*** endRecord();
	*** get(int);
	*** get(java.lang.String);
	*** getIndex(java.lang.String);
	*** hexToDec(char);
	*** readHeaders();
	*** readRecord();
	*** setTextQualifier(char);
	*** skipLine();
	*** updateCurrentValue();
}

-keep class com.csvreader.CsvReader$ColumnBuffer {
	*** Buffer;
	*** Position;
	*** this$0;
}

-keep class com.csvreader.CsvReader$DataBuffer {
	*** Buffer;
	*** ColumnStart;
	*** Count;
	*** LineStart;
	*** Position;
	*** this$0;
}

-keep class com.csvreader.CsvReader$HeadersHolder {
	*** Headers;
	*** IndexByName;
	*** Length;
	*** this$0;
}

-keep class com.csvreader.CsvReader$RawRecordBuffer {
	*** Buffer;
	*** Position;
	*** this$0;
}

-keep class com.csvreader.CsvReader$UserSettings {
	*** CaptureRawRecord;
	*** CaseSensitive;
	*** Comment;
	*** Delimiter;
	*** EscapeMode;
	*** RecordDelimiter;
	*** SafetySwitch;
	*** SkipEmptyRecords;
	*** TextQualifier;
	*** TrimWhitespace;
	*** UseComments;
	*** UseTextQualifier;
	*** this$0;
}

-keep class com.csvreader.CsvWriter {
	*** charset;
	*** closed;
	*** fileName;
	*** firstColumn;
	*** initialized;
	*** outputStream;
	*** useCustomRecordDelimiter;
	*** userSettings;
	com.csvreader.CsvWriter(java.io.Writer,char);
	com.csvreader.CsvWriter(java.lang.String,char,java.nio.charset.Charset);
	*** checkClosed();
	*** checkInit();
	*** close();
	*** close(boolean);
	*** endRecord();
	*** replace(java.lang.String,java.lang.String,java.lang.String);
	*** write(java.lang.String,boolean);
	*** writeComment(java.lang.String);
	*** writeRecord(java.lang.String[]);
	*** writeRecord(java.lang.String[],boolean);
}

-keep class com.csvreader.CsvWriter$UserSettings {
	*** Comment;
	*** Delimiter;
	*** EscapeMode;
	*** ForceQualifier;
	*** RecordDelimiter;
	*** TextQualifier;
	*** UseTextQualifier;
	*** this$0;
}

-keep class com.google.api.client.auth.oauth2.ClientParametersAuthentication {
	*** clientId;
	*** clientSecret;
}

-keep class com.google.api.client.auth.oauth2.Credential {
	*** LOGGER;
	*** accessToken;
	*** clientAuthentication;
	*** clock;
	*** expirationTimeMilliseconds;
	*** jsonFactory;
	*** lock;
	*** method;
	*** refreshListeners;
	*** refreshToken;
	*** requestInitializer;
	*** tokenServerEncodedUrl;
	*** transport;
	com.google.api.client.auth.oauth2.Credential(com.google.api.client.auth.oauth2.Credential$AccessMethod,com.google.api.client.http.HttpTransport,com.google.api.client.json.JsonFactory,java.lang.String,com.google.api.client.http.HttpExecuteInterceptor,com.google.api.client.http.HttpRequestInitializer,java.util.List,com.google.api.client.util.Clock);
	com.google.api.client.auth.oauth2.Credential(com.google.api.client.auth.oauth2.Credential$Builder);
	*** executeRefreshToken();
	*** getClientAuthentication();
	*** getClock();
	*** getExpiresInSeconds();
	*** getJsonFactory();
	*** getTokenServerEncodedUrl();
	*** getTransport();
	*** refreshToken();
	*** setAccessToken(java.lang.String);
	*** setExpirationTimeMilliseconds(java.lang.Long);
	*** setExpiresInSeconds(java.lang.Long);
	*** setFromTokenResponse(com.google.api.client.auth.oauth2.TokenResponse);
	*** setRefreshToken(java.lang.String);
}

-keep class com.google.api.client.auth.oauth2.Credential$AccessMethod {
	*** getAccessTokenFromRequest(com.google.api.client.http.HttpRequest);
	*** intercept(com.google.api.client.http.HttpRequest,java.lang.String);
}

-keep class com.google.api.client.auth.oauth2.Credential$Builder {
	*** clientAuthentication;
	*** clock;
	*** jsonFactory;
	*** method;
	*** refreshListeners;
	*** requestInitializer;
	*** tokenServerUrl;
	*** transport;
}

-keep class com.google.api.client.auth.oauth2.CredentialRefreshListener {
	*** onTokenErrorResponse(com.google.api.client.auth.oauth2.Credential,com.google.api.client.auth.oauth2.TokenErrorResponse);
	*** onTokenResponse(com.google.api.client.auth.oauth2.Credential,com.google.api.client.auth.oauth2.TokenResponse);
}

-keep class com.google.api.client.auth.oauth2.RefreshTokenRequest {
	*** refreshToken;
	*** set(java.lang.String,java.lang.Object);
	*** setClientAuthentication(com.google.api.client.http.HttpExecuteInterceptor);
	*** setGrantType(java.lang.String);
	*** setRefreshToken(java.lang.String);
	*** setRequestInitializer(com.google.api.client.http.HttpRequestInitializer);
	*** setScopes(java.lang.Iterable);
	*** setScopes(java.lang.String[]);
	*** setTokenServerUrl(com.google.api.client.http.GenericUrl);
}

-keep class com.google.api.client.auth.oauth2.TokenRequest {
	*** clientAuthentication;
	*** grantType;
	*** jsonFactory;
	*** requestInitializer;
	*** scopes;
	*** tokenServerUrl;
	*** transport;
	com.google.api.client.auth.oauth2.TokenRequest(com.google.api.client.http.HttpTransport,com.google.api.client.json.JsonFactory,com.google.api.client.http.GenericUrl,java.lang.String);
	*** execute();
	*** executeUnparsed();
	*** set(java.lang.String,java.lang.Object);
	*** setClientAuthentication(com.google.api.client.http.HttpExecuteInterceptor);
	*** setGrantType(java.lang.String);
	*** setRequestInitializer(com.google.api.client.http.HttpRequestInitializer);
	*** setScopes(java.lang.Iterable);
	*** setScopes(java.lang.String[]);
	*** setTokenServerUrl(com.google.api.client.http.GenericUrl);
}

-keep class com.google.api.client.auth.oauth2.TokenRequest$1 {
	*** this$0;
}

-keep class com.google.api.client.auth.oauth2.TokenRequest$1$1 {
	*** this$1;
	*** val$interceptor;
}

-keep class com.google.api.client.auth.oauth2.TokenResponse {
	*** accessToken;
	*** expiresInSeconds;
	*** refreshToken;
	*** scope;
	*** tokenType;
	*** clone();
	*** getAccessToken();
	*** getExpiresInSeconds();
	*** getRefreshToken();
	*** set(java.lang.String,java.lang.Object);
}

-keep class com.google.api.client.auth.oauth2.TokenResponseException {
	*** details;
	*** from(com.google.api.client.json.JsonFactory,com.google.api.client.http.HttpResponse);
	*** getDetails();
}

-keep class com.google.api.client.googleapis.auth.oauth2.GoogleBrowserClientRequestUrl {
	*** setApprovalPrompt(java.lang.String);
	*** setResponseTypes(java.lang.String[]);
}

-keep class com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets {
	*** installed;
	*** web;
	*** clone();
	*** getInstalled();
	*** load(com.google.api.client.json.JsonFactory,java.io.InputStream);
	*** set(java.lang.String,java.lang.Object);
}

-keep class com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets$Details {
	*** authUri;
	*** clientId;
	*** clientSecret;
	*** redirectUris;
	*** tokenUri;
	*** clone();
	*** getClientId();
	*** getClientSecret();
	*** set(java.lang.String,java.lang.Object);
}

-keep class com.google.api.client.googleapis.auth.oauth2.GoogleCredential {
	*** serviceAccountId;
	*** serviceAccountPrivateKey;
	*** serviceAccountScopes;
	*** serviceAccountUser;
	com.google.api.client.googleapis.auth.oauth2.GoogleCredential(com.google.api.client.auth.oauth2.Credential$AccessMethod,com.google.api.client.http.HttpTransport,com.google.api.client.json.JsonFactory,java.lang.String,com.google.api.client.http.HttpExecuteInterceptor,com.google.api.client.http.HttpRequestInitializer,java.util.List,java.lang.String,java.lang.String,java.security.PrivateKey,java.lang.String,com.google.api.client.util.Clock);
	com.google.api.client.googleapis.auth.oauth2.GoogleCredential(com.google.api.client.googleapis.auth.oauth2.GoogleCredential$Builder);
	*** setAccessToken(java.lang.String);
	*** setExpirationTimeMilliseconds(java.lang.Long);
	*** setExpiresInSeconds(java.lang.Long);
	*** setFromTokenResponse(com.google.api.client.auth.oauth2.TokenResponse);
	*** setRefreshToken(java.lang.String);
}

-keep class com.google.api.client.googleapis.auth.oauth2.GoogleCredential$Builder {
	*** serviceAccountId;
	*** serviceAccountPrivateKey;
	*** serviceAccountScopes;
	*** serviceAccountUser;
	*** addRefreshListener(com.google.api.client.auth.oauth2.CredentialRefreshListener);
	*** build();
	*** setClientAuthentication(com.google.api.client.http.HttpExecuteInterceptor);
	*** setJsonFactory(com.google.api.client.json.JsonFactory);
	*** setTransport(com.google.api.client.http.HttpTransport);
}

-keep class com.google.api.client.http.AbstractHttpContent {
	*** computedLength;
	*** mediaType;
	com.google.api.client.http.AbstractHttpContent(com.google.api.client.http.HttpMediaType);
	com.google.api.client.http.AbstractHttpContent(java.lang.String);
	*** computeLength();
	*** computeLength(com.google.api.client.http.HttpContent);
	*** getCharset();
	*** setMediaType(com.google.api.client.http.HttpMediaType);
}

-keep class com.google.api.client.http.BackOffPolicy {
	*** getNextBackOffMillis();
	*** isBackOffRequired(int);
	*** reset();
}

-keep class com.google.api.client.http.GenericUrl {
	*** URI_FRAGMENT_ESCAPER;
	*** fragment;
	*** host;
	*** pathParts;
	*** port;
	*** scheme;
	com.google.api.client.http.GenericUrl(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String);
	com.google.api.client.http.GenericUrl(java.net.URI);
	*** addQueryParams(java.util.Set,java.lang.StringBuilder);
	*** appendParam(boolean,java.lang.StringBuilder,java.lang.String,java.lang.Object);
	*** appendRawPathFromParts(java.lang.StringBuilder);
	*** build();
	*** buildAuthority();
	*** buildRelativeUrl();
	*** clone();
	*** getFragment();
	*** set(java.lang.String,java.lang.Object);
	*** toPathParts(java.lang.String);
	*** toString();
	*** toURI(java.lang.String);
	*** toURL();
	*** toURL(java.lang.String);
}

-keep class com.google.api.client.http.HttpContent {
	*** getEncoding();
	*** getLength();
	*** getType();
	*** retrySupported();
}

-keep class com.google.api.client.http.HttpEncoding {
	*** getName();
}

-keep class com.google.api.client.http.HttpExecuteInterceptor {
	*** intercept(com.google.api.client.http.HttpRequest);
}

-keep class com.google.api.client.http.HttpHeaders {
	*** accept;
	*** acceptEncoding;
	*** age;
	*** authenticate;
	*** authorization;
	*** cacheControl;
	*** contentEncoding;
	*** contentLength;
	*** contentMD5;
	*** contentRange;
	*** contentType;
	*** cookie;
	*** date;
	*** etag;
	*** expires;
	*** ifMatch;
	*** ifModifiedSince;
	*** ifNoneMatch;
	*** ifRange;
	*** ifUnmodifiedSince;
	*** lastModified;
	*** location;
	*** mimeVersion;
	*** range;
	*** retryAfter;
	*** userAgent;
	*** addHeader(java.util.logging.Logger,java.lang.StringBuilder,java.lang.StringBuilder,com.google.api.client.http.LowLevelHttpRequest,java.lang.String,java.lang.Object,java.io.Writer);
	*** clone();
	*** fromHttpResponse(com.google.api.client.http.LowLevelHttpResponse,java.lang.StringBuilder);
	*** getAsList(java.lang.Object);
	*** getContentType();
	*** getFirstHeaderValue(java.util.List);
	*** getLocation();
	*** getUserAgent();
	*** parseHeader(java.lang.String,java.lang.String,com.google.api.client.http.HttpHeaders$ParseHeaderState);
	*** parseValue(java.lang.reflect.Type,java.util.List,java.lang.String);
	*** serializeHeaders(com.google.api.client.http.HttpHeaders,java.lang.StringBuilder,java.lang.StringBuilder,java.util.logging.Logger,com.google.api.client.http.LowLevelHttpRequest);
	*** serializeHeaders(com.google.api.client.http.HttpHeaders,java.lang.StringBuilder,java.lang.StringBuilder,java.util.logging.Logger,com.google.api.client.http.LowLevelHttpRequest,java.io.Writer);
	*** set(java.lang.String,java.lang.Object);
	*** setAuthorization(java.lang.String);
	*** setAuthorization(java.util.List);
	*** setIfMatch(java.lang.String);
	*** setIfModifiedSince(java.lang.String);
	*** setIfNoneMatch(java.lang.String);
	*** setIfRange(java.lang.String);
	*** setIfUnmodifiedSince(java.lang.String);
	*** setUserAgent(java.lang.String);
	*** toStringValue(java.lang.Object);
}

-keep class com.google.api.client.http.HttpHeaders$HeaderParsingFakeLevelHttpRequest {
	*** state;
	*** target;
}

-keep class com.google.api.client.http.HttpHeaders$ParseHeaderState {
	*** arrayValueMap;
	*** classInfo;
	*** context;
	*** logger;
	*** finish();
}

-keep class com.google.api.client.http.HttpMediaType {
	*** FULL_MEDIA_TYPE_REGEX;
	*** PARAMETER_REGEX;
	*** TOKEN_REGEX;
	*** TYPE_REGEX;
	*** cachedBuildResult;
	*** parameters;
	*** subType;
	*** type;
	*** build();
	*** equalsIgnoreParameters(com.google.api.client.http.HttpMediaType);
	*** equalsIgnoreParameters(java.lang.String,java.lang.String);
	*** fromString(java.lang.String);
	*** getCharsetParameter();
	*** getParameter(java.lang.String);
	*** getSubType();
	*** getType();
	*** matchesToken(java.lang.String);
	*** quoteString(java.lang.String);
	*** removeParameter(java.lang.String);
	*** setCharsetParameter(java.nio.charset.Charset);
	*** setParameter(java.lang.String,java.lang.String);
	*** setSubType(java.lang.String);
	*** setType(java.lang.String);
}

-keep class com.google.api.client.http.HttpRequest {
	*** backOffPolicy;
	*** connectTimeout;
	*** content;
	*** contentLoggingLimit;
	*** curlLoggingEnabled;
	*** enableGZipContent;
	*** encoding;
	*** executeInterceptor;
	*** followRedirects;
	*** headers;
	*** loggingEnabled;
	*** numRetries;
	*** objectParser;
	*** readTimeout;
	*** requestMethod;
	*** responseHeaders;
	*** responseInterceptor;
	*** retryOnExecuteIOException;
	*** suppressUserAgentSuffix;
	*** throwExceptionOnExecuteError;
	*** transport;
	*** unsuccessfulResponseHandler;
	*** url;
	*** execute();
	*** executeAsync(java.util.concurrent.Executor);
	*** getContent();
	*** getContentLoggingLimit();
	*** getFollowRedirects();
	*** getInterceptor();
	*** getParser();
	*** getRequestMethod();
	*** getResponseHeaders();
	*** getTransport();
	*** handleRedirect(int,com.google.api.client.http.HttpHeaders);
	*** isLoggingEnabled();
	*** setContent(com.google.api.client.http.HttpContent);
	*** setEncoding(com.google.api.client.http.HttpEncoding);
	*** setInterceptor(com.google.api.client.http.HttpExecuteInterceptor);
	*** setParser(com.google.api.client.util.ObjectParser);
	*** setRequestMethod(java.lang.String);
	*** setThrowExceptionOnExecuteError(boolean);
	*** setUnsuccessfulResponseHandler(com.google.api.client.http.HttpUnsuccessfulResponseHandler);
	*** setUrl(com.google.api.client.http.GenericUrl);
	*** sleep(long);
}

-keep class com.google.api.client.http.HttpRequest$1 {
	*** this$0;
	*** val$contentEncoding;
	*** val$contentLength;
	*** val$contentRetrySupported;
	*** val$contentType;
	*** val$streamingContent2;
}

-keep class com.google.api.client.http.HttpRequestFactory {
	*** initializer;
	*** transport;
	*** buildGetRequest(com.google.api.client.http.GenericUrl);
	*** buildPostRequest(com.google.api.client.http.GenericUrl,com.google.api.client.http.HttpContent);
	*** buildRequest(java.lang.String,com.google.api.client.http.GenericUrl,com.google.api.client.http.HttpContent);
}

-keep class com.google.api.client.http.HttpRequestInitializer {
	*** initialize(com.google.api.client.http.HttpRequest);
}

-keep class com.google.api.client.http.HttpResponse {
	*** content;
	*** contentEncoding;
	*** contentLoggingLimit;
	*** contentRead;
	*** contentType;
	*** loggingEnabled;
	*** mediaType;
	*** request;
	*** response;
	*** statusCode;
	*** statusMessage;
	*** disconnect();
	*** getContent();
	*** getContentCharset();
	*** getContentType();
	*** getHeaders();
	*** getRequest();
	*** getStatusCode();
	*** getStatusMessage();
	*** hasMessageBody();
	*** ignore();
	*** isSuccessStatusCode();
	*** parseAs(java.lang.Class);
	*** parseAsString();
}

-keep class com.google.api.client.http.HttpResponseException {
	*** content;
	*** headers;
	*** statusCode;
	*** statusMessage;
	com.google.api.client.http.HttpResponseException(com.google.api.client.http.HttpResponseException$Builder);
	*** computeMessageBuffer(com.google.api.client.http.HttpResponse);
	*** getStatusCode();
}

-keep class com.google.api.client.http.HttpResponseException$Builder {
	*** content;
	*** headers;
	*** message;
	*** statusCode;
	*** statusMessage;
	*** setContent(java.lang.String);
	*** setMessage(java.lang.String);
}

-keep class com.google.api.client.http.HttpResponseInterceptor {
	*** interceptResponse(com.google.api.client.http.HttpResponse);
}

-keep class com.google.api.client.http.HttpStatusCodes {
	*** isRedirect(int);
	*** isSuccess(int);
}

-keep class com.google.api.client.http.HttpTransport {
	*** LOGGER;
	*** SUPPORTED_METHODS;
	com.google.api.client.http.HttpTransport();
	*** buildRequest();
	*** buildRequest(java.lang.String,java.lang.String);
	*** createRequestFactory(com.google.api.client.http.HttpRequestInitializer);
}

-keep class com.google.api.client.http.HttpUnsuccessfulResponseHandler {
	*** handleResponse(com.google.api.client.http.HttpRequest,com.google.api.client.http.HttpResponse,boolean);
}

-keep class com.google.api.client.http.LowLevelHttpRequest {
	*** contentEncoding;
	*** contentLength;
	*** contentType;
	*** streamingContent;
	com.google.api.client.http.LowLevelHttpRequest();
	*** addHeader(java.lang.String,java.lang.String);
	*** execute();
	*** getContentEncoding();
	*** getContentLength();
	*** getContentType();
	*** getStreamingContent();
	*** setContent(com.google.api.client.http.HttpContent);
	*** setContentEncoding(java.lang.String);
	*** setContentLength(long);
	*** setContentType(java.lang.String);
	*** setStreamingContent(com.google.api.client.util.StreamingContent);
	*** setTimeout(int,int);
}

-keep class com.google.api.client.http.LowLevelHttpResponse {
	com.google.api.client.http.LowLevelHttpResponse();
	*** disconnect();
	*** getContent();
	*** getContentEncoding();
	*** getContentType();
	*** getHeaderCount();
	*** getHeaderName(int);
	*** getHeaderValue(int);
	*** getReasonPhrase();
	*** getStatusCode();
	*** getStatusLine();
}

-keep class com.google.api.client.http.UrlEncodedContent {
	*** data;
	*** appendParam(boolean,java.io.Writer,java.lang.String,java.lang.Object);
	*** getContent(com.google.api.client.http.HttpRequest);
	*** getData();
	*** setData(java.lang.Object);
	*** setMediaType(com.google.api.client.http.HttpMediaType);
}

-keep class com.google.api.client.http.UrlEncodedParser {
	*** MEDIA_TYPE;
	*** parse(java.io.Reader,java.lang.Object);
	*** parse(java.lang.String,java.lang.Object);
	*** parseAndClose(java.io.Reader,java.lang.Class);
	*** parseAndClose(java.io.Reader,java.lang.reflect.Type);
	*** parseValue(java.lang.reflect.Type,java.util.List,java.lang.String);
}

-keep class com.google.api.client.http.apache.ApacheHttpRequest {
	*** httpClient;
	*** request;
}

-keep class com.google.api.client.http.apache.ApacheHttpResponse {
	*** allHeaders;
	*** request;
	*** response;
}

-keep class com.google.api.client.http.apache.ApacheHttpTransport {
	*** httpClient;
	com.google.api.client.http.apache.ApacheHttpTransport(org.apache.http.client.HttpClient);
	*** buildRequest(java.lang.String,java.lang.String);
	*** newDefaultHttpClient();
	*** newDefaultHttpClient(org.apache.http.conn.ssl.SSLSocketFactory,org.apache.http.params.HttpParams,java.net.ProxySelector);
	*** newDefaultHttpParams();
}

-keep class com.google.api.client.http.apache.ContentEntity {
	*** contentLength;
	*** streamingContent;
}

-keep class com.google.api.client.http.apache.HttpExtensionMethod {
	*** methodName;
}

-keep class com.google.api.client.http.javanet.NetHttpTransport {
	*** SUPPORTED_METHODS;
	*** hostnameVerifier;
	*** proxy;
	*** sslSocketFactory;
	com.google.api.client.http.javanet.NetHttpTransport(java.net.Proxy,javax.net.ssl.SSLSocketFactory,javax.net.ssl.HostnameVerifier);
	*** buildRequest(java.lang.String,java.lang.String);
	*** supportsMethod(java.lang.String);
}

-keep class com.google.api.client.json.CustomizeJsonParser {
	*** handleUnrecognizedKey(java.lang.Object,java.lang.String);
	*** newInstanceForArray(java.lang.Object,java.lang.reflect.Field);
	*** newInstanceForObject(java.lang.Object,java.lang.Class);
	*** stopAt(java.lang.Object,java.lang.String);
}

-keep class com.google.api.client.json.GenericJson {
	*** jsonFactory;
	com.google.api.client.json.GenericJson();
	*** clone();
	*** set(java.lang.String,java.lang.Object);
	*** setFactory(com.google.api.client.json.JsonFactory);
	*** toPrettyString();
}

-keep class com.google.api.client.json.Json {
	*** MEDIA_TYPE;
}

-keep class com.google.api.client.json.JsonFactory {
	com.google.api.client.json.JsonFactory();
	*** createJsonGenerator(java.io.OutputStream,java.nio.charset.Charset);
	*** createJsonParser(java.io.InputStream);
	*** createJsonParser(java.io.InputStream,java.nio.charset.Charset);
	*** createJsonParser(java.io.Reader);
	*** createJsonParser(java.lang.String);
	*** fromInputStream(java.io.InputStream,java.lang.Class);
	*** toByteStream(java.lang.Object,boolean);
	*** toPrettyString(java.lang.Object);
	*** toString(java.lang.Object);
	*** toString(java.lang.Object,boolean);
}

-keep class com.google.api.client.json.JsonGenerator {
	com.google.api.client.json.JsonGenerator();
	*** enablePrettyPrint();
	*** flush();
	*** serialize(boolean,java.lang.Object);
	*** serialize(java.lang.Object);
	*** writeBoolean(boolean);
	*** writeEndArray();
	*** writeEndObject();
	*** writeFieldName(java.lang.String);
	*** writeNull();
	*** writeNumber(double);
	*** writeNumber(float);
	*** writeNumber(int);
	*** writeNumber(java.math.BigDecimal);
	*** writeNumber(java.math.BigInteger);
	*** writeNumber(long);
	*** writeStartArray();
	*** writeStartObject();
	*** writeString(java.lang.String);
}

-keep class com.google.api.client.json.JsonObjectParser {
	*** jsonFactory;
	*** wrapperKeys;
	com.google.api.client.json.JsonObjectParser(com.google.api.client.json.JsonObjectParser$Builder);
	*** initializeParser(com.google.api.client.json.JsonParser);
	*** parseAndClose(java.io.InputStream,java.nio.charset.Charset,java.lang.Class);
	*** parseAndClose(java.io.InputStream,java.nio.charset.Charset,java.lang.reflect.Type);
	*** parseAndClose(java.io.Reader,java.lang.reflect.Type);
}

-keep class com.google.api.client.json.JsonObjectParser$Builder {
	*** jsonFactory;
	*** wrapperKeys;
}

-keep class com.google.api.client.json.JsonParser {
	com.google.api.client.json.JsonParser();
	*** close();
	*** getBigIntegerValue();
	*** getByteValue();
	*** getCurrentName();
	*** getCurrentToken();
	*** getDecimalValue();
	*** getDoubleValue();
	*** getFactory();
	*** getFloatValue();
	*** getIntValue();
	*** getLongValue();
	*** getShortValue();
	*** getText();
	*** nextToken();
	*** parse(java.lang.Class,com.google.api.client.json.CustomizeJsonParser);
	*** parse(java.lang.Object,com.google.api.client.json.CustomizeJsonParser);
	*** parse(java.lang.reflect.Type,boolean,com.google.api.client.json.CustomizeJsonParser);
	*** parse(java.util.ArrayList,java.lang.Object,com.google.api.client.json.CustomizeJsonParser);
	*** parseAndClose(java.lang.Class,com.google.api.client.json.CustomizeJsonParser);
	*** parseArray(java.lang.Class,java.lang.Class,com.google.api.client.json.CustomizeJsonParser);
	*** parseArray(java.lang.reflect.Field,java.util.Collection,java.lang.reflect.Type,java.util.ArrayList,com.google.api.client.json.CustomizeJsonParser);
	*** parseArray(java.util.Collection,java.lang.Class,com.google.api.client.json.CustomizeJsonParser);
	*** parseMap(java.lang.reflect.Field,java.util.Map,java.lang.reflect.Type,java.util.ArrayList,com.google.api.client.json.CustomizeJsonParser);
	*** parseValue(java.lang.reflect.Field,java.lang.reflect.Type,java.util.ArrayList,java.lang.Object,com.google.api.client.json.CustomizeJsonParser);
	*** skipChildren();
	*** skipToKey(java.util.Set);
	*** startParsing();
	*** startParsingObjectOrArray();
}

-keep class com.google.api.client.json.JsonParser$1 {
	*** $SwitchMap$com$google$api$client$json$JsonToken;
}

-keep class com.google.api.client.json.JsonToken {
	*** $VALUES;
	*** END_ARRAY;
	*** END_OBJECT;
	*** FIELD_NAME;
	*** NOT_AVAILABLE;
	*** START_ARRAY;
	*** START_OBJECT;
	*** VALUE_FALSE;
	*** VALUE_NULL;
	*** VALUE_NUMBER_FLOAT;
	*** VALUE_NUMBER_INT;
	*** VALUE_STRING;
	*** VALUE_TRUE;
	*** values();
}

-keep class com.google.api.client.json.jackson.JacksonFactory {
	*** factory;
	*** convert(org.codehaus.jackson.JsonToken);
}

-keep class com.google.api.client.json.jackson.JacksonFactory$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class com.google.api.client.json.jackson.JacksonGenerator {
	*** factory;
	*** generator;
	*** getFactory();
}

-keep class com.google.api.client.json.jackson.JacksonParser {
	*** factory;
	*** parser;
	*** getFactory();
}

-keep class com.google.api.client.json.webtoken.JsonWebSignature {
	*** signUsingRsaSha256(java.security.PrivateKey,com.google.api.client.json.JsonFactory,com.google.api.client.json.webtoken.JsonWebSignature$Header,com.google.api.client.json.webtoken.JsonWebToken$Payload);
}

-keep class com.google.api.client.json.webtoken.JsonWebSignature$Header {
	*** setAlgorithm(java.lang.String);
	*** setType(java.lang.String);
}

-keep class com.google.api.client.json.webtoken.JsonWebToken$Payload {
	*** setAudience(java.lang.Object);
	*** setExpirationTimeSeconds(java.lang.Long);
	*** setIssuedAtTimeSeconds(java.lang.Long);
	*** setIssuer(java.lang.String);
	*** setSubject(java.lang.String);
}

-keep class com.google.api.client.repackaged.com.google.common.base.Preconditions {
	*** badElementIndex(int,int,java.lang.String);
	*** badPositionIndex(int,int,java.lang.String);
	*** badPositionIndexes(int,int,int);
	*** checkArgument(boolean);
	*** checkArgument(boolean,java.lang.Object);
	*** checkArgument(boolean,java.lang.String,java.lang.Object[]);
	*** checkElementIndex(int,int,java.lang.String);
	*** checkNotNull(java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.String,java.lang.Object[]);
	*** checkPositionIndex(int,int,java.lang.String);
	*** checkState(boolean);
	*** checkState(boolean,java.lang.Object);
	*** checkState(boolean,java.lang.String,java.lang.Object[]);
	*** format(java.lang.String,java.lang.Object[]);
}

-keep class com.google.api.client.util.ArrayMap {
	*** data;
	*** size;
	*** clone();
	*** create();
	*** create(int);
	*** ensureCapacity(int);
	*** getDataIndexOfKey(java.lang.Object);
	*** getIndexOfKey(java.lang.Object);
	*** getKey(int);
	*** getValue(int);
	*** remove(int);
	*** removeFromDataIndexOfKey(int);
	*** set(int,java.lang.Object);
	*** set(int,java.lang.Object,java.lang.Object);
	*** setData(int,java.lang.Object,java.lang.Object);
	*** setDataCapacity(int);
	*** size();
	*** valueAtDataIndex(int);
}

-keep class com.google.api.client.util.ArrayMap$Entry {
	*** index;
	*** this$0;
	*** getKey();
	*** getValue();
}

-keep class com.google.api.client.util.ArrayMap$EntryIterator {
	*** nextIndex;
	*** removed;
	*** this$0;
	*** next();
}

-keep class com.google.api.client.util.ArrayMap$EntrySet {
	*** this$0;
}

-keep class com.google.api.client.util.ArrayValueMap {
	*** destination;
	*** fieldMap;
	*** keyMap;
	*** put(java.lang.reflect.Field,java.lang.Class,java.lang.Object);
	*** setValues();
}

-keep class com.google.api.client.util.ArrayValueMap$ArrayValue {
	*** addValue(java.lang.Class,java.lang.Object);
	*** toArray();
}

-keep class com.google.api.client.util.Base64 {
	*** encodeBase64String(byte[]);
}

-keep class com.google.api.client.util.ByteCountingOutputStream {
	*** count;
}

-keep class com.google.api.client.util.ByteStreams {
	*** copy(java.io.InputStream,java.io.OutputStream);
}

-keep class com.google.api.client.util.Charsets {
	*** ISO_8859_1;
	*** UTF_8;
}

-keep class com.google.api.client.util.ClassInfo {
	*** CACHE;
	*** CACHE_IGNORE_CASE;
	*** clazz;
	*** ignoreCase;
	*** nameToFieldInfoMap;
	*** names;
	*** getField(java.lang.String);
	*** getFieldInfo(java.lang.String);
	*** getIgnoreCase();
	*** isEnum();
	*** of(java.lang.Class);
	*** of(java.lang.Class,boolean);
}

-keep class com.google.api.client.util.ClassInfo$1 {
	*** this$0;
	*** compare(java.lang.String,java.lang.String);
}

-keep class com.google.api.client.util.Clock {
	*** SYSTEM;
	*** currentTimeMillis();
}

-keep class com.google.api.client.util.Data {
	*** NULL_BIG_DECIMAL;
	*** NULL_BIG_INTEGER;
	*** NULL_BOOLEAN;
	*** NULL_BYTE;
	*** NULL_CACHE;
	*** NULL_CHARACTER;
	*** NULL_DATE_TIME;
	*** NULL_DOUBLE;
	*** NULL_FLOAT;
	*** NULL_INTEGER;
	*** NULL_LONG;
	*** NULL_SHORT;
	*** NULL_STRING;
	*** clone(java.lang.Object);
	*** deepCopy(java.lang.Object,java.lang.Object);
	*** isNull(java.lang.Object);
	*** isPrimitive(java.lang.reflect.Type);
	*** mapOf(java.lang.Object);
	*** newCollectionInstance(java.lang.reflect.Type);
	*** newMapInstance(java.lang.Class);
	*** nullOf(java.lang.Class);
	*** parsePrimitiveValue(java.lang.reflect.Type,java.lang.String);
	*** resolveWildcardTypeOrTypeVariable(java.util.List,java.lang.reflect.Type);
}

-keep class com.google.api.client.util.DataMap {
	*** classInfo;
	*** object;
	*** entrySet();
	*** get(java.lang.Object);
	*** put(java.lang.String,java.lang.Object);
}

-keep class com.google.api.client.util.DataMap$Entry {
	*** fieldInfo;
	*** fieldValue;
	*** this$0;
	*** getKey();
	*** getValue();
}

-keep class com.google.api.client.util.DataMap$EntryIterator {
	*** currentFieldInfo;
	*** isComputed;
	*** isRemoved;
	*** nextFieldInfo;
	*** nextFieldValue;
	*** nextKeyIndex;
	*** this$0;
	*** hasNext();
	*** next();
}

-keep class com.google.api.client.util.DataMap$EntrySet {
	*** this$0;
	*** clear();
	*** iterator();
	*** size();
}

-keep class com.google.api.client.util.DateTime {
	*** GMT;
	*** dateOnly;
	*** tzShift;
	*** value;
	com.google.api.client.util.DateTime(boolean,long,java.lang.Integer);
	com.google.api.client.util.DateTime(long);
	*** appendInt(java.lang.StringBuilder,int,int);
	*** parseRfc3339(java.lang.String);
	*** toStringRfc3339();
}

-keep class com.google.api.client.util.FieldInfo {
	*** CACHE;
	*** field;
	*** isPrimitive;
	*** name;
	*** enumValue();
	*** getField();
	*** getFieldValue(java.lang.reflect.Field,java.lang.Object);
	*** getGenericType();
	*** getName();
	*** getType();
	*** getValue(java.lang.Object);
	*** isFinal();
	*** isPrimitive();
	*** of(java.lang.Enum);
	*** of(java.lang.reflect.Field);
	*** setFieldValue(java.lang.reflect.Field,java.lang.Object,java.lang.Object);
	*** setValue(java.lang.Object,java.lang.Object);
}

-keep class com.google.api.client.util.GenericData {
	*** classInfo;
	*** unknownFields;
	com.google.api.client.util.GenericData();
	com.google.api.client.util.GenericData(java.util.EnumSet);
	*** clone();
	*** entrySet();
	*** get(java.lang.Object);
	*** getClassInfo();
	*** put(java.lang.String,java.lang.Object);
	*** set(java.lang.String,java.lang.Object);
}

-keep class com.google.api.client.util.GenericData$EntryIterator {
	*** fieldIterator;
	*** startedUnknown;
	*** this$0;
	*** unknownIterator;
	*** next();
}

-keep class com.google.api.client.util.GenericData$EntrySet {
	*** dataEntrySet;
	*** this$0;
}

-keep class com.google.api.client.util.GenericData$Flags {
	*** $VALUES;
	*** IGNORE_CASE;
}

-keep class com.google.api.client.util.IOUtils {
	*** computeLength(com.google.api.client.util.StreamingContent);
	*** copy(java.io.InputStream,java.io.OutputStream);
	*** copy(java.io.InputStream,java.io.OutputStream,boolean);
}

-keep class com.google.api.client.util.Joiner {
	*** join(java.lang.Iterable);
	*** on(char);
}

-keep class com.google.api.client.util.Key {
	*** value();
}

-keep class com.google.api.client.util.LoggingByteArrayOutputStream {
	*** close();
	*** write(byte[],int,int);
	*** write(int);
}

-keep class com.google.api.client.util.LoggingInputStream {
	*** logStream;
}

-keep class com.google.api.client.util.ObjectParser {
	*** parseAndClose(java.io.InputStream,java.nio.charset.Charset,java.lang.Class);
	*** parseAndClose(java.io.InputStream,java.nio.charset.Charset,java.lang.reflect.Type);
}

-keep class com.google.api.client.util.Objects {
	*** equal(java.lang.Object,java.lang.Object);
}

-keep class com.google.api.client.util.Preconditions {
	*** checkArgument(boolean);
	*** checkArgument(boolean,java.lang.Object);
	*** checkArgument(boolean,java.lang.String,java.lang.Object[]);
	*** checkNotNull(java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.String,java.lang.Object[]);
	*** checkState(boolean);
}

-keep class com.google.api.client.util.Sets {
	*** newHashSet();
}

-keep class com.google.api.client.util.StreamingContent {
	*** writeTo(java.io.OutputStream);
}

-keep class com.google.api.client.util.StringUtils {
	*** LINE_SEPARATOR;
	*** getBytesUtf8(java.lang.String);
}

-keep class com.google.api.client.util.Strings {
	*** isNullOrEmpty(java.lang.String);
}

-keep class com.google.api.client.util.Throwables {
	*** propagate(java.lang.Throwable);
}

-keep class com.google.api.client.util.Types {
	*** getActualParameterAtPosition(java.lang.reflect.Type,java.lang.Class,int);
	*** getArrayComponentType(java.lang.reflect.Type);
	*** getBound(java.lang.reflect.WildcardType);
	*** getIterableParameter(java.lang.reflect.Type);
	*** getMapValueParameter(java.lang.reflect.Type);
	*** getRawArrayComponentType(java.util.List,java.lang.reflect.Type);
	*** getRawClass(java.lang.reflect.ParameterizedType);
	*** getSuperParameterizedType(java.lang.reflect.Type,java.lang.Class);
	*** handleExceptionForNewInstance(java.lang.Exception,java.lang.Class);
	*** isArray(java.lang.reflect.Type);
	*** isAssignableToOrFrom(java.lang.Class,java.lang.Class);
	*** iterableOf(java.lang.Object);
	*** newInstance(java.lang.Class);
	*** resolveTypeVariable(java.util.List,java.lang.reflect.TypeVariable);
	*** toArray(java.util.Collection,java.lang.Class);
}

-keep class com.google.api.client.util.Value {
	*** value();
}

-keep class com.google.api.client.util.escape.CharEscapers {
	*** URI_ESCAPER;
	*** URI_PATH_ESCAPER;
	*** URI_QUERY_STRING_ESCAPER;
	*** decodeUri(java.lang.String);
	*** escapeUri(java.lang.String);
	*** escapeUriPath(java.lang.String);
	*** escapeUriQuery(java.lang.String);
}

-keep class com.google.api.client.util.escape.Escaper {
	com.google.api.client.util.escape.Escaper();
	*** escape(java.lang.String);
}

-keep class com.google.api.client.util.escape.PercentEscaper {
	*** UPPER_HEX_DIGITS;
	*** URI_ESCAPED_SPACE;
	*** plusForSpace;
	*** safeOctets;
	*** createSafeOctets(java.lang.String);
}

-keep class com.google.api.client.util.escape.Platform {
	*** DEST_TL;
	*** charBufferFromThreadLocal();
}

-keep class com.google.api.client.util.escape.Platform$1 {
	*** initialValue();
}

-keep class com.google.api.client.util.escape.UnicodeEscaper {
	com.google.api.client.util.escape.UnicodeEscaper();
	*** codePointAt(java.lang.CharSequence,int,int);
	*** escape(int);
	*** escapeSlow(java.lang.String,int);
	*** growBuffer(char[],int,int);
	*** nextEscapeIndex(java.lang.CharSequence,int,int);
}

-keep class com.google.common.base.Ascii {
	*** toLowerCase(java.lang.String);
}

-keep class com.google.common.base.CharMatcher {
	*** precomputedInternal();
}

-keep class com.google.common.base.Charsets {
	*** ISO_8859_1;
	*** US_ASCII;
	*** UTF_16;
	*** UTF_16BE;
	*** UTF_16LE;
	*** UTF_8;
}

-keep class com.google.common.base.Equivalence {
	com.google.common.base.Equivalence();
	*** doEquivalent(java.lang.Object,java.lang.Object);
	*** doHash(java.lang.Object);
	*** equals();
	*** equivalent(java.lang.Object,java.lang.Object);
	*** hash(java.lang.Object);
	*** identity();
}

-keep class com.google.common.base.Equivalence$Equals {
	*** INSTANCE;
}

-keep class com.google.common.base.Equivalence$Identity {
	*** INSTANCE;
}

-keep class com.google.common.base.Function {
	*** apply(java.lang.Object);
	*** equals(java.lang.Object);
}

-keep class com.google.common.base.FunctionalEquivalence {
	*** function;
	*** resultEquivalence;
}

-keep class com.google.common.base.Joiner {
	*** separator;
	com.google.common.base.Joiner(com.google.common.base.Joiner);
	com.google.common.base.Joiner(com.google.common.base.Joiner,com.google.common.base.Joiner$1);
	*** access$100(com.google.common.base.Joiner);
	*** appendTo(java.lang.Appendable,java.lang.Iterable);
	*** appendTo(java.lang.Appendable,java.util.Iterator);
	*** appendTo(java.lang.StringBuilder,java.lang.Iterable);
	*** appendTo(java.lang.StringBuilder,java.util.Iterator);
	*** iterable(java.lang.Object,java.lang.Object,java.lang.Object[]);
	*** join(java.lang.Iterable);
	*** join(java.util.Iterator);
	*** on(char);
	*** on(java.lang.String);
	*** toString(java.lang.Object);
	*** useForNull(java.lang.String);
	*** withKeyValueSeparator(java.lang.String);
}

-keep class com.google.common.base.Joiner$1 {
	*** this$0;
	*** val$nullText;
}

-keep class com.google.common.base.Joiner$2 {
	*** this$0;
}

-keep class com.google.common.base.Joiner$MapJoiner {
	*** joiner;
	*** keyValueSeparator;
	com.google.common.base.Joiner$MapJoiner(com.google.common.base.Joiner,java.lang.String);
	*** appendTo(java.lang.Appendable,java.lang.Iterable);
	*** appendTo(java.lang.Appendable,java.util.Iterator);
	*** appendTo(java.lang.StringBuilder,java.lang.Iterable);
	*** appendTo(java.lang.StringBuilder,java.util.Iterator);
	*** appendTo(java.lang.StringBuilder,java.util.Map);
	*** join(java.lang.Iterable);
	*** join(java.util.Iterator);
}

-keep class com.google.common.base.Objects {
	*** equal(java.lang.Object,java.lang.Object);
	*** firstNonNull(java.lang.Object,java.lang.Object);
	*** hashCode(java.lang.Object[]);
	*** simpleName(java.lang.Class);
	*** toStringHelper(java.lang.Object);
}

-keep class com.google.common.base.Objects$ToStringHelper {
	*** add(java.lang.String,int);
	*** add(java.lang.String,java.lang.Object);
	*** add(java.lang.String,long);
	*** addValue(java.lang.Object);
	*** toString();
}

-keep class com.google.common.base.Optional {
	*** absent();
	*** of(java.lang.Object);
}

-keep class com.google.common.base.PairwiseEquivalence {
	*** elementEquivalence;
	*** doEquivalent(java.lang.Iterable,java.lang.Iterable);
	*** doHash(java.lang.Iterable);
}

-keep class com.google.common.base.Platform {
	*** DEST_TL;
	*** systemNanoTime();
}

-keep class com.google.common.base.Platform$1 {
	*** initialValue();
}

-keep class com.google.common.base.Preconditions {
	*** badElementIndex(int,int,java.lang.String);
	*** badPositionIndex(int,int,java.lang.String);
	*** badPositionIndexes(int,int,int);
	*** checkArgument(boolean);
	*** checkArgument(boolean,java.lang.Object);
	*** checkArgument(boolean,java.lang.String,java.lang.Object[]);
	*** checkElementIndex(int,int);
	*** checkElementIndex(int,int,java.lang.String);
	*** checkNotNull(java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.String,java.lang.Object[]);
	*** checkPositionIndex(int,int);
	*** checkPositionIndex(int,int,java.lang.String);
	*** checkPositionIndexes(int,int,int);
	*** checkState(boolean);
	*** checkState(boolean,java.lang.Object);
	*** checkState(boolean,java.lang.String,java.lang.Object[]);
	*** format(java.lang.String,java.lang.Object[]);
}

-keep class com.google.common.base.Predicate {
	*** apply(java.lang.Object);
}

-keep class com.google.common.base.Predicates {
	*** and(com.google.common.base.Predicate,com.google.common.base.Predicate);
	*** in(java.util.Collection);
	*** instanceOf(java.lang.Class);
	*** not(com.google.common.base.Predicate);
}

-keep class com.google.common.base.Splitter {
	*** omitEmptyStrings();
	*** on(char);
	*** on(java.util.regex.Pattern);
	*** split(java.lang.CharSequence);
}

-keep class com.google.common.base.Stopwatch {
	*** elapsedNanos;
	*** isRunning;
	*** startTick;
	*** ticker;
	com.google.common.base.Stopwatch(com.google.common.base.Ticker);
	*** abbreviate(java.util.concurrent.TimeUnit);
	*** chooseUnit(long);
	*** elapsed(java.util.concurrent.TimeUnit);
	*** elapsedNanos();
	*** start();
	*** stop();
	*** toString(int);
}

-keep class com.google.common.base.Stopwatch$1 {
	*** $SwitchMap$java$util$concurrent$TimeUnit;
}

-keep class com.google.common.base.Supplier {
	*** get();
}

-keep class com.google.common.base.Suppliers {
	*** ofInstance(java.lang.Object);
}

-keep class com.google.common.base.Suppliers$SupplierFunction {
	*** INSTANCE;
}

-keep class com.google.common.base.Suppliers$SupplierOfInstance {
	*** instance;
}

-keep class com.google.common.base.Throwables {
	*** propagate(java.lang.Throwable);
	*** propagateIfPossible(java.lang.Throwable,java.lang.Class);
	*** propagateIfPossible(java.lang.Throwable,java.lang.Class,java.lang.Class);
}

-keep class com.google.common.base.Ticker {
	*** SYSTEM_TICKER;
	com.google.common.base.Ticker();
	*** read();
	*** systemTicker();
}

-keep class com.google.common.cache.AbstractCache$SimpleStatsCounter {
	*** incrementBy(com.google.common.cache.AbstractCache$StatsCounter);
	*** snapshot();
}

-keep class com.google.common.cache.AbstractCache$StatsCounter {
	*** recordEviction();
	*** recordHits(int);
	*** recordLoadException(long);
	*** recordLoadSuccess(long);
	*** recordMisses(int);
}

-keep class com.google.common.cache.CacheBuilder {
	*** CACHE_STATS_COUNTER;
	*** EMPTY_STATS;
	*** NULL_STATS_COUNTER;
	*** NULL_TICKER;
	*** concurrencyLevel;
	*** expireAfterAccessNanos;
	*** expireAfterWriteNanos;
	*** initialCapacity;
	*** keyEquivalence;
	*** keyStrength;
	*** logger;
	*** maximumSize;
	*** maximumWeight;
	*** refreshNanos;
	*** removalListener;
	*** statsCounterSupplier;
	*** strictParsing;
	*** ticker;
	*** valueEquivalence;
	*** valueStrength;
	*** weigher;
	*** build(com.google.common.cache.CacheLoader);
	*** checkNonLoadingCache();
	*** checkWeightWithWeigher();
	*** from(com.google.common.cache.CacheBuilderSpec);
	*** getConcurrencyLevel();
	*** getExpireAfterAccessNanos();
	*** getExpireAfterWriteNanos();
	*** getInitialCapacity();
	*** getKeyEquivalence();
	*** getKeyStrength();
	*** getMaximumWeight();
	*** getRefreshNanos();
	*** getRemovalListener();
	*** getStatsCounterSupplier();
	*** getTicker(boolean);
	*** getValueEquivalence();
	*** getValueStrength();
	*** getWeigher();
	*** lenientParsing();
	*** newBuilder();
	*** setKeyStrength(com.google.common.cache.LocalCache$Strength);
	*** setValueStrength(com.google.common.cache.LocalCache$Strength);
	*** weakKeys();
}

-keep class com.google.common.cache.CacheBuilder$2 {
	*** get();
}

-keep class com.google.common.cache.CacheBuilder$NullListener {
	*** $VALUES;
	*** INSTANCE;
}

-keep class com.google.common.cache.CacheBuilder$OneWeigher {
	*** $VALUES;
	*** INSTANCE;
}

-keep class com.google.common.cache.CacheBuilderSpec {
	*** parse(java.lang.String);
	*** toCacheBuilder();
}

-keep class com.google.common.cache.CacheLoader {
	com.google.common.cache.CacheLoader();
	*** load(java.lang.Object);
	*** loadAll(java.lang.Iterable);
	*** reload(java.lang.Object,java.lang.Object);
}

-keep class com.google.common.cache.CacheLoader$FunctionToCacheLoader {
	*** computingFunction;
}

-keep class com.google.common.cache.CacheLoader$SupplierToCacheLoader {
	*** computingSupplier;
}

-keep class com.google.common.cache.CacheStats {
	*** evictionCount;
	*** hitCount;
	*** loadExceptionCount;
	*** loadSuccessCount;
	*** missCount;
	*** totalLoadTime;
	*** requestCount();
}

-keep class com.google.common.cache.LoadingCache {
	*** getUnchecked(java.lang.Object);
}

-keep class com.google.common.cache.LocalCache {
	*** DISCARDING_QUEUE;
	*** UNSET;
	*** concurrencyLevel;
	*** defaultLoader;
	*** entryFactory;
	*** entrySet;
	*** expireAfterAccessNanos;
	*** expireAfterWriteNanos;
	*** globalStatsCounter;
	*** keyEquivalence;
	*** keySet;
	*** keyStrength;
	*** logger;
	*** maxWeight;
	*** refreshNanos;
	*** removalListener;
	*** removalNotificationQueue;
	*** sameThreadExecutor;
	*** segmentMask;
	*** segmentShift;
	*** segments;
	*** ticker;
	*** valueEquivalence;
	*** valueStrength;
	*** values;
	*** weigher;
	*** cleanUp();
	*** clear();
	*** connectAccessOrder(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** connectWriteOrder(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** createSegment(int,long,com.google.common.cache.AbstractCache$StatsCounter);
	*** customWeigher();
	*** discardingQueue();
	*** evictsBySize();
	*** expiresAfterAccess();
	*** expiresAfterWrite();
	*** get(java.lang.Object);
	*** get(java.lang.Object,com.google.common.cache.CacheLoader);
	*** getAll(java.lang.Iterable);
	*** getAllPresent(java.lang.Iterable);
	*** getIfPresent(java.lang.Object);
	*** getOrLoad(java.lang.Object);
	*** hash(java.lang.Object);
	*** invalidateAll(java.lang.Iterable);
	*** isExpired(com.google.common.cache.LocalCache$ReferenceEntry,long);
	*** loadAll(java.util.Set,com.google.common.cache.CacheLoader);
	*** longSize();
	*** newSegmentArray(int);
	*** nullEntry();
	*** nullifyAccessOrder(com.google.common.cache.LocalCache$ReferenceEntry);
	*** nullifyWriteOrder(com.google.common.cache.LocalCache$ReferenceEntry);
	*** processPendingNotifications();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** reclaimKey(com.google.common.cache.LocalCache$ReferenceEntry);
	*** reclaimValue(com.google.common.cache.LocalCache$ValueReference);
	*** recordsAccess();
	*** recordsTime();
	*** recordsWrite();
	*** refresh(java.lang.Object);
	*** refreshes();
	*** rehash(int);
	*** remove(java.lang.Object);
	*** segmentFor(int);
	*** unset();
	*** usesAccessEntries();
	*** usesAccessQueue();
	*** usesKeyReferences();
	*** usesValueReferences();
	*** usesWriteEntries();
	*** usesWriteQueue();
}

-keep class com.google.common.cache.LocalCache$EntryFactory {
	*** $VALUES;
	*** STRONG;
	*** STRONG_ACCESS;
	*** STRONG_ACCESS_WRITE;
	*** STRONG_WRITE;
	*** WEAK;
	*** WEAK_ACCESS;
	*** WEAK_ACCESS_WRITE;
	*** WEAK_WRITE;
	*** factories;
	com.google.common.cache.LocalCache$EntryFactory(java.lang.String,int);
	com.google.common.cache.LocalCache$EntryFactory(java.lang.String,int,com.google.common.cache.LocalCache$1);
	*** copyAccessEntry(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** copyEntry(com.google.common.cache.LocalCache$Segment,com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** copyWriteEntry(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** getFactory(com.google.common.cache.LocalCache$Strength,boolean,boolean);
	*** newEntry(com.google.common.cache.LocalCache$Segment,java.lang.Object,int,com.google.common.cache.LocalCache$ReferenceEntry);
}

-keep class com.google.common.cache.LocalCache$LoadingValueReference {
	*** futureValue;
	*** oldValue;
	*** stopwatch;
	com.google.common.cache.LocalCache$LoadingValueReference(com.google.common.cache.LocalCache$ValueReference);
	*** elapsedNanos();
	*** fullyFailedFuture(java.lang.Throwable);
	*** getOldValue();
	*** isActive();
	*** loadFuture(java.lang.Object,com.google.common.cache.CacheLoader);
	*** set(java.lang.Object);
	*** setException(com.google.common.util.concurrent.SettableFuture,java.lang.Throwable);
	*** setException(java.lang.Throwable);
}

-keep class com.google.common.cache.LocalCache$LocalLoadingCache {
	*** get(java.lang.Object);
	*** getUnchecked(java.lang.Object);
}

-keep class com.google.common.cache.LocalCache$LocalManualCache {
	*** localCache;
	com.google.common.cache.LocalCache$LocalManualCache(com.google.common.cache.LocalCache);
	com.google.common.cache.LocalCache$LocalManualCache(com.google.common.cache.LocalCache,com.google.common.cache.LocalCache$1);
}

-keep class com.google.common.cache.LocalCache$LocalManualCache$1 {
	*** this$0;
	*** val$valueLoader;
}

-keep class com.google.common.cache.LocalCache$NullEntry {
	*** INSTANCE;
}

-keep class com.google.common.cache.LocalCache$ReferenceEntry {
	*** getAccessTime();
	*** getHash();
	*** getKey();
	*** getNext();
	*** getNextInAccessQueue();
	*** getNextInWriteQueue();
	*** getPreviousInAccessQueue();
	*** getPreviousInWriteQueue();
	*** getValueReference();
	*** getWriteTime();
	*** setAccessTime(long);
	*** setNextInAccessQueue(com.google.common.cache.LocalCache$ReferenceEntry);
	*** setNextInWriteQueue(com.google.common.cache.LocalCache$ReferenceEntry);
	*** setPreviousInAccessQueue(com.google.common.cache.LocalCache$ReferenceEntry);
	*** setPreviousInWriteQueue(com.google.common.cache.LocalCache$ReferenceEntry);
	*** setValueReference(com.google.common.cache.LocalCache$ValueReference);
	*** setWriteTime(long);
}

-keep class com.google.common.cache.LocalCache$Segment {
	*** accessQueue;
	*** count;
	*** keyReferenceQueue;
	*** map;
	*** maxSegmentWeight;
	*** modCount;
	*** readCount;
	*** recencyQueue;
	*** statsCounter;
	*** table;
	*** threshold;
	*** totalWeight;
	*** valueReferenceQueue;
	*** writeQueue;
	*** cleanUp();
	*** clear();
	*** clearKeyReferenceQueue();
	*** clearReferenceQueues();
	*** clearValueReferenceQueue();
	*** containsKey(java.lang.Object,int);
	*** copyEntry(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** drainKeyReferenceQueue();
	*** drainRecencyQueue();
	*** drainReferenceQueues();
	*** drainValueReferenceQueue();
	*** enqueueNotification(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.RemovalCause);
	*** enqueueNotification(java.lang.Object,int,com.google.common.cache.LocalCache$ValueReference,com.google.common.cache.RemovalCause);
	*** evictEntries();
	*** expand();
	*** expireEntries(long);
	*** get(java.lang.Object,int);
	*** get(java.lang.Object,int,com.google.common.cache.CacheLoader);
	*** getAndRecordStats(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,com.google.common.util.concurrent.ListenableFuture);
	*** getEntry(java.lang.Object,int);
	*** getFirst(int);
	*** getLiveEntry(java.lang.Object,int,long);
	*** getLiveValue(com.google.common.cache.LocalCache$ReferenceEntry,long);
	*** getNextEvictable();
	*** initTable(java.util.concurrent.atomic.AtomicReferenceArray);
	*** insertLoadingValueReference(java.lang.Object,int,boolean);
	*** loadAsync(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,com.google.common.cache.CacheLoader);
	*** loadSync(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,com.google.common.cache.CacheLoader);
	*** lockedGetOrLoad(java.lang.Object,int,com.google.common.cache.CacheLoader);
	*** newEntry(java.lang.Object,int,com.google.common.cache.LocalCache$ReferenceEntry);
	*** newEntryArray(int);
	*** postReadCleanup();
	*** postWriteCleanup();
	*** preWriteCleanup(long);
	*** put(java.lang.Object,int,java.lang.Object,boolean);
	*** reclaimKey(com.google.common.cache.LocalCache$ReferenceEntry,int);
	*** reclaimValue(java.lang.Object,int,com.google.common.cache.LocalCache$ValueReference);
	*** recordLockedRead(com.google.common.cache.LocalCache$ReferenceEntry,long);
	*** recordRead(com.google.common.cache.LocalCache$ReferenceEntry,long);
	*** recordWrite(com.google.common.cache.LocalCache$ReferenceEntry,int,long);
	*** refresh(java.lang.Object,int,com.google.common.cache.CacheLoader,boolean);
	*** remove(java.lang.Object,int);
	*** remove(java.lang.Object,int,java.lang.Object);
	*** removeCollectedEntry(com.google.common.cache.LocalCache$ReferenceEntry);
	*** removeEntry(com.google.common.cache.LocalCache$ReferenceEntry,int,com.google.common.cache.RemovalCause);
	*** removeEntryFromChain(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry);
	*** removeLoadingValue(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference);
	*** removeValueFromChain(com.google.common.cache.LocalCache$ReferenceEntry,com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,int,com.google.common.cache.LocalCache$ValueReference,com.google.common.cache.RemovalCause);
	*** replace(java.lang.Object,int,java.lang.Object);
	*** replace(java.lang.Object,int,java.lang.Object,java.lang.Object);
	*** runLockedCleanup(long);
	*** runUnlockedCleanup();
	*** scheduleRefresh(com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,int,java.lang.Object,long,com.google.common.cache.CacheLoader);
	*** setValue(com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,java.lang.Object,long);
	*** storeLoadedValue(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,java.lang.Object);
	*** tryDrainReferenceQueues();
	*** tryExpireEntries(long);
	*** waitForLoadingValue(com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,com.google.common.cache.LocalCache$ValueReference);
}

-keep class com.google.common.cache.LocalCache$SoftValueReference {
	*** entry;
	com.google.common.cache.LocalCache$SoftValueReference(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.cache.LocalCache$ReferenceEntry);
}

-keep class com.google.common.cache.LocalCache$Strength {
	*** $VALUES;
	*** SOFT;
	*** STRONG;
	*** WEAK;
	com.google.common.cache.LocalCache$Strength(java.lang.String,int);
	com.google.common.cache.LocalCache$Strength(java.lang.String,int,com.google.common.cache.LocalCache$1);
	*** defaultEquivalence();
	*** referenceValue(com.google.common.cache.LocalCache$Segment,com.google.common.cache.LocalCache$ReferenceEntry,java.lang.Object,int);
}

-keep class com.google.common.cache.LocalCache$StrongValueReference {
	*** referent;
	com.google.common.cache.LocalCache$StrongValueReference(java.lang.Object);
	*** get();
}

-keep class com.google.common.cache.LocalCache$ValueReference {
	*** copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.cache.LocalCache$ReferenceEntry);
	*** get();
	*** getEntry();
	*** getWeight();
	*** isActive();
	*** isLoading();
	*** notifyNewValue(java.lang.Object);
	*** waitForValue();
}

-keep class com.google.common.cache.LocalCache$WeakEntry {
	*** hash;
	*** next;
	*** valueReference;
}

-keep class com.google.common.cache.LocalCache$WeakValueReference {
	*** entry;
	com.google.common.cache.LocalCache$WeakValueReference(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.cache.LocalCache$ReferenceEntry);
}

-keep class com.google.common.cache.LocalCache$WeightedSoftValueReference {
	*** weight;
}

-keep class com.google.common.cache.LocalCache$WeightedStrongValueReference {
	*** weight;
}

-keep class com.google.common.cache.LocalCache$WeightedWeakValueReference {
	*** weight;
}

-keep class com.google.common.cache.RemovalCause {
	*** COLLECTED;
	*** EXPIRED;
	*** EXPLICIT;
	*** REPLACED;
	*** SIZE;
	*** wasEvicted();
}

-keep class com.google.common.cache.RemovalListener {
	*** onRemoval(com.google.common.cache.RemovalNotification);
}

-keep class com.google.common.cache.Weigher {
	*** weigh(java.lang.Object,java.lang.Object);
}

-keep class com.google.common.collect.AbstractIndexedListIterator {
	*** position;
	*** size;
	com.google.common.collect.AbstractIndexedListIterator(int);
	com.google.common.collect.AbstractIndexedListIterator(int,int);
	*** get(int);
	*** hasNext();
	*** hasPrevious();
}

-keep class com.google.common.collect.AbstractIterator {
	*** next;
	*** state;
	com.google.common.collect.AbstractIterator();
	*** computeNext();
	*** endOfData();
	*** hasNext();
	*** tryToComputeNext();
}

-keep class com.google.common.collect.AbstractIterator$1 {
	*** $SwitchMap$com$google$common$collect$AbstractIterator$State;
}

-keep class com.google.common.collect.AbstractIterator$State {
	*** DONE;
	*** FAILED;
	*** NOT_READY;
	*** READY;
}

-keep class com.google.common.collect.AbstractMapBasedMultimap {
	*** map;
	*** totalSize;
	com.google.common.collect.AbstractMapBasedMultimap(java.util.Map);
	*** access$000(com.google.common.collect.AbstractMapBasedMultimap);
	*** access$100(com.google.common.collect.AbstractMapBasedMultimap,java.util.Collection);
	*** access$208(com.google.common.collect.AbstractMapBasedMultimap);
	*** access$210(com.google.common.collect.AbstractMapBasedMultimap);
	*** access$212(com.google.common.collect.AbstractMapBasedMultimap,int);
	*** access$220(com.google.common.collect.AbstractMapBasedMultimap,int);
	*** access$300(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection);
	*** clear();
	*** containsKey(java.lang.Object);
	*** createCollection();
	*** createCollection(java.lang.Object);
	*** createUnmodifiableEmptyCollection();
	*** entries();
	*** get(java.lang.Object);
	*** getOrCreateCollection(java.lang.Object);
	*** iteratorOrListIterator(java.util.Collection);
	*** put(java.lang.Object,java.lang.Object);
	*** removeAll(java.lang.Object);
	*** removeValuesForKey(java.lang.Object);
	*** replaceValues(java.lang.Object,java.lang.Iterable);
	*** setMap(java.util.Map);
	*** size();
	*** unmodifiableCollectionSubclass(java.util.Collection);
	*** values();
	*** wrapCollection(java.lang.Object,java.util.Collection);
	*** wrapList(java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection);
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$AsMap {
	*** entrySet;
	*** submap;
	*** this$0;
	com.google.common.collect.AbstractMapBasedMultimap$AsMap(com.google.common.collect.AbstractMapBasedMultimap,java.util.Map);
	*** get(java.lang.Object);
	*** remove(java.lang.Object);
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$EntryIterator {
	*** collection;
	*** key;
	*** keyIterator;
	*** this$0;
	*** valueIterator;
	*** findValueIteratorAndKey();
	*** next();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$KeySet {
	*** subMap;
	*** this$0;
	com.google.common.collect.AbstractMapBasedMultimap$KeySet(com.google.common.collect.AbstractMapBasedMultimap,java.util.Map);
	*** iterator();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList {
	*** this$0;
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap {
	*** sortedKeySet;
	*** this$0;
	*** createKeySet();
	*** keySet();
	*** sortedMap();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet {
	*** this$0;
	*** sortedMap();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection {
	*** ancestor;
	*** ancestorDelegate;
	*** delegate;
	*** key;
	*** this$0;
	com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.Collection,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection);
	*** addToMap();
	*** getAncestor();
	*** getDelegate();
	*** getKey();
	*** refreshIfEmpty();
	*** removeIfEmpty();
	*** size();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator {
	*** delegateIterator;
	*** originalDelegate;
	*** this$1;
	*** validateIterator();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$WrappedList {
	*** this$0;
	com.google.common.collect.AbstractMapBasedMultimap$WrappedList(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection);
	*** getListDelegate();
}

-keep class com.google.common.collect.AbstractMapBasedMultimap$WrappedSet {
	*** this$0;
}

-keep class com.google.common.collect.AbstractMapBasedMultiset {
	*** backingMap;
	*** size;
	com.google.common.collect.AbstractMapBasedMultiset(java.util.Map);
	*** access$122(com.google.common.collect.AbstractMapBasedMultiset,long);
	*** add(java.lang.Object,int);
	*** clear();
	*** count(java.lang.Object);
	*** entrySet();
	*** getAndSet(com.google.common.collect.Count,int);
	*** iterator();
	*** remove(java.lang.Object,int);
	*** setBackingMap(java.util.Map);
	*** setCount(java.lang.Object,int);
	*** size();
}

-keep class com.google.common.collect.AbstractMapBasedMultiset$1 {
	*** this$0;
	*** toRemove;
	*** val$backingEntries;
	*** next();
}

-keep class com.google.common.collect.AbstractMapEntry {
	com.google.common.collect.AbstractMapEntry();
	*** getKey();
	*** getValue();
}

-keep class com.google.common.collect.AbstractMultimap {
	*** asMap;
	*** entries;
	*** keySet;
	*** keys;
	*** values;
	com.google.common.collect.AbstractMultimap();
	*** asMap();
	*** containsEntry(java.lang.Object,java.lang.Object);
	*** containsValue(java.lang.Object);
	*** createAsMap();
	*** createEntries();
	*** createKeySet();
	*** createKeys();
	*** createValues();
	*** entries();
	*** entryIterator();
	*** equals(java.lang.Object);
	*** hashCode();
	*** isEmpty();
	*** keySet();
	*** keys();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(com.google.common.collect.Multimap);
	*** putAll(java.lang.Object,java.lang.Iterable);
	*** remove(java.lang.Object,java.lang.Object);
	*** toString();
	*** values();
}

-keep class com.google.common.collect.AbstractMultimap$1 {
	*** this$0;
}

-keep class com.google.common.collect.AbstractMultiset {
	*** elementSet;
	*** entrySet;
	com.google.common.collect.AbstractMultiset();
	*** add(java.lang.Object);
	*** add(java.lang.Object,int);
	*** addAll(java.util.Collection);
	*** contains(java.lang.Object);
	*** count(java.lang.Object);
	*** createElementSet();
	*** createEntrySet();
	*** distinctElements();
	*** elementSet();
	*** entryIterator();
	*** entrySet();
	*** equals(java.lang.Object);
	*** hashCode();
	*** isEmpty();
	*** remove(java.lang.Object);
	*** remove(java.lang.Object,int);
	*** removeAll(java.util.Collection);
	*** retainAll(java.util.Collection);
	*** setCount(java.lang.Object,int,int);
	*** size();
	*** toString();
}

-keep class com.google.common.collect.AbstractMultiset$EntrySet {
	*** this$0;
}

-keep class com.google.common.collect.AbstractSetMultimap {
	com.google.common.collect.AbstractSetMultimap(java.util.Map);
	*** asMap();
	*** createCollection();
	*** createUnmodifiableEmptyCollection();
	*** entries();
	*** equals(java.lang.Object);
	*** get(java.lang.Object);
	*** put(java.lang.Object,java.lang.Object);
	*** removeAll(java.lang.Object);
	*** replaceValues(java.lang.Object,java.lang.Iterable);
}

-keep class com.google.common.collect.AllEqualOrdering {
	*** INSTANCE;
}

-keep class com.google.common.collect.ByFunctionOrdering {
	*** function;
	*** ordering;
}

-keep class com.google.common.collect.CartesianList {
	*** create(java.util.List);
}

-keep class com.google.common.collect.Collections2 {
	*** STANDARD_JOINER;
	*** cast(java.lang.Iterable);
	*** containsAllImpl(java.util.Collection,java.util.Collection);
	*** isPermutation(java.util.List,java.util.List);
	*** isPositiveInt(long);
	*** newStringBuilderForCollection(int);
	*** orderedPermutations(java.lang.Iterable,java.util.Comparator);
	*** safeContains(java.util.Collection,java.lang.Object);
	*** toStringImpl(java.util.Collection);
}

-keep class com.google.common.collect.Collections2$FilteredCollection {
	*** predicate;
	*** unfiltered;
	*** createCombined(com.google.common.base.Predicate);
}

-keep class com.google.common.collect.ComparatorOrdering {
	*** comparator;
}

-keep class com.google.common.collect.CompoundOrdering {
	*** comparators;
}

-keep class com.google.common.collect.Count {
	*** value;
	*** addAndGet(int);
	*** get();
	*** getAndAdd(int);
	*** getAndSet(int);
	*** set(int);
}

-keep class com.google.common.collect.DescendingImmutableSortedSet {
	*** forward;
	*** descendingIterator();
	*** descendingSet();
	*** iterator();
	*** size();
}

-keep class com.google.common.collect.EmptyImmutableBiMap {
	*** INSTANCE;
	*** entrySet();
	*** inverse();
	*** keySet();
}

-keep class com.google.common.collect.EmptyImmutableList {
	*** INSTANCE;
	*** iterator();
	*** listIterator();
	*** listIterator(int);
	*** subList(int,int);
}

-keep class com.google.common.collect.EmptyImmutableSet {
	*** INSTANCE;
	*** asList();
	*** iterator();
}

-keep class com.google.common.collect.EmptyImmutableSetMultimap {
	*** INSTANCE;
}

-keep class com.google.common.collect.EmptyImmutableSortedSet {
	*** asList();
	*** descendingIterator();
	*** iterator();
}

-keep class com.google.common.collect.ExplicitOrdering {
	*** rankMap;
	com.google.common.collect.ExplicitOrdering(com.google.common.collect.ImmutableMap);
	*** buildRankMap(java.util.List);
	*** rank(java.lang.Object);
}

-keep class com.google.common.collect.FluentIterable {
	*** filter(com.google.common.base.Predicate);
	*** from(java.lang.Iterable);
	*** toSet();
}

-keep class com.google.common.collect.ForwardingCollection {
	com.google.common.collect.ForwardingCollection();
	*** contains(java.lang.Object);
	*** delegate();
	*** iterator();
	*** size();
	*** toArray(java.lang.Object[]);
}

-keep class com.google.common.collect.ForwardingObject {
	com.google.common.collect.ForwardingObject();
	*** delegate();
}

-keep class com.google.common.collect.ForwardingSet {
	com.google.common.collect.ForwardingSet();
	*** delegate();
}

-keep class com.google.common.collect.HashMultimap {
	*** expectedValuesPerKey;
	*** create();
	*** createCollection();
	*** putAll(com.google.common.collect.Multimap);
}

-keep class com.google.common.collect.HashMultiset {
	*** create();
	*** create(int);
	*** create(java.lang.Iterable);
}

-keep class com.google.common.collect.Hashing {
	*** MAX_TABLE_SIZE;
	*** closedTableSize(int,double);
	*** smear(int);
}

-keep class com.google.common.collect.ImmutableAsList {
	com.google.common.collect.ImmutableAsList();
	*** delegateCollection();
}

-keep class com.google.common.collect.ImmutableBiMap {
	com.google.common.collect.ImmutableBiMap();
	*** fromEntries(java.util.Collection);
	*** inverse();
	*** of();
	*** of(java.lang.Object,java.lang.Object);
	*** values();
}

-keep class com.google.common.collect.ImmutableBiMap$Builder {
	*** build();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
}

-keep class com.google.common.collect.ImmutableCollection {
	*** EMPTY_IMMUTABLE_COLLECTION;
	*** asList;
	com.google.common.collect.ImmutableCollection();
	*** asList();
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** createAsList();
	*** isEmpty();
	*** isPartialView();
	*** iterator();
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class com.google.common.collect.ImmutableCollection$Builder {
	com.google.common.collect.ImmutableCollection$Builder();
	*** add(java.lang.Object);
	*** addAll(java.lang.Iterable);
	*** addAll(java.util.Iterator);
	*** expandedCapacity(int,int);
}

-keep class com.google.common.collect.ImmutableCollection$EmptyImmutableCollection {
	*** EMPTY_ARRAY;
	com.google.common.collect.ImmutableCollection$EmptyImmutableCollection();
	*** iterator();
}

-keep class com.google.common.collect.ImmutableEntry {
	*** key;
	*** value;
	*** getKey();
	*** getValue();
}

-keep class com.google.common.collect.ImmutableEnumMap {
	*** delegate;
	com.google.common.collect.ImmutableEnumMap(java.util.EnumMap);
	*** asImmutable(java.util.EnumMap);
}

-keep class com.google.common.collect.ImmutableEnumSet {
	*** delegate;
	*** hashCode;
	com.google.common.collect.ImmutableEnumSet(java.util.EnumSet);
	*** asImmutable(java.util.EnumSet);
	*** iterator();
}

-keep class com.google.common.collect.ImmutableList {
	com.google.common.collect.ImmutableList();
	*** asImmutableList(java.lang.Object[]);
	*** builder();
	*** construct(java.lang.Object[]);
	*** contains(java.lang.Object);
	*** copyFromCollection(java.util.Collection);
	*** copyOf(java.lang.Iterable);
	*** copyOf(java.lang.Object[]);
	*** copyOf(java.util.Collection);
	*** copyOf(java.util.Iterator);
	*** equals(java.lang.Object);
	*** hashCode();
	*** indexOf(java.lang.Object);
	*** iterator();
	*** lastIndexOf(java.lang.Object);
	*** listIterator();
	*** listIterator(int);
	*** of();
	*** of(java.lang.Object);
	*** of(java.lang.Object,java.lang.Object);
	*** reverse();
	*** subList(int,int);
	*** subListUnchecked(int,int);
}

-keep class com.google.common.collect.ImmutableList$1 {
	*** this$0;
}

-keep class com.google.common.collect.ImmutableList$Builder {
	*** contents;
	*** size;
	com.google.common.collect.ImmutableList$Builder(int);
	*** add(java.lang.Object);
	*** add(java.lang.Object[]);
	*** addAll(java.lang.Iterable);
	*** addAll(java.util.Iterator);
	*** build();
	*** ensureCapacity(int);
}

-keep class com.google.common.collect.ImmutableList$ReverseImmutableList {
	*** forwardList;
	*** size;
	*** listIterator(int);
	*** reverseIndex(int);
	*** reversePosition(int);
	*** subList(int,int);
}

-keep class com.google.common.collect.ImmutableList$SubList {
	*** length;
	*** offset;
	*** this$0;
	*** subList(int,int);
}

-keep class com.google.common.collect.ImmutableListMultimap {
	*** copyOf(com.google.common.collect.Multimap);
	*** of();
	*** of(java.lang.Object,java.lang.Object);
	*** of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object);
	*** of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object);
	*** of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object);
	*** of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object);
}

-keep class com.google.common.collect.ImmutableMap {
	*** entrySet;
	*** keySet;
	*** multimapView;
	*** values;
	com.google.common.collect.ImmutableMap();
	*** builder();
	*** containsKey(java.lang.Object);
	*** containsValue(java.lang.Object);
	*** copyOf(java.util.Map);
	*** createEntrySet();
	*** createKeySet();
	*** createMultimapView();
	*** entryOf(java.lang.Object,java.lang.Object);
	*** entrySet();
	*** equals(java.lang.Object);
	*** get(java.lang.Object);
	*** hashCode();
	*** isPartialView();
	*** keySet();
	*** of();
	*** of(java.lang.Object,java.lang.Object);
	*** values();
	*** viewMapValuesAsSingletonSets();
}

-keep class com.google.common.collect.ImmutableMap$1MapViewOfValuesAsSingletonSets {
	*** this$0;
	*** get(java.lang.Object);
}

-keep class com.google.common.collect.ImmutableMap$Builder {
	*** entries;
	com.google.common.collect.ImmutableMap$Builder();
	*** build();
	*** fromEntryList(java.util.List);
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
}

-keep class com.google.common.collect.ImmutableMapKeySet {
	*** map;
	*** iterator();
}

-keep class com.google.common.collect.ImmutableMapValues {
	*** map;
	*** iterator();
}

-keep class com.google.common.collect.ImmutableMultimap {
	*** map;
	*** size;
	com.google.common.collect.ImmutableMultimap(com.google.common.collect.ImmutableMap,int);
	*** asMap();
	*** createEntries();
	*** createKeys();
	*** createValues();
	*** entries();
	*** entryIterator();
	*** get(java.lang.Object);
	*** isPartialView();
	*** keySet();
	*** keys();
	*** removeAll(java.lang.Object);
	*** replaceValues(java.lang.Object,java.lang.Iterable);
	*** values();
}

-keep class com.google.common.collect.ImmutableMultimap$FieldSettersHolder {
	*** MAP_FIELD_SETTER;
	*** SIZE_FIELD_SETTER;
}

-keep class com.google.common.collect.ImmutableMultiset {
	*** copyFromEntries(java.util.Collection);
}

-keep class com.google.common.collect.ImmutableSet {
	*** CUTOFF;
	com.google.common.collect.ImmutableSet();
	*** access$000(int,java.lang.Object[]);
	*** builder();
	*** chooseTableSize(int);
	*** construct(int,java.lang.Object[]);
	*** copyFromCollection(java.util.Collection);
	*** copyOf(java.lang.Object[]);
	*** copyOf(java.util.Collection);
	*** copyOf(java.util.Iterator);
	*** hashCode();
	*** isHashCodeFast();
	*** iterator();
	*** of();
	*** of(java.lang.Object);
}

-keep class com.google.common.collect.ImmutableSet$ArrayImmutableSet {
	*** elements;
	com.google.common.collect.ImmutableSet$ArrayImmutableSet(java.lang.Object[]);
	*** iterator();
	*** size();
}

-keep class com.google.common.collect.ImmutableSet$Builder {
	*** contents;
	*** size;
	com.google.common.collect.ImmutableSet$Builder();
	com.google.common.collect.ImmutableSet$Builder(int);
	*** add(java.lang.Object);
	*** add(java.lang.Object[]);
	*** addAll(java.lang.Iterable);
	*** addAll(java.util.Iterator);
	*** build();
	*** ensureCapacity(int);
}

-keep class com.google.common.collect.ImmutableSetMultimap {
	*** emptySet;
	*** entries;
	*** inverse;
	*** builder();
	*** copyOf(com.google.common.collect.Multimap,java.util.Comparator);
	*** entries();
	*** get(java.lang.Object);
	*** inverse();
	*** invert();
	*** of();
	*** removeAll(java.lang.Object);
	*** replaceValues(java.lang.Object,java.lang.Iterable);
}

-keep class com.google.common.collect.ImmutableSetMultimap$Builder {
	*** build();
	*** put(java.lang.Object,java.lang.Object);
}

-keep class com.google.common.collect.ImmutableSortedAsList {
	*** comparator();
	*** delegateCollection();
	*** indexOf(java.lang.Object);
}

-keep class com.google.common.collect.ImmutableSortedSet {
	*** NATURAL_EMPTY_SET;
	*** NATURAL_ORDER;
	*** comparator;
	*** descendingSet;
	com.google.common.collect.ImmutableSortedSet(java.util.Comparator);
	*** ceiling(java.lang.Object);
	*** comparator();
	*** construct(java.util.Comparator,int,java.lang.Object[]);
	*** copyOf(java.util.Collection);
	*** copyOf(java.util.Comparator,java.lang.Iterable);
	*** copyOf(java.util.Comparator,java.util.Collection);
	*** copyOf(java.util.Comparator,java.util.Iterator);
	*** createDescendingSet();
	*** descendingIterator();
	*** descendingSet();
	*** emptySet();
	*** emptySet(java.util.Comparator);
	*** floor(java.lang.Object);
	*** headSet(java.lang.Object);
	*** headSet(java.lang.Object,boolean);
	*** headSetImpl(java.lang.Object,boolean);
	*** higher(java.lang.Object);
	*** indexOf(java.lang.Object);
	*** iterator();
	*** lower(java.lang.Object);
	*** sortAndUnique(java.util.Comparator,int,java.lang.Object[]);
	*** subSet(java.lang.Object,boolean,java.lang.Object,boolean);
	*** subSet(java.lang.Object,java.lang.Object);
	*** subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean);
	*** tailSet(java.lang.Object);
	*** tailSet(java.lang.Object,boolean);
	*** tailSetImpl(java.lang.Object,boolean);
	*** unsafeCompare(java.lang.Object,java.lang.Object);
	*** unsafeCompare(java.util.Comparator,java.lang.Object,java.lang.Object);
}

-keep class com.google.common.collect.ImmutableSortedSet$Builder {
	*** comparator;
	*** add(java.lang.Object);
	*** add(java.lang.Object[]);
	*** addAll(java.lang.Iterable);
	*** addAll(java.util.Iterator);
	*** build();
}

-keep class com.google.common.collect.ImmutableSortedSetFauxverideShim {
	com.google.common.collect.ImmutableSortedSetFauxverideShim();
}

-keep class com.google.common.collect.Iterables {
	*** addAll(java.util.Collection,java.lang.Iterable);
	*** checkNonnegativeIndex(int);
	*** concat(java.lang.Iterable);
	*** cycle(java.lang.Iterable);
	*** get(java.lang.Iterable,int);
	*** getFirst(java.lang.Iterable,java.lang.Object);
	*** getLastInNonemptyList(java.util.List);
	*** getOnlyElement(java.lang.Iterable);
	*** iterators(java.lang.Iterable);
	*** removeIfFromRandomAccessList(java.util.List,com.google.common.base.Predicate);
	*** slowRemoveIfForRemainingElements(java.util.List,com.google.common.base.Predicate,int,int);
	*** toArray(java.lang.Iterable);
	*** toArray(java.lang.Iterable,java.lang.Class);
	*** toCollection(java.lang.Iterable);
	*** toIterator();
	*** transform(java.lang.Iterable,com.google.common.base.Function);
}

-keep class com.google.common.collect.Iterables$3 {
	*** val$iterableIterator;
	*** next();
}

-keep class com.google.common.collect.Iterators {
	*** EMPTY_LIST_ITERATOR;
	*** EMPTY_MODIFIABLE_ITERATOR;
	*** addAll(java.util.Collection,java.util.Iterator);
	*** all(java.util.Iterator,com.google.common.base.Predicate);
	*** any(java.util.Iterator,com.google.common.base.Predicate);
	*** checkNonnegative(int);
	*** checkRemove(boolean);
	*** clear(java.util.Iterator);
	*** concat(java.util.Iterator);
	*** concat(java.util.Iterator,java.util.Iterator);
	*** contains(java.util.Iterator,java.lang.Object);
	*** cycle(java.lang.Iterable);
	*** elementsEqual(java.util.Iterator,java.util.Iterator);
	*** emptyIterator();
	*** emptyListIterator();
	*** emptyModifiableIterator();
	*** filter(java.util.Iterator,com.google.common.base.Predicate);
	*** find(java.util.Iterator,com.google.common.base.Predicate);
	*** find(java.util.Iterator,com.google.common.base.Predicate,java.lang.Object);
	*** forArray(java.lang.Object[],int,int,int);
	*** frequency(java.util.Iterator,java.lang.Object);
	*** get(java.util.Iterator,int);
	*** getLast(java.util.Iterator);
	*** getLast(java.util.Iterator,java.lang.Object);
	*** getNext(java.util.Iterator,java.lang.Object);
	*** getOnlyElement(java.util.Iterator);
	*** getOnlyElement(java.util.Iterator,java.lang.Object);
	*** indexOf(java.util.Iterator,com.google.common.base.Predicate);
	*** partitionImpl(java.util.Iterator,int,boolean);
	*** peekingIterator(java.util.Iterator);
	*** removeAll(java.util.Iterator,java.util.Collection);
	*** removeIf(java.util.Iterator,com.google.common.base.Predicate);
	*** retainAll(java.util.Iterator,java.util.Collection);
	*** singletonIterator(java.lang.Object);
	*** size(java.util.Iterator);
	*** toString(java.util.Iterator);
	*** tryFind(java.util.Iterator,com.google.common.base.Predicate);
	*** unmodifiableIterator(java.util.Iterator);
}

-keep class com.google.common.collect.Iterators$11 {
	*** val$array;
}

-keep class com.google.common.collect.Iterators$12 {
	*** val$array;
	*** val$offset;
}

-keep class com.google.common.collect.Iterators$13 {
	*** done;
	*** val$value;
}

-keep class com.google.common.collect.Iterators$14 {
	*** val$enumeration;
}

-keep class com.google.common.collect.Iterators$3 {
	*** val$iterator;
}

-keep class com.google.common.collect.Iterators$6 {
	*** val$iterator;
	*** val$pad;
	*** val$size;
	*** hasNext();
	*** next();
}

-keep class com.google.common.collect.Iterators$7 {
	*** val$predicate;
	*** val$unfiltered;
}

-keep class com.google.common.collect.Iterators$MergingIterator {
	*** comparator;
	*** queue;
}

-keep class com.google.common.collect.LexicographicalOrdering {
	*** elementOrder;
	*** compare(java.lang.Iterable,java.lang.Iterable);
}

-keep class com.google.common.collect.Lists {
	*** asList(java.lang.Object,java.lang.Object[]);
	*** cartesianProduct(java.util.List);
	*** cast(java.lang.Iterable);
	*** charactersOf(java.lang.String);
	*** computeArrayListCapacity(int);
	*** equalsImpl(java.util.List,java.lang.Object);
	*** hashCodeImpl(java.util.List);
	*** indexOfImpl(java.util.List,java.lang.Object);
	*** lastIndexOfImpl(java.util.List,java.lang.Object);
	*** newArrayList();
	*** newArrayList(java.lang.Iterable);
	*** newArrayList(java.lang.Object[]);
	*** newArrayList(java.util.Iterator);
	*** newArrayListWithCapacity(int);
	*** newLinkedList();
}

-keep class com.google.common.collect.Lists$Partition {
	*** list;
	*** size;
	com.google.common.collect.Lists$Partition(java.util.List,int);
	*** get(int);
	*** size();
}

-keep class com.google.common.collect.Lists$ReverseList {
	*** getForwardList();
}

-keep class com.google.common.collect.Lists$StringAsImmutableList {
	*** hash;
	*** string;
	*** get(int);
	*** size();
	*** subList(int,int);
}

-keep class com.google.common.collect.Lists$TransformingRandomAccessList {
	*** fromList;
	*** function;
}

-keep class com.google.common.collect.Lists$TransformingSequentialList {
	*** fromList;
	*** function;
}

-keep class com.google.common.collect.MapMaker {
	*** makeMap();
	*** weakKeys();
}

-keep class com.google.common.collect.Maps {
	*** STANDARD_JOINER;
	*** asEntryTransformer(com.google.common.base.Function);
	*** asMap(java.util.NavigableSet,com.google.common.base.Function);
	*** asMap(java.util.SortedSet,com.google.common.base.Function);
	*** asMapSortedIgnoreNavigable(java.util.SortedSet,com.google.common.base.Function);
	*** asSetEntryIterator(java.util.Set,com.google.common.base.Function);
	*** capacity(int);
	*** containsValueImpl(java.util.Map,java.lang.Object);
	*** difference(java.util.Map,java.util.Map,com.google.common.base.Equivalence);
	*** difference(java.util.SortedMap,java.util.Map);
	*** equalsImpl(java.util.Map,java.lang.Object);
	*** filterEntries(com.google.common.collect.BiMap,com.google.common.base.Predicate);
	*** filterEntries(java.util.Map,com.google.common.base.Predicate);
	*** filterEntries(java.util.NavigableMap,com.google.common.base.Predicate);
	*** filterEntries(java.util.SortedMap,com.google.common.base.Predicate);
	*** filterFiltered(com.google.common.collect.Maps$AbstractFilteredMap,com.google.common.base.Predicate);
	*** filterFiltered(com.google.common.collect.Maps$FilteredEntryBiMap,com.google.common.base.Predicate);
	*** filterFiltered(com.google.common.collect.Maps$FilteredEntryNavigableMap,com.google.common.base.Predicate);
	*** filterFiltered(com.google.common.collect.Maps$FilteredEntrySortedMap,com.google.common.base.Predicate);
	*** filterKeys(com.google.common.collect.BiMap,com.google.common.base.Predicate);
	*** filterKeys(java.util.SortedMap,com.google.common.base.Predicate);
	*** filterSortedIgnoreNavigable(java.util.SortedMap,com.google.common.base.Predicate);
	*** filterValues(com.google.common.collect.BiMap,com.google.common.base.Predicate);
	*** filterValues(java.util.SortedMap,com.google.common.base.Predicate);
	*** immutableEntry(java.lang.Object,java.lang.Object);
	*** keyIterator(java.util.Iterator);
	*** mapDifference(boolean,java.util.Map,java.util.Map,java.util.Map,java.util.Map);
	*** newHashMap();
	*** newHashMapWithExpectedSize(int);
	*** newIdentityHashMap();
	*** newLinkedHashMap();
	*** newTreeMap(java.util.Comparator);
	*** orNaturalOrder(java.util.Comparator);
	*** removeOnlyNavigableSet(java.util.NavigableSet);
	*** removeOnlySet(java.util.Set);
	*** removeOnlySortedSet(java.util.SortedSet);
	*** safeContainsKey(java.util.Map,java.lang.Object);
	*** safeGet(java.util.Map,java.lang.Object);
	*** safeRemove(java.util.Map,java.lang.Object);
	*** sortedMapDifference(boolean,java.util.SortedMap,java.util.SortedMap,java.util.SortedMap,java.util.SortedMap);
	*** toMap(java.util.Iterator,com.google.common.base.Function);
	*** toStringImpl(java.util.Map);
	*** transformEntries(java.util.Map,com.google.common.collect.Maps$EntryTransformer);
	*** transformEntries(java.util.NavigableMap,com.google.common.collect.Maps$EntryTransformer);
	*** transformEntries(java.util.SortedMap,com.google.common.collect.Maps$EntryTransformer);
	*** transformEntriesIgnoreNavigable(java.util.SortedMap,com.google.common.collect.Maps$EntryTransformer);
	*** uniqueIndex(java.util.Iterator,com.google.common.base.Function);
	*** unmodifiableEntry(java.util.Map$Entry);
	*** unmodifiableOrNull(java.util.Map$Entry);
	*** valueIterator(com.google.common.collect.UnmodifiableIterator);
	*** valueIterator(java.util.Iterator);
}

-keep class com.google.common.collect.Maps$9 {
	*** val$entryIterator;
}

-keep class com.google.common.collect.Maps$AbstractFilteredMap {
	*** predicate;
	*** unfiltered;
}

-keep class com.google.common.collect.Maps$EntryFunction {
	*** KEY;
	*** VALUE;
}

-keep class com.google.common.collect.Maps$FilteredEntryBiMap {
	*** unfiltered();
}

-keep class com.google.common.collect.Maps$FilteredEntryNavigableMap {
	*** sortedMap();
}

-keep class com.google.common.collect.Maps$FilteredEntrySortedMap {
	*** sortedMap();
}

-keep class com.google.common.collect.Maps$KeySet {
	com.google.common.collect.Maps$KeySet();
	*** contains(java.lang.Object);
	*** map();
}

-keep class com.google.common.collect.Maps$ValueDifferenceImpl {
	*** create(java.lang.Object,java.lang.Object);
}

-keep class com.google.common.collect.Multimap {
	*** asMap();
	*** clear();
	*** containsEntry(java.lang.Object,java.lang.Object);
	*** entries();
	*** get(java.lang.Object);
	*** isEmpty();
	*** keySet();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(com.google.common.collect.Multimap);
	*** remove(java.lang.Object,java.lang.Object);
	*** removeAll(java.lang.Object);
	*** size();
}

-keep class com.google.common.collect.Multimaps$Entries {
	com.google.common.collect.Multimaps$Entries();
	*** multimap();
}

-keep class com.google.common.collect.Multimaps$EntrySet {
	com.google.common.collect.Multimaps$EntrySet();
}

-keep class com.google.common.collect.Multiset {
	*** add(java.lang.Object);
	*** add(java.lang.Object,int);
	*** count(java.lang.Object);
	*** elementSet();
	*** entrySet();
	*** equals(java.lang.Object);
	*** remove(java.lang.Object,int);
	*** setCount(java.lang.Object,int);
	*** setCount(java.lang.Object,int,int);
}

-keep class com.google.common.collect.Multiset$Entry {
	*** getCount();
	*** getElement();
}

-keep class com.google.common.collect.Multisets {
	*** DECREASING_COUNT_ORDERING;
	*** addAllImpl(com.google.common.collect.Multiset,java.util.Collection);
	*** cast(java.lang.Iterable);
	*** checkNonnegative(int,java.lang.String);
	*** equalsImpl(com.google.common.collect.Multiset,java.lang.Object);
	*** inferDistinctElements(java.lang.Iterable);
	*** iteratorImpl(com.google.common.collect.Multiset);
	*** removeAllImpl(com.google.common.collect.Multiset,java.util.Collection);
	*** removeOccurrencesImpl(com.google.common.collect.Multiset,com.google.common.collect.Multiset);
	*** retainAllImpl(com.google.common.collect.Multiset,java.util.Collection);
	*** retainOccurrencesImpl(com.google.common.collect.Multiset,com.google.common.collect.Multiset);
	*** setCountImpl(com.google.common.collect.Multiset,java.lang.Object,int);
	*** setCountImpl(com.google.common.collect.Multiset,java.lang.Object,int,int);
	*** sizeImpl(com.google.common.collect.Multiset);
}

-keep class com.google.common.collect.Multisets$5 {
	*** compare(com.google.common.collect.Multiset$Entry,com.google.common.collect.Multiset$Entry);
}

-keep class com.google.common.collect.Multisets$EntrySet {
	com.google.common.collect.Multisets$EntrySet();
	*** multiset();
}

-keep class com.google.common.collect.Multisets$FilteredMultiset {
	*** predicate;
	*** unfiltered;
}

-keep class com.google.common.collect.NaturalOrdering {
	*** INSTANCE;
	*** binarySearch(java.util.List,java.lang.Comparable);
	*** compare(java.lang.Comparable,java.lang.Comparable);
}

-keep class com.google.common.collect.NullsFirstOrdering {
	*** ordering;
}

-keep class com.google.common.collect.NullsLastOrdering {
	*** ordering;
}

-keep class com.google.common.collect.ObjectArrays {
	*** EMPTY_ARRAY;
	*** arraysCopyOf(java.lang.Object[],int);
	*** checkElementNotNull(java.lang.Object,int);
	*** fillArray(java.lang.Iterable,java.lang.Object[]);
	*** newArray(java.lang.Class,int);
	*** newArray(java.lang.Object[],int);
	*** swap(java.lang.Object[],int,int);
	*** toArrayImpl(java.util.Collection);
	*** toArrayImpl(java.util.Collection,java.lang.Object[]);
}

-keep class com.google.common.collect.Ordering {
	com.google.common.collect.Ordering();
	*** compare(java.lang.Object,java.lang.Object);
	*** explicit(java.util.List);
	*** from(java.util.Comparator);
	*** immutableSortedCopy(java.lang.Iterable);
	*** leastOf(java.lang.Iterable,int);
	*** leastOf(java.util.Iterator,int);
	*** max(java.lang.Iterable);
	*** max(java.lang.Object,java.lang.Object);
	*** max(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]);
	*** max(java.util.Iterator);
	*** min(java.lang.Iterable);
	*** min(java.lang.Object,java.lang.Object);
	*** min(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]);
	*** min(java.util.Iterator);
	*** natural();
	*** nullsFirst();
	*** nullsLast();
	*** partition(java.lang.Object[],int,int,int);
	*** reverse();
	*** sortedCopy(java.lang.Iterable);
}

-keep class com.google.common.collect.Ordering$ArbitraryOrderingHolder {
	*** ARBITRARY_ORDERING;
}

-keep class com.google.common.collect.PeekingIterator {
	*** next();
}

-keep class com.google.common.collect.Platform {
	*** mapsAsMapSortedSet(java.util.SortedSet,com.google.common.base.Function);
	*** mapsFilterSortedMap(java.util.SortedMap,com.google.common.base.Predicate);
	*** mapsTransformEntriesSortedMap(java.util.SortedMap,com.google.common.collect.Maps$EntryTransformer);
	*** newArray(java.lang.Object[],int);
	*** setsFilterSortedSet(java.util.SortedSet,com.google.common.base.Predicate);
}

-keep class com.google.common.collect.Queues {
	*** newLinkedBlockingQueue();
}

-keep class com.google.common.collect.RegularImmutableAsList {
	*** delegate;
	*** delegateList;
	com.google.common.collect.RegularImmutableAsList(com.google.common.collect.ImmutableCollection,com.google.common.collect.ImmutableList);
	*** delegateCollection();
	*** get(int);
	*** listIterator(int);
}

-keep class com.google.common.collect.RegularImmutableBiMap {
	*** entries;
	*** hashCode;
	*** inverse;
	*** kToVTable;
	*** mask;
	*** vToKTable;
	*** createEntryArray(int);
	*** inverse();
}

-keep class com.google.common.collect.RegularImmutableBiMap$BiMapEntry {
	*** getNextInKToVBucket();
	*** getNextInVToKBucket();
}

-keep class com.google.common.collect.RegularImmutableList {
	*** array;
	*** offset;
	*** size;
	com.google.common.collect.RegularImmutableList(java.lang.Object[],int,int);
	*** listIterator(int);
	*** size();
}

-keep class com.google.common.collect.RegularImmutableMap {
	*** entries;
	*** mask;
	*** table;
	*** createEntryArray(int);
	*** newLinkedEntry(java.lang.Object,java.lang.Object,com.google.common.collect.RegularImmutableMap$LinkedEntry);
}

-keep class com.google.common.collect.RegularImmutableMap$LinkedEntry {
	*** next();
}

-keep class com.google.common.collect.RegularImmutableSet {
	*** hashCode;
	*** mask;
	*** table;
}

-keep class com.google.common.collect.RegularImmutableSortedSet {
	*** elements;
	*** containsAll(java.util.Collection);
	*** descendingIterator();
	*** getSubSet(int,int);
	*** headIndex(java.lang.Object,boolean);
	*** iterator();
	*** size();
	*** tailIndex(java.lang.Object,boolean);
	*** tailSetImpl(java.lang.Object,boolean);
	*** unsafeBinarySearch(java.lang.Object);
	*** unsafeComparator();
}

-keep class com.google.common.collect.ReverseNaturalOrdering {
	*** INSTANCE;
	*** compare(java.lang.Comparable,java.lang.Comparable);
	*** max(java.lang.Comparable,java.lang.Comparable);
	*** max(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable[]);
	*** max(java.lang.Iterable);
	*** max(java.util.Iterator);
	*** min(java.lang.Comparable,java.lang.Comparable);
	*** min(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable[]);
	*** min(java.lang.Iterable);
	*** min(java.util.Iterator);
}

-keep class com.google.common.collect.ReverseOrdering {
	*** forwardOrder;
}

-keep class com.google.common.collect.Serialization {
	*** populateMultimap(com.google.common.collect.Multimap,java.io.ObjectInputStream,int);
	*** populateMultiset(com.google.common.collect.Multiset,java.io.ObjectInputStream,int);
	*** readCount(java.io.ObjectInputStream);
	*** writeMultimap(com.google.common.collect.Multimap,java.io.ObjectOutputStream);
	*** writeMultiset(com.google.common.collect.Multiset,java.io.ObjectOutputStream);
}

-keep class com.google.common.collect.Serialization$FieldSetter {
	*** set(java.lang.Object,int);
	*** set(java.lang.Object,java.lang.Object);
}

-keep class com.google.common.collect.SetMultimap {
	*** get(java.lang.Object);
}

-keep class com.google.common.collect.Sets {
	*** cartesianProduct(java.util.List);
	*** cast(java.lang.Iterable);
	*** difference(java.util.Set,java.util.Set);
	*** equalsImpl(java.util.Set,java.lang.Object);
	*** filter(java.util.NavigableSet,com.google.common.base.Predicate);
	*** filter(java.util.SortedSet,com.google.common.base.Predicate);
	*** filterSortedIgnoreNavigable(java.util.SortedSet,com.google.common.base.Predicate);
	*** hashCodeImpl(java.util.Set);
	*** intersection(java.util.Set,java.util.Set);
	*** makeComplementByHand(java.util.Collection,java.lang.Class);
	*** newHashSet();
	*** newHashSet(java.lang.Iterable);
	*** newHashSet(java.lang.Object[]);
	*** newHashSet(java.util.Iterator);
	*** newHashSetWithExpectedSize(int);
	*** newLinkedHashSet();
	*** newSetFromMap(java.util.Map);
	*** newTreeSet();
	*** removeAllImpl(java.util.Set,java.util.Collection);
	*** removeAllImpl(java.util.Set,java.util.Iterator);
	*** union(java.util.Set,java.util.Set);
}

-keep class com.google.common.collect.Sets$1 {
	*** val$set1;
	*** val$set2;
	*** val$set2minus1;
}

-keep class com.google.common.collect.Sets$2 {
	*** val$inSet2;
	*** val$set1;
	*** val$set2;
	*** iterator();
}

-keep class com.google.common.collect.Sets$3 {
	*** val$notInSet2;
	*** val$set1;
	*** val$set2;
	*** iterator();
}

-keep class com.google.common.collect.Sets$CartesianSet {
	*** create(java.util.List);
}

-keep class com.google.common.collect.Sets$ImprovedAbstractSet {
	com.google.common.collect.Sets$ImprovedAbstractSet();
}

-keep class com.google.common.collect.Sets$SetView {
	com.google.common.collect.Sets$SetView();
	com.google.common.collect.Sets$SetView(com.google.common.collect.Sets$1);
}

-keep class com.google.common.collect.SingletonImmutableBiMap {
	*** inverse;
	*** singleKey;
	*** singleValue;
	com.google.common.collect.SingletonImmutableBiMap(java.lang.Object,java.lang.Object);
	*** inverse();
}

-keep class com.google.common.collect.SingletonImmutableList {
	*** element;
	*** indexOf(java.lang.Object);
	*** iterator();
	*** subList(int,int);
}

-keep class com.google.common.collect.SingletonImmutableSet {
	*** cachedHashCode;
	*** element;
	*** iterator();
}

-keep class com.google.common.collect.SortedIterable {
	*** comparator();
}

-keep class com.google.common.collect.SortedIterables {
	*** comparator(java.util.SortedSet);
	*** hasSameComparator(java.util.Comparator,java.lang.Iterable);
}

-keep class com.google.common.collect.SortedLists {
	*** binarySearch(java.util.List,java.lang.Object,java.util.Comparator,com.google.common.collect.SortedLists$KeyPresentBehavior,com.google.common.collect.SortedLists$KeyAbsentBehavior);
}

-keep class com.google.common.collect.SortedLists$KeyAbsentBehavior {
	*** INVERTED_INSERTION_INDEX;
	*** NEXT_HIGHER;
}

-keep class com.google.common.collect.SortedLists$KeyPresentBehavior {
	*** ANY_PRESENT;
	*** FIRST_AFTER;
	*** FIRST_PRESENT;
}

-keep class com.google.common.collect.Synchronized {
	*** biMap(com.google.common.collect.BiMap,java.lang.Object);
	*** navigableMap(java.util.NavigableMap);
	*** navigableSet(java.util.NavigableSet);
}

-keep class com.google.common.collect.UnmodifiableIterator {
	com.google.common.collect.UnmodifiableIterator();
}

-keep class com.google.common.collect.UnmodifiableListIterator {
	com.google.common.collect.UnmodifiableListIterator();
}

-keep class com.google.common.collect.UsingToStringOrdering {
	*** INSTANCE;
}

-keep class com.google.common.eventbus.AnnotatedHandlerFinder {
	*** handlerMethodsCache;
	*** access$000(java.lang.Class);
	*** getAnnotatedMethods(java.lang.Class);
	*** getAnnotatedMethodsInternal(java.lang.Class);
	*** makeHandler(java.lang.Object,java.lang.reflect.Method);
	*** methodIsDeclaredThreadSafe(java.lang.reflect.Method);
}

-keep class com.google.common.eventbus.AnnotatedHandlerFinder$1 {
	*** load(java.lang.Class);
}

-keep class com.google.common.eventbus.AsyncEventBus {
	*** eventsToDispatch;
	*** executor;
	*** access$001(com.google.common.eventbus.AsyncEventBus,java.lang.Object,com.google.common.eventbus.EventHandler);
	*** dispatch(java.lang.Object,com.google.common.eventbus.EventHandler);
}

-keep class com.google.common.eventbus.AsyncEventBus$1 {
	*** this$0;
	*** val$event;
	*** val$handler;
}

-keep class com.google.common.eventbus.EventBus {
	*** eventsToDispatch;
	*** finder;
	*** flattenHierarchyCache;
	*** handlersByType;
	*** handlersByTypeLock;
	*** isDispatching;
	*** logger;
	com.google.common.eventbus.EventBus();
	com.google.common.eventbus.EventBus(java.lang.String);
	*** dispatch(java.lang.Object,com.google.common.eventbus.EventHandler);
	*** dispatchQueuedEvents();
	*** enqueueEvent(java.lang.Object,com.google.common.eventbus.EventHandler);
	*** flattenHierarchy(java.lang.Class);
	*** post(java.lang.Object);
	*** register(java.lang.Object);
}

-keep class com.google.common.eventbus.EventBus$1 {
	*** load(java.lang.Class);
}

-keep class com.google.common.eventbus.EventBus$2 {
	*** this$0;
	*** initialValue();
}

-keep class com.google.common.eventbus.EventBus$3 {
	*** this$0;
	*** initialValue();
}

-keep class com.google.common.eventbus.EventBus$EventWithHandler {
	*** event;
	*** handler;
}

-keep class com.google.common.eventbus.EventHandler {
	*** method;
	*** target;
	com.google.common.eventbus.EventHandler(java.lang.Object,java.lang.reflect.Method);
	*** handleEvent(java.lang.Object);
}

-keep class com.google.common.eventbus.HandlerFindingStrategy {
	*** findAllHandlers(java.lang.Object);
}

-keep class com.google.common.hash.Funnels {
	*** asOutputStream(com.google.common.hash.PrimitiveSink);
}

-keep class com.google.common.hash.HashFunction {
	*** hashBytes(byte[]);
	*** newHasher();
}

-keep class com.google.common.hash.Hasher {
	*** hash();
}

-keep class com.google.common.io.AppendableWriter {
	*** closed;
	*** target;
	*** append(char);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
	*** checkNotClosed();
}

-keep class com.google.common.io.BaseEncoding {
	*** base16();
	*** encode(byte[]);
}

-keep class com.google.common.io.ByteProcessor {
	*** getResult();
	*** processBytes(byte[],int,int);
}

-keep class com.google.common.io.ByteSink {
	com.google.common.io.ByteSink();
	*** asCharSink(java.nio.charset.Charset);
	*** openStream();
	*** write(byte[]);
	*** writeFrom(java.io.InputStream);
}

-keep class com.google.common.io.ByteSink$AsCharSink {
	*** charset;
	*** this$0;
	com.google.common.io.ByteSink$AsCharSink(com.google.common.io.ByteSink,java.nio.charset.Charset);
}

-keep class com.google.common.io.ByteSource {
	*** countBuffer;
	com.google.common.io.ByteSource();
	*** asCharSource(java.nio.charset.Charset);
	*** contentEquals(com.google.common.io.ByteSource);
	*** copyTo(com.google.common.io.ByteSink);
	*** copyTo(java.io.OutputStream);
	*** countByReading(java.io.InputStream);
	*** countBySkipping(java.io.InputStream);
	*** hash(com.google.common.hash.HashFunction);
	*** openStream();
	*** read();
	*** size();
	*** slice(long,long);
}

-keep class com.google.common.io.ByteSource$AsCharSource {
	*** charset;
	*** this$0;
	com.google.common.io.ByteSource$AsCharSource(com.google.common.io.ByteSource,java.nio.charset.Charset);
}

-keep class com.google.common.io.ByteSource$SlicedByteSource {
	*** length;
	*** offset;
	*** this$0;
	com.google.common.io.ByteSource$SlicedByteSource(com.google.common.io.ByteSource,long,long);
}

-keep class com.google.common.io.ByteStreams {
	*** NULL_OUTPUT_STREAM;
	*** asByteSink(com.google.common.io.OutputSupplier);
	*** asByteSource(byte[]);
	*** asByteSource(com.google.common.io.InputSupplier);
	*** asInputSupplier(com.google.common.io.ByteSource);
	*** asOutputSupplier(com.google.common.io.ByteSink);
	*** copy(java.io.InputStream,java.io.OutputStream);
	*** getChecksum(com.google.common.io.InputSupplier,java.util.zip.Checksum);
	*** join(java.lang.Iterable);
	*** limit(java.io.InputStream,long);
	*** read(java.io.InputStream,byte[],int,int);
	*** readBytes(com.google.common.io.InputSupplier,com.google.common.io.ByteProcessor);
	*** readBytes(java.io.InputStream,com.google.common.io.ByteProcessor);
	*** readFully(java.io.InputStream,byte[],int,int);
	*** skipFully(java.io.InputStream,long);
	*** toByteArray(java.io.InputStream);
}

-keep class com.google.common.io.ByteStreams$6 {
	*** val$supplier;
}

-keep class com.google.common.io.ByteStreams$7 {
	*** val$supplier;
}

-keep class com.google.common.io.ByteStreams$ByteArrayByteSource {
	*** bytes;
	com.google.common.io.ByteStreams$ByteArrayByteSource(byte[]);
}

-keep class com.google.common.io.ByteStreams$LimitedInputStream {
	*** left;
	*** mark;
}

-keep class com.google.common.io.CharSink {
	com.google.common.io.CharSink();
	*** openBufferedStream();
	*** openStream();
	*** write(java.lang.CharSequence);
	*** writeLines(java.lang.Iterable,java.lang.String);
}

-keep class com.google.common.io.CharSource {
	com.google.common.io.CharSource();
	*** copyTo(com.google.common.io.CharSink);
	*** copyTo(java.lang.Appendable);
	*** openBufferedStream();
	*** openStream();
	*** read();
	*** readFirstLine();
}

-keep class com.google.common.io.CharStreams {
	*** asCharSink(com.google.common.io.OutputSupplier);
	*** asCharSource(com.google.common.io.InputSupplier);
	*** asCharSource(java.lang.String);
	*** asInputSupplier(com.google.common.io.CharSource);
	*** asOutputSupplier(com.google.common.io.CharSink);
	*** asReader(java.lang.Readable);
	*** asWriter(java.lang.Appendable);
	*** copy(java.lang.Readable,java.lang.Appendable);
	*** join(java.lang.Iterable);
	*** readLines(com.google.common.io.InputSupplier);
	*** readLines(com.google.common.io.InputSupplier,com.google.common.io.LineProcessor);
	*** readLines(java.lang.Readable);
	*** readLines(java.lang.Readable,com.google.common.io.LineProcessor);
	*** toString(java.lang.Readable);
	*** toStringBuilder(java.lang.Readable);
}

-keep class com.google.common.io.CharStreams$2 {
	*** val$readable;
	*** read(java.nio.CharBuffer);
}

-keep class com.google.common.io.CharStreams$5 {
	*** val$supplier;
}

-keep class com.google.common.io.CharStreams$6 {
	*** val$supplier;
}

-keep class com.google.common.io.CharStreams$StringCharSource {
	*** LINE_SPLITTER;
	*** string;
	com.google.common.io.CharStreams$StringCharSource(java.lang.String);
	*** lines();
}

-keep class com.google.common.io.Closer {
	*** SUPPRESSOR;
	*** stack;
	*** suppressor;
	*** thrown;
	*** close();
	*** create();
	*** register(java.io.Closeable);
	*** rethrow(java.lang.Throwable);
}

-keep class com.google.common.io.Closer$LoggingSuppressor {
	*** INSTANCE;
	*** suppress(java.io.Closeable,java.lang.Throwable,java.lang.Throwable);
}

-keep class com.google.common.io.Closer$SuppressingSuppressor {
	*** INSTANCE;
	*** addSuppressed;
	*** getAddSuppressed();
	*** isAvailable();
}

-keep class com.google.common.io.Closer$Suppressor {
	*** suppress(java.io.Closeable,java.lang.Throwable,java.lang.Throwable);
}

-keep class com.google.common.io.FileWriteMode {
	*** $VALUES;
	*** APPEND;
}

-keep class com.google.common.io.Files {
	*** asByteSink(java.io.File,com.google.common.io.FileWriteMode[]);
	*** asByteSource(java.io.File);
	*** asCharSink(java.io.File,java.nio.charset.Charset,com.google.common.io.FileWriteMode[]);
	*** asCharSource(java.io.File,java.nio.charset.Charset);
	*** copy(java.io.File,java.io.File);
	*** createTempDir();
	*** map(java.io.File,java.nio.channels.FileChannel$MapMode);
	*** map(java.io.File,java.nio.channels.FileChannel$MapMode,long);
	*** map(java.io.RandomAccessFile,java.nio.channels.FileChannel$MapMode,long);
	*** modes(boolean);
	*** move(java.io.File,java.io.File);
	*** newInputStreamSupplier(java.io.File);
	*** newOutputStreamSupplier(java.io.File,boolean);
	*** newReaderSupplier(java.io.File,java.nio.charset.Charset);
	*** newWriterSupplier(java.io.File,java.nio.charset.Charset,boolean);
	*** toString(java.io.File,java.nio.charset.Charset);
	*** write(java.lang.CharSequence,java.io.File,java.nio.charset.Charset,boolean);
}

-keep class com.google.common.io.Files$FileByteSink {
	*** file;
	*** modes;
	com.google.common.io.Files$FileByteSink(java.io.File,com.google.common.io.FileWriteMode[]);
	*** openStream();
}

-keep class com.google.common.io.Files$FileByteSource {
	*** file;
	com.google.common.io.Files$FileByteSource(java.io.File);
	*** openStream();
}

-keep class com.google.common.io.InputSupplier {
	*** getInput();
}

-keep class com.google.common.io.LineProcessor {
	*** getResult();
	*** processLine(java.lang.String);
}

-keep class com.google.common.io.LineReader {
	*** readLine();
}

-keep class com.google.common.io.OutputSupplier {
	*** getOutput();
}

-keep class com.google.common.primitives.AndroidInteger {
	*** tryParse(java.lang.String,int);
}

-keep class com.google.common.primitives.Ints {
	*** compare(int,int);
	*** copyOf(int[],int);
	*** fromBytes(byte,byte,byte,byte);
	*** indexOf(int[],int,int,int);
	*** lastIndexOf(int[],int,int,int);
	*** saturatedCast(long);
}

-keep class com.google.common.primitives.Ints$IntArrayAsList {
	*** toIntArray();
}

-keep class com.google.common.primitives.Ints$LexicographicalComparator {
	*** INSTANCE;
}

-keep class com.google.common.reflect.Element {
	*** accessibleObject;
	*** member;
	com.google.common.reflect.Element(java.lang.reflect.AccessibleObject);
	*** equals(java.lang.Object);
	*** getDeclaringClass();
	*** getModifiers();
	*** hashCode();
	*** isFinal();
	*** isPrivate();
	*** isProtected();
	*** isPublic();
	*** isStatic();
	*** toString();
}

-keep class com.google.common.reflect.Invokable {
	com.google.common.reflect.Invokable(java.lang.reflect.AccessibleObject);
	*** getDeclaringClass();
	*** getGenericExceptionTypes();
	*** getGenericParameterTypes();
	*** getGenericReturnType();
	*** getParameterAnnotations();
	*** getReturnType();
	*** invokeInternal(java.lang.Object,java.lang.Object[]);
	*** returning(com.google.common.reflect.TypeToken);
}

-keep class com.google.common.reflect.Invokable$ConstructorInvokable {
	*** constructor;
	com.google.common.reflect.Invokable$ConstructorInvokable(java.lang.reflect.Constructor);
	*** getGenericExceptionTypes();
	*** getGenericParameterTypes();
	*** getGenericReturnType();
}

-keep class com.google.common.reflect.Invokable$MethodInvokable {
	*** method;
	com.google.common.reflect.Invokable$MethodInvokable(java.lang.reflect.Method);
	*** getGenericExceptionTypes();
	*** getGenericParameterTypes();
	*** getGenericReturnType();
}

-keep class com.google.common.reflect.TypeCapture {
	com.google.common.reflect.TypeCapture();
	*** capture();
}

-keep class com.google.common.reflect.TypeParameter {
	*** typeVariable;
}

-keep class com.google.common.reflect.TypeResolver {
	*** accordingTo(java.lang.reflect.Type);
	*** resolveType(java.lang.reflect.Type);
	*** where(java.lang.reflect.Type,java.lang.reflect.Type);
	*** where(java.util.Map);
}

-keep class com.google.common.reflect.TypeToken {
	*** runtimeType;
	*** typeResolver;
	com.google.common.reflect.TypeToken(java.lang.reflect.Type);
	com.google.common.reflect.TypeToken(java.lang.reflect.Type,com.google.common.reflect.TypeToken$1);
	*** access$000(com.google.common.reflect.TypeToken,java.lang.reflect.Type[]);
	*** access$200(com.google.common.reflect.TypeToken);
	*** boundAsSuperclass(java.lang.reflect.Type);
	*** boundsAsInterfaces(java.lang.reflect.Type[]);
	*** getArraySubtype(java.lang.Class);
	*** getArraySupertype(java.lang.Class);
	*** getComponentType();
	*** getGenericInterfaces();
	*** getGenericSuperclass();
	*** getImmediateRawTypes();
	*** getRawType();
	*** getRawType(java.lang.reflect.Type);
	*** getRawTypes(java.lang.reflect.Type);
	*** getRawTypes(java.lang.reflect.Type[]);
	*** getSubtype(java.lang.Class);
	*** getSubtypeFromLowerBounds(java.lang.Class,java.lang.reflect.Type[]);
	*** getSupertype(java.lang.Class);
	*** getSupertypeFromUpperBounds(java.lang.Class,java.lang.reflect.Type[]);
	*** getType();
	*** getTypes();
	*** isArray();
	*** isAssignable(java.lang.reflect.Type,java.lang.reflect.Type);
	*** isAssignableBySubtypeBound(java.lang.reflect.Type,java.lang.reflect.WildcardType);
	*** isAssignableFrom(com.google.common.reflect.TypeToken);
	*** isAssignableFrom(java.lang.reflect.Type);
	*** isAssignableFromAny(java.lang.reflect.Type[],java.lang.reflect.Type);
	*** isAssignableFromGenericArrayType(java.lang.reflect.GenericArrayType,java.lang.reflect.Type);
	*** isAssignableToClass(java.lang.reflect.Type,java.lang.Class);
	*** isAssignableToGenericArrayType(java.lang.reflect.Type,java.lang.reflect.GenericArrayType);
	*** isAssignableToParameterizedType(java.lang.reflect.Type,java.lang.reflect.ParameterizedType);
	*** isAssignableToWildcardType(java.lang.reflect.Type,java.lang.reflect.WildcardType);
	*** matchTypeArgument(java.lang.reflect.Type,java.lang.reflect.Type);
	*** newArrayClassOrGenericArrayType(java.lang.reflect.Type);
	*** of(java.lang.Class);
	*** of(java.lang.reflect.Type);
	*** resolveInPlace(java.lang.reflect.Type[]);
	*** resolveSupertype(java.lang.reflect.Type);
	*** resolveType(java.lang.reflect.Type);
	*** resolveTypeArgsForSubclass(java.lang.Class);
	*** subtypeBound(java.lang.reflect.Type);
	*** subtypeBound(java.lang.reflect.WildcardType);
	*** supertypeBound(java.lang.reflect.Type);
	*** supertypeBound(java.lang.reflect.WildcardType);
	*** toGenericType(java.lang.Class);
	*** where(com.google.common.reflect.TypeParameter,com.google.common.reflect.TypeToken);
}

-keep class com.google.common.reflect.TypeToken$1 {
	*** this$0;
}

-keep class com.google.common.reflect.TypeToken$2 {
	*** this$0;
}

-keep class com.google.common.reflect.TypeToken$ClassSet {
	*** classes;
	*** this$0;
	com.google.common.reflect.TypeToken$ClassSet(com.google.common.reflect.TypeToken);
	*** delegate();
}

-keep class com.google.common.reflect.TypeToken$InterfaceSet {
	*** allTypes;
	*** interfaces;
	*** this$0;
	*** delegate();
}

-keep class com.google.common.reflect.TypeToken$TypeCollector {
	*** FOR_GENERIC_TYPE;
	*** FOR_RAW_TYPE;
	com.google.common.reflect.TypeToken$TypeCollector();
	com.google.common.reflect.TypeToken$TypeCollector(com.google.common.reflect.TypeToken$1);
	*** classesOnly();
	*** collectTypes(java.lang.Iterable);
	*** collectTypes(java.lang.Object);
	*** collectTypes(java.lang.Object,java.util.Map);
	*** getInterfaces(java.lang.Object);
	*** getRawType(java.lang.Object);
	*** getSuperclass(java.lang.Object);
	*** sortKeysByValue(java.util.Map,java.util.Comparator);
}

-keep class com.google.common.reflect.TypeToken$TypeCollector$1 {
	*** getInterfaces(com.google.common.reflect.TypeToken);
	*** getRawType(com.google.common.reflect.TypeToken);
	*** getSuperclass(com.google.common.reflect.TypeToken);
}

-keep class com.google.common.reflect.TypeToken$TypeCollector$2 {
	*** getInterfaces(java.lang.Class);
	*** getRawType(java.lang.Class);
	*** getSuperclass(java.lang.Class);
}

-keep class com.google.common.reflect.TypeToken$TypeCollector$3 {
	*** this$0;
}

-keep class com.google.common.reflect.TypeToken$TypeCollector$4 {
	*** val$map;
	*** val$valueComparator;
}

-keep class com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector {
	*** delegate;
	com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector(com.google.common.reflect.TypeToken$TypeCollector);
	*** getRawType(java.lang.Object);
}

-keep class com.google.common.reflect.TypeToken$TypeFilter {
	*** IGNORE_TYPE_VARIABLE_OR_WILDCARD;
	*** INTERFACE_ONLY;
}

-keep class com.google.common.reflect.TypeToken$TypeSet {
	*** this$0;
	*** types;
	com.google.common.reflect.TypeToken$TypeSet(com.google.common.reflect.TypeToken);
	*** classes();
	*** delegate();
	*** interfaces();
	*** rawTypes();
}

-keep class com.google.common.reflect.Types {
	*** containsTypeVariable(java.lang.reflect.Type);
	*** getArrayClass(java.lang.Class);
	*** getComponentType(java.lang.reflect.Type);
	*** newArrayType(java.lang.reflect.Type);
	*** newParameterizedType(java.lang.Class,java.lang.reflect.Type[]);
	*** toString(java.lang.reflect.Type);
}

-keep class com.google.common.reflect.Types$JavaVersion {
	*** JAVA7;
	*** newArrayType(java.lang.reflect.Type);
}

-keep class com.google.common.util.concurrent.AbstractFuture {
	*** executionList;
	*** sync;
	com.google.common.util.concurrent.AbstractFuture();
	*** cancellationExceptionWithCause(java.lang.String,java.lang.Throwable);
	*** interruptTask();
	*** set(java.lang.Object);
	*** setException(java.lang.Throwable);
}

-keep class com.google.common.util.concurrent.AbstractFuture$Sync {
	*** exception;
	*** value;
	*** cancel(boolean);
	*** complete(java.lang.Object,java.lang.Throwable,int);
	*** get();
	*** get(long);
	*** getValue();
	*** isCancelled();
	*** isDone();
	*** set(java.lang.Object);
	*** setException(java.lang.Throwable);
	*** wasInterrupted();
}

-keep class com.google.common.util.concurrent.AbstractListeningExecutorService {
	com.google.common.util.concurrent.AbstractListeningExecutorService();
	*** submit(java.lang.Runnable);
	*** submit(java.lang.Runnable,java.lang.Object);
	*** submit(java.util.concurrent.Callable);
}

-keep class com.google.common.util.concurrent.ExecutionList {
	*** executed;
	*** log;
	*** runnables;
	*** add(java.lang.Runnable,java.util.concurrent.Executor);
	*** execute();
}

-keep class com.google.common.util.concurrent.ExecutionList$RunnableExecutorPair {
	*** execute();
}

-keep class com.google.common.util.concurrent.Futures {
	*** immediateFuture(java.lang.Object);
}

-keep class com.google.common.util.concurrent.ListenableFuture {
	*** addListener(java.lang.Runnable,java.util.concurrent.Executor);
}

-keep class com.google.common.util.concurrent.ListenableFutureTask {
	*** create(java.lang.Runnable,java.lang.Object);
	*** create(java.util.concurrent.Callable);
}

-keep class com.google.common.util.concurrent.ListeningExecutorService {
	*** submit(java.util.concurrent.Callable);
}

-keep class com.google.common.util.concurrent.MoreExecutors {
	*** invokeAnyImpl(com.google.common.util.concurrent.ListeningExecutorService,java.util.Collection,boolean,long);
	*** isAppEngine();
	*** platformThreadFactory();
	*** sameThreadExecutor();
	*** submitAndAddQueueListener(com.google.common.util.concurrent.ListeningExecutorService,java.util.concurrent.Callable,java.util.concurrent.BlockingQueue);
	*** useDaemonThreadFactory(java.util.concurrent.ThreadPoolExecutor);
}

-keep class com.google.common.util.concurrent.MoreExecutors$Application {
	*** addDelayedShutdownHook(java.util.concurrent.ExecutorService,long,java.util.concurrent.TimeUnit);
	*** getExitingExecutorService(java.util.concurrent.ThreadPoolExecutor);
	*** getExitingExecutorService(java.util.concurrent.ThreadPoolExecutor,long,java.util.concurrent.TimeUnit);
	*** getExitingScheduledExecutorService(java.util.concurrent.ScheduledThreadPoolExecutor);
	*** getExitingScheduledExecutorService(java.util.concurrent.ScheduledThreadPoolExecutor,long,java.util.concurrent.TimeUnit);
}

-keep class com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService {
	*** lock;
	*** runningTasks;
	*** shutdown;
	*** termination;
	com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService();
	*** endTask();
	*** isShutdown();
	*** isTerminated();
	*** shutdown();
	*** startTask();
}

-keep class com.google.common.util.concurrent.SettableFuture {
	*** create();
	*** set(java.lang.Object);
	*** setException(java.lang.Throwable);
}

-keep class com.google.common.util.concurrent.ThreadFactoryBuilder {
	*** backingThreadFactory;
	*** daemon;
	*** nameFormat;
	*** priority;
	*** uncaughtExceptionHandler;
	*** build();
	*** build(com.google.common.util.concurrent.ThreadFactoryBuilder);
	*** setDaemon(boolean);
	*** setNameFormat(java.lang.String);
	*** setThreadFactory(java.util.concurrent.ThreadFactory);
}

-keep class com.google.common.util.concurrent.ThreadFactoryBuilder$1 {
	*** val$backingThreadFactory;
	*** val$count;
	*** val$daemon;
	*** val$nameFormat;
	*** val$priority;
	*** val$uncaughtExceptionHandler;
}

-keep class com.google.common.util.concurrent.Uninterruptibles {
	*** getUninterruptibly(java.util.concurrent.Future);
}

-keep class com.google.inject.AbstractModule {
	*** binder;
	com.google.inject.AbstractModule();
	*** bind(java.lang.Class);
	*** binder();
	*** configure();
}

-keep class com.google.inject.Binder {
	*** addError(com.google.inject.spi.Message);
	*** addError(java.lang.String,java.lang.Object[]);
	*** addError(java.lang.Throwable);
	*** bind(com.google.inject.Key);
	*** bind(com.google.inject.TypeLiteral);
	*** bind(java.lang.Class);
	*** bindConstant();
	*** bindInterceptor(com.google.inject.matcher.Matcher,com.google.inject.matcher.Matcher,org.aopalliance.intercept.MethodInterceptor[]);
	*** bindListener(com.google.inject.matcher.Matcher,com.google.inject.spi.TypeListener);
	*** bindScope(java.lang.Class,com.google.inject.Scope);
	*** convertToTypes(com.google.inject.matcher.Matcher,com.google.inject.spi.TypeConverter);
	*** currentStage();
	*** getMembersInjector(com.google.inject.TypeLiteral);
	*** getMembersInjector(java.lang.Class);
	*** getProvider(com.google.inject.Key);
	*** getProvider(java.lang.Class);
	*** install(com.google.inject.Module);
	*** newPrivateBinder();
	*** requestInjection(java.lang.Object);
	*** requestStaticInjection(java.lang.Class[]);
	*** skipSources(java.lang.Class[]);
	*** withSource(java.lang.Object);
}

-keep class com.google.inject.Binding {
	*** acceptScopingVisitor(com.google.inject.spi.BindingScopingVisitor);
	*** acceptTargetVisitor(com.google.inject.spi.BindingTargetVisitor);
	*** getKey();
	*** getProvider();
}

-keep class com.google.inject.ConfigurationException {
	*** messages;
	*** partialValue;
	*** getErrorMessages();
	*** getPartialValue();
	*** withPartialValue(java.lang.Object);
}

-keep class com.google.inject.CreationException {
	*** messages;
	*** getErrorMessages();
}

-keep class com.google.inject.Guice {
	*** createInjector(com.google.inject.Module[]);
	*** createInjector(com.google.inject.Stage,java.lang.Iterable);
	*** createInjector(java.lang.Iterable);
}

-keep class com.google.inject.ImplementedBy {
	*** value();
}

-keep class com.google.inject.Inject {
	*** optional();
}

-keep class com.google.inject.Injector {
	*** getBinding(com.google.inject.Key);
	*** getInstance(java.lang.Class);
}

-keep class com.google.inject.Key {
	*** annotationStrategy;
	*** hashCode;
	*** typeLiteral;
	*** computeHashCode();
	*** ensureIsBindingAnnotation(java.lang.Class);
	*** ensureRetainedAtRuntime(java.lang.Class);
	*** equals(java.lang.Object);
	*** get(com.google.inject.TypeLiteral);
	*** get(com.google.inject.TypeLiteral,java.lang.Class);
	*** get(com.google.inject.TypeLiteral,java.lang.annotation.Annotation);
	*** get(java.lang.Class);
	*** get(java.lang.Class,java.lang.Class);
	*** get(java.lang.Class,java.lang.annotation.Annotation);
	*** getAnnotation();
	*** getAnnotationType();
	*** getTypeLiteral();
	*** hasAttributes();
	*** ofType(com.google.inject.TypeLiteral);
	*** ofType(java.lang.reflect.Type);
	*** strategyFor(java.lang.Class);
	*** strategyFor(java.lang.annotation.Annotation);
	*** toString();
	*** withoutAttributes();
}

-keep class com.google.inject.Key$AnnotationStrategy {
	*** getAnnotation();
	*** getAnnotationType();
	*** hasAttributes();
	*** withoutAttributes();
}

-keep class com.google.inject.Key$NullAnnotationStrategy {
	*** $VALUES;
	*** INSTANCE;
}

-keep class com.google.inject.MembersInjector {
	*** injectMembers(java.lang.Object);
}

-keep class com.google.inject.Module {
	*** configure(com.google.inject.Binder);
}

-keep class com.google.inject.PrivateBinder {
	*** expose(com.google.inject.Key);
	*** expose(com.google.inject.TypeLiteral);
	*** expose(java.lang.Class);
	*** withSource(java.lang.Object);
}

-keep class com.google.inject.PrivateModule {
	*** binder;
	*** configure();
}

-keep class com.google.inject.ProvidedBy {
	*** value();
}

-keep class com.google.inject.Provider {
	*** get();
}

-keep class com.google.inject.ProvisionException {
	*** messages;
	*** getErrorMessages();
}

-keep class com.google.inject.Scope {
	*** scope(com.google.inject.Key,com.google.inject.Provider);
}

-keep class com.google.inject.Scopes {
	*** NO_SCOPE;
	*** NULL;
	*** SINGLETON;
	*** access$000();
}

-keep class com.google.inject.Scopes$1$1 {
	*** instance;
	*** this$0;
	*** val$creator;
}

-keep class com.google.inject.Stage {
	*** $VALUES;
	*** DEVELOPMENT;
	*** PRODUCTION;
	*** TOOL;
}

-keep class com.google.inject.TypeLiteral {
	*** hashCode;
	*** rawType;
	*** type;
	*** equals(java.lang.Object);
	*** fromSuperclassTypeParameter(java.lang.Class);
	*** get(java.lang.Class);
	*** get(java.lang.reflect.Type);
	*** getFieldType(java.lang.reflect.Field);
	*** getParameterTypes(java.lang.reflect.Member);
	*** getRawType();
	*** getReturnType(java.lang.reflect.Method);
	*** getSuperclassTypeParameter(java.lang.Class);
	*** getSupertype(java.lang.Class);
	*** getType();
	*** hashCode();
	*** providerType();
	*** resolve(java.lang.reflect.Type);
	*** resolveAll(java.lang.reflect.Type[]);
	*** resolveType(java.lang.reflect.Type);
	*** toString();
}

-keep class com.google.inject.binder.LinkedBindingBuilder {
	*** to(com.google.inject.Key);
	*** to(java.lang.Class);
	*** toConstructor(java.lang.reflect.Constructor,com.google.inject.TypeLiteral);
	*** toInstance(java.lang.Object);
	*** toProvider(com.google.inject.Key);
	*** toProvider(com.google.inject.Provider);
	*** toProvider(java.lang.Class);
}

-keep class com.google.inject.binder.ScopedBindingBuilder {
	*** asEagerSingleton();
	*** in(com.google.inject.Scope);
	*** in(java.lang.Class);
}

-keep class com.google.inject.internal.AbstractBindingBuilder {
	*** NULL_KEY;
	*** binder;
	*** binding;
	*** elements;
	*** position;
	com.google.inject.internal.AbstractBindingBuilder(com.google.inject.Binder,java.util.List,java.lang.Object,com.google.inject.Key);
	*** annotatedWithInternal(java.lang.Class);
	*** annotatedWithInternal(java.lang.annotation.Annotation);
	*** checkNotAnnotated();
	*** checkNotScoped();
	*** checkNotTargetted();
	*** getBinding();
	*** keyTypeIsSet();
	*** setBinding(com.google.inject.internal.BindingImpl);
}

-keep class com.google.inject.internal.AbstractBindingProcessor {
	*** FORBIDDEN_TYPES;
	*** bindingData;
	com.google.inject.internal.AbstractBindingProcessor(com.google.inject.internal.Errors,com.google.inject.internal.ProcessedBindingData);
	*** access$000(com.google.inject.internal.AbstractBindingProcessor,java.lang.Object,com.google.inject.Key);
	*** invalidBinding(com.google.inject.internal.InjectorImpl,com.google.inject.Key,java.lang.Object);
	*** isOkayDuplicate(com.google.inject.internal.BindingImpl,com.google.inject.internal.BindingImpl,com.google.inject.internal.State);
	*** putBinding(com.google.inject.internal.BindingImpl);
	*** validateKey(java.lang.Object,com.google.inject.Key);
}

-keep class com.google.inject.internal.AbstractBindingProcessor$Processor {
	*** key;
	*** rawType;
	*** scoping;
	*** source;
	*** this$0;
	com.google.inject.internal.AbstractBindingProcessor$Processor(com.google.inject.internal.AbstractBindingProcessor,com.google.inject.internal.BindingImpl);
	*** prepareBinding();
	*** scheduleInitialization(com.google.inject.internal.BindingImpl);
}

-keep class com.google.inject.internal.AbstractBindingProcessor$Processor$1 {
	*** this$1;
	*** val$binding;
}

-keep class com.google.inject.internal.AbstractProcessor {
	*** errors;
	*** injector;
	com.google.inject.internal.AbstractProcessor(com.google.inject.internal.Errors);
	*** process(com.google.inject.internal.InjectorImpl,java.util.List);
	*** process(java.lang.Iterable);
	*** visitOther(com.google.inject.spi.Element);
}

-keep class com.google.inject.internal.Annotations {
	*** bindingAnnotationChecker;
	*** scopeChecker;
	*** canonicalizeIfNamed(java.lang.Class);
	*** canonicalizeIfNamed(java.lang.annotation.Annotation);
	*** checkForMisplacedScopeAnnotations(java.lang.Class,java.lang.Object,com.google.inject.internal.Errors);
	*** findBindingAnnotation(com.google.inject.internal.Errors,java.lang.reflect.Member,java.lang.annotation.Annotation[]);
	*** findScopeAnnotation(com.google.inject.internal.Errors,java.lang.Class);
	*** findScopeAnnotation(com.google.inject.internal.Errors,java.lang.annotation.Annotation[]);
	*** getKey(com.google.inject.TypeLiteral,java.lang.reflect.Member,java.lang.annotation.Annotation[],com.google.inject.internal.Errors);
	*** isBindingAnnotation(java.lang.Class);
	*** isMarker(java.lang.Class);
	*** isRetainedAtRuntime(java.lang.Class);
	*** isScopeAnnotation(java.lang.Class);
}

-keep class com.google.inject.internal.Annotations$AnnotationChecker {
	*** annotationTypes;
	*** cache;
	*** hasAnnotations;
	*** access$000(com.google.inject.internal.Annotations$AnnotationChecker);
	*** hasAnnotations(java.lang.Class);
}

-keep class com.google.inject.internal.Annotations$AnnotationChecker$1 {
	*** this$0;
	*** apply(java.lang.Class);
}

-keep class com.google.inject.internal.BindingBuilder {
	*** annotatedWith(java.lang.Class);
	*** annotatedWith(java.lang.annotation.Annotation);
	*** copyErrorsToBinder(com.google.inject.ConfigurationException);
	*** to(com.google.inject.Key);
	*** to(com.google.inject.TypeLiteral);
	*** to(java.lang.Class);
	*** toConstructor(java.lang.reflect.Constructor,com.google.inject.TypeLiteral);
	*** toProvider(com.google.inject.Key);
	*** toProvider(com.google.inject.Provider);
	*** toProvider(com.google.inject.TypeLiteral);
	*** toProvider(java.lang.Class);
}

-keep class com.google.inject.internal.BindingImpl {
	*** injector;
	*** internalFactory;
	*** key;
	*** provider;
	*** scoping;
	*** source;
	com.google.inject.internal.BindingImpl(com.google.inject.internal.InjectorImpl,com.google.inject.Key,java.lang.Object,com.google.inject.internal.InternalFactory,com.google.inject.internal.Scoping);
	com.google.inject.internal.BindingImpl(java.lang.Object,com.google.inject.Key,com.google.inject.internal.Scoping);
	*** getInjector();
	*** getInternalFactory();
	*** getKey();
	*** getProvider();
	*** getScoping();
	*** getSource();
	*** isConstant();
	*** withKey(com.google.inject.Key);
	*** withScoping(com.google.inject.internal.Scoping);
}

-keep class com.google.inject.internal.BindingProcessor {
	*** initializer;
	*** access$000(com.google.inject.internal.BindingProcessor);
	*** bindExposed(com.google.inject.spi.PrivateElements,com.google.inject.Key);
	*** visit(com.google.inject.Binding);
	*** visit(com.google.inject.spi.PrivateElements);
}

-keep class com.google.inject.internal.BindingProcessor$1 {
	*** this$0;
	*** visit(com.google.inject.spi.ConstructorBinding);
	*** visit(com.google.inject.spi.ConvertedConstantBinding);
	*** visit(com.google.inject.spi.ExposedBinding);
	*** visit(com.google.inject.spi.InstanceBinding);
	*** visit(com.google.inject.spi.LinkedKeyBinding);
	*** visit(com.google.inject.spi.ProviderBinding);
	*** visit(com.google.inject.spi.ProviderInstanceBinding);
	*** visit(com.google.inject.spi.ProviderKeyBinding);
	*** visit(com.google.inject.spi.UntargettedBinding);
	*** visitOther(com.google.inject.Binding);
}

-keep class com.google.inject.internal.BoundProviderFactory {
	*** injector;
	*** providerFactory;
	*** providerKey;
	*** source;
}

-keep class com.google.inject.internal.BytecodeGen {
	*** CGLIB_PACKAGE;
	*** CLASS_LOADER_CACHE;
	*** CUSTOM_LOADER_ENABLED;
	*** ENHANCER_NAMING_POLICY;
	*** FASTCLASS_NAMING_POLICY;
	*** GUICE_CLASS_LOADER;
	*** GUICE_INTERNAL_PACKAGE;
	*** logger;
	*** canonicalize(java.lang.ClassLoader);
	*** getClassLoader(java.lang.Class);
	*** getClassLoader(java.lang.Class,java.lang.ClassLoader);
	*** newEnhancer(java.lang.Class,com.google.inject.internal.BytecodeGen$Visibility);
	*** newFastClass(java.lang.Class,com.google.inject.internal.BytecodeGen$Visibility);
}

-keep class com.google.inject.internal.BytecodeGen$3 {
	*** apply(java.lang.ClassLoader);
}

-keep class com.google.inject.internal.BytecodeGen$BridgeClassLoader {
	*** classicLoadClass(java.lang.String,boolean);
}

-keep class com.google.inject.internal.BytecodeGen$SystemBridgeHolder {
	*** SYSTEM_BRIDGE;
}

-keep class com.google.inject.internal.BytecodeGen$Visibility {
	*** $VALUES;
	*** PUBLIC;
	*** SAME_PACKAGE;
	com.google.inject.internal.BytecodeGen$Visibility(java.lang.String,int);
	com.google.inject.internal.BytecodeGen$Visibility(java.lang.String,int,com.google.inject.internal.BytecodeGen$1);
	*** and(com.google.inject.internal.BytecodeGen$Visibility);
	*** forMember(java.lang.reflect.Member);
	*** forType(java.lang.Class);
}

-keep class com.google.inject.internal.ConstantBindingBuilderImpl {
	*** toConstant(java.lang.Class,java.lang.Object);
}

-keep class com.google.inject.internal.ConstantFactory {
	*** initializable;
}

-keep class com.google.inject.internal.ConstructionContext {
	*** constructing;
	*** currentReference;
	*** invocationHandlers;
	*** createProxy(com.google.inject.internal.Errors,java.lang.Class);
	*** finishConstruction();
	*** getCurrentReference();
	*** isConstructing();
	*** removeCurrentReference();
	*** setCurrentReference(java.lang.Object);
	*** setProxyDelegates(java.lang.Object);
	*** startConstruction();
}

-keep class com.google.inject.internal.ConstructionProxy {
	*** getInjectionPoint();
	*** getMethodInterceptors();
	*** newInstance(java.lang.Object[]);
}

-keep class com.google.inject.internal.ConstructionProxyFactory {
	*** create();
}

-keep class com.google.inject.internal.ConstructorBindingImpl {
	*** constructorInjectionPoint;
	*** factory;
	*** create(com.google.inject.internal.InjectorImpl,com.google.inject.Key,com.google.inject.spi.InjectionPoint,java.lang.Object,com.google.inject.internal.Scoping,com.google.inject.internal.Errors,boolean);
	*** getConstructor();
	*** getInjectableMembers();
	*** getInternalConstructor();
	*** getInternalDependencies();
	*** initialize(com.google.inject.internal.InjectorImpl,com.google.inject.internal.Errors);
	*** isInitialized();
}

-keep class com.google.inject.internal.ConstructorBindingImpl$Factory {
	*** allowCircularProxy;
	*** constructorInjector;
	*** failIfNotLinked;
	*** key;
	*** access$000(com.google.inject.internal.ConstructorBindingImpl$Factory);
	*** access$002(com.google.inject.internal.ConstructorBindingImpl$Factory,com.google.inject.internal.ConstructorInjector);
	*** access$102(com.google.inject.internal.ConstructorBindingImpl$Factory,boolean);
}

-keep class com.google.inject.internal.ConstructorInjector {
	*** constructionProxy;
	*** injectableMembers;
	*** membersInjector;
	*** parameterInjectors;
	*** construct(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,java.lang.Class,boolean);
	*** getConstructionProxy();
	*** getInjectableMembers();
}

-keep class com.google.inject.internal.ConstructorInjectorStore {
	*** cache;
	*** injector;
	*** access$000(com.google.inject.internal.ConstructorInjectorStore,com.google.inject.spi.InjectionPoint,com.google.inject.internal.Errors);
	*** createConstructor(com.google.inject.spi.InjectionPoint,com.google.inject.internal.Errors);
	*** get(com.google.inject.spi.InjectionPoint,com.google.inject.internal.Errors);
	*** remove(com.google.inject.spi.InjectionPoint);
}

-keep class com.google.inject.internal.ConstructorInjectorStore$1 {
	*** this$0;
	*** create(com.google.inject.spi.InjectionPoint,com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.ContextualCallable {
	*** call(com.google.inject.internal.InternalContext);
}

-keep class com.google.inject.internal.CreationListener {
	*** notify(com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.DefaultConstructionProxyFactory {
	*** injectionPoint;
	*** access$000(com.google.inject.internal.DefaultConstructionProxyFactory);
	*** create();
}

-keep class com.google.inject.internal.DefaultConstructionProxyFactory$1 {
	*** this$0;
	*** val$constructor;
	*** val$fastConstructor;
}

-keep class com.google.inject.internal.DefaultConstructionProxyFactory$2 {
	*** this$0;
	*** val$constructor;
}

-keep class com.google.inject.internal.DeferredLookups {
	*** injector;
	*** lookups;
	*** initialize(com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.DelegatingInvocationHandler {
	*** delegate;
	*** setDelegate(java.lang.Object);
}

-keep class com.google.inject.internal.EncounterImpl {
	*** aspects;
	*** errors;
	*** injectionListeners;
	*** lookups;
	*** membersInjectors;
	*** valid;
	*** getAspects();
	*** getInjectionListeners();
	*** getMembersInjector(com.google.inject.TypeLiteral);
	*** getMembersInjectors();
	*** getProvider(com.google.inject.Key);
	*** invalidate();
}

-keep class com.google.inject.internal.Errors {
	*** converters;
	*** errors;
	*** parent;
	*** root;
	*** source;
	*** addMessage(com.google.inject.spi.Message);
	*** addMessage(java.lang.String,java.lang.Object[]);
	*** addMessage(java.lang.Throwable,java.lang.String,java.lang.Object[]);
	*** ambiguousTypeConversion(java.lang.String,java.lang.Object,com.google.inject.TypeLiteral,com.google.inject.spi.TypeConverterBinding,com.google.inject.spi.TypeConverterBinding);
	*** bindingAlreadySet(com.google.inject.Key,java.lang.Object);
	*** bindingToProvider();
	*** cannotBindToGuiceType(java.lang.String);
	*** cannotInjectAbstractMethod(java.lang.reflect.Method);
	*** cannotInjectFinalField(java.lang.reflect.Field);
	*** cannotInjectInnerClass(java.lang.Class);
	*** cannotInjectMethodWithTypeParameters(java.lang.reflect.Method);
	*** cannotInjectRawMembersInjector();
	*** cannotInjectRawProvider();
	*** cannotInjectRawTypeLiteral();
	*** cannotInjectTypeLiteralOf(java.lang.reflect.Type);
	*** cannotSatisfyCircularDependency(java.lang.Class);
	*** checkForNull(java.lang.Object,java.lang.Object,com.google.inject.spi.Dependency);
	*** childBindingAlreadySet(com.google.inject.Key,java.util.Set);
	*** circularProxiesDisabled(java.lang.Class);
	*** constructorNotDefinedByType(java.lang.reflect.Constructor,com.google.inject.TypeLiteral);
	*** conversionError(java.lang.String,java.lang.Object,com.google.inject.TypeLiteral,com.google.inject.spi.TypeConverterBinding,java.lang.RuntimeException);
	*** conversionTypeError(java.lang.String,java.lang.Object,com.google.inject.TypeLiteral,com.google.inject.spi.TypeConverterBinding,java.lang.Object);
	*** convert(java.lang.Object);
	*** converterReturnedNull(java.lang.String,java.lang.Object,com.google.inject.TypeLiteral,com.google.inject.spi.TypeConverterBinding);
	*** duplicateBindingAnnotations(java.lang.reflect.Member,java.lang.Class,java.lang.Class);
	*** duplicateScopeAnnotations(java.lang.Class,java.lang.Class);
	*** duplicateScopes(com.google.inject.Scope,java.lang.Class,com.google.inject.Scope);
	*** errorCheckingDuplicateBinding(com.google.inject.Key,java.lang.Object,java.lang.Throwable);
	*** errorEnhancingClass(java.lang.Class,java.lang.Throwable);
	*** errorInProvider(java.lang.RuntimeException);
	*** errorInUserCode(java.lang.Throwable,java.lang.String,java.lang.Object[]);
	*** errorInUserInjector(com.google.inject.MembersInjector,com.google.inject.TypeLiteral,java.lang.RuntimeException);
	*** errorInjectingConstructor(java.lang.Throwable);
	*** errorInjectingMethod(java.lang.Throwable);
	*** errorNotifyingInjectionListener(com.google.inject.spi.InjectionListener,com.google.inject.TypeLiteral,java.lang.RuntimeException);
	*** errorNotifyingTypeListener(com.google.inject.spi.TypeListenerBinding,com.google.inject.TypeLiteral,java.lang.Throwable);
	*** format(java.lang.String,java.lang.Object[]);
	*** format(java.lang.String,java.util.Collection);
	*** formatInjectionPoint(java.util.Formatter,com.google.inject.spi.Dependency,com.google.inject.spi.InjectionPoint);
	*** formatSource(java.util.Formatter,java.lang.Object);
	*** getMessages();
	*** getMessagesFromThrowable(java.lang.Throwable);
	*** getOnlyCause(java.util.Collection);
	*** getSources();
	*** hasErrors();
	*** jitBindingAlreadySet(com.google.inject.Key);
	*** jitDisabled(com.google.inject.Key);
	*** keyNotFullySpecified(com.google.inject.TypeLiteral);
	*** merge(com.google.inject.internal.Errors);
	*** merge(com.google.inject.spi.Message);
	*** merge(java.util.Collection);
	*** misplacedBindingAnnotation(java.lang.reflect.Member,java.lang.annotation.Annotation);
	*** missingConstantValues();
	*** missingConstructor(java.lang.Class);
	*** missingImplementation(com.google.inject.Key);
	*** missingRuntimeRetention(java.lang.Object);
	*** missingScopeAnnotation();
	*** notASubtype(java.lang.Class,java.lang.Class);
	*** optionalConstructor(java.lang.reflect.Constructor);
	*** recursiveBinding();
	*** recursiveImplementationType();
	*** recursiveProviderType();
	*** scopeAnnotationOnAbstractType(java.lang.Class,java.lang.Class,java.lang.Object);
	*** scopeNotFound(java.lang.Class);
	*** size();
	*** throwConfigurationExceptionIfErrorsExist();
	*** throwCreationExceptionIfErrorsExist();
	*** throwIfNewErrors(int);
	*** throwProvisionExceptionIfErrorsExist();
	*** toException();
	*** tooManyConstructors(java.lang.Class);
	*** unwrap(java.lang.RuntimeException);
	*** voidProviderMethod();
	*** withSource(java.lang.Object);
}

-keep class com.google.inject.internal.Errors$2 {
	*** toString(java.lang.Class);
}

-keep class com.google.inject.internal.Errors$3 {
	*** toString(java.lang.reflect.Member);
}

-keep class com.google.inject.internal.Errors$4 {
	*** toString(com.google.inject.Key);
}

-keep class com.google.inject.internal.Errors$Converter {
	*** type;
	com.google.inject.internal.Errors$Converter(java.lang.Class);
	*** appliesTo(java.lang.Object);
	*** convert(java.lang.Object);
	*** toString(java.lang.Object);
}

-keep class com.google.inject.internal.ErrorsException {
	*** errors;
	*** getErrors();
}

-keep class com.google.inject.internal.Exceptions {
	*** throwCleanly(java.lang.reflect.InvocationTargetException);
}

-keep class com.google.inject.internal.ExposedBindingImpl {
	*** privateElements;
	*** getPrivateElements();
}

-keep class com.google.inject.internal.FactoryProxy {
	*** injector;
	*** key;
	*** source;
	*** targetFactory;
	*** targetKey;
}

-keep class com.google.inject.internal.FailableCache {
	*** delegate;
	com.google.inject.internal.FailableCache();
	*** create(java.lang.Object,com.google.inject.internal.Errors);
	*** get(java.lang.Object,com.google.inject.internal.Errors);
	*** remove(java.lang.Object);
}

-keep class com.google.inject.internal.FailableCache$1 {
	*** this$0;
}

-keep class com.google.inject.internal.InheritingState {
	*** blacklistedKeys;
	*** converters;
	*** explicitBindings;
	*** explicitBindingsMutable;
	*** listenerBindings;
	*** lock;
	*** methodAspects;
	*** parent;
	*** scopes;
}

-keep class com.google.inject.internal.Initializable {
	*** get(com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.Initializables {
	*** of(java.lang.Object);
}

-keep class com.google.inject.internal.Initializables$1 {
	*** val$instance;
}

-keep class com.google.inject.internal.Initializer {
	*** creatingThread;
	*** pendingInjection;
	*** ready;
	*** injectAll(com.google.inject.internal.Errors);
	*** requestInjection(com.google.inject.internal.InjectorImpl,java.lang.Object,java.lang.Object,java.util.Set);
	*** validateOustandingInjections(com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.Initializer$InjectableReference {
	*** get(com.google.inject.internal.Errors);
	*** validate(com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.InjectionRequestProcessor {
	*** initializer;
	*** staticInjections;
	*** injectMembers();
	*** validate();
	*** visit(com.google.inject.spi.InjectionRequest);
	*** visit(com.google.inject.spi.StaticInjectionRequest);
}

-keep class com.google.inject.internal.InjectionRequestProcessor$StaticInjection {
	*** injectMembers();
	*** validate();
}

-keep class com.google.inject.internal.InjectorImpl {
	*** STRING_TYPE;
	*** bindingsMultimap;
	*** constructors;
	*** jitBindings;
	*** localContext;
	*** lookups;
	*** membersInjectorStore;
	*** options;
	*** parent;
	*** state;
	*** callInContext(com.google.inject.internal.ContextualCallable);
	*** cleanup(com.google.inject.internal.BindingImpl,java.util.Set);
	*** convertConstantStringBinding(com.google.inject.Key,com.google.inject.internal.Errors);
	*** createChildInjector(java.lang.Iterable);
	*** createImplementedByBinding(com.google.inject.Key,com.google.inject.internal.Scoping,com.google.inject.ImplementedBy,com.google.inject.internal.Errors);
	*** createJustInTimeBinding(com.google.inject.Key,com.google.inject.internal.Errors,boolean,com.google.inject.internal.InjectorImpl$JitLimitation);
	*** createJustInTimeBindingRecursive(com.google.inject.Key,com.google.inject.internal.Errors,boolean,com.google.inject.internal.InjectorImpl$JitLimitation);
	*** createMembersInjectorBinding(com.google.inject.Key,com.google.inject.internal.Errors);
	*** createParameterInjector(com.google.inject.spi.Dependency,com.google.inject.internal.Errors);
	*** createProvidedByBinding(com.google.inject.Key,com.google.inject.internal.Scoping,com.google.inject.ProvidedBy,com.google.inject.internal.Errors);
	*** createProviderBinding(com.google.inject.Key,com.google.inject.internal.Errors);
	*** createTypeLiteralBinding(com.google.inject.Key,com.google.inject.internal.Errors);
	*** createUninitializedBinding(com.google.inject.Key,com.google.inject.internal.Scoping,java.lang.Object,com.google.inject.internal.Errors,boolean);
	*** getBinding(com.google.inject.Key);
	*** getBindingOrThrow(com.google.inject.Key,com.google.inject.internal.Errors,com.google.inject.internal.InjectorImpl$JitLimitation);
	*** getExistingBinding(com.google.inject.Key);
	*** getInternalDependencies(com.google.inject.internal.BindingImpl);
	*** getInternalFactory(com.google.inject.Key,com.google.inject.internal.Errors,com.google.inject.internal.InjectorImpl$JitLimitation);
	*** getJustInTimeBinding(com.google.inject.Key,com.google.inject.internal.Errors,com.google.inject.internal.InjectorImpl$JitLimitation);
	*** getMembersInjector(com.google.inject.TypeLiteral);
	*** getMembersInjector(java.lang.Class);
	*** getParametersInjectors(java.util.List,com.google.inject.internal.Errors);
	*** getProvidedKey(com.google.inject.Key,com.google.inject.internal.Errors);
	*** getProvider(com.google.inject.Key);
	*** getProvider(java.lang.Class);
	*** getProviderOrThrow(com.google.inject.Key,com.google.inject.internal.Errors);
	*** index();
	*** index(com.google.inject.Binding);
	*** initializeBinding(com.google.inject.internal.BindingImpl,com.google.inject.internal.Errors);
	*** initializeJitBinding(com.google.inject.internal.BindingImpl,com.google.inject.internal.Errors);
	*** isMembersInjector(com.google.inject.Key);
	*** isProvider(com.google.inject.Key);
	*** isTypeLiteral(com.google.inject.Key);
	*** removeFailedJitBinding(com.google.inject.Key,com.google.inject.spi.InjectionPoint);
}

-keep class com.google.inject.internal.InjectorImpl$1 {
	*** this$0;
	*** initialValue();
}

-keep class com.google.inject.internal.InjectorImpl$4 {
	*** this$0;
	*** val$dependency;
	*** val$factory;
}

-keep class com.google.inject.internal.InjectorImpl$4$1 {
	*** this$1;
	*** val$errors;
}

-keep class com.google.inject.internal.InjectorImpl$BindingsMultimap {
	*** multimap;
	com.google.inject.internal.InjectorImpl$BindingsMultimap();
	*** getAll(com.google.inject.TypeLiteral);
	*** put(com.google.inject.TypeLiteral,com.google.inject.Binding);
}

-keep class com.google.inject.internal.InjectorImpl$ConvertedConstantBindingImpl {
	*** originalBinding;
	*** provider;
	*** typeConverterBinding;
	*** value;
	*** getSourceKey();
}

-keep class com.google.inject.internal.InjectorImpl$InjectorOptions {
	*** disableCircularProxies;
	*** jitDisabled;
	*** stage;
}

-keep class com.google.inject.internal.InjectorImpl$JitLimitation {
	*** $VALUES;
	*** EXISTING_JIT;
	*** NEW_OR_EXISTING_JIT;
	*** NO_JIT;
}

-keep class com.google.inject.internal.InjectorImpl$MethodInvoker {
	*** invoke(java.lang.Object,java.lang.Object[]);
}

-keep class com.google.inject.internal.InjectorImpl$ProviderBindingImpl {
	*** providedBinding;
	*** createInternalFactory(com.google.inject.Binding);
	*** getProvidedKey();
}

-keep class com.google.inject.internal.InjectorOptionsProcessor {
	*** disableCircularProxies;
	*** jitDisabled;
	*** getOptions(com.google.inject.Stage,com.google.inject.internal.InjectorImpl$InjectorOptions);
	*** visit(com.google.inject.spi.DisableCircularProxiesOption);
	*** visit(com.google.inject.spi.RequireExplicitBindingsOption);
}

-keep class com.google.inject.internal.InjectorShell {
	*** elements;
	*** injector;
	com.google.inject.internal.InjectorShell(com.google.inject.internal.InjectorShell$Builder,java.util.List,com.google.inject.internal.InjectorImpl);
	*** access$100(com.google.inject.internal.InjectorImpl);
	*** access$200(com.google.inject.internal.InjectorImpl);
	*** bindInjector(com.google.inject.internal.InjectorImpl);
	*** bindLogger(com.google.inject.internal.InjectorImpl);
	*** getElements();
	*** getInjector();
}

-keep class com.google.inject.internal.InjectorShell$Builder {
	*** elements;
	*** modules;
	*** options;
	*** parent;
	*** privateElements;
	*** stage;
	*** state;
	*** addModules(java.lang.Iterable);
	*** build(com.google.inject.internal.Initializer,com.google.inject.internal.ProcessedBindingData,com.google.inject.internal.util.$Stopwatch,com.google.inject.internal.Errors);
	*** getStage();
	*** getState();
	*** lock();
	*** parent(com.google.inject.internal.InjectorImpl);
	*** privateElements(com.google.inject.spi.PrivateElements);
	*** stage(com.google.inject.Stage);
}

-keep class com.google.inject.internal.InjectorShell$InjectorFactory {
	*** injector;
	com.google.inject.internal.InjectorShell$InjectorFactory(com.google.inject.Injector);
	*** get();
	*** get(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,com.google.inject.spi.Dependency,boolean);
}

-keep class com.google.inject.internal.InjectorShell$LoggerFactory {
	com.google.inject.internal.InjectorShell$LoggerFactory();
	*** get();
	*** get(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,com.google.inject.spi.Dependency,boolean);
}

-keep class com.google.inject.internal.InjectorShell$RootModule {
	*** stage;
	com.google.inject.internal.InjectorShell$RootModule(com.google.inject.Stage);
}

-keep class com.google.inject.internal.InstanceBindingImpl {
	*** injectionPoints;
	*** instance;
	*** provider;
}

-keep class com.google.inject.internal.InterceptorBindingProcessor {
	*** visit(com.google.inject.spi.InterceptorBinding);
}

-keep class com.google.inject.internal.InternalContext {
	*** constructionContexts;
	*** dependency;
	*** getConstructionContext(java.lang.Object);
	*** getDependency();
	*** setDependency(com.google.inject.spi.Dependency);
}

-keep class com.google.inject.internal.InternalFactory {
	*** get(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,com.google.inject.spi.Dependency,boolean);
}

-keep class com.google.inject.internal.InternalFactoryToProviderAdapter {
	*** initializable;
	*** source;
}

-keep class com.google.inject.internal.InternalInjectorCreator {
	*** bindingData;
	*** errors;
	*** initializer;
	*** injectionRequestProcessor;
	*** shellBuilder;
	*** shells;
	*** stopwatch;
	*** addModules(java.lang.Iterable);
	*** build();
	*** initializeStatically();
	*** injectDynamically();
	*** isEagerSingleton(com.google.inject.internal.InjectorImpl,com.google.inject.internal.BindingImpl,com.google.inject.Stage);
	*** loadEagerSingletons(com.google.inject.internal.InjectorImpl,com.google.inject.Stage,com.google.inject.internal.Errors);
	*** parentInjector(com.google.inject.internal.InjectorImpl);
	*** primaryInjector();
	*** stage(com.google.inject.Stage);
}

-keep class com.google.inject.internal.InternalInjectorCreator$1 {
	*** dependency;
	*** this$0;
	*** val$binding;
	*** val$errors;
	*** call(com.google.inject.internal.InternalContext);
}

-keep class com.google.inject.internal.LinkedBindingImpl {
	*** targetKey;
	*** getLinkedKey();
}

-keep class com.google.inject.internal.LinkedProviderBindingImpl {
	*** providerKey;
	*** getProviderKey();
}

-keep class com.google.inject.internal.LookupProcessor {
	*** visit(com.google.inject.spi.MembersInjectorLookup);
	*** visit(com.google.inject.spi.ProviderLookup);
}

-keep class com.google.inject.internal.Lookups {
	*** getMembersInjector(com.google.inject.TypeLiteral);
	*** getProvider(com.google.inject.Key);
}

-keep class com.google.inject.internal.MembersInjectorImpl {
	*** addedAspects;
	*** injectionListeners;
	*** injector;
	*** memberInjectors;
	*** typeLiteral;
	*** userMembersInjectors;
	*** getAddedAspects();
	*** getInjectionPoints();
	*** injectAndNotify(java.lang.Object,com.google.inject.internal.Errors,boolean);
	*** injectMembers(java.lang.Object,com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,boolean);
	*** notifyListeners(java.lang.Object,com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.MembersInjectorStore {
	*** cache;
	*** injector;
	*** typeListenerBindings;
	*** access$000(com.google.inject.internal.MembersInjectorStore,com.google.inject.TypeLiteral,com.google.inject.internal.Errors);
	*** createWithListeners(com.google.inject.TypeLiteral,com.google.inject.internal.Errors);
	*** get(com.google.inject.TypeLiteral,com.google.inject.internal.Errors);
	*** getInjectors(java.util.Set,com.google.inject.internal.Errors);
	*** hasTypeListeners();
	*** remove(com.google.inject.TypeLiteral);
}

-keep class com.google.inject.internal.MembersInjectorStore$1 {
	*** this$0;
	*** create(com.google.inject.TypeLiteral,com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.MessageProcessor {
	*** logger;
	*** getRootMessage(java.lang.Throwable);
	*** visit(com.google.inject.spi.Message);
}

-keep class com.google.inject.internal.MethodAspect {
	*** interceptors();
	*** matches(java.lang.Class);
	*** matches(java.lang.reflect.Method);
}

-keep class com.google.inject.internal.MoreTypes {
	*** EMPTY_TYPE_ARRAY;
	*** PRIMITIVE_TO_WRAPPER;
	*** access$000(java.lang.reflect.Type,java.lang.String);
	*** access$100(java.lang.reflect.Type);
	*** access$200(java.lang.Object);
	*** canonicalize(java.lang.reflect.Type);
	*** canonicalizeForKey(com.google.inject.TypeLiteral);
	*** checkNotPrimitive(java.lang.reflect.Type,java.lang.String);
	*** declaringClassOf(java.lang.reflect.TypeVariable);
	*** equals(java.lang.reflect.Type,java.lang.reflect.Type);
	*** getGenericSupertype(java.lang.reflect.Type,java.lang.Class,java.lang.Class);
	*** getRawType(java.lang.reflect.Type);
	*** hashCodeOrZero(java.lang.Object);
	*** indexOf(java.lang.Object[],java.lang.Object);
	*** isFullySpecified(java.lang.reflect.Type);
	*** resolveTypeVariable(java.lang.reflect.Type,java.lang.Class,java.lang.reflect.TypeVariable);
	*** typeToString(java.lang.reflect.Type);
}

-keep class com.google.inject.internal.MoreTypes$CompositeType {
	*** isFullySpecified();
}

-keep class com.google.inject.internal.MoreTypes$GenericArrayTypeImpl {
	*** componentType;
}

-keep class com.google.inject.internal.MoreTypes$ParameterizedTypeImpl {
	*** ownerType;
	*** rawType;
	*** typeArguments;
}

-keep class com.google.inject.internal.Nullability {
	*** allowsNull(java.lang.annotation.Annotation[]);
}

-keep class com.google.inject.internal.PrivateElementProcessor {
	*** injectorShellBuilders;
	*** getInjectorShellBuilders();
	*** visit(com.google.inject.spi.PrivateElements);
}

-keep class com.google.inject.internal.PrivateElementsImpl {
	*** addExposureBuilder(com.google.inject.internal.ExposureBuilder);
	*** getElementsMutable();
	*** initInjector(com.google.inject.Injector);
}

-keep class com.google.inject.internal.ProcessedBindingData {
	*** creationListeners;
	*** uninitializedBindings;
	*** addCreationListener(com.google.inject.internal.CreationListener);
	*** addUninitializedBinding(java.lang.Runnable);
	*** initializeBindings();
	*** runCreationListeners(com.google.inject.internal.Errors);
}

-keep class com.google.inject.internal.ProviderInstanceBindingImpl {
	*** injectionPoints;
	*** providerInstance;
	*** getProviderInstance();
}

-keep class com.google.inject.internal.ProviderMethod {
	*** dependencies;
	*** exposed;
	*** instance;
	*** key;
	*** method;
	*** parameterProviders;
	*** scopeAnnotation;
	*** configure(com.google.inject.Binder);
}

-keep class com.google.inject.internal.ProviderMethodsModule {
	*** delegate;
	*** typeLiteral;
	*** createProviderMethod(com.google.inject.Binder,java.lang.reflect.Method);
	*** forModule(com.google.inject.Module);
	*** forObject(java.lang.Object);
	*** getKey(com.google.inject.internal.Errors,com.google.inject.TypeLiteral,java.lang.reflect.Member,java.lang.annotation.Annotation[]);
	*** getProviderMethods(com.google.inject.Binder);
}

-keep class com.google.inject.internal.ProviderToInternalFactoryAdapter {
	*** injector;
	*** internalFactory;
	*** access$000(com.google.inject.internal.ProviderToInternalFactoryAdapter);
}

-keep class com.google.inject.internal.ProviderToInternalFactoryAdapter$1 {
	*** this$0;
	*** val$errors;
}

-keep class com.google.inject.internal.ProxyFactory {
	*** callbacks;
	*** declaringClass;
	*** injectionPoint;
	*** interceptors;
	*** logger;
	*** methods;
	*** visibility;
}

-keep class com.google.inject.internal.ProxyFactory$MethodInterceptorsPair {
	*** interceptors;
	*** method;
	*** addAll(java.util.List);
	*** hasInterceptors();
}

-keep class com.google.inject.internal.ScopeBindingProcessor {
	*** visit(com.google.inject.spi.ScopeBinding);
}

-keep class com.google.inject.internal.Scoping {
	*** EAGER_SINGLETON;
	*** SINGLETON_ANNOTATION;
	*** SINGLETON_INSTANCE;
	*** UNSCOPED;
	com.google.inject.internal.Scoping();
	com.google.inject.internal.Scoping(com.google.inject.internal.Scoping$1);
	*** acceptVisitor(com.google.inject.spi.BindingScopingVisitor);
	*** applyTo(com.google.inject.binder.ScopedBindingBuilder);
	*** equals(java.lang.Object);
	*** forAnnotation(java.lang.Class);
	*** forInstance(com.google.inject.Scope);
	*** getScopeAnnotation();
	*** getScopeInstance();
	*** isEagerSingleton(com.google.inject.Stage);
	*** isExplicitlyScoped();
	*** isNoScope();
	*** makeInjectable(com.google.inject.internal.Scoping,com.google.inject.internal.InjectorImpl,com.google.inject.internal.Errors);
	*** scope(com.google.inject.Key,com.google.inject.internal.InjectorImpl,com.google.inject.internal.InternalFactory,java.lang.Object,com.google.inject.internal.Scoping);
}

-keep class com.google.inject.internal.Scoping$5 {
	*** val$scopingAnnotation;
}

-keep class com.google.inject.internal.Scoping$6 {
	*** val$scope;
}

-keep class com.google.inject.internal.SingleFieldInjector {
	*** dependency;
	*** factory;
	*** field;
	*** injectionPoint;
}

-keep class com.google.inject.internal.SingleMemberInjector {
	*** getInjectionPoint();
	*** inject(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,java.lang.Object);
}

-keep class com.google.inject.internal.SingleMethodInjector {
	*** injectionPoint;
	*** methodInvoker;
	*** parameterInjectors;
	*** createMethodInvoker(java.lang.reflect.Method);
}

-keep class com.google.inject.internal.SingleParameterInjector {
	*** NO_ARGUMENTS;
	*** dependency;
	*** factory;
	*** getAll(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext,com.google.inject.internal.SingleParameterInjector[]);
	*** inject(com.google.inject.internal.Errors,com.google.inject.internal.InternalContext);
}

-keep class com.google.inject.internal.State {
	*** NONE;
	*** addConverter(com.google.inject.spi.TypeConverterBinding);
	*** addMethodAspect(com.google.inject.internal.MethodAspect);
	*** addTypeListener(com.google.inject.spi.TypeListenerBinding);
	*** blacklist(com.google.inject.Key,java.lang.Object);
	*** getConverter(java.lang.String,com.google.inject.TypeLiteral,com.google.inject.internal.Errors,java.lang.Object);
	*** getConvertersThisLevel();
	*** getExplicitBinding(com.google.inject.Key);
	*** getExplicitBindingsThisLevel();
	*** getMethodAspects();
	*** getScope(java.lang.Class);
	*** getScopes();
	*** getSourcesForBlacklistedKey(com.google.inject.Key);
	*** getTypeListenerBindings();
	*** isBlacklisted(com.google.inject.Key);
	*** lock();
	*** parent();
	*** putAnnotation(java.lang.Class,com.google.inject.Scope);
	*** putBinding(com.google.inject.Key,com.google.inject.internal.BindingImpl);
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor {
	*** convertToClass(java.lang.Class,com.google.inject.spi.TypeConverter);
	*** convertToClasses(com.google.inject.matcher.Matcher,com.google.inject.spi.TypeConverter);
	*** convertToPrimitiveType(java.lang.Class,java.lang.Class);
	*** internalConvertToTypes(com.google.inject.matcher.Matcher,com.google.inject.spi.TypeConverter);
	*** prepareBuiltInConverters(com.google.inject.internal.InjectorImpl);
	*** visit(com.google.inject.spi.TypeConverterBinding);
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor$1 {
	*** this$0;
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor$2 {
	*** this$0;
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor$3 {
	*** this$0;
	*** matches(com.google.inject.TypeLiteral);
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor$4 {
	*** this$0;
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor$5 {
	*** this$0;
	*** val$parser;
	*** val$wrapperType;
}

-keep class com.google.inject.internal.TypeConverterBindingProcessor$6 {
	*** this$0;
	*** val$typeMatcher;
	*** matches(com.google.inject.TypeLiteral);
}

-keep class com.google.inject.internal.TypeListenerBindingProcessor {
	*** visit(com.google.inject.spi.TypeListenerBinding);
}

-keep class com.google.inject.internal.UniqueAnnotations {
	*** create();
}

-keep class com.google.inject.internal.UntargettedBindingProcessor {
	*** visit(com.google.inject.Binding);
}

-keep class com.google.inject.internal.UntargettedBindingProcessor$1 {
	*** this$0;
	*** visit(com.google.inject.spi.UntargettedBinding);
	*** visitOther(com.google.inject.Binding);
}

-keep class com.google.inject.internal.WeakKeySet {
	*** backingSet;
	*** add(com.google.inject.Key,java.lang.Object);
	*** contains(com.google.inject.Key);
	*** getSources(com.google.inject.Key);
}

-keep class com.google.inject.internal.asm.$AnnotationVisitor {
	*** visit(java.lang.String,java.lang.Object);
	*** visitAnnotation(java.lang.String,java.lang.String);
	*** visitArray(java.lang.String);
	*** visitEnd();
	*** visitEnum(java.lang.String,java.lang.String,java.lang.String);
}

-keep class com.google.inject.internal.asm.$AnnotationWriter {
	*** g;
	*** a();
	*** a(com.google.inject.internal.asm.$AnnotationWriter[],int,com.google.inject.internal.asm.$ByteVector);
	*** a(com.google.inject.internal.asm.$ByteVector);
}

-keep class com.google.inject.internal.asm.$Attribute {
	*** a;
	*** b;
	*** type;
	*** a();
	*** a(com.google.inject.internal.asm.$ClassWriter,byte[],int,int,int);
	*** a(com.google.inject.internal.asm.$ClassWriter,byte[],int,int,int,com.google.inject.internal.asm.$ByteVector);
	*** getLabels();
	*** isCodeAttribute();
	*** read(com.google.inject.internal.asm.$ClassReader,int,int,char[],int,com.google.inject.internal.asm.$Label[]);
	*** write(com.google.inject.internal.asm.$ClassWriter,byte[],int,int,int);
}

-keep class com.google.inject.internal.asm.$ByteVector {
	*** a;
	*** b;
	*** a(int);
	*** a(int,int);
	*** b(int,int);
	*** putByte(int);
	*** putByteArray(byte[],int,int);
	*** putInt(int);
	*** putLong(long);
	*** putShort(int);
	*** putUTF8(java.lang.String);
}

-keep class com.google.inject.internal.asm.$ClassAdapter {
	*** cv;
	com.google.inject.internal.asm.$ClassAdapter(com.google.inject.internal.asm.$ClassVisitor);
}

-keep class com.google.inject.internal.asm.$ClassReader {
	*** a;
	*** b;
	*** c;
	*** d;
	*** header;
	com.google.inject.internal.asm.$ClassReader(byte[]);
	com.google.inject.internal.asm.$ClassReader(byte[],int,int);
	com.google.inject.internal.asm.$ClassReader(java.io.InputStream);
	*** a(com.google.inject.internal.asm.$Attribute[],java.lang.String,int,int,char[],int,com.google.inject.internal.asm.$Label[]);
	*** a(com.google.inject.internal.asm.$ClassWriter);
	*** a(int,char[],boolean,com.google.inject.internal.asm.$AnnotationVisitor);
	*** a(int,char[],java.lang.String,com.google.inject.internal.asm.$AnnotationVisitor);
	*** a(int,int,char[]);
	*** a(int,java.lang.String,char[],boolean,com.google.inject.internal.asm.$MethodVisitor);
	*** a(java.io.InputStream);
	*** a(java.lang.Object[],int,int,char[],com.google.inject.internal.asm.$Label[]);
	*** accept(com.google.inject.internal.asm.$ClassVisitor,com.google.inject.internal.asm.$Attribute[],int);
	*** accept(com.google.inject.internal.asm.$ClassVisitor,int);
	*** readClass(int,char[]);
	*** readConst(int,char[]);
	*** readInt(int);
	*** readLabel(int,com.google.inject.internal.asm.$Label[]);
	*** readLong(int);
	*** readShort(int);
	*** readUTF8(int,char[]);
	*** readUnsignedShort(int);
}

-keep class com.google.inject.internal.asm.$ClassVisitor {
	*** visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]);
	*** visitAnnotation(java.lang.String,boolean);
	*** visitAttribute(com.google.inject.internal.asm.$Attribute);
	*** visitEnd();
	*** visitField(int,java.lang.String,java.lang.String,java.lang.String,java.lang.Object);
	*** visitInnerClass(java.lang.String,java.lang.String,java.lang.String,int);
	*** visitMethod(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]);
	*** visitOuterClass(java.lang.String,java.lang.String,java.lang.String);
	*** visitSource(java.lang.String,java.lang.String);
}

-keep class com.google.inject.internal.asm.$ClassWriter {
	*** A;
	*** B;
	*** D;
	*** E;
	*** F;
	*** G;
	*** H;
	*** I;
	*** J;
	*** a;
	*** b;
	*** c;
	*** d;
	*** e;
	*** f;
	*** g;
	*** h;
	*** i;
	*** j;
	*** k;
	*** l;
	*** m;
	*** n;
	*** o;
	*** p;
	*** q;
	*** r;
	*** s;
	*** t;
	*** u;
	*** v;
	*** w;
	*** x;
	*** y;
	*** z;
	com.google.inject.internal.asm.$ClassWriter(int);
	*** a(com.google.inject.internal.asm.$Item);
	*** a(double);
	*** a(float);
	*** a(int);
	*** a(int,int);
	*** a(int,int,int);
	*** a(java.lang.Object);
	*** a(java.lang.String);
	*** a(java.lang.String,int);
	*** a(java.lang.String,java.lang.String,java.lang.String);
	*** a(java.lang.String,java.lang.String,java.lang.String,boolean);
	*** a(long);
	*** b(com.google.inject.internal.asm.$Item);
	*** b(java.lang.String);
	*** c(com.google.inject.internal.asm.$Item);
	*** c(java.lang.String);
	*** getCommonSuperClass(java.lang.String,java.lang.String);
	*** newClass(java.lang.String);
	*** newNameType(java.lang.String,java.lang.String);
	*** newUTF8(java.lang.String);
	*** toByteArray();
	*** visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]);
}

-keep class com.google.inject.internal.asm.$Edge {
	*** a;
	*** b;
	*** c;
}

-keep class com.google.inject.internal.asm.$FieldVisitor {
	*** visitAnnotation(java.lang.String,boolean);
	*** visitAttribute(com.google.inject.internal.asm.$Attribute);
	*** visitEnd();
}

-keep class com.google.inject.internal.asm.$FieldWriter {
	*** a;
	*** b;
	*** c;
	*** d;
	*** e;
	*** f;
	*** g;
	*** h;
	*** i;
	*** j;
	*** a();
	*** a(com.google.inject.internal.asm.$ByteVector);
}

-keep class com.google.inject.internal.asm.$Frame {
	*** a;
	*** b;
	*** c;
	*** d;
	*** e;
	*** f;
	*** g;
	*** h;
	*** i;
	*** a();
	*** a(com.google.inject.internal.asm.$ClassWriter,com.google.inject.internal.asm.$Frame,int);
	*** a(com.google.inject.internal.asm.$ClassWriter,int);
	*** a(com.google.inject.internal.asm.$ClassWriter,int,com.google.inject.internal.asm.$Type[],int);
	*** a(com.google.inject.internal.asm.$ClassWriter,int,int[],int);
	*** a(com.google.inject.internal.asm.$ClassWriter,java.lang.String);
	*** a(int);
	*** a(int,int);
	*** a(int,int,com.google.inject.internal.asm.$ClassWriter,com.google.inject.internal.asm.$Item);
	*** a(java.lang.String);
	*** b(com.google.inject.internal.asm.$ClassWriter,java.lang.String);
	*** b(int);
	*** c(int);
	*** d(int);
}

-keep class com.google.inject.internal.asm.$Handler {
	*** a;
	*** b;
	*** c;
	*** d;
	*** e;
	*** f;
}

-keep class com.google.inject.internal.asm.$Item {
	*** a;
	*** b;
	*** c;
	*** d;
	*** g;
	*** h;
	*** i;
	*** j;
	*** k;
	*** a(com.google.inject.internal.asm.$Item);
	*** a(double);
	*** a(float);
	*** a(int);
	*** a(int,java.lang.String,java.lang.String,java.lang.String);
	*** a(long);
}

-keep class com.google.inject.internal.asm.$Label {
	*** a;
	*** b;
	*** c;
	*** d;
	*** e;
	*** f;
	*** g;
	*** h;
	*** i;
	*** j;
	*** k;
	*** a();
	*** a(com.google.inject.internal.asm.$Label);
	*** a(com.google.inject.internal.asm.$MethodWriter,com.google.inject.internal.asm.$ByteVector,int,boolean);
	*** a(com.google.inject.internal.asm.$MethodWriter,int,byte[]);
	*** a(int,int);
	*** a(long);
	*** a(long,int);
	*** b(com.google.inject.internal.asm.$Label,long,int);
}

-keep class com.google.inject.internal.asm.$MethodAdapter {
	*** mv;
	com.google.inject.internal.asm.$MethodAdapter(com.google.inject.internal.asm.$MethodVisitor);
}

-keep class com.google.inject.internal.asm.$MethodVisitor {
	*** visitAnnotation(java.lang.String,boolean);
	*** visitAnnotationDefault();
	*** visitAttribute(com.google.inject.internal.asm.$Attribute);
	*** visitCode();
	*** visitEnd();
	*** visitFieldInsn(int,java.lang.String,java.lang.String,java.lang.String);
	*** visitFrame(int,int,java.lang.Object[],int,java.lang.Object[]);
	*** visitIincInsn(int,int);
	*** visitInsn(int);
	*** visitIntInsn(int,int);
	*** visitJumpInsn(int,com.google.inject.internal.asm.$Label);
	*** visitLabel(com.google.inject.internal.asm.$Label);
	*** visitLdcInsn(java.lang.Object);
	*** visitLineNumber(int,com.google.inject.internal.asm.$Label);
	*** visitLocalVariable(java.lang.String,java.lang.String,java.lang.String,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label,int);
	*** visitLookupSwitchInsn(com.google.inject.internal.asm.$Label,int[],com.google.inject.internal.asm.$Label[]);
	*** visitMaxs(int,int);
	*** visitMethodInsn(int,java.lang.String,java.lang.String,java.lang.String);
	*** visitMultiANewArrayInsn(java.lang.String,int);
	*** visitParameterAnnotation(int,java.lang.String,boolean);
	*** visitTableSwitchInsn(int,int,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label[]);
	*** visitTryCatchBlock(com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label,java.lang.String);
	*** visitTypeInsn(int,java.lang.String);
	*** visitVarInsn(int,int);
}

-keep class com.google.inject.internal.asm.$MethodWriter {
	*** A;
	*** B;
	*** C;
	*** D;
	*** E;
	*** F;
	*** G;
	*** H;
	*** I;
	*** J;
	*** K;
	*** L;
	*** M;
	*** N;
	*** O;
	*** P;
	*** Q;
	*** R;
	*** S;
	*** a;
	*** b;
	*** c;
	*** d;
	*** e;
	*** f;
	*** g;
	*** h;
	*** i;
	*** j;
	*** k;
	*** l;
	*** m;
	*** n;
	*** o;
	*** p;
	*** q;
	*** r;
	*** s;
	*** t;
	*** u;
	*** v;
	*** w;
	*** x;
	*** y;
	*** z;
	*** a();
	*** a(byte[],int);
	*** a(byte[],int,int);
	*** a(com.google.inject.internal.asm.$ByteVector);
	*** a(com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label[]);
	*** a(int,com.google.inject.internal.asm.$Label);
	*** a(int,int);
	*** a(int,int,int);
	*** a(int[],int[],com.google.inject.internal.asm.$Label);
	*** a(int[],int[],int,int);
	*** a(java.lang.Object);
	*** a(java.lang.String);
	*** b();
	*** b(byte[],int);
	*** b(com.google.inject.internal.asm.$Frame);
	*** c();
	*** c(byte[],int);
	*** d();
	*** e();
	*** visitLabel(com.google.inject.internal.asm.$Label);
}

-keep class com.google.inject.internal.asm.$Opcodes {
	*** DOUBLE;
	*** FLOAT;
	*** INTEGER;
	*** LONG;
	*** NULL;
	*** TOP;
	*** UNINITIALIZED_THIS;
}

-keep class com.google.inject.internal.asm.$Type {
	*** BOOLEAN_TYPE;
	*** BYTE_TYPE;
	*** CHAR_TYPE;
	*** DOUBLE_TYPE;
	*** FLOAT_TYPE;
	*** INT_TYPE;
	*** LONG_TYPE;
	*** SHORT_TYPE;
	*** VOID_TYPE;
	*** a;
	*** b;
	*** c;
	*** d;
	com.google.inject.internal.asm.$Type(int,char[],int,int);
	*** a(char[],int);
	*** a(java.lang.StringBuffer);
	*** a(java.lang.StringBuffer,java.lang.Class);
	*** equals(java.lang.Object);
	*** getArgumentTypes(java.lang.String);
	*** getClassName();
	*** getDescriptor();
	*** getDescriptor(java.lang.Class);
	*** getDimensions();
	*** getElementType();
	*** getInternalName();
	*** getMethodDescriptor(com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Type[]);
	*** getMethodDescriptor(java.lang.reflect.Method);
	*** getObjectType(java.lang.String);
	*** getOpcode(int);
	*** getReturnType(java.lang.String);
	*** getSize();
	*** getSort();
	*** getType(java.lang.Class);
	*** getType(java.lang.String);
	*** hashCode();
}

-keep class com.google.inject.internal.cglib.core.$AbstractClassGenerator {
	*** CURRENT;
	*** NAME_KEY;
	*** attemptLoad;
	*** classLoader;
	*** className;
	*** key;
	*** namePrefix;
	*** namingPolicy;
	*** source;
	*** strategy;
	*** useCache;
	com.google.inject.internal.cglib.core.$AbstractClassGenerator(com.google.inject.internal.cglib.core.$AbstractClassGenerator$Source);
	*** create(java.lang.Object);
	*** firstInstance(java.lang.Class);
	*** getClassLoader();
	*** getClassName();
	*** getClassName(java.lang.ClassLoader);
	*** getClassNameCache(java.lang.ClassLoader);
	*** getDefaultClassLoader();
	*** setClassLoader(java.lang.ClassLoader);
	*** setNamePrefix(java.lang.String);
	*** setNamingPolicy(com.google.inject.internal.cglib.core.$NamingPolicy);
}

-keep class com.google.inject.internal.cglib.core.$AbstractClassGenerator$1 {
	*** this$0;
	*** val$nameCache;
}

-keep class com.google.inject.internal.cglib.core.$AbstractClassGenerator$Source {
	*** cache;
	*** name;
}

-keep class com.google.inject.internal.cglib.core.$Block {
	*** e;
	*** end;
	*** start;
	*** end();
	*** getCodeEmitter();
	*** getEnd();
	*** getStart();
}

-keep class com.google.inject.internal.cglib.core.$ClassEmitter {
	*** classInfo;
	*** fieldInfo;
	*** hookCounter;
	*** rawStaticInit;
	*** staticHook;
	*** staticHookSig;
	*** staticInit;
	com.google.inject.internal.cglib.core.$ClassEmitter(com.google.inject.internal.asm.$ClassVisitor);
	*** begin_class(int,int,java.lang.String,com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Type[],java.lang.String);
	*** begin_method(int,com.google.inject.internal.cglib.core.$Signature,com.google.inject.internal.asm.$Type[]);
	*** begin_static();
	*** declare_field(int,java.lang.String,com.google.inject.internal.asm.$Type,java.lang.Object);
	*** end_class();
	*** getAccess();
	*** getClassInfo();
	*** getClassType();
	*** getFieldInfo(java.lang.String);
	*** getNextHook();
	*** getStaticHook();
	*** getSuperType();
	*** init();
	*** isFieldDeclared(java.lang.String);
	*** setTarget(com.google.inject.internal.asm.$ClassVisitor);
}

-keep class com.google.inject.internal.cglib.core.$ClassEmitter$1 {
	*** this$0;
	*** val$access;
	*** val$classType;
	*** val$interfaces;
	*** val$superType;
}

-keep class com.google.inject.internal.cglib.core.$ClassEmitter$3 {
	*** this$0;
}

-keep class com.google.inject.internal.cglib.core.$ClassEmitter$FieldInfo {
	*** access;
	*** name;
	*** type;
	*** value;
	*** equals(java.lang.Object);
}

-keep class com.google.inject.internal.cglib.core.$ClassGenerator {
	*** generateClass(com.google.inject.internal.asm.$ClassVisitor);
}

-keep class com.google.inject.internal.cglib.core.$ClassInfo {
	com.google.inject.internal.cglib.core.$ClassInfo();
	*** getModifiers();
	*** getSuperType();
	*** getType();
}

-keep class com.google.inject.internal.cglib.core.$ClassNameReader {
	*** EARLY_EXIT;
	*** access$100();
	*** getClassInfo(com.google.inject.internal.asm.$ClassReader);
	*** getClassName(com.google.inject.internal.asm.$ClassReader);
}

-keep class com.google.inject.internal.cglib.core.$ClassNameReader$1 {
	*** val$array;
}

-keep class com.google.inject.internal.cglib.core.$ClassNameReader$EarlyExitException {
	com.google.inject.internal.cglib.core.$ClassNameReader$EarlyExitException();
}

-keep class com.google.inject.internal.cglib.core.$CodeEmitter {
	*** BOOLEAN_VALUE;
	*** CHAR_VALUE;
	*** CSTRUCT_NULL;
	*** CSTRUCT_STRING;
	*** DOUBLE_VALUE;
	*** FLOAT_VALUE;
	*** INT_VALUE;
	*** LONG_VALUE;
	*** ce;
	*** state;
	com.google.inject.internal.cglib.core.$CodeEmitter(com.google.inject.internal.cglib.core.$ClassEmitter,com.google.inject.internal.asm.$MethodVisitor,int,com.google.inject.internal.cglib.core.$Signature,com.google.inject.internal.asm.$Type[]);
	*** aaload();
	*** aaload(int);
	*** aastore();
	*** aconst_null();
	*** array_load(com.google.inject.internal.asm.$Type);
	*** arraylength();
	*** athrow();
	*** begin_block();
	*** box(com.google.inject.internal.asm.$Type);
	*** cast_numeric(com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Type);
	*** catch_exception(com.google.inject.internal.cglib.core.$Block,com.google.inject.internal.asm.$Type);
	*** checkcast(com.google.inject.internal.asm.$Type);
	*** checkcast_this();
	*** dup();
	*** dup2();
	*** dup2_x1();
	*** dup2_x2();
	*** dup_x1();
	*** dup_x2();
	*** emit_field(int,com.google.inject.internal.asm.$Type,java.lang.String,com.google.inject.internal.asm.$Type);
	*** emit_invoke(int,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$Signature);
	*** emit_type(int,com.google.inject.internal.asm.$Type);
	*** end_method();
	*** getClassEmitter();
	*** getfield(java.lang.String);
	*** getstatic(com.google.inject.internal.asm.$Type,java.lang.String,com.google.inject.internal.asm.$Type);
	*** goTo(com.google.inject.internal.asm.$Label);
	*** if_cmp(com.google.inject.internal.asm.$Type,int,com.google.inject.internal.asm.$Label);
	*** if_icmp(int,com.google.inject.internal.asm.$Label);
	*** if_jump(int,com.google.inject.internal.asm.$Label);
	*** ifnonnull(com.google.inject.internal.asm.$Label);
	*** ifnull(com.google.inject.internal.asm.$Label);
	*** iinc(com.google.inject.internal.cglib.core.$Local,int);
	*** instance_of(com.google.inject.internal.asm.$Type);
	*** instance_of_this();
	*** invoke(com.google.inject.internal.cglib.core.$MethodInfo,com.google.inject.internal.asm.$Type);
	*** invoke_constructor(com.google.inject.internal.asm.$Type);
	*** invoke_constructor(com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$Signature);
	*** invoke_constructor_this();
	*** invoke_constructor_this(com.google.inject.internal.cglib.core.$Signature);
	*** invoke_interface(com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$Signature);
	*** invoke_static(com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$Signature);
	*** invoke_static_this(com.google.inject.internal.cglib.core.$Signature);
	*** invoke_virtual(com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$Signature);
	*** isSorted(int[]);
	*** isStaticHook();
	*** load_arg(int);
	*** load_args();
	*** load_args(int,int);
	*** load_local(com.google.inject.internal.asm.$Type,int);
	*** load_local(com.google.inject.internal.cglib.core.$Local);
	*** load_this();
	*** make_label();
	*** make_local();
	*** make_local(com.google.inject.internal.asm.$Type);
	*** mark();
	*** mark(com.google.inject.internal.asm.$Label);
	*** math(int,com.google.inject.internal.asm.$Type);
	*** new_instance(com.google.inject.internal.asm.$Type);
	*** new_instance_this();
	*** newarray();
	*** newarray(com.google.inject.internal.asm.$Type);
	*** pop();
	*** pop2();
	*** process_switch(int[],com.google.inject.internal.cglib.core.$ProcessSwitchCallback);
	*** process_switch(int[],com.google.inject.internal.cglib.core.$ProcessSwitchCallback,boolean);
	*** push(double);
	*** push(float);
	*** push(int);
	*** push(java.lang.String);
	*** push(long);
	*** putfield(java.lang.String);
	*** putstatic(com.google.inject.internal.asm.$Type,java.lang.String,com.google.inject.internal.asm.$Type);
	*** return_value();
	*** skipArgs(int);
	*** store_local(com.google.inject.internal.asm.$Type,int);
	*** store_local(com.google.inject.internal.cglib.core.$Local);
	*** super_invoke(com.google.inject.internal.cglib.core.$Signature);
	*** super_invoke_constructor();
	*** super_invoke_constructor(com.google.inject.internal.cglib.core.$Signature);
	*** swap();
	*** swap(com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Type);
	*** throw_exception(com.google.inject.internal.asm.$Type,java.lang.String);
	*** unbox(com.google.inject.internal.asm.$Type);
	*** visitMaxs(int,int);
	*** zero_or_null(com.google.inject.internal.asm.$Type);
}

-keep class com.google.inject.internal.cglib.core.$CodeEmitter$State {
	*** access;
	*** argumentTypes;
	*** classInfo;
	*** exceptionTypes;
	*** localOffset;
	*** sig;
}

-keep class com.google.inject.internal.cglib.core.$CodeGenerationException {
	*** cause;
}

-keep class com.google.inject.internal.cglib.core.$CollectionUtils {
	*** bucket(java.util.Collection,com.google.inject.internal.cglib.core.$Transformer);
	*** filter(java.util.Collection,com.google.inject.internal.cglib.core.$Predicate);
	*** getIndexMap(java.util.List);
	*** reverse(java.util.Map,java.util.Map);
	*** transform(java.util.Collection,com.google.inject.internal.cglib.core.$Transformer);
}

-keep class com.google.inject.internal.cglib.core.$Constants {
	*** EMPTY_CLASS_ARRAY;
	*** SIG_STATIC;
	*** TYPES_EMPTY;
	*** TYPE_BIG_DECIMAL;
	*** TYPE_BIG_INTEGER;
	*** TYPE_BOOLEAN;
	*** TYPE_BYTE;
	*** TYPE_CHARACTER;
	*** TYPE_CLASS;
	*** TYPE_CLASS_ARRAY;
	*** TYPE_DOUBLE;
	*** TYPE_ERROR;
	*** TYPE_FLOAT;
	*** TYPE_INTEGER;
	*** TYPE_LONG;
	*** TYPE_NUMBER;
	*** TYPE_OBJECT;
	*** TYPE_OBJECT_ARRAY;
	*** TYPE_RUNTIME_EXCEPTION;
	*** TYPE_SHORT;
	*** TYPE_SIGNATURE;
	*** TYPE_STRING;
	*** TYPE_STRING_BUFFER;
	*** TYPE_THROWABLE;
}

-keep class com.google.inject.internal.cglib.core.$Customizer {
	*** customize(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type);
}

-keep class com.google.inject.internal.cglib.core.$DebuggingClassWriter {
	*** className;
	*** debugLocation;
	*** superName;
	*** traceEnabled;
	*** access$001(com.google.inject.internal.cglib.core.$DebuggingClassWriter);
	*** access$100();
	*** access$200(com.google.inject.internal.cglib.core.$DebuggingClassWriter);
	*** access$300();
}

-keep class com.google.inject.internal.cglib.core.$DebuggingClassWriter$1 {
	*** this$0;
}

-keep class com.google.inject.internal.cglib.core.$DefaultGeneratorStrategy {
	*** INSTANCE;
	*** getClassWriter();
	*** transform(byte[]);
	*** transform(com.google.inject.internal.cglib.core.$ClassGenerator);
}

-keep class com.google.inject.internal.cglib.core.$DefaultNamingPolicy {
	*** INSTANCE;
	com.google.inject.internal.cglib.core.$DefaultNamingPolicy();
	*** getClassName(java.lang.String,java.lang.String,java.lang.Object,com.google.inject.internal.cglib.core.$Predicate);
	*** getTag();
}

-keep class com.google.inject.internal.cglib.core.$DuplicatesPredicate {
	*** unique;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils {
	*** APPEND_BOOLEAN;
	*** APPEND_CHAR;
	*** APPEND_DOUBLE;
	*** APPEND_FLOAT;
	*** APPEND_INT;
	*** APPEND_LONG;
	*** APPEND_STRING;
	*** CSTRUCT_NULL;
	*** CSTRUCT_THROWABLE;
	*** DEFAULT_DELIMITERS;
	*** DOUBLE_TO_LONG_BITS;
	*** EQUALS;
	*** FLOAT_TO_INT_BITS;
	*** FOR_NAME;
	*** GET_DECLARED_METHOD;
	*** GET_NAME;
	*** HASH_CODE;
	*** LENGTH;
	*** SET_LENGTH;
	*** STRING_CHAR_AT;
	*** STRING_LENGTH;
	*** TO_STRING;
	*** class$java$lang$Class;
	*** class$org$objectweb$asm$Type;
	*** access$100();
	*** access$200(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Label,com.google.inject.internal.cglib.core.$Customizer,com.google.inject.internal.cglib.core.$ProcessArrayCallback);
	*** access$300(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters,com.google.inject.internal.cglib.core.$Customizer,com.google.inject.internal.cglib.core.$ProcessArrayCallback);
	*** access$500();
	*** access$800(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback,com.google.inject.internal.cglib.core.$EmitUtils$ParameterTyper,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label);
	*** access$900(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback,com.google.inject.internal.cglib.core.$EmitUtils$ParameterTyper,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label,java.util.BitSet);
	*** add_property(com.google.inject.internal.cglib.core.$ClassEmitter,java.lang.String,com.google.inject.internal.asm.$Type,java.lang.String);
	*** append_string(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters,com.google.inject.internal.cglib.core.$Customizer);
	*** append_string_helper(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters,com.google.inject.internal.cglib.core.$Customizer,com.google.inject.internal.cglib.core.$ProcessArrayCallback);
	*** begin_method(com.google.inject.internal.cglib.core.$ClassEmitter,com.google.inject.internal.cglib.core.$MethodInfo,int);
	*** class$(java.lang.String);
	*** constructor_switch(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback);
	*** factory_method(com.google.inject.internal.cglib.core.$ClassEmitter,com.google.inject.internal.cglib.core.$Signature);
	*** getSwitchKeys(java.util.Map);
	*** hash_array(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,int,com.google.inject.internal.cglib.core.$Customizer);
	*** hash_code(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,int,com.google.inject.internal.cglib.core.$Customizer);
	*** hash_long(com.google.inject.internal.cglib.core.$CodeEmitter);
	*** hash_object(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$Customizer);
	*** hash_primitive(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type);
	*** load_class(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type);
	*** load_class_helper(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type);
	*** member_helper_size(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback,com.google.inject.internal.cglib.core.$EmitUtils$ParameterTyper,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label);
	*** member_helper_type(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback,com.google.inject.internal.cglib.core.$EmitUtils$ParameterTyper,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label,java.util.BitSet);
	*** member_switch_helper(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback,boolean);
	*** method_switch(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback);
	*** not_equals(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Label,com.google.inject.internal.cglib.core.$Customizer);
	*** not_equals_helper(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.asm.$Label,com.google.inject.internal.cglib.core.$Customizer,com.google.inject.internal.cglib.core.$ProcessArrayCallback);
	*** null_constructor(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** nullcmp(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label);
	*** process_array(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$ProcessArrayCallback);
	*** process_arrays(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.asm.$Type,com.google.inject.internal.cglib.core.$ProcessArrayCallback);
	*** push_array(com.google.inject.internal.cglib.core.$CodeEmitter,java.lang.Object[]);
	*** push_object(com.google.inject.internal.cglib.core.$CodeEmitter,java.lang.Object);
	*** remapComponentType(java.lang.Class);
	*** shrinkStringBuffer(com.google.inject.internal.cglib.core.$CodeEmitter,int);
	*** stringSwitchHelper(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,com.google.inject.internal.cglib.core.$ObjectSwitchCallback,com.google.inject.internal.asm.$Label,com.google.inject.internal.asm.$Label,int);
	*** string_switch(com.google.inject.internal.cglib.core.$CodeEmitter,java.lang.String[],int,com.google.inject.internal.cglib.core.$ObjectSwitchCallback);
	*** string_switch_hash(com.google.inject.internal.cglib.core.$CodeEmitter,java.lang.String[],com.google.inject.internal.cglib.core.$ObjectSwitchCallback,boolean);
	*** string_switch_trie(com.google.inject.internal.cglib.core.$CodeEmitter,java.lang.String[],com.google.inject.internal.cglib.core.$ObjectSwitchCallback);
	*** wrap_throwable(com.google.inject.internal.cglib.core.$Block,com.google.inject.internal.asm.$Type);
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$10 {
	*** val$cache;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$12 {
	*** val$buckets;
	*** val$cached;
	*** val$callback;
	*** val$def;
	*** val$e;
	*** val$end;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$13 {
	*** val$typer;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$14 {
	*** val$buckets;
	*** val$callback;
	*** val$def;
	*** val$e;
	*** val$end;
	*** val$typer;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$15 {
	*** val$j;
	*** val$typer;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$16 {
	*** val$callback;
	*** val$checked;
	*** val$def;
	*** val$e;
	*** val$end;
	*** val$fbuckets;
	*** val$typer;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$6 {
	*** val$buckets;
	*** val$callback;
	*** val$def;
	*** val$e;
	*** val$end;
	*** val$skipEquals;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$7 {
	*** val$customizer;
	*** val$e;
	*** val$multiplier;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$8 {
	*** val$customizer;
	*** val$e;
	*** val$notEquals;
	*** processElement(com.google.inject.internal.asm.$Type);
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$9 {
	*** val$customizer;
	*** val$d;
	*** val$e;
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters {
	*** after;
	*** before;
	*** inside;
	*** access$400(com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters);
	*** access$600(com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters);
	*** access$700(com.google.inject.internal.cglib.core.$EmitUtils$ArrayDelimiters);
}

-keep class com.google.inject.internal.cglib.core.$EmitUtils$ParameterTyper {
	*** getParameterTypes(com.google.inject.internal.cglib.core.$MethodInfo);
}

-keep class com.google.inject.internal.cglib.core.$GeneratorStrategy {
	*** generate(com.google.inject.internal.cglib.core.$ClassGenerator);
}

-keep class com.google.inject.internal.cglib.core.$KeyFactory {
	*** APPEND_STRING;
	*** CLASS_BY_NAME;
	*** EQUALS;
	*** GET_CLASS;
	*** GET_NAME;
	*** HASH_CODE;
	*** KEY_FACTORY;
	*** OBJECT_BY_CLASS;
	*** PRIMES;
	*** TO_STRING;
	*** class$java$lang$Object;
	*** class$net$sf$cglib$core$KeyFactory;
	com.google.inject.internal.cglib.core.$KeyFactory();
	*** access$000();
	*** access$100();
	*** access$200();
	*** access$300();
	*** access$400();
	*** access$500();
	*** access$600();
	*** access$700();
	*** class$(java.lang.String);
	*** create(java.lang.Class);
	*** create(java.lang.Class,com.google.inject.internal.cglib.core.$Customizer);
	*** create(java.lang.ClassLoader,java.lang.Class,com.google.inject.internal.cglib.core.$Customizer);
}

-keep class com.google.inject.internal.cglib.core.$KeyFactory$Generator {
	*** SOURCE;
	*** constant;
	*** customizer;
	*** keyInterface;
	*** multiplier;
	*** create();
	*** getFieldName(int);
	*** setCustomizer(com.google.inject.internal.cglib.core.$Customizer);
	*** setInterface(java.lang.Class);
}

-keep class com.google.inject.internal.cglib.core.$Local {
	*** index;
	*** type;
	*** getIndex();
	*** getType();
}

-keep class com.google.inject.internal.cglib.core.$LocalVariablesSorter {
	*** firstLocal;
	*** state;
	com.google.inject.internal.cglib.core.$LocalVariablesSorter(com.google.inject.internal.cglib.core.$LocalVariablesSorter);
	com.google.inject.internal.cglib.core.$LocalVariablesSorter(int,java.lang.String,com.google.inject.internal.asm.$MethodVisitor);
	*** newLocal(int);
	*** remap(int);
	*** remap(int,int);
}

-keep class com.google.inject.internal.cglib.core.$LocalVariablesSorter$State {
	*** mapping;
	*** nextLocal;
	com.google.inject.internal.cglib.core.$LocalVariablesSorter$State();
}

-keep class com.google.inject.internal.cglib.core.$MethodInfo {
	com.google.inject.internal.cglib.core.$MethodInfo();
	*** getClassInfo();
	*** getExceptionTypes();
	*** getModifiers();
	*** getSignature();
}

-keep class com.google.inject.internal.cglib.core.$MethodInfoTransformer {
	*** INSTANCE;
	*** getInstance();
}

-keep class com.google.inject.internal.cglib.core.$MethodWrapper {
	*** KEY_FACTORY;
	*** class$net$sf$cglib$core$MethodWrapper$MethodWrapperKey;
	*** class$(java.lang.String);
	*** create(java.lang.reflect.Method);
	*** createSet(java.util.Collection);
}

-keep class com.google.inject.internal.cglib.core.$MethodWrapper$MethodWrapperKey {
	*** newInstance(java.lang.String,java.lang.String[],java.lang.String);
}

-keep class com.google.inject.internal.cglib.core.$MethodWrapper$MethodWrapperKey$$$KeyFactoryByCGLIB$$e23ecb5d {
	*** FIELD_0;
	*** FIELD_1;
	*** FIELD_2;
}

-keep class com.google.inject.internal.cglib.core.$NamingPolicy {
	*** getClassName(java.lang.String,java.lang.String,java.lang.Object,com.google.inject.internal.cglib.core.$Predicate);
}

-keep class com.google.inject.internal.cglib.core.$ObjectSwitchCallback {
	*** processCase(java.lang.Object,com.google.inject.internal.asm.$Label);
	*** processDefault();
}

-keep class com.google.inject.internal.cglib.core.$Predicate {
	*** evaluate(java.lang.Object);
}

-keep class com.google.inject.internal.cglib.core.$ProcessArrayCallback {
	*** processElement(com.google.inject.internal.asm.$Type);
}

-keep class com.google.inject.internal.cglib.core.$ProcessSwitchCallback {
	*** processCase(int,com.google.inject.internal.asm.$Label);
	*** processDefault();
}

-keep class com.google.inject.internal.cglib.core.$ReflectUtils {
	*** CGLIB_PACKAGES;
	*** DEFINE_CLASS;
	*** PROTECTION_DOMAIN;
	*** array$B;
	*** class$java$lang$Object;
	*** class$java$lang$String;
	*** class$java$security$ProtectionDomain;
	*** class$net$sf$cglib$core$ReflectUtils;
	*** defaultLoader;
	*** primitives;
	*** transforms;
	*** access$000();
	*** access$002(java.lang.reflect.Method);
	*** addAllInterfaces(java.lang.Class,java.util.List);
	*** addAllMethods(java.lang.Class,java.util.List);
	*** class$(java.lang.String);
	*** defineClass(java.lang.String,byte[],java.lang.ClassLoader);
	*** findConstructor(java.lang.String,java.lang.ClassLoader);
	*** findInterfaceMethod(java.lang.Class);
	*** findMethod(java.lang.String,java.lang.ClassLoader);
	*** findNewInstance(java.lang.Class);
	*** findPackageProtected(java.lang.Class[]);
	*** getClass(java.lang.String,java.lang.ClassLoader);
	*** getClass(java.lang.String,java.lang.ClassLoader,java.lang.String[]);
	*** getClassInfo(java.lang.Class);
	*** getConstructor(java.lang.Class,java.lang.Class[]);
	*** getExceptionTypes(java.lang.reflect.Member);
	*** getMethodInfo(java.lang.reflect.Member);
	*** getMethodInfo(java.lang.reflect.Member,int);
	*** getNames(java.lang.Class[]);
	*** getPropertiesHelper(java.lang.Class,boolean,boolean);
	*** getSignature(java.lang.reflect.Member);
	*** newInstance(java.lang.Class);
	*** newInstance(java.lang.Class,java.lang.Class[],java.lang.Object[]);
	*** newInstance(java.lang.reflect.Constructor,java.lang.Object[]);
	*** parseTypes(java.lang.String,java.lang.ClassLoader);
}

-keep class com.google.inject.internal.cglib.core.$ReflectUtils$3 {
	*** ci;
	*** val$member;
	*** val$modifiers;
	*** val$sig;
}

-keep class com.google.inject.internal.cglib.core.$ReflectUtils$4 {
	*** val$clazz;
	*** val$sc;
	*** val$type;
}

-keep class com.google.inject.internal.cglib.core.$Signature {
	*** desc;
	*** name;
	com.google.inject.internal.cglib.core.$Signature(java.lang.String,java.lang.String);
	*** equals(java.lang.Object);
	*** getArgumentTypes();
	*** getDescriptor();
	*** getName();
	*** getReturnType();
	*** hashCode();
	*** toString();
}

-keep class com.google.inject.internal.cglib.core.$Transformer {
	*** transform(java.lang.Object);
}

-keep class com.google.inject.internal.cglib.core.$TypeUtils {
	*** rtransforms;
	*** transforms;
	*** DCONST(double);
	*** FCONST(float);
	*** ICONST(int);
	*** LCONST(long);
	*** NEWARRAY(com.google.inject.internal.asm.$Type);
	*** add(com.google.inject.internal.asm.$Type[],com.google.inject.internal.asm.$Type);
	*** emulateClassGetName(com.google.inject.internal.asm.$Type);
	*** escapeType(java.lang.String);
	*** fromInternalName(java.lang.String);
	*** fromInternalNames(java.lang.String[]);
	*** getBoxedType(com.google.inject.internal.asm.$Type);
	*** getClassName(com.google.inject.internal.asm.$Type);
	*** getComponentType(com.google.inject.internal.asm.$Type);
	*** getPackageName(com.google.inject.internal.asm.$Type);
	*** getPackageName(java.lang.String);
	*** getTypes(java.lang.Class[]);
	*** isAbstract(int);
	*** isArray(com.google.inject.internal.asm.$Type);
	*** isConstructor(com.google.inject.internal.cglib.core.$MethodInfo);
	*** isFinal(int);
	*** isInterface(int);
	*** isPrimitive(com.google.inject.internal.asm.$Type);
	*** isStatic(int);
	*** map(java.lang.String);
	*** parseConstructor(com.google.inject.internal.asm.$Type[]);
	*** parseConstructor(java.lang.String);
	*** parseSignature(java.lang.String);
	*** parseType(java.lang.String);
	*** parseTypes(java.lang.String,int,int);
	*** toInternalNames(com.google.inject.internal.asm.$Type[]);
	*** upperFirst(java.lang.String);
}

-keep class com.google.inject.internal.cglib.core.$VisibilityPredicate {
	*** pkg;
	*** protectedOk;
}

-keep class com.google.inject.internal.cglib.proxy.$CallbackFilter {
	*** accept(java.lang.reflect.Method);
}

-keep class com.google.inject.internal.cglib.proxy.$CallbackGenerator {
	*** generate(com.google.inject.internal.cglib.core.$ClassEmitter,com.google.inject.internal.cglib.proxy.$CallbackGenerator$Context,java.util.List);
	*** generateStatic(com.google.inject.internal.cglib.core.$CodeEmitter,com.google.inject.internal.cglib.proxy.$CallbackGenerator$Context,java.util.List);
}

-keep class com.google.inject.internal.cglib.proxy.$CallbackInfo {
	*** determineTypes(com.google.inject.internal.cglib.proxy.$Callback[]);
	*** determineTypes(java.lang.Class[]);
	*** getGenerators(com.google.inject.internal.asm.$Type[]);
}

-keep class com.google.inject.internal.cglib.proxy.$Enhancer {
	*** ALL_ZERO;
	*** BIND_CALLBACKS;
	*** CALLBACK;
	*** CALLBACK_ARRAY;
	*** CSTRUCT_NULL;
	*** FACTORY;
	*** GET_CALLBACK;
	*** GET_CALLBACKS;
	*** ILLEGAL_ARGUMENT_EXCEPTION;
	*** ILLEGAL_STATE_EXCEPTION;
	*** KEY_FACTORY;
	*** MULTIARG_NEW_INSTANCE;
	*** NEW_INSTANCE;
	*** SET_CALLBACK;
	*** SET_CALLBACKS;
	*** SET_STATIC_CALLBACKS;
	*** SET_THREAD_CALLBACKS;
	*** SINGLE_NEW_INSTANCE;
	*** SOURCE;
	*** THREAD_LOCAL;
	*** THREAD_LOCAL_GET;
	*** THREAD_LOCAL_SET;
	*** argumentTypes;
	*** arguments;
	*** array$Lnet$sf$cglib$proxy$Callback;
	*** callbackTypes;
	*** callbacks;
	*** class$java$lang$Object;
	*** class$net$sf$cglib$proxy$Enhancer;
	*** class$net$sf$cglib$proxy$Enhancer$EnhancerKey;
	*** class$net$sf$cglib$proxy$Factory;
	*** classOnly;
	*** filter;
	*** interceptDuringConstruction;
	*** interfaces;
	*** serialVersionUID;
	*** superclass;
	*** useFactory;
	*** class$(java.lang.String);
	*** create();
	*** createHelper();
	*** createUsingReflection(java.lang.Class);
	*** emitBindCallbacks(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** emitCommonNewInstance(com.google.inject.internal.cglib.core.$CodeEmitter);
	*** emitConstructors(com.google.inject.internal.cglib.core.$ClassEmitter,java.util.List);
	*** emitCurrentCallback(com.google.inject.internal.cglib.core.$CodeEmitter,int);
	*** emitGetCallback(com.google.inject.internal.cglib.core.$ClassEmitter,int[]);
	*** emitGetCallbacks(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** emitMethods(com.google.inject.internal.cglib.core.$ClassEmitter,java.util.List,java.util.List);
	*** emitNewInstanceCallback(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** emitNewInstanceCallbacks(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** emitNewInstanceMultiarg(com.google.inject.internal.cglib.core.$ClassEmitter,java.util.List);
	*** emitSetCallback(com.google.inject.internal.cglib.core.$ClassEmitter,int[]);
	*** emitSetCallbacks(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** emitSetStaticCallbacks(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** emitSetThreadCallbacks(com.google.inject.internal.cglib.core.$ClassEmitter);
	*** filterConstructors(java.lang.Class,java.util.List);
	*** getCallbackField(int);
	*** getCallbackKeys();
	*** getCallbacksSetter(java.lang.Class,java.lang.String);
	*** getMethods(java.lang.Class,java.lang.Class[],java.util.List);
	*** getMethods(java.lang.Class,java.lang.Class[],java.util.List,java.util.List,java.util.Set);
	*** rename(com.google.inject.internal.cglib.core.$Signature,int);
	*** setCallback(com.google.inject.internal.cglib.proxy.$Callback);
	*** setCallbackFilter(com.google.inject.internal.cglib.proxy.$CallbackFilter);
	*** setCallbackTypes(java.lang.Class[]);
	*** setCallbacks(com.google.inject.internal.cglib.proxy.$Callback[]);
	*** setCallbacksHelper(java.lang.Class,com.google.inject.internal.cglib.proxy.$Callback[],java.lang.String);
	*** setInterfaces(java.lang.Class[]);
	*** setSuperclass(java.lang.Class);
	*** setThreadCallbacks(java.lang.Class,com.google.inject.internal.cglib.proxy.$Callback[]);
	*** setUseFactory(boolean);
	*** validate();
}

-keep class com.google.inject.internal.cglib.proxy.$Enhancer$EnhancerKey {
	*** newInstance(java.lang.String,java.lang.String[],com.google.inject.internal.cglib.proxy.$CallbackFilter,com.google.inject.internal.asm.$Type[],boolean,boolean,java.lang.Long);
}

-keep class com.google.inject.internal.cglib.proxy.$Factory {
	*** newInstance(com.google.inject.internal.cglib.proxy.$Callback[]);
	*** newInstance(java.lang.Class[],java.lang.Object[],com.google.inject.internal.cglib.proxy.$Callback[]);
}

-keep class com.google.inject.internal.cglib.proxy.$NoOp {
	*** INSTANCE;
}

-keep class com.google.inject.internal.cglib.reflect.$FastClass {
	*** class$java$lang$Class;
	*** class$net$sf$cglib$reflect$FastClass;
	*** type;
	com.google.inject.internal.cglib.reflect.$FastClass(java.lang.Class);
	*** class$(java.lang.String);
	*** create(java.lang.ClassLoader,java.lang.Class);
	*** getConstructor(java.lang.reflect.Constructor);
	*** getIndex(java.lang.Class[]);
	*** getIndex(java.lang.String,java.lang.Class[]);
	*** getJavaClass();
	*** getMethod(java.lang.reflect.Method);
	*** invoke(int,java.lang.Object,java.lang.Object[]);
	*** newInstance(int,java.lang.Object[]);
}

-keep class com.google.inject.internal.cglib.reflect.$FastClass$Generator {
	*** SOURCE;
	*** type;
	*** create();
	*** setType(java.lang.Class);
}

-keep class com.google.inject.internal.cglib.reflect.$FastClassEmitter {
	*** CONSTRUCTOR_GET_INDEX;
	*** CSTRUCT_CLASS;
	*** FAST_CLASS;
	*** GET_MAX_INDEX;
	*** GET_SIGNATURE_WITHOUT_RETURN_TYPE;
	*** ILLEGAL_ARGUMENT_EXCEPTION;
	*** INVOCATION_TARGET_EXCEPTION;
	*** INVOCATION_TARGET_EXCEPTION_ARRAY;
	*** INVOKE;
	*** METHOD_GET_INDEX;
	*** NEW_INSTANCE;
	*** SIGNATURE_GET_INDEX;
	*** TO_STRING;
	*** emitIndexByClassArray(java.util.List);
	*** emitIndexBySignature(java.util.List);
	*** getIntRange(int);
	*** invokeSwitchHelper(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List,int,com.google.inject.internal.asm.$Type);
	*** signatureSwitchHelper(com.google.inject.internal.cglib.core.$CodeEmitter,java.util.List);
}

-keep class com.google.inject.internal.cglib.reflect.$FastClassEmitter$1 {
	*** this$0;
}

-keep class com.google.inject.internal.cglib.reflect.$FastClassEmitter$3 {
	*** this$0;
	*** val$e;
	*** val$signatures;
}

-keep class com.google.inject.internal.cglib.reflect.$FastClassEmitter$4 {
	*** val$arg;
	*** val$base;
	*** val$e;
	*** val$illegalArg;
	*** val$info;
}

-keep class com.google.inject.internal.cglib.reflect.$FastClassEmitter$GetIndexCallback {
	*** e;
	*** indexes;
}

-keep class com.google.inject.internal.cglib.reflect.$FastConstructor {
	*** newInstance(java.lang.Object[]);
}

-keep class com.google.inject.internal.cglib.reflect.$FastMember {
	*** fc;
	*** index;
	*** member;
	com.google.inject.internal.cglib.reflect.$FastMember(com.google.inject.internal.cglib.reflect.$FastClass,java.lang.reflect.Member,int);
}

-keep class com.google.inject.internal.util.$AbstractMapEntry {
	com.google.inject.internal.util.$AbstractMapEntry();
	*** getKey();
	*** getValue();
}

-keep class com.google.inject.internal.util.$Classes {
	*** isConcrete(java.lang.Class);
	*** isInnerClass(java.lang.Class);
	*** memberType(java.lang.reflect.Member);
	*** toString(java.lang.reflect.Member);
}

-keep class com.google.inject.internal.util.$Collections2 {
	*** setEquals(java.util.Set,java.lang.Object);
	*** toCollection(java.lang.Iterable);
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap {
	*** access$000(int);
	*** rehash(int);
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Builder {
	*** concurrencyLevel;
	*** initialCapacity;
	*** loadFactor;
	*** buildComputingMap(com.google.inject.internal.util.$CustomConcurrentHashMap$ComputingStrategy,com.google.inject.internal.util.$Function);
	*** buildMap(com.google.inject.internal.util.$CustomConcurrentHashMap$Strategy);
	*** concurrencyLevel(int);
	*** initialCapacity(int);
	*** loadFactor(float);
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$ComputingImpl {
	*** computer;
	*** computingStrategy;
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$ComputingStrategy {
	*** compute(java.lang.Object,java.lang.Object,com.google.inject.internal.util.$Function);
	*** waitForValue(java.lang.Object);
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Impl {
	*** entrySet;
	*** keySet;
	*** loadFactor;
	*** segmentMask;
	*** segmentShift;
	*** segments;
	*** strategy;
	*** values;
	com.google.inject.internal.util.$CustomConcurrentHashMap$Impl(com.google.inject.internal.util.$CustomConcurrentHashMap$Strategy,com.google.inject.internal.util.$CustomConcurrentHashMap$Builder);
	*** entrySet();
	*** hash(java.lang.Object);
	*** newSegmentArray(int);
	*** put(java.lang.Object,java.lang.Object);
	*** segmentFor(int);
	*** size();
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Impl$Fields {
	*** loadFactor;
	*** segmentMask;
	*** segmentShift;
	*** segments;
	*** strategy;
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Impl$InternalsImpl {
	*** this$0;
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Impl$Segment {
	*** count;
	*** modCount;
	*** table;
	*** this$0;
	*** threshold;
	*** clear();
	*** containsKey(java.lang.Object,int);
	*** containsValue(java.lang.Object);
	*** expand();
	*** get(java.lang.Object,int);
	*** getEntry(java.lang.Object,int);
	*** getFirst(int);
	*** newEntryArray(int);
	*** put(java.lang.Object,int,java.lang.Object,boolean);
	*** remove(java.lang.Object,int);
	*** remove(java.lang.Object,int,java.lang.Object);
	*** removeEntry(java.lang.Object,int);
	*** removeEntry(java.lang.Object,int,java.lang.Object);
	*** replace(java.lang.Object,int,java.lang.Object);
	*** replace(java.lang.Object,int,java.lang.Object,java.lang.Object);
	*** setTable(java.util.concurrent.atomic.AtomicReferenceArray);
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Internals {
	*** removeEntry(java.lang.Object);
	*** removeEntry(java.lang.Object,java.lang.Object);
}

-keep class com.google.inject.internal.util.$CustomConcurrentHashMap$Strategy {
	*** copyEntry(java.lang.Object,java.lang.Object,java.lang.Object);
	*** equalKeys(java.lang.Object,java.lang.Object);
	*** equalValues(java.lang.Object,java.lang.Object);
	*** getHash(java.lang.Object);
	*** getKey(java.lang.Object);
	*** getNext(java.lang.Object);
	*** getValue(java.lang.Object);
	*** hashKey(java.lang.Object);
	*** newEntry(java.lang.Object,int,java.lang.Object);
	*** setInternals(com.google.inject.internal.util.$CustomConcurrentHashMap$Internals);
	*** setValue(java.lang.Object,java.lang.Object);
}

-keep class com.google.inject.internal.util.$ExpirationTimer {
	*** instance;
}

-keep class com.google.inject.internal.util.$FinalizableReference {
	*** finalizeReferent();
}

-keep class com.google.inject.internal.util.$FinalizableReferenceQueue {
	*** logger;
	*** queue;
	*** startFinalizer;
	*** threadStarted;
	*** access$000();
	*** cleanUp();
	*** getStartFinalizer(java.lang.Class);
	*** loadFinalizer(com.google.inject.internal.util.$FinalizableReferenceQueue$FinalizerLoader[]);
}

-keep class com.google.inject.internal.util.$FinalizableReferenceQueue$DecoupledLoader {
	*** getBaseUrl();
	*** newLoader(java.net.URL);
}

-keep class com.google.inject.internal.util.$FinalizableReferenceQueue$FinalizerLoader {
	*** loadFinalizer();
}

-keep class com.google.inject.internal.util.$FinalizableSoftReference {
	com.google.inject.internal.util.$FinalizableSoftReference(java.lang.Object,com.google.inject.internal.util.$FinalizableReferenceQueue);
}

-keep class com.google.inject.internal.util.$FinalizableWeakReference {
	com.google.inject.internal.util.$FinalizableWeakReference(java.lang.Object,com.google.inject.internal.util.$FinalizableReferenceQueue);
}

-keep class com.google.inject.internal.util.$Finalizer {
	*** finalizableReferenceClassReference;
	*** frqReference;
	*** logger;
	*** queue;
	*** cleanUp(java.lang.ref.Reference);
	*** getFinalizeReferentMethod();
}

-keep class com.google.inject.internal.util.$Finalizer$ShutDown {
	com.google.inject.internal.util.$Finalizer$ShutDown();
}

-keep class com.google.inject.internal.util.$Function {
	*** apply(java.lang.Object);
}

-keep class com.google.inject.internal.util.$Hashing {
	*** chooseTableSize(int);
	*** smear(int);
}

-keep class com.google.inject.internal.util.$ImmutableCollection {
	*** EMPTY_ARRAY;
	*** EMPTY_IMMUTABLE_COLLECTION;
	*** EMPTY_ITERATOR;
	com.google.inject.internal.util.$ImmutableCollection();
	*** access$100();
	*** access$200();
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** isEmpty();
	*** iterator();
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class com.google.inject.internal.util.$ImmutableCollection$EmptyImmutableCollection {
	com.google.inject.internal.util.$ImmutableCollection$EmptyImmutableCollection();
	*** iterator();
}

-keep class com.google.inject.internal.util.$ImmutableEntry {
	*** key;
	*** value;
}

-keep class com.google.inject.internal.util.$ImmutableList {
	*** EMPTY_IMMUTABLE_LIST;
	com.google.inject.internal.util.$ImmutableList();
	com.google.inject.internal.util.$ImmutableList(com.google.inject.internal.util.$ImmutableList$1);
	*** copyIntoArray(java.lang.Object[]);
	*** copyOf(java.lang.Iterable);
	*** copyOf(java.lang.Object[],int);
	*** copyOfInternal(java.util.ArrayList);
	*** copyOfInternal(java.util.Collection);
	*** createFromIterable(java.lang.Iterable,int);
	*** iterator();
	*** nullChecked(java.lang.Object[]);
	*** of();
	*** of(java.lang.Object);
	*** of(java.lang.Object,java.lang.Object,java.lang.Object);
	*** of(java.lang.Object[]);
	*** subList(int,int);
}

-keep class com.google.inject.internal.util.$ImmutableList$Builder {
	*** contents;
	*** addAll(java.lang.Iterable);
	*** build();
}

-keep class com.google.inject.internal.util.$ImmutableList$EmptyImmutableList {
	*** EMPTY_ARRAY;
	com.google.inject.internal.util.$ImmutableList$EmptyImmutableList();
	*** iterator();
	*** subList(int,int);
}

-keep class com.google.inject.internal.util.$ImmutableList$RegularImmutableList {
	*** array;
	*** offset;
	*** size;
	com.google.inject.internal.util.$ImmutableList$RegularImmutableList(java.lang.Object[]);
	com.google.inject.internal.util.$ImmutableList$RegularImmutableList(java.lang.Object[],int,int);
	*** indexOf(java.lang.Object);
	*** iterator();
	*** listIterator(int);
	*** size();
	*** subList(int,int);
}

-keep class com.google.inject.internal.util.$ImmutableMap {
	*** EMPTY_IMMUTABLE_MAP;
	com.google.inject.internal.util.$ImmutableMap();
	*** access$300(java.lang.Object,java.lang.Object);
	*** builder();
	*** copyOf(java.util.Map);
	*** entryOf(java.lang.Object,java.lang.Object);
	*** entrySet();
	*** keySet();
	*** of();
	*** of(java.lang.Object,java.lang.Object);
	*** values();
}

-keep class com.google.inject.internal.util.$ImmutableMap$Builder {
	*** entries;
	*** build();
	*** fromEntryList(java.util.List);
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
}

-keep class com.google.inject.internal.util.$ImmutableMap$EmptyImmutableMap {
	com.google.inject.internal.util.$ImmutableMap$EmptyImmutableMap();
	*** entrySet();
	*** keySet();
	*** values();
}

-keep class com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap {
	*** entries;
	*** entrySet;
	*** keySet;
	*** keySetHashCode;
	*** mask;
	*** table;
	*** values;
	com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap(java.util.Map$Entry[]);
	*** access$500(com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap);
	*** access$600(com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap);
	*** containsKey(java.lang.Object);
	*** containsValue(java.lang.Object);
	*** entrySet();
	*** get(java.lang.Object);
	*** keySet();
	*** size();
	*** values();
}

-keep class com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap$EntrySet {
	*** map;
}

-keep class com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap$KeySet {
	*** map;
	*** transform(java.util.Map$Entry);
}

-keep class com.google.inject.internal.util.$ImmutableMap$RegularImmutableMap$Values {
	*** map;
	*** iterator();
}

-keep class com.google.inject.internal.util.$ImmutableMap$SingletonImmutableMap {
	*** entry;
	*** entrySet;
	*** keySet;
	*** singleKey;
	*** singleValue;
	*** values;
	com.google.inject.internal.util.$ImmutableMap$SingletonImmutableMap(java.lang.Object,java.lang.Object);
	com.google.inject.internal.util.$ImmutableMap$SingletonImmutableMap(java.util.Map$Entry);
	*** entry();
	*** entrySet();
	*** keySet();
	*** values();
}

-keep class com.google.inject.internal.util.$ImmutableSet {
	*** EMPTY_IMMUTABLE_SET;
	com.google.inject.internal.util.$ImmutableSet();
	*** builder();
	*** copyOf(java.lang.Iterable);
	*** copyOfInternal(java.util.Collection);
	*** create(java.lang.Iterable,int);
	*** equals(java.lang.Object);
	*** hashCode();
	*** isHashCodeFast();
	*** iterator();
	*** of();
	*** of(java.lang.Object);
	*** of(java.lang.Object[]);
}

-keep class com.google.inject.internal.util.$ImmutableSet$ArrayImmutableSet {
	*** elements;
	com.google.inject.internal.util.$ImmutableSet$ArrayImmutableSet(java.lang.Object[]);
	*** iterator();
	*** size();
}

-keep class com.google.inject.internal.util.$ImmutableSet$Builder {
	*** contents;
	*** add(java.lang.Object);
	*** addAll(java.lang.Iterable);
	*** build();
}

-keep class com.google.inject.internal.util.$ImmutableSet$EmptyImmutableSet {
	*** EMPTY_ARRAY;
	com.google.inject.internal.util.$ImmutableSet$EmptyImmutableSet();
	*** iterator();
}

-keep class com.google.inject.internal.util.$ImmutableSet$RegularImmutableSet {
	*** hashCode;
	*** mask;
	*** table;
}

-keep class com.google.inject.internal.util.$ImmutableSet$SingletonImmutableSet {
	*** element;
	*** hashCode;
	*** iterator();
}

-keep class com.google.inject.internal.util.$ImmutableSet$TransformedImmutableSet {
	*** hashCode;
	*** source;
	com.google.inject.internal.util.$ImmutableSet$TransformedImmutableSet(java.lang.Object[],int);
	*** iterator();
	*** size();
	*** toArray(java.lang.Object[]);
	*** transform(java.lang.Object);
}

-keep class com.google.inject.internal.util.$Iterables {
	*** concat(java.lang.Iterable);
	*** concat(java.lang.Iterable,java.lang.Iterable);
	*** getOnlyElement(java.lang.Iterable);
	*** toString(java.lang.Iterable);
	*** transform(java.lang.Iterable,com.google.inject.internal.util.$Function);
}

-keep class com.google.inject.internal.util.$Iterables$1 {
	*** apply(java.lang.Iterable);
}

-keep class com.google.inject.internal.util.$Iterables$2 {
	*** val$iterators;
}

-keep class com.google.inject.internal.util.$Iterables$3 {
	*** val$fromIterable;
	*** val$function;
}

-keep class com.google.inject.internal.util.$Iterables$IterableWithToString {
	com.google.inject.internal.util.$Iterables$IterableWithToString();
}

-keep class com.google.inject.internal.util.$Iterators {
	*** EMPTY_ITERATOR;
	*** EMPTY_LIST_ITERATOR;
	*** concat(java.util.Iterator);
	*** emptyIterator();
	*** emptyListIterator();
	*** forArray(java.lang.Object[]);
	*** forArray(java.lang.Object[],int,int);
	*** getOnlyElement(java.util.Iterator);
	*** singletonIterator(java.lang.Object);
	*** toString(java.util.Iterator);
	*** transform(java.util.Iterator,com.google.inject.internal.util.$Function);
	*** unmodifiableIterator(java.util.Iterator);
}

-keep class com.google.inject.internal.util.$Iterators$3 {
	*** val$iterator;
}

-keep class com.google.inject.internal.util.$Iterators$4 {
	*** current;
	*** removeFrom;
	*** val$inputs;
	*** hasNext();
}

-keep class com.google.inject.internal.util.$Iterators$5 {
	*** val$fromIterator;
	*** val$function;
}

-keep class com.google.inject.internal.util.$Iterators$6 {
	*** i;
	*** length;
	*** val$array;
}

-keep class com.google.inject.internal.util.$Iterators$7 {
	*** i;
	*** val$array;
	*** val$end;
	*** val$offset;
	*** hasNext();
}

-keep class com.google.inject.internal.util.$Iterators$8 {
	*** done;
	*** val$value;
}

-keep class com.google.inject.internal.util.$Lists {
	*** computeArrayListCapacity(int);
	*** newArrayList();
	*** newArrayList(java.lang.Iterable);
	*** newArrayList(java.util.Iterator);
}

-keep class com.google.inject.internal.util.$MapMaker {
	*** COMPUTING;
	*** builder;
	*** expirationNanos;
	*** keyStrength;
	*** useCustomMap;
	*** valueStrength;
	*** access$100(com.google.inject.internal.util.$MapMaker);
	*** access$200(com.google.inject.internal.util.$MapMaker);
	*** access$300(com.google.inject.internal.util.$MapMaker);
	*** access$400(com.google.inject.internal.util.$MapMaker);
	*** access$500();
	*** access$600();
	*** computing();
	*** makeComputingMap(com.google.inject.internal.util.$Function);
	*** setKeyStrength(com.google.inject.internal.util.$MapMaker$Strength);
	*** setValueStrength(com.google.inject.internal.util.$MapMaker$Strength);
	*** weakKeys();
	*** weakValues();
}

-keep class com.google.inject.internal.util.$MapMaker$LinkedSoftEntry {
	*** next;
}

-keep class com.google.inject.internal.util.$MapMaker$LinkedStrongEntry {
	*** next;
}

-keep class com.google.inject.internal.util.$MapMaker$LinkedWeakEntry {
	*** next;
}

-keep class com.google.inject.internal.util.$MapMaker$QueueHolder {
	*** queue;
}

-keep class com.google.inject.internal.util.$MapMaker$ReferenceEntry {
	*** getHash();
	*** getKey();
	*** getNext();
	*** getValueReference();
	*** setValueReference(com.google.inject.internal.util.$MapMaker$ValueReference);
}

-keep class com.google.inject.internal.util.$MapMaker$SoftEntry {
	*** hash;
	*** internals;
	*** valueReference;
	com.google.inject.internal.util.$MapMaker$SoftEntry(com.google.inject.internal.util.$CustomConcurrentHashMap$Internals,java.lang.Object,int);
}

-keep class com.google.inject.internal.util.$MapMaker$StrategyImpl {
	*** expirationNanos;
	*** internals;
	*** keyStrength;
	*** map;
	*** valueStrength;
	*** compute(java.lang.Object,com.google.inject.internal.util.$MapMaker$ReferenceEntry,com.google.inject.internal.util.$Function);
	*** copyEntry(java.lang.Object,com.google.inject.internal.util.$MapMaker$ReferenceEntry,com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** getHash(com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** getKey(com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** getNext(com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** getValue(com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** newEntry(java.lang.Object,int,com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** scheduleRemoval(java.lang.Object,java.lang.Object);
	*** setValue(com.google.inject.internal.util.$MapMaker$ReferenceEntry,java.lang.Object);
	*** setValueReference(com.google.inject.internal.util.$MapMaker$ReferenceEntry,com.google.inject.internal.util.$MapMaker$ValueReference);
	*** waitForValue(com.google.inject.internal.util.$MapMaker$ReferenceEntry);
}

-keep class com.google.inject.internal.util.$MapMaker$StrategyImpl$1 {
	*** this$0;
	*** val$keyReference;
	*** val$valueReference;
}

-keep class com.google.inject.internal.util.$MapMaker$StrategyImpl$Fields {
	*** expirationNanos;
	*** internals;
	*** keyStrength;
	*** map;
	*** valueStrength;
}

-keep class com.google.inject.internal.util.$MapMaker$Strength {
	*** $VALUES;
	*** SOFT;
	*** STRONG;
	*** WEAK;
	com.google.inject.internal.util.$MapMaker$Strength(java.lang.String,int);
	com.google.inject.internal.util.$MapMaker$Strength(java.lang.String,int,com.google.inject.internal.util.$MapMaker$1);
	*** equal(java.lang.Object,java.lang.Object);
	*** hash(java.lang.Object);
	*** newEntry(com.google.inject.internal.util.$CustomConcurrentHashMap$Internals,java.lang.Object,int,com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** referenceValue(com.google.inject.internal.util.$MapMaker$ReferenceEntry,java.lang.Object);
}

-keep class com.google.inject.internal.util.$MapMaker$StrongEntry {
	*** hash;
	*** internals;
	*** key;
	*** valueReference;
	com.google.inject.internal.util.$MapMaker$StrongEntry(com.google.inject.internal.util.$CustomConcurrentHashMap$Internals,java.lang.Object,int);
}

-keep class com.google.inject.internal.util.$MapMaker$StrongValueReference {
	*** referent;
	*** get();
}

-keep class com.google.inject.internal.util.$MapMaker$ValueReference {
	*** copyFor(com.google.inject.internal.util.$MapMaker$ReferenceEntry);
	*** get();
	*** waitForValue();
}

-keep class com.google.inject.internal.util.$MapMaker$WeakEntry {
	*** hash;
	*** internals;
	*** valueReference;
	com.google.inject.internal.util.$MapMaker$WeakEntry(com.google.inject.internal.util.$CustomConcurrentHashMap$Internals,java.lang.Object,int);
}

-keep class com.google.inject.internal.util.$Maps {
	*** immutableEntry(java.lang.Object,java.lang.Object);
	*** newHashMap();
	*** newIdentityHashMap();
	*** newLinkedHashMap();
}

-keep class com.google.inject.internal.util.$ObjectArrays {
	*** newArray(java.lang.Object[],int);
}

-keep class com.google.inject.internal.util.$Objects {
	*** equal(java.lang.Object,java.lang.Object);
	*** hashCode(java.lang.Object[]);
}

-keep class com.google.inject.internal.util.$Preconditions {
	*** checkArgument(boolean);
	*** checkArgument(boolean,java.lang.Object);
	*** checkArgument(boolean,java.lang.String,java.lang.Object[]);
	*** checkContentsNotNull(java.lang.Iterable,java.lang.Object);
	*** checkElementIndex(int,int);
	*** checkElementIndex(int,int,java.lang.String);
	*** checkNotNull(java.lang.Object);
	*** checkNotNull(java.lang.Object,java.lang.Object);
	*** checkPositionIndex(int,int);
	*** checkPositionIndex(int,int,java.lang.String);
	*** checkPositionIndexes(int,int,int);
	*** checkState(boolean,java.lang.Object);
	*** checkState(boolean,java.lang.String,java.lang.Object[]);
	*** containsOrIsNull(java.lang.Iterable);
	*** format(java.lang.String,java.lang.Object[]);
}

-keep class com.google.inject.internal.util.$Sets {
	*** newHashSet();
	*** newLinkedHashSet();
}

-keep class com.google.inject.internal.util.$SourceProvider {
	*** DEFAULT_INSTANCE;
	*** UNKNOWN_SOURCE;
	*** classNamesToSkip;
	*** asStrings(java.lang.Class[]);
	*** get();
	*** plusSkippedClasses(java.lang.Class[]);
}

-keep class com.google.inject.internal.util.$StackTraceElements {
	*** forMember(java.lang.reflect.Member);
	*** forType(java.lang.Class);
}

-keep class com.google.inject.internal.util.$Stopwatch {
	*** logger;
	*** start;
	*** reset();
	*** resetAndLog(java.lang.String);
}

-keep class com.google.inject.internal.util.$Strings {
	*** capitalize(java.lang.String);
}

-keep class com.google.inject.internal.util.$ToStringBuilder {
	*** add(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class com.google.inject.internal.util.$UnmodifiableIterator {
	com.google.inject.internal.util.$UnmodifiableIterator();
}

-keep class com.google.inject.matcher.AbstractMatcher {
	com.google.inject.matcher.AbstractMatcher();
}

-keep class com.google.inject.matcher.Matcher {
	*** matches(java.lang.Object);
}

-keep class com.google.inject.matcher.Matchers {
	*** ANY;
	*** any();
	*** checkForRuntimeRetention(java.lang.Class);
	*** identicalTo(java.lang.Object);
	*** subclassesOf(java.lang.Class);
}

-keep class com.google.inject.matcher.Matchers$Any {
	com.google.inject.matcher.Matchers$Any();
}

-keep class com.google.inject.matcher.Matchers$IdenticalTo {
	*** value;
}

-keep class com.google.inject.matcher.Matchers$SubclassesOf {
	*** superclass;
	*** matches(java.lang.Class);
}

-keep class com.google.inject.name.Names {
	*** named(java.lang.String);
}

-keep class com.google.inject.spi.BindingScopingVisitor {
	*** visitEagerSingleton();
	*** visitNoScoping();
	*** visitScope(com.google.inject.Scope);
	*** visitScopeAnnotation(java.lang.Class);
}

-keep class com.google.inject.spi.BindingTargetVisitor {
	*** visit(com.google.inject.spi.ConstructorBinding);
	*** visit(com.google.inject.spi.ConvertedConstantBinding);
	*** visit(com.google.inject.spi.ExposedBinding);
	*** visit(com.google.inject.spi.InstanceBinding);
	*** visit(com.google.inject.spi.LinkedKeyBinding);
	*** visit(com.google.inject.spi.ProviderBinding);
	*** visit(com.google.inject.spi.ProviderInstanceBinding);
	*** visit(com.google.inject.spi.ProviderKeyBinding);
	*** visit(com.google.inject.spi.UntargettedBinding);
}

-keep class com.google.inject.spi.ConstructorBinding {
	*** getConstructor();
}

-keep class com.google.inject.spi.DefaultBindingScopingVisitor {
	com.google.inject.spi.DefaultBindingScopingVisitor();
	*** visitOther();
}

-keep class com.google.inject.spi.DefaultBindingTargetVisitor {
	com.google.inject.spi.DefaultBindingTargetVisitor();
	*** visitOther(com.google.inject.Binding);
}

-keep class com.google.inject.spi.DefaultElementVisitor {
	com.google.inject.spi.DefaultElementVisitor();
	*** visit(com.google.inject.Binding);
	*** visit(com.google.inject.spi.PrivateElements);
	*** visit(com.google.inject.spi.ScopeBinding);
	*** visitOther(com.google.inject.spi.Element);
}

-keep class com.google.inject.spi.Dependency {
	*** injectionPoint;
	*** key;
	*** nullable;
	*** parameterIndex;
	*** forInjectionPoints(java.util.Set);
	*** get(com.google.inject.Key);
	*** getInjectionPoint();
	*** getKey();
	*** getParameterIndex();
	*** isNullable();
}

-keep class com.google.inject.spi.Element {
	*** acceptVisitor(com.google.inject.spi.ElementVisitor);
	*** applyTo(com.google.inject.Binder);
	*** getSource();
}

-keep class com.google.inject.spi.ElementVisitor {
	*** visit(com.google.inject.Binding);
	*** visit(com.google.inject.spi.Message);
	*** visit(com.google.inject.spi.ProviderLookup);
	*** visit(com.google.inject.spi.ScopeBinding);
	*** visit(com.google.inject.spi.TypeConverterBinding);
}

-keep class com.google.inject.spi.Elements {
	*** GET_INSTANCE_VISITOR;
	*** getElements(com.google.inject.Stage,java.lang.Iterable);
	*** getElements(java.lang.Iterable);
}

-keep class com.google.inject.spi.Elements$RecordingBinder {
	*** elements;
	*** modules;
	*** parent;
	*** privateElements;
	*** source;
	*** sourceProvider;
	*** stage;
	com.google.inject.spi.Elements$RecordingBinder(com.google.inject.Stage);
	*** access$100(com.google.inject.spi.Elements$RecordingBinder);
	*** addError(java.lang.String,java.lang.Object[]);
	*** addError(java.lang.Throwable);
	*** bind(com.google.inject.Key);
	*** exposeInternal(com.google.inject.Key);
	*** getMembersInjector(com.google.inject.TypeLiteral);
	*** getProvider(com.google.inject.Key);
	*** getSource();
	*** install(com.google.inject.Module);
	*** requestInjection(com.google.inject.TypeLiteral,java.lang.Object);
	*** skipSources(java.lang.Class[]);
	*** withSource(java.lang.Object);
}

-keep class com.google.inject.spi.ExposedBinding {
	*** getPrivateElements();
}

-keep class com.google.inject.spi.HasDependencies {
	*** getDependencies();
}

-keep class com.google.inject.spi.InjectionListener {
	*** afterInjection(java.lang.Object);
}

-keep class com.google.inject.spi.InjectionPoint {
	*** declaringType;
	*** dependencies;
	*** logger;
	*** member;
	*** optional;
	*** checkForMisplacedBindingAnnotations(java.lang.reflect.Member,com.google.inject.internal.Errors);
	*** forConstructor(java.lang.reflect.Constructor,com.google.inject.TypeLiteral);
	*** forConstructorOf(com.google.inject.TypeLiteral);
	*** forInstanceMethodsAndFields(com.google.inject.TypeLiteral);
	*** forInstanceMethodsAndFields(java.lang.Class);
	*** forMember(java.lang.reflect.Member,com.google.inject.TypeLiteral,java.lang.annotation.Annotation[][]);
	*** forStaticMethodsAndFields(com.google.inject.TypeLiteral);
	*** getAtInject(java.lang.reflect.AnnotatedElement);
	*** getDeclaringType();
	*** getDependencies();
	*** getInjectionPoints(com.google.inject.TypeLiteral,boolean,com.google.inject.internal.Errors);
	*** getMember();
	*** hierarchyFor(com.google.inject.TypeLiteral);
	*** isOptional();
	*** isToolable();
	*** isValidMethod(com.google.inject.spi.InjectionPoint$InjectableMethod,com.google.inject.internal.Errors);
	*** newDependency(com.google.inject.Key,boolean,int);
	*** overrides(java.lang.reflect.Method,java.lang.reflect.Method);
}

-keep class com.google.inject.spi.InjectionPoint$InjectableField {
	*** field;
}

-keep class com.google.inject.spi.InjectionPoint$InjectableMember {
	*** declaringType;
	*** jsr330;
	*** next;
	*** optional;
	*** previous;
	com.google.inject.spi.InjectionPoint$InjectableMember(com.google.inject.TypeLiteral,java.lang.annotation.Annotation);
	*** toInjectionPoint();
}

-keep class com.google.inject.spi.InjectionPoint$InjectableMembers {
	*** head;
	*** tail;
	*** add(com.google.inject.spi.InjectionPoint$InjectableMember);
	*** isEmpty();
}

-keep class com.google.inject.spi.InjectionPoint$InjectableMethod {
	*** method;
}

-keep class com.google.inject.spi.InjectionPoint$OverrideIndex {
	*** position;
	*** add(com.google.inject.spi.InjectionPoint$InjectableMethod);
	*** removeIfOverriddenBy(java.lang.reflect.Method,boolean,com.google.inject.spi.InjectionPoint$InjectableMethod);
}

-keep class com.google.inject.spi.InjectionPoint$Position {
	*** BOTTOM;
	*** MIDDLE;
}

-keep class com.google.inject.spi.InjectionRequest {
	*** getInjectionPoints();
	*** getInstance();
	*** getSource();
}

-keep class com.google.inject.spi.InstanceBinding {
	*** getInjectionPoints();
	*** getInstance();
}

-keep class com.google.inject.spi.InterceptorBinding {
	*** getClassMatcher();
	*** getInterceptors();
	*** getMethodMatcher();
}

-keep class com.google.inject.spi.LinkedKeyBinding {
	*** getLinkedKey();
}

-keep class com.google.inject.spi.MembersInjectorLookup {
	*** getMembersInjector();
	*** getType();
	*** initializeDelegate(com.google.inject.MembersInjector);
}

-keep class com.google.inject.spi.Message {
	*** cause;
	*** message;
	*** sources;
	com.google.inject.spi.Message(java.util.List,java.lang.String,java.lang.Throwable);
	*** getCause();
	*** getMessage();
	*** getSource();
	*** getSources();
}

-keep class com.google.inject.spi.PrivateElements {
	*** getElements();
	*** getExposedKeys();
	*** getExposedSource(com.google.inject.Key);
	*** getInjector();
}

-keep class com.google.inject.spi.ProviderInstanceBinding {
	*** getInjectionPoints();
	*** getProviderInstance();
}

-keep class com.google.inject.spi.ProviderKeyBinding {
	*** getProviderKey();
}

-keep class com.google.inject.spi.ProviderLookup {
	*** delegate;
	*** key;
	*** source;
	*** access$000(com.google.inject.spi.ProviderLookup);
	*** access$100(com.google.inject.spi.ProviderLookup);
	*** getKey();
	*** getProvider();
	*** getSource();
	*** initializeDelegate(com.google.inject.Provider);
}

-keep class com.google.inject.spi.ProviderLookup$1 {
	*** this$0;
}

-keep class com.google.inject.spi.ProviderWithExtensionVisitor {
	*** acceptExtensionVisitor(com.google.inject.spi.BindingTargetVisitor,com.google.inject.spi.ProviderInstanceBinding);
}

-keep class com.google.inject.spi.ScopeBinding {
	*** annotationType;
	*** scope;
	*** source;
	*** getAnnotationType();
	*** getScope();
	*** getSource();
}

-keep class com.google.inject.spi.TypeConverter {
	*** convert(java.lang.String,com.google.inject.TypeLiteral);
}

-keep class com.google.inject.spi.TypeConverterBinding {
	*** source;
	*** typeConverter;
	*** typeMatcher;
	*** getSource();
	*** getTypeConverter();
	*** getTypeMatcher();
}

-keep class com.google.inject.spi.TypeListener {
	*** hear(com.google.inject.TypeLiteral,com.google.inject.spi.TypeEncounter);
}

-keep class com.google.inject.spi.TypeListenerBinding {
	*** getListener();
	*** getSource();
	*** getTypeMatcher();
}

-keep class com.google.inject.util.Modules {
	*** EMPTY_MODULE;
	*** combine(java.lang.Iterable);
	*** override(com.google.inject.Module[]);
}

-keep class com.google.inject.util.Modules$ModuleWriter {
	*** binder;
	com.google.inject.util.Modules$ModuleWriter(com.google.inject.Binder);
	*** visitOther(com.google.inject.spi.Element);
	*** writeAll(java.lang.Iterable);
}

-keep class com.google.inject.util.Modules$OverriddenModuleBuilder {
	*** with(com.google.inject.Module[]);
}

-keep class com.google.inject.util.Modules$RealOverriddenModuleBuilder {
	*** baseModules;
	com.google.inject.util.Modules$RealOverriddenModuleBuilder(java.lang.Iterable);
	*** access$100(com.google.inject.util.Modules$RealOverriddenModuleBuilder);
	*** with(java.lang.Iterable);
}

-keep class com.google.inject.util.Modules$RealOverriddenModuleBuilder$1 {
	*** this$0;
	*** val$overrides;
	*** access$200(com.google.inject.util.Modules$RealOverriddenModuleBuilder$1,com.google.inject.Binding);
	*** getScopeInstanceOrNull(com.google.inject.Binding);
}

-keep class com.google.inject.util.Modules$RealOverriddenModuleBuilder$1$1 {
	*** this$1;
	*** val$overriddenKeys;
	*** val$overridesScopeAnnotations;
	*** visit(com.google.inject.Binding);
	*** visit(com.google.inject.spi.PrivateElements);
	*** visit(com.google.inject.spi.ScopeBinding);
}

-keep class com.google.inject.util.Modules$RealOverriddenModuleBuilder$1$2 {
	*** this$1;
	*** val$overriddenKeys;
	*** val$scopeBindings;
	*** val$scopeInstancesInUse;
	*** rewrite(com.google.inject.Binder,com.google.inject.spi.PrivateElements,java.util.Set);
	*** visit(com.google.inject.Binding);
	*** visit(com.google.inject.spi.PrivateElements);
	*** visit(com.google.inject.spi.ScopeBinding);
}

-keep class com.google.inject.util.Modules$RealOverriddenModuleBuilder$1$3 {
	*** this$1;
	*** val$overridesScopeAnnotations;
	*** val$scopeInstancesInUse;
	*** visit(com.google.inject.spi.ScopeBinding);
}

-keep class com.google.inject.util.Modules$RealOverriddenModuleBuilder$1$4 {
	*** this$1;
	*** visitScope(com.google.inject.Scope);
}

-keep class com.google.inject.util.Providers {
	*** of(java.lang.Object);
}

-keep class com.google.inject.util.Providers$1 {
	*** val$instance;
}

-keep class com.google.inject.util.Types {
	*** arrayOf(java.lang.reflect.Type);
	*** newParameterizedTypeWithOwner(java.lang.reflect.Type,java.lang.reflect.Type,java.lang.reflect.Type[]);
	*** providerOf(java.lang.reflect.Type);
	*** subtypeOf(java.lang.reflect.Type);
	*** supertypeOf(java.lang.reflect.Type);
}

-keep class com.jcraft.jzlib.ZOutputStream {
	*** buf;
	*** buf1;
	*** bufsize;
	*** compress;
	*** flush;
	*** out;
	*** z;
	com.jcraft.jzlib.ZOutputStream(java.io.OutputStream,int,boolean);
	*** end();
	*** finish();
	*** flush();
	*** write(byte[],int,int);
}

-keep class com.jcraft.jzlib.ZStream {
	*** avail_in;
	*** avail_out;
	*** msg;
	*** next_in;
	*** next_in_index;
	*** next_out;
	*** next_out_index;
	*** total_in;
	*** total_out;
	*** deflate(int);
	*** deflateEnd();
	*** deflateInit(int,boolean);
	*** free();
	*** inflate(int);
	*** inflateEnd();
	*** inflateInit();
}

-keep class com.librato.metrics.LibratoReporter {
	*** builder(com.codahale.metrics.MetricRegistry,java.lang.String,java.lang.String,java.lang.String);
	*** enable(com.librato.metrics.LibratoReporter$Builder,long,java.util.concurrent.TimeUnit);
}

-keep class com.mcdermottroe.apple.OSXKeychain {
	*** PROTOCOLS;
	*** instance;
	*** _addGenericPassword(java.lang.String,java.lang.String,java.lang.String);
	*** _addInternetPassword(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,int,int,java.lang.String);
	*** _deleteGenericPassword(java.lang.String,java.lang.String);
	*** _findGenericPassword(java.lang.String,java.lang.String);
	*** _findInternetPassword(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int);
	*** _modifyGenericPassword(java.lang.String,java.lang.String,java.lang.String);
	*** addGenericPassword(java.lang.String,java.lang.String,java.lang.String);
	*** addInternetPassword(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,com.mcdermottroe.apple.OSXKeychainProtocolType,com.mcdermottroe.apple.OSXKeychainAuthenticationType,java.lang.String);
	*** findGenericPassword(java.lang.String,java.lang.String);
	*** findInternetPassword(java.lang.String,java.lang.String,java.lang.String);
	*** getInstance();
	*** getPort(int,com.mcdermottroe.apple.OSXKeychainProtocolType);
	*** getProtocol(int,java.lang.String);
	*** getUsername(java.lang.String,java.net.URL);
	*** loadSharedObject();
	*** modifyGenericPassword(java.lang.String,java.lang.String,java.lang.String);
}

-keep class com.mcdermottroe.apple.OSXKeychainAuthenticationType {
	*** Any;
	*** getValue();
}

-keep class com.mcdermottroe.apple.OSXKeychainProtocolType {
	*** $VALUES;
	*** AFP;
	*** Any;
	*** AppleTalk;
	*** CIFS;
	*** CVSpserver;
	*** DAAP;
	*** EPPC;
	*** FTP;
	*** FTPAccount;
	*** FTPProxy;
	*** FTPS;
	*** HTTP;
	*** HTTPProxy;
	*** HTTPS;
	*** HTTPSProxy;
	*** IMAP;
	*** IMAPS;
	*** IPP;
	*** IRC;
	*** IRCS;
	*** LDAP;
	*** LDAPS;
	*** NNTP;
	*** NNTPS;
	*** POP3;
	*** POP3S;
	*** RTSP;
	*** RTSPProxy;
	*** SMB;
	*** SMTP;
	*** SOCKS;
	*** SSH;
	*** SVN;
	*** Telnet;
	*** TelnetS;
	*** symbol;
	*** value;
	*** getValue();
	*** toString();
	*** values();
}

-keep class com.ochafik.lang.jnaerator.runtime.Bits {
	*** value();
}

-keep class com.ochafik.lang.jnaerator.runtime.LibraryExtractor {
	*** extract(java.net.URL);
	*** getCurrentOSAndArchString();
	*** getFileName(java.net.URL);
	*** getLibraryPath(java.lang.String,boolean,java.lang.Class);
	*** getTracingLibrary(java.lang.Object,java.lang.Class);
	*** shouldTraceCalls(java.lang.String);
}

-keep class com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper {
	*** DEFAULT_OPTIONS;
	*** linked;
}

-keep class com.ochafik.lang.jnaerator.runtime.Mangling {
	*** value();
}

-keep class com.ochafik.lang.jnaerator.runtime.Structure {
	*** dependency;
	com.ochafik.lang.jnaerator.runtime.Structure();
	*** byReference();
	*** byValue();
	*** castToArray(int);
	*** castToReferenceArray(int);
	*** castToValueArray(int);
	*** clone();
	*** compareTo(com.ochafik.lang.jnaerator.runtime.Structure);
	*** newArray(java.lang.Class,int);
	*** newByReference();
	*** newByValue();
	*** newInstance();
	*** read();
	*** readDependency();
	*** setDependency(com.ochafik.lang.jnaerator.runtime.StructureType);
	*** setupClone(com.ochafik.lang.jnaerator.runtime.Structure,com.ochafik.lang.jnaerator.runtime.StructureType);
	*** toArray(com.sun.jna.Structure[]);
	*** toArray(int);
	*** toReferenceArray(int);
	*** toValueArray(int);
	*** use(com.sun.jna.Pointer);
	*** use(com.sun.jna.Pointer,long);
	*** use(java.nio.Buffer,long);
	*** write();
}

-keep class com.ochafik.lang.jnaerator.runtime.StructureType {
	*** read();
}

-keep class com.ochafik.lang.jnaerator.runtime.Union {
	*** use(com.sun.jna.Pointer);
}

-keep class com.ochafik.net.URLUtils {
	*** getResource(java.lang.Class,java.lang.String);
	*** listFiles(java.net.URL,com.ochafik.util.listenable.Filter);
}

-keep class com.ochafik.util.listenable.Filter {
	*** accept(java.lang.Object);
}

-keep class com.sachingarg.CompressedOutputStream {
	*** Encoder;
	*** Model;
	*** close();
	*** write(byte[],int,int);
	*** write(int);
}

-keep class com.sachingarg.DecompressedInputStream {
	*** Decoder;
	*** Model;
	*** _nextByte;
	*** close();
	*** read();
	*** read(byte[],int,int);
}

-keep class com.sachingarg.FenwickTreeModel {
	*** $assertionsDisabled;
	*** NoOfSymbols;
	*** fw;
	com.sachingarg.FenwickTreeModel(int);
	*** getCumulativeFrequency(int);
	*** getNumberOfSymbols();
	*** getSymbolForFrequency(int);
	*** update(int);
}

-keep class com.sachingarg.IRangeEncoder {
	*** EncodeRange(int,int,int);
	*** Flush();
}

-keep class com.sachingarg.RCModel {
	*** getCumulativeFrequency(int);
	*** getNumberOfSymbols();
	*** getSymbolForFrequency(int);
	*** update(int);
}

-keep class com.sachingarg.RangeCoder64 {
	*** Low;
	*** Range;
	com.sachingarg.RangeCoder64();
}

-keep class com.sachingarg.RangeDecoder64 {
	*** Code;
	*** _in;
	*** GetCurrentCount(int);
	*** RemoveRange(int,int,int);
}

-keep class com.sachingarg.RangeEncoder64 {
	*** Flushed;
	*** _out;
}

-keep class com.sun.beans.TypeResolver {
	*** $assertionsDisabled;
	*** CACHE;
	*** erase(java.lang.reflect.Type);
	*** erase(java.lang.reflect.Type[]);
	*** fixGenericArray(java.lang.reflect.Type);
	*** getActualType(java.lang.Class);
	*** prepare(java.util.Map,java.lang.reflect.Type);
	*** resolve(java.lang.reflect.Type,java.lang.reflect.Type);
	*** resolve(java.lang.reflect.Type,java.lang.reflect.Type[]);
	*** resolveInClass(java.lang.Class,java.lang.reflect.Type);
	*** resolveInClass(java.lang.Class,java.lang.reflect.Type[]);
}

-keep class com.sun.beans.WeakCache {
	*** map;
	*** clear();
	*** get(java.lang.Object);
	*** put(java.lang.Object,java.lang.Object);
}

-keep class com.sun.beans.WildcardTypeImpl {
	*** lowerBounds;
	*** upperBounds;
}

-keep class com.sun.beans.finder.BeanInfoFinder {
	*** getPackages();
	*** instantiate(java.lang.Class,java.lang.String,java.lang.String);
	*** isValid(java.lang.Class,java.lang.reflect.Method);
	*** setPackages(java.lang.String[]);
}

-keep class com.sun.beans.finder.ClassFinder {
	*** findClass(java.lang.String);
	*** findClass(java.lang.String,java.lang.ClassLoader);
	*** resolveClass(java.lang.String,java.lang.ClassLoader);
}

-keep class com.sun.beans.finder.InstanceFinder {
	*** EMPTY;
	*** allow;
	*** packages;
	*** suffix;
	*** type;
	com.sun.beans.finder.InstanceFinder(java.lang.Class,boolean,java.lang.String,java.lang.String[]);
	*** find(java.lang.Class);
	*** getPackages();
	*** instantiate(java.lang.Class,java.lang.String);
	*** instantiate(java.lang.Class,java.lang.String,java.lang.String);
	*** setPackages(java.lang.String[]);
}

-keep class com.sun.beans.finder.PrimitiveTypeMap {
	*** getType(java.lang.String);
}

-keep class com.sun.crypto.provider.AESCipher {
	*** core;
}

-keep class com.sun.crypto.provider.AESConstants {
	*** AES_KEYSIZES;
}

-keep class com.sun.crypto.provider.AESCrypt {
	*** K;
	*** ROUNDS_12;
	*** ROUNDS_14;
	*** S;
	*** Si;
	*** T1;
	*** T2;
	*** T3;
	*** T4;
	*** T5;
	*** T6;
	*** T7;
	*** T8;
	*** U1;
	*** U2;
	*** U3;
	*** U4;
	*** alog;
	*** lastKey;
	*** limit;
	*** log;
	*** rcon;
	*** sessionK;
	*** expandToSubKey(int[][],boolean);
	*** getRounds(int);
	*** isKeySizeValid(int);
	*** makeSessionKey(byte[]);
	*** mul(int,int);
	*** mul4(int,byte[]);
}

-keep class com.sun.crypto.provider.AESKeyGenerator {
	*** keySize;
	*** random;
	*** engineInit(java.security.SecureRandom);
}

-keep class com.sun.crypto.provider.AESParameters {
	*** core;
}

-keep class com.sun.crypto.provider.ARCFOURCipher {
	*** S;
	*** is;
	*** js;
	*** lastKey;
	*** crypt(byte[],int,int,byte[],int);
	*** engineDoFinal(byte[],int,int);
	*** engineUpdate(byte[],int,int);
	*** engineUpdate(byte[],int,int,byte[],int);
	*** getEncodedKey(java.security.Key);
	*** init(byte[]);
	*** init(int,java.security.Key);
}

-keep class com.sun.crypto.provider.BlockCipherParamsCore {
	*** block_size;
	*** iv;
	*** getEncoded();
	*** getParameterSpec(java.lang.Class);
	*** init(byte[]);
	*** init(byte[],java.lang.String);
	*** init(java.security.spec.AlgorithmParameterSpec);
	*** toString();
}

-keep class com.sun.crypto.provider.CipherBlockChaining {
	*** k;
	*** r;
	*** rSave;
	com.sun.crypto.provider.CipherBlockChaining(com.sun.crypto.provider.SymmetricCipher);
	*** decrypt(byte[],int,int,byte[],int);
	*** encrypt(byte[],int,int,byte[],int);
	*** reset();
}

-keep class com.sun.crypto.provider.CipherCore {
	*** blockSize;
	*** buffer;
	*** buffered;
	*** cipher;
	*** cipherMode;
	*** decrypting;
	*** diffBlocksize;
	*** minBytes;
	*** padding;
	*** unitBytes;
	*** doFinal(byte[],int,int);
	*** doFinal(byte[],int,int,byte[],int);
	*** finalNoPadding(byte[],int,byte[],int,int);
	*** getIV();
	*** getKeyBytes(java.security.Key);
	*** getNumOfUnit(java.lang.String,int,int);
	*** getOutputSize(int);
	*** getParameters(java.lang.String);
	*** init(int,java.security.Key,java.security.AlgorithmParameters,java.security.SecureRandom);
	*** init(int,java.security.Key,java.security.SecureRandom);
	*** init(int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
	*** setMode(java.lang.String);
	*** setPadding(java.lang.String);
	*** unwrap(byte[],java.lang.String,int);
	*** update(byte[],int,int);
	*** update(byte[],int,int,byte[],int);
	*** wrap(java.security.Key);
}

-keep class com.sun.crypto.provider.CipherFeedback {
	*** k;
	*** numBytes;
	*** register;
	*** registerSave;
	*** reset();
}

-keep class com.sun.crypto.provider.ConstructKeys {
	*** constructKey(byte[],java.lang.String,int);
}

-keep class com.sun.crypto.provider.CounterMode {
	*** counter;
	*** counterSave;
	*** encryptedCounter;
	*** encryptedCounterSave;
	*** used;
	*** usedSave;
	*** crypt(byte[],int,int,byte[],int);
	*** increment(byte[]);
	*** reset();
}

-keep class com.sun.crypto.provider.FeedbackCipher {
	*** blockSize;
	*** embeddedCipher;
	*** iv;
	com.sun.crypto.provider.FeedbackCipher(com.sun.crypto.provider.SymmetricCipher);
	*** decrypt(byte[],int,int,byte[],int);
	*** decryptFinal(byte[],int,int,byte[],int);
	*** encrypt(byte[],int,int,byte[],int);
	*** encryptFinal(byte[],int,int,byte[],int);
	*** getEmbeddedCipher();
	*** getIV();
	*** init(boolean,java.lang.String,byte[],byte[]);
	*** reset();
	*** restore();
	*** save();
}

-keep class com.sun.crypto.provider.HmacCore {
	*** blockLen;
	*** first;
	*** k_ipad;
	*** k_opad;
	*** md;
	com.sun.crypto.provider.HmacCore(java.security.MessageDigest,int);
	*** clone();
	*** doFinal();
	*** getDigestLength();
	*** init(java.security.Key,java.security.spec.AlgorithmParameterSpec);
	*** reset();
	*** update(byte);
	*** update(byte[],int,int);
	*** update(java.nio.ByteBuffer);
}

-keep class com.sun.crypto.provider.HmacSHA1 {
	*** hmac;
}

-keep class com.sun.crypto.provider.OutputFeedback {
	*** k;
	*** numBytes;
	*** register;
	*** registerSave;
	*** encrypt(byte[],int,int,byte[],int);
	*** reset();
}

-keep class com.sun.crypto.provider.PCBC {
	*** k;
	*** kSave;
	*** reset();
}

-keep class com.sun.crypto.provider.PKCS5Padding {
	*** blockSize;
}

-keep class com.sun.crypto.provider.Padding {
	*** padLength(int);
	*** padWithLen(byte[],int,int);
	*** unpad(byte[],int,int);
}

-keep class com.sun.crypto.provider.RC2Crypt {
	*** getEffectiveKeyBits();
}

-keep class com.sun.crypto.provider.RSACipher {
	*** B0;
	*** bufOfs;
	*** buffer;
	*** mode;
	*** oaepHashAlgorithm;
	*** outputSize;
	*** padding;
	*** paddingType;
	*** privateKey;
	*** publicKey;
	*** spec;
	*** doFinal();
	*** init(int,java.security.Key,java.security.SecureRandom,java.security.spec.AlgorithmParameterSpec);
	*** update(byte[],int,int);
}

-keep class com.sun.crypto.provider.SunJCE {
	*** RANDOM;
}

-keep class com.sun.crypto.provider.SunJCE$1 {
	*** this$0;
}

-keep class com.sun.crypto.provider.SymmetricCipher {
	com.sun.crypto.provider.SymmetricCipher();
	*** decryptBlock(byte[],int,byte[],int);
	*** encryptBlock(byte[],int,byte[],int);
	*** getBlockSize();
	*** init(boolean,java.lang.String,byte[]);
}

-keep class com.sun.crypto.provider.TlsKeyMaterialGenerator {
	*** protocolVersion;
	*** spec;
	*** engineGenerateKey0();
}

-keep class com.sun.crypto.provider.TlsMasterSecretGenerator {
	*** protocolVersion;
	*** spec;
}

-keep class com.sun.crypto.provider.TlsMasterSecretGenerator$TlsMasterSecretKey {
	*** key;
	*** majorVersion;
	*** minorVersion;
}

-keep class com.sun.crypto.provider.TlsPrfGenerator {
	*** B0;
	*** HMAC_ipad128;
	*** HMAC_ipad64;
	*** HMAC_opad128;
	*** HMAC_opad64;
	*** LABEL_CLIENT_WRITE_KEY;
	*** LABEL_IV_BLOCK;
	*** LABEL_KEY_EXPANSION;
	*** LABEL_MASTER_SECRET;
	*** LABEL_SERVER_WRITE_KEY;
	*** SSL3_CONST;
	*** spec;
	com.sun.crypto.provider.TlsPrfGenerator();
	*** concat(byte[],byte[]);
	*** doTLS10PRF(byte[],byte[],byte[],int);
	*** doTLS10PRF(byte[],byte[],byte[],int,java.security.MessageDigest,java.security.MessageDigest);
	*** doTLS12PRF(byte[],byte[],byte[],int,java.lang.String,int,int);
	*** doTLS12PRF(byte[],byte[],byte[],int,java.security.MessageDigest,int,int);
	*** engineGenerateKey0(boolean);
	*** expand(java.security.MessageDigest,int,byte[],int,int,byte[],byte[],byte[],byte[],byte[]);
	*** genConst();
	*** genPad(byte,int);
}

-keep class com.sun.crypto.provider.TlsRsaPremasterSecretGenerator {
	*** random;
	*** spec;
}

-keep class com.sun.java.swing.SwingUtilities3 {
	*** $assertionsDisabled;
	*** DELEGATE_REPAINT_MANAGER_KEY;
	*** vsyncedMap;
	*** getDelegateRepaintManager(java.awt.Component);
}

-keep class com.sun.jna.Callback {
	*** FORBIDDEN_NAMES;
}

-keep class com.sun.jna.CallbackProxy {
	*** getParameterTypes();
	*** getReturnType();
}

-keep class com.sun.jna.CallbackReference {
	*** PROXY_CALLBACK_METHOD;
	*** allocations;
	*** array$Lcom$sun$jna$WString;
	*** array$Ljava$lang$Object;
	*** array$Ljava$lang$String;
	*** callbackMap;
	*** cbstruct;
	*** class$com$sun$jna$AltCallingConvention;
	*** class$com$sun$jna$Callback;
	*** class$com$sun$jna$CallbackProxy;
	*** class$com$sun$jna$NativeMapped;
	*** class$com$sun$jna$Pointer;
	*** class$com$sun$jna$Structure;
	*** class$com$sun$jna$Structure$ByValue;
	*** class$com$sun$jna$WString;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** class$java$lang$Void;
	*** initializers;
	*** method;
	*** proxy;
	*** checkMethod(java.lang.reflect.Method);
	*** class$(java.lang.String);
	*** dispose();
	*** findCallbackClass(java.lang.Class);
	*** getCallback();
	*** getCallback(java.lang.Class,com.sun.jna.Pointer);
	*** getCallback(java.lang.Class,com.sun.jna.Pointer,boolean);
	*** getCallbackMethod(com.sun.jna.Callback);
	*** getCallbackMethod(java.lang.Class);
	*** getFunctionPointer(com.sun.jna.Callback);
	*** getFunctionPointer(com.sun.jna.Callback,boolean);
	*** getNativeFunctionPointer(com.sun.jna.Callback);
	*** getNativeString(java.lang.Object,boolean);
	*** getNativeType(java.lang.Class);
	*** getTrampoline();
	*** isAllowableNativeType(java.lang.Class);
	*** setCallbackOptions(int);
	*** setCallbackThreadInitializer(com.sun.jna.Callback,com.sun.jna.CallbackThreadInitializer);
}

-keep class com.sun.jna.CallbackReference$AttachOptions {
	*** daemon;
	*** detach;
	*** name;
}

-keep class com.sun.jna.CallbackReference$DefaultCallbackProxy {
	*** getCallback();
}

-keep class com.sun.jna.CallbackReference$NativeFunctionHandler {
	*** getPointer();
}

-keep class com.sun.jna.CallbackThreadInitializer {
	*** detach(com.sun.jna.Callback);
	*** getName(com.sun.jna.Callback);
	*** getThreadGroup(com.sun.jna.Callback);
	*** isDaemon(com.sun.jna.Callback);
}

-keep class com.sun.jna.FromNativeContext {
	*** type;
	com.sun.jna.FromNativeContext(java.lang.Class);
}

-keep class com.sun.jna.FromNativeConverter {
	*** fromNative(java.lang.Object,com.sun.jna.FromNativeContext);
	*** nativeType();
}

-keep class com.sun.jna.Function {
	*** INTEGER_FALSE;
	*** INTEGER_TRUE;
	*** array$Lcom$sun$jna$NativeMapped;
	*** array$Lcom$sun$jna$Pointer;
	*** array$Lcom$sun$jna$Structure;
	*** array$Lcom$sun$jna$Structure$ByReference;
	*** array$Lcom$sun$jna$WString;
	*** array$Ljava$lang$String;
	*** callFlags;
	*** class$com$sun$jna$Callback;
	*** class$com$sun$jna$NativeMapped;
	*** class$com$sun$jna$Pointer;
	*** class$com$sun$jna$Structure;
	*** class$com$sun$jna$Structure$ByReference;
	*** class$com$sun$jna$Structure$ByValue;
	*** class$com$sun$jna$WString;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Object;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** class$java$lang$Void;
	*** functionName;
	*** library;
	*** options;
	*** checkCallingConvention(int);
	*** class$(java.lang.String);
	*** concatenateVarArgs(java.lang.Object[]);
	*** convertArgument(java.lang.Object[],int,java.lang.reflect.Method,com.sun.jna.TypeMapper,boolean);
	*** getCallingConvention();
	*** getFunction(com.sun.jna.Pointer,int);
	*** getName();
	*** invoke(java.lang.Class,java.lang.Object[]);
	*** invoke(java.lang.Class,java.lang.Object[],java.util.Map);
	*** invoke(java.lang.Object[],java.lang.Class,boolean);
	*** invokePointer(int,java.lang.Object[]);
	*** invokeString(int,java.lang.Object[],boolean);
	*** isPrimitiveArray(java.lang.Class);
	*** isVarArgs(java.lang.reflect.Method);
	*** valueOf(boolean);
}

-keep class com.sun.jna.Function$PostCallRead {
	*** read();
}

-keep class com.sun.jna.FunctionMapper {
	*** getFunctionName(com.sun.jna.NativeLibrary,java.lang.reflect.Method);
}

-keep class com.sun.jna.FunctionParameterContext {
	*** args;
	*** function;
	*** index;
	com.sun.jna.FunctionParameterContext(com.sun.jna.Function,java.lang.Object[],int);
}

-keep class com.sun.jna.FunctionResultContext {
	*** args;
	*** function;
	com.sun.jna.FunctionResultContext(java.lang.Class,com.sun.jna.Function,java.lang.Object[]);
}

-keep class com.sun.jna.IntegerType {
	*** number;
	*** size;
	*** unsigned;
	*** value;
	com.sun.jna.IntegerType(int,long,boolean);
	*** intValue();
	*** longValue();
	*** setValue(long);
}

-keep class com.sun.jna.InvocationMapper {
	*** getInvocationHandler(com.sun.jna.NativeLibrary,java.lang.reflect.Method);
}

-keep class com.sun.jna.Library$1 {
	*** class$com$sun$jna$AltCallingConvention;
	*** class$java$lang$Object;
	*** class$(java.lang.String);
}

-keep class com.sun.jna.Library$Handler {
	*** OBJECT_EQUALS;
	*** OBJECT_HASHCODE;
	*** OBJECT_TOSTRING;
	*** functionMapper;
	*** functions;
	*** interfaceClass;
	*** invocationMapper;
	*** nativeLibrary;
	*** options;
}

-keep class com.sun.jna.Library$Handler$FunctionInfo {
	*** function;
	*** handler;
	*** isVarArgs;
	*** options;
	com.sun.jna.Library$Handler$FunctionInfo();
}

-keep class com.sun.jna.Memory {
	*** buffers;
	*** size;
	com.sun.jna.Memory();
	com.sun.jna.Memory(long);
	*** boundsCheck(long,long);
	*** clear();
	*** dispose();
	*** free(long);
	*** getPointer(long);
	*** getSize();
	*** malloc(long);
	*** share(long,long);
	*** size();
	*** toString();
	*** valid();
}

-keep class com.sun.jna.Memory$SharedMemory {
	*** this$0;
}

-keep class com.sun.jna.MethodParameterContext {
	*** method;
}

-keep class com.sun.jna.MethodResultContext {
	*** method;
}

-keep class com.sun.jna.Native {
	*** DEFAULT_HANDLER;
	*** LONG_SIZE;
	*** POINTER_SIZE;
	*** SIZE_T_SIZE;
	*** WCHAR_SIZE;
	*** alignments;
	*** callbackExceptionHandler;
	*** class$com$sun$jna$Callback;
	*** class$com$sun$jna$IntegerType;
	*** class$com$sun$jna$LastErrorException;
	*** class$com$sun$jna$Library;
	*** class$com$sun$jna$Native;
	*** class$com$sun$jna$NativeMapped;
	*** class$com$sun$jna$Pointer;
	*** class$com$sun$jna$PointerType;
	*** class$com$sun$jna$Structure;
	*** class$com$sun$jna$Structure$ByReference;
	*** class$com$sun$jna$Structure$ByValue;
	*** class$com$sun$jna$TypeMapper;
	*** class$com$sun$jna$WString;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** class$java$lang$Void;
	*** class$java$nio$Buffer;
	*** finalizer;
	*** lastError;
	*** libraries;
	*** nativeLibraryPath;
	*** options;
	*** registeredClasses;
	*** registeredLibraries;
	*** typeMappers;
	*** unloader;
	*** _getDirectBufferPointer(java.nio.Buffer);
	*** _getPointer(long);
	*** access$000();
	*** access$100();
	*** access$200(java.lang.Class,long[]);
	*** cacheOptions(java.lang.Class,java.util.Map,java.lang.Object);
	*** class$(java.lang.String);
	*** close(long);
	*** createNativeCallback(com.sun.jna.Callback,java.lang.reflect.Method,java.lang.Class[],java.lang.Class,int,boolean);
	*** deleteNativeLibrary(java.lang.String);
	*** dispose();
	*** findEnclosingLibraryClass(java.lang.Class);
	*** findSymbol(long,java.lang.String);
	*** free(long);
	*** freeNativeCallback(long);
	*** getAPIChecksum();
	*** getByte(long);
	*** getBytes(java.lang.String);
	*** getBytes(java.lang.String,java.lang.String);
	*** getCallingClass();
	*** getChar(long);
	*** getConversion(java.lang.Class,com.sun.jna.TypeMapper);
	*** getDirectBufferPointer(java.nio.Buffer);
	*** getDirectByteBuffer(long,long);
	*** getDouble(long);
	*** getFloat(long);
	*** getInt(long);
	*** getLibraryOptions(java.lang.Class);
	*** getLong(long);
	*** getNativeClass(java.lang.Class);
	*** getNativeLibraryResourcePath(int,java.lang.String,java.lang.String);
	*** getNativeSize(java.lang.Class);
	*** getNativeSize(java.lang.Class,java.lang.Object);
	*** getNativeVersion();
	*** getPointer(long);
	*** getShort(long);
	*** getSignature(java.lang.Class);
	*** getString(long,boolean);
	*** getStructureAlignment(java.lang.Class);
	*** getTempDir();
	*** getTypeMapper(java.lang.Class);
	*** getWebStartLibraryPath(java.lang.String);
	*** indexOf(long,byte);
	*** initIDs();
	*** invokeDouble(long,int,java.lang.Object[]);
	*** invokeFloat(long,int,java.lang.Object[]);
	*** invokeInt(long,int,java.lang.Object[]);
	*** invokeLong(long,int,java.lang.Object[]);
	*** invokeObject(long,int,java.lang.Object[]);
	*** invokePointer(long,int,java.lang.Object[]);
	*** invokeStructure(long,int,java.lang.Object[],com.sun.jna.Structure);
	*** invokeStructure(long,int,java.lang.Object[],long,long);
	*** invokeVoid(long,int,java.lang.Object[]);
	*** isSupportedNativeType(java.lang.Class);
	*** loadLibrary(java.lang.String,java.lang.Class);
	*** loadLibrary(java.lang.String,java.lang.Class,java.util.Map);
	*** loadLibraryInstance(java.lang.Class);
	*** loadNativeLibrary();
	*** loadNativeLibraryFromJar();
	*** malloc(long);
	*** markTemporaryFile(java.io.File);
	*** open(java.lang.String);
	*** read(long,byte[],int,int);
	*** read(long,char[],int,int);
	*** read(long,double[],int,int);
	*** read(long,float[],int,int);
	*** read(long,int[],int,int);
	*** read(long,long[],int,int);
	*** read(long,short[],int,int);
	*** register(java.lang.Class,com.sun.jna.NativeLibrary);
	*** registerMethod(java.lang.Class,java.lang.String,java.lang.String,int[],long[],long[],int,long,long,java.lang.Class,long,int,boolean,com.sun.jna.ToNativeConverter[],com.sun.jna.FromNativeConverter);
	*** removeTemporaryFiles();
	*** replace(java.lang.String,java.lang.String,java.lang.String);
	*** setByte(long,byte);
	*** setChar(long,char);
	*** setDouble(long,double);
	*** setFloat(long,float);
	*** setInt(long,int);
	*** setLastError(int);
	*** setLong(long,long);
	*** setMemory(long,long,byte);
	*** setPointer(long,long);
	*** setPreserveLastError(boolean);
	*** setProtected(boolean);
	*** setShort(long,short);
	*** setString(long,java.lang.String,boolean);
	*** sizeof(int);
	*** toString(byte[],java.lang.String);
	*** unregister(java.lang.Class);
	*** unregister(java.lang.Class,long[]);
	*** write(long,byte[],int,int);
	*** write(long,char[],int,int);
	*** write(long,double[],int,int);
	*** write(long,float[],int,int);
	*** write(long,int[],int,int);
	*** write(long,long[],int,int);
	*** write(long,short[],int,int);
}

-keep class com.sun.jna.Native$7 {
	*** getClassContext();
}

-keep class com.sun.jna.Native$AWT {
	*** getComponentID(java.lang.Object);
	*** getWindowID(java.awt.Window);
}

-keep class com.sun.jna.Native$Buffers {
	*** isBuffer(java.lang.Class);
}

-keep class com.sun.jna.NativeLibrary {
	*** callFlags;
	*** class$com$sun$jna$LastErrorException;
	*** functions;
	*** handle;
	*** libraries;
	*** libraryName;
	*** libraryPath;
	*** librarySearchPath;
	*** options;
	*** searchPaths;
	*** class$(java.lang.String);
	*** dispose();
	*** disposeAll();
	*** findLibraryPath(java.lang.String,java.util.List);
	*** functionKey(java.lang.String,int);
	*** getFile();
	*** getFunction(java.lang.String);
	*** getFunction(java.lang.String,int);
	*** getFunction(java.lang.String,java.lang.reflect.Method);
	*** getGlobalVariableAddress(java.lang.String);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.util.Map);
	*** getLibraryName(java.lang.String);
	*** getName();
	*** getOptions();
	*** getSymbolAddress(java.lang.String);
	*** initPaths(java.lang.String);
	*** isVersionedName(java.lang.String);
	*** loadLibrary(java.lang.String,java.util.Map);
	*** mapLibraryName(java.lang.String);
	*** matchLibrary(java.lang.String,java.util.List);
	*** parseVersion(java.lang.String);
}

-keep class com.sun.jna.NativeLong {
	*** SIZE;
}

-keep class com.sun.jna.NativeMapped {
	*** fromNative(java.lang.Object,com.sun.jna.FromNativeContext);
	*** nativeType();
	*** toNative();
}

-keep class com.sun.jna.NativeMappedConverter {
	*** class$com$sun$jna$NativeMapped;
	*** class$com$sun$jna$Pointer;
	*** converters;
	*** instance;
	*** nativeType;
	*** type;
	*** class$(java.lang.String);
	*** defaultValue();
	*** fromNative(java.lang.Object,com.sun.jna.FromNativeContext);
	*** getInstance(java.lang.Class);
	*** nativeType();
	*** toNative(java.lang.Object,com.sun.jna.ToNativeContext);
}

-keep class com.sun.jna.NativeString {
	*** pointer;
	*** wide;
	com.sun.jna.NativeString(java.lang.String,boolean);
	*** compareTo(java.lang.Object);
	*** getPointer();
	*** toString();
}

-keep class com.sun.jna.Platform {
	*** C_LIBRARY_NAME;
	*** HAS_AWT;
	*** HAS_BUFFERS;
	*** MATH_LIBRARY_NAME;
	*** RO_FIELDS;
	*** osType;
	*** getOSType();
	*** is64Bit();
	*** isARM();
	*** isAix();
	*** isFreeBSD();
	*** isIntel();
	*** isLinux();
	*** isMac();
	*** isPPC();
	*** isSolaris();
	*** isWindows();
	*** isWindowsCE();
}

-keep class com.sun.jna.Pointer {
	*** NULL;
	*** SIZE;
	*** class$com$sun$jna$Callback;
	*** class$com$sun$jna$NativeMapped;
	*** class$com$sun$jna$Pointer;
	*** class$com$sun$jna$Structure;
	*** class$com$sun$jna$Structure$ByReference;
	*** class$com$sun$jna$WString;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** class$java$nio$Buffer;
	*** peer;
	com.sun.jna.Pointer();
	com.sun.jna.Pointer(long);
	*** class$(java.lang.String);
	*** clear(long);
	*** equals(java.lang.Object);
	*** getArrayValue(long,java.lang.Object,java.lang.Class);
	*** getByte(long);
	*** getByteArray(long,int);
	*** getByteBuffer(long,long);
	*** getChar(long);
	*** getDouble(long);
	*** getFloat(long);
	*** getInt(long);
	*** getLong(long);
	*** getPointer(long);
	*** getPointerArray(long);
	*** getPointerArray(long,int);
	*** getShort(long);
	*** getString(long);
	*** getString(long,boolean);
	*** getStringArray(long);
	*** getStringArray(long,boolean);
	*** getStringArray(long,int,boolean);
	*** getValue(long,java.lang.Class,java.lang.Object);
	*** hashCode();
	*** indexOf(long,byte);
	*** read(long,byte[],int,int);
	*** read(long,char[],int,int);
	*** read(long,com.sun.jna.Pointer[],int,int);
	*** read(long,double[],int,int);
	*** read(long,float[],int,int);
	*** read(long,int[],int,int);
	*** read(long,long[],int,int);
	*** read(long,short[],int,int);
	*** setArrayValue(long,java.lang.Object,java.lang.Class);
	*** setByte(long,byte);
	*** setChar(long,char);
	*** setDouble(long,double);
	*** setFloat(long,float);
	*** setInt(long,int);
	*** setLong(long,long);
	*** setMemory(long,long,byte);
	*** setPointer(long,com.sun.jna.Pointer);
	*** setShort(long,short);
	*** setString(long,java.lang.String,boolean);
	*** setValue(long,java.lang.Object,java.lang.Class);
	*** share(long);
	*** share(long,long);
	*** toString();
	*** write(long,byte[],int,int);
	*** write(long,char[],int,int);
	*** write(long,com.sun.jna.Pointer[],int,int);
	*** write(long,double[],int,int);
	*** write(long,float[],int,int);
	*** write(long,int[],int,int);
	*** write(long,long[],int,int);
	*** write(long,short[],int,int);
}

-keep class com.sun.jna.Pointer$Opaque {
	*** MSG;
	com.sun.jna.Pointer$Opaque(long);
}

-keep class com.sun.jna.PointerType {
	*** class$com$sun$jna$Pointer;
	*** pointer;
	com.sun.jna.PointerType();
	*** class$(java.lang.String);
	*** getPointer();
	*** setPointer(com.sun.jna.Pointer);
}

-keep class com.sun.jna.Structure {
	*** MAX_GNUC_ALIGNMENT;
	*** REQUIRES_FIELD_ORDER;
	*** REVERSE_FIELDS;
	*** alignType;
	*** array;
	*** autoRead;
	*** autoWrite;
	*** busy;
	*** class$com$sun$jna$Callback;
	*** class$com$sun$jna$NativeMapped;
	*** class$com$sun$jna$Pointer;
	*** class$com$sun$jna$Structure;
	*** class$com$sun$jna$Structure$ByReference;
	*** class$com$sun$jna$Structure$MemberOrder;
	*** class$com$sun$jna$WString;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** class$java$nio$Buffer;
	*** fieldOrder;
	*** isARM;
	*** isPPC;
	*** isSPARC;
	*** layoutInfo;
	*** memory;
	*** nativeStrings;
	*** reads;
	*** size;
	*** structAlignment;
	*** structFields;
	*** typeInfo;
	*** typeMapper;
	com.sun.jna.Structure();
	com.sun.jna.Structure(com.sun.jna.Pointer);
	com.sun.jna.Structure(com.sun.jna.Pointer,int);
	com.sun.jna.Structure(com.sun.jna.Pointer,int,com.sun.jna.TypeMapper);
	*** allocateMemory();
	*** allocateMemory(boolean);
	*** allocateMemory(int);
	*** autoAllocate(int);
	*** autoRead();
	*** autoRead(com.sun.jna.Structure[]);
	*** autoWrite();
	*** autoWrite(com.sun.jna.Structure[]);
	*** baseClass();
	*** busy();
	*** cacheTypeInfo(com.sun.jna.Pointer);
	*** calculateAlignedSize(int,int);
	*** calculateSize(boolean);
	*** calculateSize(boolean,boolean);
	*** class$(java.lang.String);
	*** clear();
	*** deriveLayout(boolean,boolean);
	*** ensureAllocated();
	*** ensureAllocated(boolean);
	*** fieldOrderMatch(java.util.List);
	*** fields();
	*** format(java.lang.Class);
	*** getAutoRead();
	*** getAutoWrite();
	*** getField(com.sun.jna.Structure$StructField);
	*** getFieldOrder();
	*** getFields(boolean);
	*** getNativeAlignment(java.lang.Class,java.lang.Object,boolean);
	*** getNativeSize(java.lang.Class,java.lang.Object);
	*** getPointer();
	*** getStructAlignment();
	*** getTypeInfo();
	*** getTypeInfo(java.lang.Object);
	*** hasFieldOrder();
	*** initializeField(com.sun.jna.Structure$StructField,java.lang.Class);
	*** initializeFields();
	*** newInstance(java.lang.Class);
	*** read();
	*** readField(com.sun.jna.Structure$StructField);
	*** reading();
	*** setAlignType(int);
	*** setAutoRead(boolean);
	*** setAutoWrite(boolean);
	*** setField(com.sun.jna.Structure$StructField,java.lang.Object);
	*** setField(com.sun.jna.Structure$StructField,java.lang.Object,boolean);
	*** setFieldOrder(java.lang.String[]);
	*** setTypeMapper(com.sun.jna.TypeMapper);
	*** size();
	*** sortFields(java.util.List,java.util.List);
	*** structureArrayCheck(com.sun.jna.Structure[]);
	*** toArray(com.sun.jna.Structure[]);
	*** toArray(int);
	*** toString(boolean);
	*** toString(int,boolean,boolean);
	*** updateStructureByReference(java.lang.Class,com.sun.jna.Structure,com.sun.jna.Pointer);
	*** useMemory(com.sun.jna.Pointer);
	*** useMemory(com.sun.jna.Pointer,int);
	*** write();
	*** writeField(com.sun.jna.Structure$StructField);
}

-keep class com.sun.jna.Structure$2$StructureSet {
	*** count;
	*** elements;
	*** this$0;
	*** contains(java.lang.Object);
	*** ensureCapacity(int);
	*** indexOf(java.lang.Object);
}

-keep class com.sun.jna.Structure$AutoAllocated {
	*** this$0;
}

-keep class com.sun.jna.Structure$FFIType {
	*** access$200(java.lang.Object,java.lang.Class);
	*** get(java.lang.Object);
}

-keep class com.sun.jna.Structure$FFIType$FFITypes {
	*** ffi_type_double;
	*** ffi_type_float;
	*** ffi_type_pointer;
	*** ffi_type_sint16;
	*** ffi_type_sint32;
	*** ffi_type_sint64;
	*** ffi_type_sint8;
	*** ffi_type_uint16;
	*** ffi_type_uint32;
	*** ffi_type_void;
}

-keep class com.sun.jna.Structure$LayoutInfo {
	*** alignType;
	*** alignment;
	*** fieldOrder;
	*** fields;
	*** size;
	*** this$0;
	*** typeMapper;
	*** variable;
	com.sun.jna.Structure$LayoutInfo(com.sun.jna.Structure);
}

-keep class com.sun.jna.Structure$MemberOrder {
	*** FIELDS;
	*** access$000();
}

-keep class com.sun.jna.Structure$StructField {
	*** context;
	*** field;
	*** isReadOnly;
	*** isVolatile;
	*** name;
	*** offset;
	*** readConverter;
	*** size;
	*** this$0;
	*** type;
	*** writeConverter;
}

-keep class com.sun.jna.StructureReadContext {
	*** field;
	*** structure;
}

-keep class com.sun.jna.StructureWriteContext {
	*** field;
	*** struct;
}

-keep class com.sun.jna.ToNativeContext {
	com.sun.jna.ToNativeContext();
}

-keep class com.sun.jna.ToNativeConverter {
	*** nativeType();
	*** toNative(java.lang.Object,com.sun.jna.ToNativeContext);
}

-keep class com.sun.jna.TypeMapper {
	*** getFromNativeConverter(java.lang.Class);
	*** getToNativeConverter(java.lang.Class);
}

-keep class com.sun.jna.WString {
	*** string;
	*** toString();
}

-keep class com.sun.jna.WeakIdentityHashMap {
	*** backingStore;
	*** queue;
	*** reap();
}

-keep class com.sun.jna.platform.win32.Advapi32Util {
	*** registryGetIntValue(com.sun.jna.platform.win32.WinReg$HKEY,java.lang.String,java.lang.String);
	*** registryGetStringValue(com.sun.jna.platform.win32.WinReg$HKEY,java.lang.String,java.lang.String);
	*** registrySetIntValue(com.sun.jna.platform.win32.WinReg$HKEY,java.lang.String,java.lang.String,int);
	*** registrySetStringValue(com.sun.jna.platform.win32.WinReg$HKEY,java.lang.String,java.lang.String,java.lang.String);
}

-keep class com.sun.jna.platform.win32.Kernel32Util {
	*** formatMessageFromHR(com.sun.jna.platform.win32.WinNT$HRESULT);
}

-keep class com.sun.jna.platform.win32.Shell32Util {
	*** getFolderPath(int);
}

-keep class com.sun.jna.platform.win32.W32Errors {
	*** HRESULT_FROM_WIN32(int);
}

-keep class com.sun.jna.platform.win32.Win32Exception {
	*** _hr;
	com.sun.jna.platform.win32.Win32Exception(com.sun.jna.platform.win32.WinNT$HRESULT);
}

-keep class com.sun.jna.platform.win32.WinReg {
	*** HKEY_CURRENT_USER;
}

-keep class com.sun.jna.ptr.ByReference {
	com.sun.jna.ptr.ByReference(int);
}

-keep class com.sun.jna.ptr.IntByReference {
	com.sun.jna.ptr.IntByReference(int);
	*** setValue(int);
}

-keep class com.sun.jna.ptr.PointerByReference {
	com.sun.jna.ptr.PointerByReference(com.sun.jna.Pointer);
	*** setValue(com.sun.jna.Pointer);
}

-keep class com.sun.jna.ptr.ShortByReference {
	com.sun.jna.ptr.ShortByReference(short);
	*** setValue(short);
}

-keep class com.sun.jna.win32.StdCallFunctionMapper {
	*** class$com$sun$jna$NativeMapped;
	*** class$(java.lang.String);
	*** getArgumentNativeStackSize(java.lang.Class);
}

-keep class com.sun.management.OSMBeanFactory {
	*** osMBean;
	*** getOperatingSystemMXBean(sun.management.VMManagement);
}

-keep class com.sun.management.OperatingSystemMXBean {
	*** getTotalPhysicalMemorySize();
}

-keep class com.sun.management.UnixOperatingSystem {
	*** initialize();
}

-keep class com.sun.proxy.$Proxy0 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy1 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy10 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy11 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy12 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy13 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy14 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy15 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy16 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy17 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy18 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy19 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
	*** m6;
	*** m7;
	*** m8;
	*** m9;
}

-keep class com.sun.proxy.$Proxy2 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy20 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy21 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy22 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy23 {
	*** m0;
	*** m1;
	*** m10;
	*** m11;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
	*** m6;
	*** m7;
	*** m8;
	*** m9;
}

-keep class com.sun.proxy.$Proxy24 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
	*** m6;
	*** m7;
	*** m8;
	*** m9;
}

-keep class com.sun.proxy.$Proxy25 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
}

-keep class com.sun.proxy.$Proxy26 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy27 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy28 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy29 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy3 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
}

-keep class com.sun.proxy.$Proxy30 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy31 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy32 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
	*** m6;
}

-keep class com.sun.proxy.$Proxy33 {
	*** m0;
	*** m1;
	*** m10;
	*** m11;
	*** m12;
	*** m13;
	*** m14;
	*** m15;
	*** m16;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
	*** m6;
	*** m7;
	*** m8;
	*** m9;
}

-keep class com.sun.proxy.$Proxy34 {
	*** m0;
	*** m1;
	*** m10;
	*** m11;
	*** m12;
	*** m13;
	*** m14;
	*** m15;
	*** m16;
	*** m17;
	*** m18;
	*** m19;
	*** m2;
	*** m20;
	*** m21;
	*** m3;
	*** m4;
	*** m5;
	*** m6;
	*** m7;
	*** m8;
	*** m9;
}

-keep class com.sun.proxy.$Proxy35 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
	*** m5;
}

-keep class com.sun.proxy.$Proxy36 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy37 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy38 {
	*** m0;
	*** m1;
	*** m10;
	*** m11;
	*** m12;
	*** m13;
	*** m14;
	*** m15;
	*** m16;
	*** m17;
	*** m18;
	*** m19;
	*** m2;
	*** m20;
	*** m21;
	*** m22;
	*** m23;
	*** m24;
	*** m25;
	*** m26;
	*** m27;
	*** m28;
	*** m29;
	*** m3;
	*** m30;
	*** m31;
	*** m32;
	*** m33;
	*** m34;
	*** m35;
	*** m36;
	*** m37;
	*** m38;
	*** m39;
	*** m4;
	*** m40;
	*** m41;
	*** m42;
	*** m43;
	*** m44;
	*** m45;
	*** m46;
	*** m47;
	*** m48;
	*** m49;
	*** m5;
	*** m50;
	*** m51;
	*** m52;
	*** m53;
	*** m54;
	*** m55;
	*** m56;
	*** m57;
	*** m58;
	*** m59;
	*** m6;
	*** m60;
	*** m61;
	*** m62;
	*** m63;
	*** m64;
	*** m65;
	*** m66;
	*** m67;
	*** m68;
	*** m69;
	*** m7;
	*** m70;
	*** m71;
	*** m72;
	*** m73;
	*** m74;
	*** m75;
	*** m76;
	*** m77;
	*** m78;
	*** m79;
	*** m8;
	*** m80;
	*** m81;
	*** m82;
	*** m9;
}

-keep class com.sun.proxy.$Proxy39 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy4 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy40 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy5 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy6 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy7 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
	*** m4;
}

-keep class com.sun.proxy.$Proxy8 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.proxy.$Proxy9 {
	*** m0;
	*** m1;
	*** m2;
	*** m3;
}

-keep class com.sun.security.auth.PrincipalComparator {
	*** implies(javax.security.auth.Subject);
}

-keep class com.sun.security.sasl.Provider$1 {
	*** this$0;
	*** run();
}

-keep class cx.ath.matthew.debug.Debug {
	*** print(int,byte[]);
	*** print(int,java.lang.Object);
	*** print(int,java.lang.String);
	*** print(int,java.lang.Throwable);
	*** print(java.lang.Object);
}

-keep class cx.ath.matthew.utils.Hexdump {
	*** toAscii(byte[],int,int);
	*** toHex(byte[],int,int);
}

-keep class fr.free.miniupnp.IGDdatas {
	*** CIF;
	*** IPv6FC;
	*** cureltname;
	*** first;
	*** level;
	*** presentationurl;
	*** second;
	*** tmp;
	*** urlbase;
	fr.free.miniupnp.IGDdatas();
	*** initFieldOrder();
	*** newByReference();
	*** newByValue();
	*** newInstance();
}

-keep class fr.free.miniupnp.IGDdatas_service {
	*** controlurl;
	*** eventsuburl;
	*** scpdurl;
	*** servicetype;
	fr.free.miniupnp.IGDdatas_service();
	*** initFieldOrder();
	*** newByReference();
	*** newByValue();
	*** newInstance();
}

-keep class fr.free.miniupnp.MiniupnpcLibrary {
	*** INSTANCE;
	*** FreeUPNPUrls(fr.free.miniupnp.UPNPUrls);
	*** UPNP_AddPortMapping(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** UPNP_DeletePortMapping(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** UPNP_GetExternalIPAddress(java.lang.String,java.lang.String,java.nio.ByteBuffer);
	*** UPNP_GetSpecificPortMappingEntry(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** UPNP_GetValidIGD(fr.free.miniupnp.UPNPDev,fr.free.miniupnp.UPNPUrls,fr.free.miniupnp.IGDdatas,java.nio.ByteBuffer,int);
	*** freeUPNPDevlist(fr.free.miniupnp.UPNPDev);
	*** upnpDiscover(int,java.lang.String,java.lang.String,int,int,java.nio.IntBuffer);
}

-keep class fr.free.miniupnp.NameValueParserData {
	*** curelt;
	*** head;
	*** portListing;
	*** portListingLength;
	fr.free.miniupnp.NameValueParserData();
	*** initFieldOrder();
	*** newByReference();
	*** newByValue();
	*** newInstance();
}

-keep class fr.free.miniupnp.UPNPDev {
	*** buffer;
	*** descURL;
	*** pNext;
	*** scope_id;
	*** st;
	fr.free.miniupnp.UPNPDev();
	*** initFieldOrder();
	*** newByReference();
	*** newByValue();
	*** newInstance();
}

-keep class fr.free.miniupnp.UPNPUrls {
	*** controlURL;
	*** controlURL_6FC;
	*** controlURL_CIF;
	*** ipcondescURL;
	*** rootdescURL;
	fr.free.miniupnp.UPNPUrls();
	*** initFieldOrder();
	*** newByReference();
	*** newByValue();
	*** newInstance();
}

-keep class fr.free.miniupnp.UPNParg {
	*** elt;
	*** val;
	fr.free.miniupnp.UPNParg();
	*** initFieldOrder();
	*** newByReference();
	*** newByValue();
	*** newInstance();
}

-keep class fr.free.miniupnp.libnatpmp.LibraryExtractor {
	*** libPathSet;
	*** extract(java.net.URL);
	*** getCurrentOSAndArchString();
	*** getFileName(java.net.URL);
	*** getLibraryPath(java.lang.String,boolean,java.lang.Class);
	*** is64Bit();
	*** isMac();
	*** isWindows();
}

-keep class fr.free.miniupnp.libnatpmp.NatPmp {
	*** JNA_LIBRARY_NAME;
	*** natpmp;
	*** free();
	*** init(int,int);
	*** readNatPmpResponseOrRetry(fr.free.miniupnp.libnatpmp.NatPmpResponse);
	*** sendNewPortMappingRequest(int,int,int,int);
	*** sendPublicAddressRequest();
	*** startup();
}

-keep class fr.free.miniupnp.libnatpmp.NatPmpResponse {
	*** mappedpublicport;
}

-keep class fr.free.miniupnp.libnatpmp.URLUtils {
	*** getResource(java.lang.Class,java.lang.String);
	*** listFiles(java.net.URL);
}

-keep class io.netty.bootstrap.AbstractBootstrap {
	*** attrs;
	*** channelFactory;
	*** group;
	*** handler;
	*** localAddress;
	*** options;
	io.netty.bootstrap.AbstractBootstrap();
	io.netty.bootstrap.AbstractBootstrap(io.netty.bootstrap.AbstractBootstrap);
	*** access$000(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** attrs();
	*** bind();
	*** bind(int);
	*** bind(java.lang.String,int);
	*** bind(java.net.InetAddress,int);
	*** bind(java.net.SocketAddress);
	*** channelFactory();
	*** channelFactory(io.netty.bootstrap.ChannelFactory);
	*** clone();
	*** doBind(java.net.SocketAddress);
	*** doBind0(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** group();
	*** group(io.netty.channel.EventLoopGroup);
	*** handler();
	*** handler(io.netty.channel.ChannelHandler);
	*** init(io.netty.channel.Channel);
	*** initAndRegister();
	*** localAddress();
	*** localAddress(java.net.SocketAddress);
	*** option(io.netty.channel.ChannelOption,java.lang.Object);
	*** options();
	*** toString();
	*** validate();
}

-keep class io.netty.bootstrap.AbstractBootstrap$1 {
	*** this$0;
	*** val$channel;
	*** val$localAddress;
	*** val$promise;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.bootstrap.AbstractBootstrap$2 {
	*** val$channel;
	*** val$localAddress;
	*** val$promise;
	*** val$regFuture;
}

-keep class io.netty.bootstrap.Bootstrap {
	*** logger;
	*** remoteAddress;
	*** access$000(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** clone();
	*** connect(java.net.SocketAddress);
	*** connect(java.net.SocketAddress,java.net.SocketAddress);
	*** doConnect(java.net.SocketAddress,java.net.SocketAddress);
	*** doConnect0(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** validate();
}

-keep class io.netty.bootstrap.Bootstrap$1 {
	*** this$0;
	*** val$channel;
	*** val$localAddress;
	*** val$promise;
	*** val$regFuture;
	*** val$remoteAddress;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.bootstrap.Bootstrap$2 {
	*** val$channel;
	*** val$localAddress;
	*** val$promise;
	*** val$regFuture;
	*** val$remoteAddress;
}

-keep class io.netty.bootstrap.ChannelFactory {
	*** newChannel();
}

-keep class io.netty.bootstrap.ServerBootstrap {
	*** childAttrs;
	*** childGroup;
	*** childHandler;
	*** childOptions;
	*** logger;
	*** access$000();
	*** bind(java.net.SocketAddress);
	*** childHandler(io.netty.channel.ChannelHandler);
	*** clone();
	*** group(io.netty.channel.EventLoopGroup);
	*** group(io.netty.channel.EventLoopGroup,io.netty.channel.EventLoopGroup);
	*** newAttrArray(int);
	*** newOptionArray(int);
	*** validate();
}

-keep class io.netty.bootstrap.ServerBootstrap$1 {
	*** this$0;
	*** val$currentChildAttrs;
	*** val$currentChildGroup;
	*** val$currentChildHandler;
	*** val$currentChildOptions;
}

-keep class io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor {
	*** childAttrs;
	*** childGroup;
	*** childHandler;
	*** childOptions;
}

-keep class io.netty.buffer.AbstractByteBuf {
	*** leakDetector;
	*** markedReaderIndex;
	*** markedWriterIndex;
	*** maxCapacity;
	*** readerIndex;
	*** swappedBuf;
	*** writerIndex;
	io.netty.buffer.AbstractByteBuf(int);
	*** _getByte(int);
	*** _getInt(int);
	*** _getLong(int);
	*** _getShort(int);
	*** _getUnsignedMedium(int);
	*** _setByte(int,int);
	*** _setInt(int,int);
	*** _setLong(int,long);
	*** _setMedium(int,int);
	*** _setShort(int,int);
	*** adjustMarkers(int);
	*** bytesBefore(int,int,byte);
	*** calculateNewCapacity(int);
	*** checkDstIndex(int,int,int,int);
	*** checkIndex(int);
	*** checkIndex(int,int);
	*** checkReadableBytes(int);
	*** checkSrcIndex(int,int,int,int);
	*** clear();
	*** compareTo(io.netty.buffer.ByteBuf);
	*** ensureAccessible();
	*** ensureWritable(int);
	*** forEachByteAsc0(int,int,io.netty.buffer.ByteBufProcessor);
	*** forEachByteDesc0(int,int,io.netty.buffer.ByteBufProcessor);
	*** getByte(int);
	*** getBytes(int,byte[]);
	*** getBytes(int,io.netty.buffer.ByteBuf);
	*** getBytes(int,io.netty.buffer.ByteBuf,int);
	*** getInt(int);
	*** getLong(int);
	*** getShort(int);
	*** getUnsignedMedium(int);
	*** indexOf(int,int,byte);
	*** markReaderIndex();
	*** markWriterIndex();
	*** maxCapacity();
	*** nioBuffer(int,int);
	*** order(java.nio.ByteOrder);
	*** readByte();
	*** readBytes(byte[]);
	*** readBytes(byte[],int,int);
	*** readBytes(io.netty.buffer.ByteBuf);
	*** readBytes(io.netty.buffer.ByteBuf,int);
	*** readBytes(io.netty.buffer.ByteBuf,int,int);
	*** readBytes(java.io.OutputStream,int);
	*** readBytes(java.nio.ByteBuffer);
	*** readInt();
	*** readLong();
	*** readShort();
	*** readUnsignedMedium();
	*** readableBytes();
	*** readerIndex();
	*** readerIndex(int);
	*** resetReaderIndex();
	*** resetWriterIndex();
	*** setBoolean(int,boolean);
	*** setByte(int,int);
	*** setBytes(int,byte[]);
	*** setBytes(int,io.netty.buffer.ByteBuf);
	*** setBytes(int,io.netty.buffer.ByteBuf,int);
	*** setChar(int,int);
	*** setDouble(int,double);
	*** setFloat(int,float);
	*** setIndex(int,int);
	*** setInt(int,int);
	*** setLong(int,long);
	*** setMedium(int,int);
	*** setShort(int,int);
	*** setZero(int,int);
	*** skipBytes(int);
	*** slice(int,int);
	*** toString();
	*** toString(int,int,java.nio.charset.Charset);
	*** writableBytes();
	*** writeBoolean(boolean);
	*** writeByte(int);
	*** writeBytes(byte[]);
	*** writeBytes(byte[],int,int);
	*** writeBytes(io.netty.buffer.ByteBuf);
	*** writeBytes(io.netty.buffer.ByteBuf,int);
	*** writeBytes(io.netty.buffer.ByteBuf,int,int);
	*** writeBytes(java.nio.ByteBuffer);
	*** writeChar(int);
	*** writeDouble(double);
	*** writeFloat(float);
	*** writeInt(int);
	*** writeLong(long);
	*** writeMedium(int);
	*** writeShort(int);
	*** writeZero(int);
	*** writerIndex();
	*** writerIndex(int);
}

-keep class io.netty.buffer.AbstractByteBufAllocator {
	*** directByDefault;
	*** emptyBuf;
	io.netty.buffer.AbstractByteBufAllocator(boolean);
	*** compositeDirectBuffer();
	*** compositeDirectBuffer(int);
	*** compositeHeapBuffer();
	*** compositeHeapBuffer(int);
	*** directBuffer();
	*** directBuffer(int);
	*** directBuffer(int,int);
	*** heapBuffer();
	*** heapBuffer(int);
	*** heapBuffer(int,int);
	*** newDirectBuffer(int,int);
	*** newHeapBuffer(int,int);
	*** validate(int,int);
}

-keep class io.netty.buffer.AbstractDerivedByteBuf {
	io.netty.buffer.AbstractDerivedByteBuf(int);
	*** retain();
	*** retain(int);
}

-keep class io.netty.buffer.AbstractReferenceCountedByteBuf {
	*** REFCNT_FIELD_OFFSET;
	*** refCnt;
	*** refCntUpdater;
	io.netty.buffer.AbstractReferenceCountedByteBuf(int);
	*** deallocate();
	*** retain();
	*** retain(int);
}

-keep class io.netty.buffer.ByteBuf {
	io.netty.buffer.ByteBuf();
	*** alloc();
	*** array();
	*** arrayOffset();
	*** bytesBefore(byte);
	*** bytesBefore(int,byte);
	*** bytesBefore(int,int,byte);
	*** capacity();
	*** capacity(int);
	*** clear();
	*** compareTo(io.netty.buffer.ByteBuf);
	*** copy();
	*** copy(int,int);
	*** discardReadBytes();
	*** discardSomeReadBytes();
	*** duplicate();
	*** ensureWritable(int);
	*** ensureWritable(int,boolean);
	*** equals(java.lang.Object);
	*** forEachByte(int,int,io.netty.buffer.ByteBufProcessor);
	*** forEachByte(io.netty.buffer.ByteBufProcessor);
	*** forEachByteDesc(int,int,io.netty.buffer.ByteBufProcessor);
	*** forEachByteDesc(io.netty.buffer.ByteBufProcessor);
	*** getBoolean(int);
	*** getByte(int);
	*** getBytes(int,byte[]);
	*** getBytes(int,byte[],int,int);
	*** getBytes(int,io.netty.buffer.ByteBuf);
	*** getBytes(int,io.netty.buffer.ByteBuf,int);
	*** getBytes(int,io.netty.buffer.ByteBuf,int,int);
	*** getBytes(int,java.io.OutputStream,int);
	*** getBytes(int,java.nio.ByteBuffer);
	*** getBytes(int,java.nio.channels.GatheringByteChannel,int);
	*** getChar(int);
	*** getDouble(int);
	*** getFloat(int);
	*** getInt(int);
	*** getLong(int);
	*** getMedium(int);
	*** getShort(int);
	*** getUnsignedByte(int);
	*** getUnsignedInt(int);
	*** getUnsignedMedium(int);
	*** getUnsignedShort(int);
	*** hasArray();
	*** hasMemoryAddress();
	*** hashCode();
	*** indexOf(int,int,byte);
	*** internalNioBuffer(int,int);
	*** isDirect();
	*** isReadable();
	*** isReadable(int);
	*** isWritable();
	*** isWritable(int);
	*** markReaderIndex();
	*** markWriterIndex();
	*** maxCapacity();
	*** maxWritableBytes();
	*** memoryAddress();
	*** nioBuffer();
	*** nioBuffer(int,int);
	*** nioBufferCount();
	*** nioBuffers();
	*** nioBuffers(int,int);
	*** order();
	*** order(java.nio.ByteOrder);
	*** readBoolean();
	*** readByte();
	*** readBytes(byte[]);
	*** readBytes(byte[],int,int);
	*** readBytes(int);
	*** readBytes(io.netty.buffer.ByteBuf);
	*** readBytes(io.netty.buffer.ByteBuf,int);
	*** readBytes(io.netty.buffer.ByteBuf,int,int);
	*** readBytes(java.io.OutputStream,int);
	*** readBytes(java.nio.ByteBuffer);
	*** readBytes(java.nio.channels.GatheringByteChannel,int);
	*** readChar();
	*** readDouble();
	*** readFloat();
	*** readInt();
	*** readLong();
	*** readMedium();
	*** readShort();
	*** readSlice(int);
	*** readUnsignedByte();
	*** readUnsignedInt();
	*** readUnsignedMedium();
	*** readUnsignedShort();
	*** readableBytes();
	*** readerIndex();
	*** readerIndex(int);
	*** resetReaderIndex();
	*** resetWriterIndex();
	*** retain();
	*** retain(int);
	*** setBoolean(int,boolean);
	*** setByte(int,int);
	*** setBytes(int,byte[]);
	*** setBytes(int,byte[],int,int);
	*** setBytes(int,io.netty.buffer.ByteBuf);
	*** setBytes(int,io.netty.buffer.ByteBuf,int);
	*** setBytes(int,io.netty.buffer.ByteBuf,int,int);
	*** setBytes(int,java.io.InputStream,int);
	*** setBytes(int,java.nio.ByteBuffer);
	*** setBytes(int,java.nio.channels.ScatteringByteChannel,int);
	*** setChar(int,int);
	*** setDouble(int,double);
	*** setFloat(int,float);
	*** setIndex(int,int);
	*** setInt(int,int);
	*** setLong(int,long);
	*** setMedium(int,int);
	*** setShort(int,int);
	*** setZero(int,int);
	*** skipBytes(int);
	*** slice();
	*** slice(int,int);
	*** toString();
	*** toString(int,int,java.nio.charset.Charset);
	*** toString(java.nio.charset.Charset);
	*** unwrap();
	*** writableBytes();
	*** writeBoolean(boolean);
	*** writeByte(int);
	*** writeBytes(byte[]);
	*** writeBytes(byte[],int,int);
	*** writeBytes(io.netty.buffer.ByteBuf);
	*** writeBytes(io.netty.buffer.ByteBuf,int);
	*** writeBytes(io.netty.buffer.ByteBuf,int,int);
	*** writeBytes(java.io.InputStream,int);
	*** writeBytes(java.nio.ByteBuffer);
	*** writeBytes(java.nio.channels.ScatteringByteChannel,int);
	*** writeChar(int);
	*** writeDouble(double);
	*** writeFloat(float);
	*** writeInt(int);
	*** writeLong(long);
	*** writeMedium(int);
	*** writeShort(int);
	*** writeZero(int);
	*** writerIndex();
	*** writerIndex(int);
}

-keep class io.netty.buffer.ByteBufAllocator {
	*** buffer();
	*** buffer(int);
	*** buffer(int,int);
	*** directBuffer();
	*** directBuffer(int);
	*** directBuffer(int,int);
	*** heapBuffer();
	*** heapBuffer(int);
	*** heapBuffer(int,int);
	*** ioBuffer(int);
}

-keep class io.netty.buffer.ByteBufHolder {
	*** content();
	*** duplicate();
	*** retain();
}

-keep class io.netty.buffer.ByteBufProcessor {
	*** process(byte);
}

-keep class io.netty.buffer.ByteBufUtil {
	*** compare(io.netty.buffer.ByteBuf,io.netty.buffer.ByteBuf);
	*** decodeString(java.nio.ByteBuffer,java.nio.charset.Charset);
	*** encodeString(java.nio.CharBuffer,java.nio.charset.Charset);
	*** equals(io.netty.buffer.ByteBuf,io.netty.buffer.ByteBuf);
	*** hashCode(io.netty.buffer.ByteBuf);
	*** hexDump(io.netty.buffer.ByteBuf);
	*** indexOf(io.netty.buffer.ByteBuf,int,int,byte);
	*** swapInt(int);
	*** swapLong(long);
	*** swapMedium(int);
	*** swapShort(short);
}

-keep class io.netty.buffer.CompositeByteBuf {
	*** $assertionsDisabled;
	*** FULL_BYTEBUFFER;
	*** alloc;
	*** components;
	*** direct;
	*** freed;
	*** leak;
	*** maxNumComponents;
	*** _getByte(int);
	*** _getInt(int);
	*** _getShort(int);
	*** _setByte(int,int);
	*** _setInt(int,int);
	*** _setShort(int,int);
	*** addComponent0(int,io.netty.buffer.ByteBuf);
	*** addComponents0(int,io.netty.buffer.ByteBuf[]);
	*** addComponents0(int,java.lang.Iterable);
	*** alloc();
	*** allocBuffer(int);
	*** capacity();
	*** capacity(int);
	*** checkComponentIndex(int);
	*** checkComponentIndex(int,int);
	*** clear();
	*** consolidateIfNeeded();
	*** copiedNioBuffer(int,int);
	*** copyTo(int,int,int,io.netty.buffer.ByteBuf);
	*** discardReadBytes();
	*** discardReadComponents();
	*** discardSomeReadBytes();
	*** ensureWritable(int);
	*** findComponent(int);
	*** getBytes(int,byte[]);
	*** getBytes(int,byte[],int,int);
	*** getBytes(int,io.netty.buffer.ByteBuf);
	*** getBytes(int,io.netty.buffer.ByteBuf,int);
	*** getBytes(int,io.netty.buffer.ByteBuf,int,int);
	*** getBytes(int,java.io.OutputStream,int);
	*** getBytes(int,java.nio.ByteBuffer);
	*** internalComponent(int);
	*** internalComponentAtOffset(int);
	*** markReaderIndex();
	*** markWriterIndex();
	*** nioBuffers(int,int);
	*** numComponents();
	*** order();
	*** readBytes(byte[]);
	*** readBytes(byte[],int,int);
	*** readBytes(io.netty.buffer.ByteBuf);
	*** readBytes(io.netty.buffer.ByteBuf,int);
	*** readBytes(io.netty.buffer.ByteBuf,int,int);
	*** readBytes(java.io.OutputStream,int);
	*** readBytes(java.nio.ByteBuffer);
	*** readerIndex(int);
	*** resetReaderIndex();
	*** resetWriterIndex();
	*** retain();
	*** retain(int);
	*** setBoolean(int,boolean);
	*** setByte(int,int);
	*** setBytes(int,byte[]);
	*** setBytes(int,byte[],int,int);
	*** setBytes(int,io.netty.buffer.ByteBuf);
	*** setBytes(int,io.netty.buffer.ByteBuf,int);
	*** setBytes(int,io.netty.buffer.ByteBuf,int,int);
	*** setBytes(int,java.nio.ByteBuffer);
	*** setChar(int,int);
	*** setDouble(int,double);
	*** setFloat(int,float);
	*** setIndex(int,int);
	*** setInt(int,int);
	*** setLong(int,long);
	*** setMedium(int,int);
	*** setShort(int,int);
	*** setZero(int,int);
	*** skipBytes(int);
	*** toComponentIndex(int);
	*** toNioBuffer(io.netty.buffer.ByteBuf,int,int);
	*** updateComponentOffsets(int);
	*** writeBoolean(boolean);
	*** writeByte(int);
	*** writeBytes(byte[]);
	*** writeBytes(byte[],int,int);
	*** writeBytes(io.netty.buffer.ByteBuf);
	*** writeBytes(io.netty.buffer.ByteBuf,int);
	*** writeBytes(io.netty.buffer.ByteBuf,int,int);
	*** writeBytes(java.nio.ByteBuffer);
	*** writeChar(int);
	*** writeDouble(double);
	*** writeFloat(float);
	*** writeInt(int);
	*** writeLong(long);
	*** writeMedium(int);
	*** writeShort(int);
	*** writeZero(int);
	*** writerIndex(int);
}

-keep class io.netty.buffer.CompositeByteBuf$Component {
	*** buf;
	*** endOffset;
	*** length;
	*** offset;
	*** freeIfNecessary();
}

-keep class io.netty.buffer.DuplicatedByteBuf {
	*** buffer;
	*** _getByte(int);
	*** _getInt(int);
	*** _getLong(int);
	*** _getShort(int);
	*** _getUnsignedMedium(int);
	*** _setByte(int,int);
	*** _setInt(int,int);
	*** _setLong(int,long);
	*** _setMedium(int,int);
	*** _setShort(int,int);
}

-keep class io.netty.buffer.EmptyByteBuf {
	*** EMPTY_BYTE_BUFFER;
	*** EMPTY_BYTE_BUFFER_ADDRESS;
	*** alloc;
	*** order;
	*** str;
	*** swapped;
	io.netty.buffer.EmptyByteBuf(io.netty.buffer.ByteBufAllocator,java.nio.ByteOrder);
	*** alloc();
	*** checkIndex(int);
	*** checkIndex(int,int);
	*** checkLength(int);
	*** compareTo(io.netty.buffer.ByteBuf);
	*** hasMemoryAddress();
	*** nioBuffer();
	*** nioBuffers();
	*** order();
	*** retain();
	*** retain(int);
	*** toString(java.nio.charset.Charset);
}

-keep class io.netty.buffer.ReadOnlyByteBuf {
	*** buffer;
	*** _getByte(int);
	*** _getInt(int);
	*** _getLong(int);
	*** _getShort(int);
	*** _getUnsignedMedium(int);
}

-keep class io.netty.buffer.ReadOnlyByteBufferBuf {
	*** allocator;
	*** buffer;
	*** leak;
	*** tmpNioBuf;
	io.netty.buffer.ReadOnlyByteBufferBuf(io.netty.buffer.ByteBufAllocator,java.nio.ByteBuffer);
	*** _getByte(int);
	*** _getInt(int);
	*** _getLong(int);
	*** _getShort(int);
	*** _getUnsignedMedium(int);
	*** alloc();
	*** capacity();
	*** getByte(int);
	*** getBytes(int,byte[],int,int);
	*** getBytes(int,java.nio.ByteBuffer);
	*** internalNioBuffer();
	*** order();
}

-keep class io.netty.buffer.ReadOnlyUnsafeDirectByteBuf {
	*** NATIVE_ORDER;
	*** memoryAddress;
	*** addr(int);
}

-keep class io.netty.buffer.SlicedByteBuf {
	*** adjustment;
	*** buffer;
	*** length;
}

-keep class io.netty.buffer.SwappedByteBuf {
	*** buf;
	*** order;
	*** compareTo(io.netty.buffer.ByteBuf);
	*** getInt(int);
	*** getLong(int);
	*** getMedium(int);
	*** getShort(int);
	*** order();
	*** readInt();
	*** readLong();
	*** readMedium();
	*** readShort();
	*** retain();
	*** retain(int);
	*** setInt(int,int);
	*** setLong(int,long);
	*** setShort(int,int);
	*** writeInt(int);
	*** writeLong(long);
	*** writeShort(int);
}

-keep class io.netty.buffer.Unpooled {
	*** ALLOC;
	*** BIG_ENDIAN;
	*** EMPTY_BUFFER;
	*** LITTLE_ENDIAN;
	*** buffer(int);
	*** buffer(int,int);
	*** compositeBuffer(int);
	*** copiedBuffer(byte[]);
	*** copiedBuffer(char[],int,int,java.nio.charset.Charset);
	*** copiedBuffer(io.netty.buffer.ByteBuf);
	*** copiedBuffer(java.nio.ByteBuffer);
	*** copiedBuffer(java.nio.CharBuffer,java.nio.charset.Charset);
	*** unmodifiableBuffer(io.netty.buffer.ByteBuf);
	*** wrappedBuffer(byte[]);
	*** wrappedBuffer(byte[],int,int);
	*** wrappedBuffer(int,byte[][]);
	*** wrappedBuffer(int,io.netty.buffer.ByteBuf[]);
	*** wrappedBuffer(int,java.nio.ByteBuffer[]);
	*** wrappedBuffer(io.netty.buffer.ByteBuf);
	*** wrappedBuffer(java.nio.ByteBuffer);
}

-keep class io.netty.buffer.UnpooledByteBufAllocator {
	*** DEFAULT;
}

-keep class io.netty.buffer.UnpooledDirectByteBuf {
	*** alloc;
	*** buffer;
	*** capacity;
	*** doNotFree;
	*** leak;
	*** tmpNioBuf;
	*** _getByte(int);
	*** _getInt(int);
	*** _getLong(int);
	*** _getShort(int);
	*** _getUnsignedMedium(int);
	*** _setByte(int,int);
	*** _setInt(int,int);
	*** _setLong(int,long);
	*** _setMedium(int,int);
	*** _setShort(int,int);
	*** alloc();
	*** capacity();
	*** getByte(int);
	*** getBytes(int,byte[],int,int);
	*** getBytes(int,java.nio.ByteBuffer);
	*** internalNioBuffer();
	*** order();
	*** setByte(int,int);
	*** setByteBuffer(java.nio.ByteBuffer);
	*** setBytes(int,java.nio.ByteBuffer);
}

-keep class io.netty.buffer.UnpooledHeapByteBuf {
	*** alloc;
	*** array;
	*** tmpNioBuf;
	io.netty.buffer.UnpooledHeapByteBuf(io.netty.buffer.ByteBufAllocator,byte[],int,int,int);
	*** _getByte(int);
	*** _getInt(int);
	*** _getLong(int);
	*** _getShort(int);
	*** _getUnsignedMedium(int);
	*** _setByte(int,int);
	*** _setInt(int,int);
	*** _setLong(int,long);
	*** _setMedium(int,int);
	*** _setShort(int,int);
	*** alloc();
	*** capacity();
	*** getBytes(int,byte[],int,int);
	*** internalNioBuffer();
	*** nioBuffer(int,int);
	*** setArray(byte[]);
	*** setBytes(int,byte[],int,int);
}

-keep class io.netty.buffer.UnpooledUnsafeDirectByteBuf {
	*** NATIVE_ORDER;
	*** alloc;
	*** buffer;
	*** capacity;
	*** doNotFree;
	*** leak;
	*** memoryAddress;
	*** tmpNioBuf;
	*** addr(int);
	*** alloc();
	*** capacity();
	*** internalNioBuffer();
	*** setByteBuffer(java.nio.ByteBuffer);
}

-keep class io.netty.buffer.UnreleasableByteBuf {
	*** buf;
	*** swappedBuf;
	*** compareTo(io.netty.buffer.ByteBuf);
	*** order();
	*** retain();
	*** retain(int);
}

-keep class io.netty.channel.AbstractChannel {
	*** CLOSED_CHANNEL_EXCEPTION;
	*** NOT_YET_CONNECTED_EXCEPTION;
	*** closeFuture;
	*** estimatorHandle;
	*** eventLoop;
	*** hashCode;
	*** localAddress;
	*** logger;
	*** parent;
	*** pipeline;
	*** registered;
	*** remoteAddress;
	*** strVal;
	*** strValActive;
	*** succeededFuture;
	*** unsafe;
	*** unsafeVoidPromise;
	*** voidPromise;
	io.netty.channel.AbstractChannel(io.netty.channel.Channel);
	*** access$002(io.netty.channel.AbstractChannel,io.netty.channel.EventLoop);
	*** access$200();
	*** access$300(io.netty.channel.AbstractChannel);
	*** access$400(io.netty.channel.AbstractChannel);
	*** access$402(io.netty.channel.AbstractChannel,boolean);
	*** access$500(io.netty.channel.AbstractChannel);
	*** access$600(io.netty.channel.AbstractChannel);
	*** alloc();
	*** compareTo(io.netty.channel.Channel);
	*** doBeginRead();
	*** doBind(java.net.SocketAddress);
	*** doClose();
	*** doDeregister();
	*** doDisconnect();
	*** doRegister();
	*** doWrite(io.netty.channel.ChannelOutboundBuffer);
	*** estimatorHandle();
	*** eventLoop();
	*** flush();
	*** isCompatible(io.netty.channel.EventLoop);
	*** isRegistered();
	*** localAddress();
	*** localAddress0();
	*** newPromise();
	*** newUnsafe();
	*** parent();
	*** pipeline();
	*** read();
	*** remoteAddress();
	*** remoteAddress0();
	*** unsafe();
	*** voidPromise();
}

-keep class io.netty.channel.AbstractChannel$AbstractUnsafe {
	*** inFlush0;
	*** outboundBuffer;
	*** this$0;
	io.netty.channel.AbstractChannel$AbstractUnsafe(io.netty.channel.AbstractChannel);
	*** access$100(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise);
	*** close(io.netty.channel.ChannelPromise);
	*** closeForcibly();
	*** closeIfClosed();
	*** deregister(io.netty.channel.ChannelPromise);
	*** ensureOpen(io.netty.channel.ChannelPromise);
	*** flush0();
	*** invokeLater(java.lang.Runnable);
	*** register0(io.netty.channel.ChannelPromise);
	*** voidPromise();
}

-keep class io.netty.channel.AbstractChannel$AbstractUnsafe$1 {
	*** this$1;
	*** val$promise;
}

-keep class io.netty.channel.AbstractChannel$AbstractUnsafe$2 {
	*** this$1;
}

-keep class io.netty.channel.AbstractChannel$AbstractUnsafe$4 {
	*** this$1;
	*** val$promise;
}

-keep class io.netty.channel.AbstractChannel$AbstractUnsafe$5 {
	*** this$1;
}

-keep class io.netty.channel.AbstractChannel$AbstractUnsafe$6 {
	*** this$1;
}

-keep class io.netty.channel.AbstractChannel$CloseFuture {
	*** this$0;
	*** setClosed();
	*** setFailure(java.lang.Throwable);
}

-keep class io.netty.channel.AdaptiveRecvByteBufAllocator {
	*** DEFAULT;
	*** SIZE_TABLE;
	*** initial;
	*** maxIndex;
	*** minIndex;
	io.netty.channel.AdaptiveRecvByteBufAllocator(int,int,int);
	*** access$000(int);
	*** access$100();
	*** getSizeTableIndex(int);
}

-keep class io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl {
	*** decreaseNow;
	*** index;
	*** maxIndex;
	*** minIndex;
	*** nextReceiveBufferSize;
}

-keep class io.netty.channel.Channel {
	*** closeFuture();
	*** config();
	*** eventLoop();
	*** flush();
	*** isActive();
	*** isOpen();
	*** isRegistered();
	*** isWritable();
	*** metadata();
	*** read();
	*** remoteAddress();
	*** unsafe();
}

-keep class io.netty.channel.Channel$Unsafe {
	*** beginRead();
	*** bind(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** close(io.netty.channel.ChannelPromise);
	*** closeForcibly();
	*** connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** deregister(io.netty.channel.ChannelPromise);
	*** disconnect(io.netty.channel.ChannelPromise);
	*** flush();
	*** localAddress();
	*** outboundBuffer();
	*** register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise);
	*** remoteAddress();
	*** voidPromise();
	*** write(java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.ChannelConfig {
	*** getAllocator();
	*** getConnectTimeoutMillis();
	*** getMaxMessagesPerRead();
	*** getMessageSizeEstimator();
	*** getOption(io.netty.channel.ChannelOption);
	*** getRecvByteBufAllocator();
	*** getWriteBufferHighWaterMark();
	*** getWriteBufferLowWaterMark();
	*** getWriteSpinCount();
	*** isAutoRead();
	*** setAutoRead(boolean);
	*** setOption(io.netty.channel.ChannelOption,java.lang.Object);
	*** setOptions(java.util.Map);
}

-keep class io.netty.channel.ChannelDuplexHandler {
	io.netty.channel.ChannelDuplexHandler();
}

-keep class io.netty.channel.ChannelException {
	io.netty.channel.ChannelException();
	io.netty.channel.ChannelException(java.lang.String);
	io.netty.channel.ChannelException(java.lang.String,java.lang.Throwable);
	io.netty.channel.ChannelException(java.lang.Throwable);
}

-keep class io.netty.channel.ChannelFuture {
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** awaitUninterruptibly();
	*** channel();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
}

-keep class io.netty.channel.ChannelFutureListener {
	*** CLOSE_ON_FAILURE;
}

-keep class io.netty.channel.ChannelFutureListener$1 {
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.channel.ChannelFutureListener$2 {
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.channel.ChannelFutureListener$3 {
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.channel.ChannelHandler {
	*** exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable);
	*** handlerAdded(io.netty.channel.ChannelHandlerContext);
	*** handlerRemoved(io.netty.channel.ChannelHandlerContext);
}

-keep class io.netty.channel.ChannelHandlerAdapter {
	*** added;
	io.netty.channel.ChannelHandlerAdapter();
	*** isSharable();
}

-keep class io.netty.channel.ChannelHandlerContext {
	*** channel();
	*** executor();
	*** fireChannelActive();
	*** fireChannelInactive();
	*** fireChannelRead(java.lang.Object);
	*** fireChannelReadComplete();
	*** fireChannelRegistered();
	*** fireChannelUnregistered();
	*** fireChannelWritabilityChanged();
	*** fireExceptionCaught(java.lang.Throwable);
	*** fireUserEventTriggered(java.lang.Object);
	*** flush();
	*** handler();
	*** isRemoved();
	*** name();
}

-keep class io.netty.channel.ChannelInboundHandler {
	*** channelActive(io.netty.channel.ChannelHandlerContext);
	*** channelInactive(io.netty.channel.ChannelHandlerContext);
	*** channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object);
	*** channelReadComplete(io.netty.channel.ChannelHandlerContext);
	*** channelRegistered(io.netty.channel.ChannelHandlerContext);
	*** channelUnregistered(io.netty.channel.ChannelHandlerContext);
	*** channelWritabilityChanged(io.netty.channel.ChannelHandlerContext);
	*** userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object);
}

-keep class io.netty.channel.ChannelInboundHandlerAdapter {
	io.netty.channel.ChannelInboundHandlerAdapter();
	*** channelActive(io.netty.channel.ChannelHandlerContext);
	*** channelInactive(io.netty.channel.ChannelHandlerContext);
	*** channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object);
	*** channelRegistered(io.netty.channel.ChannelHandlerContext);
	*** channelWritabilityChanged(io.netty.channel.ChannelHandlerContext);
	*** userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object);
}

-keep class io.netty.channel.ChannelInitializer {
	*** logger;
	io.netty.channel.ChannelInitializer();
	*** initChannel(io.netty.channel.Channel);
}

-keep class io.netty.channel.ChannelMetadata {
	*** hasDisconnect;
	*** hasDisconnect();
}

-keep class io.netty.channel.ChannelOption {
	*** AIO_READ_TIMEOUT;
	*** AIO_WRITE_TIMEOUT;
	*** ALLOCATOR;
	*** ALLOW_HALF_CLOSURE;
	*** AUTO_READ;
	*** CONNECT_TIMEOUT_MILLIS;
	*** IP_MULTICAST_ADDR;
	*** IP_MULTICAST_IF;
	*** IP_MULTICAST_LOOP_DISABLED;
	*** IP_MULTICAST_TTL;
	*** IP_TOS;
	*** MAX_MESSAGES_PER_READ;
	*** RCVBUF_ALLOCATOR;
	*** SO_BACKLOG;
	*** SO_BROADCAST;
	*** SO_KEEPALIVE;
	*** SO_LINGER;
	*** SO_RCVBUF;
	*** SO_REUSEADDR;
	*** SO_SNDBUF;
	*** SO_TIMEOUT;
	*** TCP_NODELAY;
	*** WRITE_BUFFER_HIGH_WATER_MARK;
	*** WRITE_BUFFER_LOW_WATER_MARK;
	*** WRITE_SPIN_COUNT;
	*** names;
	*** validate(java.lang.Object);
}

-keep class io.netty.channel.ChannelOutboundBuffer {
	*** RECYCLER;
	*** TOTAL_PENDING_SIZE_UPDATER;
	*** WRITABLE_UPDATER;
	*** channel;
	*** flushed;
	*** flushedPendingSizes;
	*** flushedProgresses;
	*** flushedPromises;
	*** flushedTotals;
	*** handle;
	*** head;
	*** inFail;
	*** logger;
	*** nioBufferCount;
	*** nioBufferSize;
	*** nioBuffers;
	*** tail;
	*** totalPendingSize;
	*** unflushed;
	*** unflushedCount;
	*** unflushedPendingSizes;
	*** unflushedPromises;
	*** unflushedTotals;
	*** writable;
	io.netty.channel.ChannelOutboundBuffer(io.netty.util.Recycler$Handle);
	io.netty.channel.ChannelOutboundBuffer(io.netty.util.Recycler$Handle,int);
	*** addFlush();
	*** addMessage(java.lang.Object,io.netty.channel.ChannelPromise);
	*** close(java.nio.channels.ClosedChannelException);
	*** current();
	*** decrementPendingOutboundBytes(int);
	*** doubleFlushedCapacity();
	*** doubleNioBufferArray(java.nio.ByteBuffer[],int);
	*** doubleUnflushedCapacity();
	*** failFlushed(java.lang.Throwable);
	*** getWritable();
	*** incrementPendingOutboundBytes(int);
	*** isEmpty();
	*** newInstance(io.netty.channel.AbstractChannel);
	*** nioBufferCount();
	*** nioBufferSize();
	*** nioBuffers();
	*** progress(long);
	*** remove();
	*** remove(java.lang.Throwable);
	*** safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable);
	*** safeRelease(java.lang.Object);
	*** size();
	*** total(java.lang.Object);
}

-keep class io.netty.channel.ChannelOutboundBuffer$1 {
	*** newObject(io.netty.util.Recycler$Handle);
}

-keep class io.netty.channel.ChannelOutboundHandler {
	*** bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise);
	*** connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise);
	*** disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise);
	*** flush(io.netty.channel.ChannelHandlerContext);
	*** read(io.netty.channel.ChannelHandlerContext);
	*** write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.ChannelOutboundHandlerAdapter {
	io.netty.channel.ChannelOutboundHandlerAdapter();
	*** write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.ChannelOutboundInvoker {
	*** bind(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** close();
	*** close(io.netty.channel.ChannelPromise);
	*** connect(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** deregister();
	*** deregister(io.netty.channel.ChannelPromise);
	*** disconnect();
	*** disconnect(io.netty.channel.ChannelPromise);
	*** read();
	*** write(java.lang.Object);
	*** write(java.lang.Object,io.netty.channel.ChannelPromise);
	*** writeAndFlush(java.lang.Object);
	*** writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.ChannelPipeline {
	*** addFirst(java.lang.String,io.netty.channel.ChannelHandler);
	*** addLast(io.netty.channel.ChannelHandler[]);
	*** addLast(java.lang.String,io.netty.channel.ChannelHandler);
	*** fireChannelActive();
	*** fireChannelRead(java.lang.Object);
	*** fireChannelReadComplete();
	*** fireChannelWritabilityChanged();
	*** fireExceptionCaught(java.lang.Throwable);
	*** fireUserEventTriggered(java.lang.Object);
	*** get(java.lang.String);
	*** remove(io.netty.channel.ChannelHandler);
	*** remove(java.lang.String);
}

-keep class io.netty.channel.ChannelPromise {
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** channel();
	*** setFailure(java.lang.Throwable);
	*** setSuccess();
	*** trySuccess();
}

-keep class io.netty.channel.ChannelPropertyAccess {
	*** alloc();
	*** newFailedFuture(java.lang.Throwable);
	*** newPromise();
	*** newSucceededFuture();
	*** pipeline();
}

-keep class io.netty.channel.CompleteChannelFuture {
	*** channel;
	io.netty.channel.CompleteChannelFuture(io.netty.channel.Channel,io.netty.util.concurrent.EventExecutor);
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** addListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** await();
	*** awaitUninterruptibly();
	*** channel();
	*** getNow();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
	*** removeListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** sync();
	*** syncUninterruptibly();
}

-keep class io.netty.channel.DefaultChannelConfig {
	*** DEFAULT_ALLOCATOR;
	*** DEFAULT_MSG_SIZE_ESTIMATOR;
	*** DEFAULT_RCVBUF_ALLOCATOR;
	*** allocator;
	*** autoRead;
	*** channel;
	*** connectTimeoutMillis;
	*** maxMessagesPerRead;
	*** msgSizeEstimator;
	*** rcvBufAllocator;
	*** writeBufferHighWaterMark;
	*** writeBufferLowWaterMark;
	*** writeSpinCount;
	io.netty.channel.DefaultChannelConfig(io.netty.channel.Channel);
	*** getAllocator();
	*** getConnectTimeoutMillis();
	*** getMaxMessagesPerRead();
	*** getOption(io.netty.channel.ChannelOption);
	*** getOptions();
	*** getOptions(java.util.Map,io.netty.channel.ChannelOption[]);
	*** getRecvByteBufAllocator();
	*** getWriteBufferHighWaterMark();
	*** getWriteBufferLowWaterMark();
	*** getWriteSpinCount();
	*** isAutoRead();
	*** setAllocator(io.netty.buffer.ByteBufAllocator);
	*** setAutoRead(boolean);
	*** setConnectTimeoutMillis(int);
	*** setMaxMessagesPerRead(int);
	*** setMessageSizeEstimator(io.netty.channel.MessageSizeEstimator);
	*** setOption(io.netty.channel.ChannelOption,java.lang.Object);
	*** setRecvByteBufAllocator(io.netty.channel.RecvByteBufAllocator);
	*** setWriteBufferHighWaterMark(int);
	*** setWriteBufferLowWaterMark(int);
	*** setWriteSpinCount(int);
	*** validate(io.netty.channel.ChannelOption,java.lang.Object);
}

-keep class io.netty.channel.DefaultChannelHandlerContext {
	*** channel;
	*** executor;
	*** handler;
	*** invokeChannelReadCompleteTask;
	*** invokeChannelWritableStateChangedTask;
	*** invokeFlushTask;
	*** invokeReadTask;
	*** name;
	*** next;
	*** pipeline;
	*** prev;
	*** removed;
	*** succeededFuture;
	*** access$1300(io.netty.channel.DefaultChannelHandlerContext,io.netty.channel.ChannelPromise);
	*** access$1500(io.netty.channel.DefaultChannelHandlerContext);
	*** access$1600(io.netty.channel.DefaultChannelHandlerContext);
	*** access$1900(io.netty.channel.DefaultChannelHandlerContext);
	*** access$2000(io.netty.channel.DefaultChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise);
	*** bind(java.net.SocketAddress);
	*** bind(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** channel();
	*** close();
	*** close(io.netty.channel.ChannelPromise);
	*** connect(java.net.SocketAddress);
	*** connect(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** connect(java.net.SocketAddress,java.net.SocketAddress);
	*** connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** deregister();
	*** deregister(io.netty.channel.ChannelPromise);
	*** disconnect();
	*** disconnect(io.netty.channel.ChannelPromise);
	*** executor();
	*** findContextInbound();
	*** findContextOutbound();
	*** fireChannelActive();
	*** fireChannelInactive();
	*** fireChannelRead(java.lang.Object);
	*** fireChannelReadComplete();
	*** fireChannelRegistered();
	*** fireChannelUnregistered();
	*** fireChannelWritabilityChanged();
	*** fireExceptionCaught(java.lang.Throwable);
	*** fireUserEventTriggered(java.lang.Object);
	*** flush();
	*** handler();
	*** inExceptionCaught(java.lang.Throwable);
	*** invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** invokeChannelActive();
	*** invokeChannelInactive();
	*** invokeChannelRead(java.lang.Object);
	*** invokeChannelReadComplete();
	*** invokeChannelRegistered();
	*** invokeChannelUnregistered();
	*** invokeChannelWritabilityChanged();
	*** invokeClose(io.netty.channel.ChannelPromise);
	*** invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** invokeDeregister(io.netty.channel.ChannelPromise);
	*** invokeDisconnect(io.netty.channel.ChannelPromise);
	*** invokeExceptionCaught(java.lang.Throwable);
	*** invokeFlush();
	*** invokeRead();
	*** invokeUserEventTriggered(java.lang.Object);
	*** invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise);
	*** name();
	*** newPromise();
	*** notifyHandlerException(java.lang.Throwable);
	*** notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise);
	*** read();
	*** setRemoved();
	*** submitWriteTask(io.netty.channel.DefaultChannelHandlerContext,io.netty.util.concurrent.EventExecutor,java.lang.Object,boolean,io.netty.channel.ChannelPromise);
	*** teardown();
	*** teardown0();
	*** validatePromise(io.netty.channel.ChannelPromise,boolean);
	*** write(java.lang.Object);
	*** write(java.lang.Object,io.netty.channel.ChannelPromise);
	*** writeAndFlush(java.lang.Object);
	*** writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.DefaultChannelHandlerContext$14 {
	*** this$0;
	*** val$next;
	*** val$promise;
}

-keep class io.netty.channel.DefaultChannelHandlerContext$16 {
	*** this$0;
	*** val$next;
}

-keep class io.netty.channel.DefaultChannelHandlerContext$WriteTask {
	*** RECYCLER;
	*** ctx;
	*** flush;
	*** handle;
	*** msg;
	*** promise;
	*** size;
	io.netty.channel.DefaultChannelHandlerContext$WriteTask(io.netty.util.Recycler$Handle);
	*** access$1700(io.netty.channel.DefaultChannelHandlerContext,java.lang.Object,int,boolean,io.netty.channel.ChannelPromise);
	*** newInstance(io.netty.channel.DefaultChannelHandlerContext,java.lang.Object,int,boolean,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.DefaultChannelHandlerContext$WriteTask$1 {
	*** newObject(io.netty.util.Recycler$Handle);
}

-keep class io.netty.channel.DefaultChannelPipeline {
	*** $assertionsDisabled;
	*** channel;
	*** childExecutors;
	*** head;
	*** logger;
	*** name2ctx;
	*** nameCaches;
	*** tail;
	*** addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler);
	*** addAfter0(java.lang.String,io.netty.channel.DefaultChannelHandlerContext,io.netty.channel.DefaultChannelHandlerContext);
	*** addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler);
	*** addBefore0(java.lang.String,io.netty.channel.DefaultChannelHandlerContext,io.netty.channel.DefaultChannelHandlerContext);
	*** addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[]);
	*** addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler);
	*** addFirst0(java.lang.String,io.netty.channel.DefaultChannelHandlerContext);
	*** addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[]);
	*** addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler);
	*** addLast0(java.lang.String,io.netty.channel.DefaultChannelHandlerContext);
	*** bind(java.net.SocketAddress);
	*** bind(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** callHandlerAdded(io.netty.channel.ChannelHandlerContext);
	*** callHandlerAdded0(io.netty.channel.ChannelHandlerContext);
	*** callHandlerRemoved(io.netty.channel.DefaultChannelHandlerContext);
	*** callHandlerRemoved0(io.netty.channel.DefaultChannelHandlerContext);
	*** checkDuplicateName(java.lang.String);
	*** checkMultiplicity(io.netty.channel.ChannelHandlerContext);
	*** close();
	*** close(io.netty.channel.ChannelPromise);
	*** connect(java.net.SocketAddress);
	*** connect(java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** connect(java.net.SocketAddress,java.net.SocketAddress);
	*** connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise);
	*** context(io.netty.channel.ChannelHandler);
	*** context(java.lang.Class);
	*** context(java.lang.String);
	*** deregister();
	*** deregister(io.netty.channel.ChannelPromise);
	*** disconnect();
	*** disconnect(io.netty.channel.ChannelPromise);
	*** fireChannelActive();
	*** fireChannelInactive();
	*** fireChannelRead(java.lang.Object);
	*** fireChannelReadComplete();
	*** fireChannelRegistered();
	*** fireChannelUnregistered();
	*** fireChannelWritabilityChanged();
	*** fireExceptionCaught(java.lang.Throwable);
	*** fireUserEventTriggered(java.lang.Object);
	*** firstContext();
	*** flush();
	*** generateName(io.netty.channel.ChannelHandler);
	*** getContextOrDie(io.netty.channel.ChannelHandler);
	*** getContextOrDie(java.lang.Class);
	*** getContextOrDie(java.lang.String);
	*** read();
	*** remove(io.netty.channel.DefaultChannelHandlerContext);
	*** remove0(io.netty.channel.DefaultChannelHandlerContext);
	*** replace(io.netty.channel.DefaultChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler);
	*** replace0(io.netty.channel.DefaultChannelHandlerContext,java.lang.String,io.netty.channel.DefaultChannelHandlerContext);
	*** teardownAll();
	*** toMap();
	*** waitForFuture(java.util.concurrent.Future);
	*** write(java.lang.Object);
	*** write(java.lang.Object,io.netty.channel.ChannelPromise);
	*** writeAndFlush(java.lang.Object);
	*** writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.DefaultChannelPipeline$HeadHandler {
	*** unsafe;
}

-keep class io.netty.channel.DefaultChannelPromise {
	*** channel;
	*** checkpoint;
	io.netty.channel.DefaultChannelPromise(io.netty.channel.Channel);
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** addListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** await();
	*** awaitUninterruptibly();
	*** channel();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
	*** removeListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** setFailure(java.lang.Throwable);
	*** setSuccess(java.lang.Void);
	*** sync();
	*** syncUninterruptibly();
	*** trySuccess();
}

-keep class io.netty.channel.DefaultMessageSizeEstimator {
	*** DEFAULT;
	*** handle;
}

-keep class io.netty.channel.DefaultMessageSizeEstimator$HandleImpl {
	*** unknownSize;
	io.netty.channel.DefaultMessageSizeEstimator$HandleImpl(int);
}

-keep class io.netty.channel.EventLoopGroup {
	*** register(io.netty.channel.Channel);
	*** register(io.netty.channel.Channel,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.FileRegion {
	*** count();
	*** transferTo(java.nio.channels.WritableByteChannel,long);
	*** transfered();
}

-keep class io.netty.channel.MessageSizeEstimator {
	*** newHandle();
}

-keep class io.netty.channel.MessageSizeEstimator$Handle {
	*** size(java.lang.Object);
}

-keep class io.netty.channel.MultithreadEventLoopGroup {
	*** DEFAULT_EVENT_LOOP_THREADS;
	*** logger;
	io.netty.channel.MultithreadEventLoopGroup(int,java.util.concurrent.ThreadFactory,java.lang.Object[]);
	*** next();
}

-keep class io.netty.channel.RecvByteBufAllocator {
	*** newHandle();
}

-keep class io.netty.channel.RecvByteBufAllocator$Handle {
	*** allocate(io.netty.buffer.ByteBufAllocator);
	*** record(int);
}

-keep class io.netty.channel.SimpleChannelInboundHandler {
	*** autoRelease;
	*** matcher;
	io.netty.channel.SimpleChannelInboundHandler();
	io.netty.channel.SimpleChannelInboundHandler(boolean);
	io.netty.channel.SimpleChannelInboundHandler(java.lang.Class,boolean);
	*** acceptInboundMessage(java.lang.Object);
	*** channelRead0(io.netty.channel.ChannelHandlerContext,java.lang.Object);
}

-keep class io.netty.channel.SingleThreadEventLoop {
	io.netty.channel.SingleThreadEventLoop(io.netty.channel.EventLoopGroup,java.util.concurrent.ThreadFactory,boolean);
	*** next();
	*** parent();
	*** register(io.netty.channel.Channel,io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.VoidChannelPromise {
	*** channel;
	*** fireException;
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** addListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** await();
	*** awaitUninterruptibly();
	*** fail();
	*** fireException(java.lang.Throwable);
	*** getNow();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
	*** removeListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** setFailure(java.lang.Throwable);
	*** setSuccess();
	*** setSuccess(java.lang.Void);
	*** sync();
	*** syncUninterruptibly();
	*** trySuccess(java.lang.Void);
}

-keep class io.netty.channel.group.ChannelGroup {
	*** close();
	*** name();
}

-keep class io.netty.channel.group.ChannelGroupException {
	*** failed;
}

-keep class io.netty.channel.group.ChannelGroupFuture {
	*** isSuccess();
	*** iterator();
}

-keep class io.netty.channel.group.ChannelMatcher {
	*** matches(io.netty.channel.Channel);
}

-keep class io.netty.channel.group.ChannelMatchers {
	*** ALL_MATCHER;
	*** NON_SERVER_CHANNEL_MATCHER;
	*** SERVER_CHANNEL_MATCHER;
	*** all();
	*** invert(io.netty.channel.group.ChannelMatcher);
	*** is(io.netty.channel.Channel);
	*** isInstanceOf(java.lang.Class);
	*** isNotInstanceOf(java.lang.Class);
}

-keep class io.netty.channel.group.ChannelMatchers$ClassMatcher {
	*** clazz;
}

-keep class io.netty.channel.group.ChannelMatchers$InvertMatcher {
	*** matcher;
}

-keep class io.netty.channel.group.DefaultChannelGroup {
	*** executor;
	*** name;
	*** nextId;
	*** nonServerChannels;
	*** remover;
	*** serverChannels;
	io.netty.channel.group.DefaultChannelGroup(java.lang.String,io.netty.util.concurrent.EventExecutor);
	*** add(io.netty.channel.Channel);
	*** close(io.netty.channel.group.ChannelMatcher);
	*** compareTo(io.netty.channel.group.ChannelGroup);
	*** deregister(io.netty.channel.group.ChannelMatcher);
	*** disconnect(io.netty.channel.group.ChannelMatcher);
	*** flush(io.netty.channel.group.ChannelMatcher);
	*** flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher);
	*** name();
	*** remove(java.lang.Object);
	*** safeDuplicate(java.lang.Object);
	*** size();
	*** write(java.lang.Object,io.netty.channel.group.ChannelMatcher);
}

-keep class io.netty.channel.group.DefaultChannelGroup$1 {
	*** this$0;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.channel.group.DefaultChannelGroupFuture {
	*** childListener;
	*** failureCount;
	*** futures;
	*** group;
	*** successCount;
	*** access$000(io.netty.channel.group.DefaultChannelGroupFuture);
	*** access$008(io.netty.channel.group.DefaultChannelGroupFuture);
	*** access$100(io.netty.channel.group.DefaultChannelGroupFuture);
	*** access$108(io.netty.channel.group.DefaultChannelGroupFuture);
	*** access$200(io.netty.channel.group.DefaultChannelGroupFuture);
	*** access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException);
	*** access$400(io.netty.channel.group.DefaultChannelGroupFuture);
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** addListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** await();
	*** awaitUninterruptibly();
	*** cause();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
	*** removeListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** setFailure(java.lang.Throwable);
	*** setFailure0(io.netty.channel.group.ChannelGroupException);
	*** setSuccess(java.lang.Void);
	*** setSuccess0();
	*** sync();
	*** syncUninterruptibly();
	*** trySuccess(java.lang.Void);
}

-keep class io.netty.channel.group.DefaultChannelGroupFuture$1 {
	*** $assertionsDisabled;
	*** this$0;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.channel.nio.AbstractNioByteChannel {
	io.netty.channel.nio.AbstractNioByteChannel(io.netty.channel.Channel,java.nio.channels.SelectableChannel);
	*** clearOpWrite();
	*** doReadBytes(io.netty.buffer.ByteBuf);
	*** doWrite(io.netty.channel.ChannelOutboundBuffer);
	*** doWriteBytes(io.netty.buffer.ByteBuf);
	*** doWriteFileRegion(io.netty.channel.FileRegion);
	*** newUnsafe();
	*** setOpWrite();
}

-keep class io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe {
	*** $assertionsDisabled;
	*** allocHandle;
	*** this$0;
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe(io.netty.channel.nio.AbstractNioByteChannel);
}

-keep class io.netty.channel.nio.AbstractNioChannel {
	*** $assertionsDisabled;
	*** ch;
	*** connectPromise;
	*** connectTimeoutFuture;
	*** inputShutdown;
	*** logger;
	*** readInterestOp;
	*** requestedRemoteAddress;
	*** selectionKey;
	*** writableTasks;
	io.netty.channel.nio.AbstractNioChannel(io.netty.channel.Channel,java.nio.channels.SelectableChannel,int);
	*** access$000(io.netty.channel.nio.AbstractNioChannel);
	*** access$002(io.netty.channel.nio.AbstractNioChannel,io.netty.channel.ChannelPromise);
	*** access$100(io.netty.channel.nio.AbstractNioChannel);
	*** access$102(io.netty.channel.nio.AbstractNioChannel,java.net.SocketAddress);
	*** access$200(io.netty.channel.nio.AbstractNioChannel);
	*** access$202(io.netty.channel.nio.AbstractNioChannel,java.util.concurrent.ScheduledFuture);
	*** access$300(io.netty.channel.nio.AbstractNioChannel);
	*** doConnect(java.net.SocketAddress,java.net.SocketAddress);
	*** doFinishConnect();
	*** eventLoop();
	*** isFlushPending();
	*** isInputShutdown();
	*** isOpen();
	*** javaChannel();
	*** selectionKey();
	*** setInputShutdown();
	*** unsafe();
}

-keep class io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe {
	*** $assertionsDisabled;
	*** this$0;
	io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe(io.netty.channel.nio.AbstractNioChannel);
}

-keep class io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1 {
	*** this$1;
	*** val$remoteAddress;
}

-keep class io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2 {
	*** this$1;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.channel.nio.AbstractNioChannel$NioUnsafe {
	*** finishConnect();
	*** forceFlush();
	*** read();
}

-keep class io.netty.channel.nio.AbstractNioMessageChannel {
	io.netty.channel.nio.AbstractNioMessageChannel(io.netty.channel.Channel,java.nio.channels.SelectableChannel,int);
	*** doReadMessages(java.util.List);
	*** doWriteMessage(java.lang.Object);
	*** newUnsafe();
}

-keep class io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe {
	*** $assertionsDisabled;
	*** readBuf;
	*** this$0;
	io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.nio.AbstractNioMessageChannel);
}

-keep class io.netty.channel.nio.NioEventLoop {
	*** DISABLE_KEYSET_OPTIMIZATION;
	*** SELECTOR_AUTO_REBUILD_THRESHOLD;
	*** cancelledKeys;
	*** ioRatio;
	*** logger;
	*** needsToSelectAgain;
	*** oldWakenUp;
	*** provider;
	*** selectedKeys;
	*** selector;
	*** wakenUp;
	*** cancel(java.nio.channels.SelectionKey);
	*** closeAll();
	*** invokeChannelUnregistered(io.netty.channel.nio.NioTask,java.nio.channels.SelectionKey,java.lang.Throwable);
	*** openSelector();
	*** processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel);
	*** processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.NioTask);
	*** processSelectedKeysOptimized(java.nio.channels.SelectionKey[]);
	*** processSelectedKeysPlain(java.util.Set);
	*** processWritable(io.netty.channel.nio.AbstractNioChannel);
	*** rebuildSelector();
	*** select();
	*** selectAgain();
	*** selectNow();
	*** setIoRatio(int);
	*** unregisterWritableTasks(io.netty.channel.nio.AbstractNioChannel);
}

-keep class io.netty.channel.nio.NioEventLoopGroup {
	io.netty.channel.nio.NioEventLoopGroup(int);
	io.netty.channel.nio.NioEventLoopGroup(int,java.util.concurrent.ThreadFactory);
	io.netty.channel.nio.NioEventLoopGroup(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider);
	*** setIoRatio(int);
}

-keep class io.netty.channel.nio.NioTask {
	*** channelReady(java.nio.channels.SelectableChannel,java.nio.channels.SelectionKey);
	*** channelUnregistered(java.nio.channels.SelectableChannel,java.lang.Throwable);
}

-keep class io.netty.channel.nio.SelectedSelectionKeySet {
	*** isA;
	*** keysA;
	*** keysASize;
	*** keysB;
	*** keysBSize;
	*** add(java.nio.channels.SelectionKey);
	*** doubleCapacityA();
	*** doubleCapacityB();
	*** flip();
}

-keep class io.netty.channel.socket.ChannelInputShutdownEvent {
	*** INSTANCE;
}

-keep class io.netty.channel.socket.DefaultServerSocketChannelConfig {
	*** backlog;
	*** javaSocket;
	*** getBacklog();
	*** getReceiveBufferSize();
	*** isReuseAddress();
	*** setAllocator(io.netty.buffer.ByteBufAllocator);
	*** setAutoRead(boolean);
	*** setBacklog(int);
	*** setConnectTimeoutMillis(int);
	*** setMaxMessagesPerRead(int);
	*** setMessageSizeEstimator(io.netty.channel.MessageSizeEstimator);
	*** setReceiveBufferSize(int);
	*** setRecvByteBufAllocator(io.netty.channel.RecvByteBufAllocator);
	*** setReuseAddress(boolean);
	*** setWriteBufferHighWaterMark(int);
	*** setWriteBufferLowWaterMark(int);
	*** setWriteSpinCount(int);
}

-keep class io.netty.channel.socket.DefaultSocketChannelConfig {
	*** allowHalfClosure;
	*** javaSocket;
	*** getReceiveBufferSize();
	*** getSendBufferSize();
	*** getSoLinger();
	*** getTrafficClass();
	*** isAllowHalfClosure();
	*** isKeepAlive();
	*** isReuseAddress();
	*** isTcpNoDelay();
	*** setAllocator(io.netty.buffer.ByteBufAllocator);
	*** setAllowHalfClosure(boolean);
	*** setAutoRead(boolean);
	*** setConnectTimeoutMillis(int);
	*** setKeepAlive(boolean);
	*** setMaxMessagesPerRead(int);
	*** setMessageSizeEstimator(io.netty.channel.MessageSizeEstimator);
	*** setReceiveBufferSize(int);
	*** setRecvByteBufAllocator(io.netty.channel.RecvByteBufAllocator);
	*** setReuseAddress(boolean);
	*** setSendBufferSize(int);
	*** setSoLinger(int);
	*** setTcpNoDelay(boolean);
	*** setTrafficClass(int);
	*** setWriteBufferHighWaterMark(int);
	*** setWriteBufferLowWaterMark(int);
	*** setWriteSpinCount(int);
}

-keep class io.netty.channel.socket.ServerSocketChannelConfig {
	*** getBacklog();
}

-keep class io.netty.channel.socket.nio.NioServerSocketChannel {
	*** METADATA;
	*** config;
	*** logger;
	*** config();
	*** javaChannel();
	*** localAddress();
	*** newSocket();
	*** remoteAddress();
}

-keep class io.netty.channel.socket.nio.NioSocketChannel {
	*** METADATA;
	*** config;
	*** logger;
	io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.Channel,java.nio.channels.SocketChannel);
	io.netty.channel.socket.nio.NioSocketChannel(java.nio.channels.SocketChannel);
	*** config();
	*** doClose();
	*** isActive();
	*** javaChannel();
	*** localAddress();
	*** newSocket();
	*** parent();
	*** remoteAddress();
	*** shutdownOutput(io.netty.channel.ChannelPromise);
}

-keep class io.netty.channel.udt.nio.NioUdtAcceptorChannel {
	*** javaChannel();
}

-keep class io.netty.channel.udt.nio.NioUdtByteConnectorChannel {
	*** javaChannel();
}

-keep class io.netty.channel.udt.nio.NioUdtMessageConnectorChannel {
	*** javaChannel();
}

-keep class io.netty.channel.udt.nio.NioUdtProvider {
	*** BYTE_ACCEPTOR;
	*** BYTE_CONNECTOR;
	*** BYTE_PROVIDER;
	*** BYTE_RENDEZVOUS;
	*** MESSAGE_ACCEPTOR;
	*** MESSAGE_CONNECTOR;
	*** MESSAGE_PROVIDER;
	*** MESSAGE_RENDEZVOUS;
	*** kind;
	*** type;
	*** channelUDT(io.netty.channel.Channel);
	*** newChannel();
}

-keep class io.netty.channel.udt.nio.NioUdtProvider$1 {
	*** $SwitchMap$com$barchart$udt$TypeUDT;
	*** $SwitchMap$com$barchart$udt$nio$KindUDT;
}

-keep class io.netty.handler.codec.ByteToMessageDecoder {
	*** cumulation;
	*** decodeWasNull;
	*** singleDecode;
	io.netty.handler.codec.ByteToMessageDecoder();
	*** actualReadableBytes();
	*** callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List);
	*** channelInactive(io.netty.channel.ChannelHandlerContext);
	*** decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List);
	*** decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List);
	*** handlerRemoved0(io.netty.channel.ChannelHandlerContext);
	*** internalBuffer();
	*** isSingleDecode();
}

-keep class io.netty.handler.codec.CodecException {
	io.netty.handler.codec.CodecException();
	io.netty.handler.codec.CodecException(java.lang.String);
	io.netty.handler.codec.CodecException(java.lang.String,java.lang.Throwable);
	io.netty.handler.codec.CodecException(java.lang.Throwable);
}

-keep class io.netty.handler.codec.DecoderException {
	io.netty.handler.codec.DecoderException();
	io.netty.handler.codec.DecoderException(java.lang.String);
	io.netty.handler.codec.DecoderException(java.lang.String,java.lang.Throwable);
	io.netty.handler.codec.DecoderException(java.lang.Throwable);
}

-keep class io.netty.handler.codec.DecoderResult {
	*** SIGNAL_SUCCESS;
	*** SIGNAL_UNFINISHED;
	*** SUCCESS;
	*** UNFINISHED;
	*** cause;
	*** cause();
	*** failure(java.lang.Throwable);
	*** isFailure();
	*** isFinished();
	*** isSuccess();
}

-keep class io.netty.handler.codec.MessageToMessageEncoder {
	*** matcher;
	io.netty.handler.codec.MessageToMessageEncoder();
	*** acceptOutboundMessage(java.lang.Object);
	*** encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List);
}

-keep class io.netty.handler.codec.ReplayingDecoder {
	*** REPLAY;
	*** checkpoint;
	*** replayable;
	*** state;
	io.netty.handler.codec.ReplayingDecoder(java.lang.Object);
	*** callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List);
	*** checkpoint();
	*** checkpoint(java.lang.Object);
	*** state();
	*** state(java.lang.Object);
}

-keep class io.netty.handler.codec.ReplayingDecoderBuffer {
	*** EMPTY_BUFFER;
	*** REPLAY;
	*** buffer;
	*** swapped;
	*** terminated;
	*** capacity();
	*** checkIndex(int,int);
	*** checkReadableBytes(int);
	*** compareTo(io.netty.buffer.ByteBuf);
	*** order();
	*** readerIndex();
	*** reject();
	*** retain();
	*** retain(int);
	*** setCumulation(io.netty.buffer.ByteBuf);
	*** terminate();
	*** writerIndex();
}

-keep class io.netty.handler.codec.http.DefaultFullHttpRequest {
	*** content;
	*** trailingHeader;
	io.netty.handler.codec.http.DefaultFullHttpRequest(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpMethod,java.lang.String,io.netty.buffer.ByteBuf);
	*** content();
	*** copy();
	*** duplicate();
	*** retain();
	*** retain(int);
	*** setMethod(io.netty.handler.codec.http.HttpMethod);
	*** setProtocolVersion(io.netty.handler.codec.http.HttpVersion);
	*** setUri(java.lang.String);
	*** trailingHeaders();
}

-keep class io.netty.handler.codec.http.DefaultFullHttpResponse {
	*** content;
	*** trailingHeaders;
	io.netty.handler.codec.http.DefaultFullHttpResponse(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpResponseStatus,io.netty.buffer.ByteBuf);
	*** content();
	*** copy();
	*** duplicate();
	*** retain();
	*** retain(int);
	*** setProtocolVersion(io.netty.handler.codec.http.HttpVersion);
	*** setStatus(io.netty.handler.codec.http.HttpResponseStatus);
	*** trailingHeaders();
}

-keep class io.netty.handler.codec.http.DefaultHttpContent {
	*** content;
	io.netty.handler.codec.http.DefaultHttpContent(io.netty.buffer.ByteBuf);
	*** content();
	*** copy();
	*** duplicate();
	*** retain();
	*** retain(int);
	*** toString();
}

-keep class io.netty.handler.codec.http.DefaultHttpHeaders {
	*** entries;
	*** head;
	io.netty.handler.codec.http.DefaultHttpHeaders();
	*** add0(int,int,java.lang.String,java.lang.String);
	*** entries();
	*** eq(java.lang.String,java.lang.String);
	*** get(java.lang.String);
	*** hash(java.lang.String);
	*** index(int);
	*** remove0(int,int,java.lang.String);
	*** toString(java.lang.Object);
	*** validateHeaderName0(java.lang.String);
}

-keep class io.netty.handler.codec.http.DefaultHttpHeaders$HeaderEntry {
	*** after;
	*** before;
	*** hash;
	*** key;
	*** next;
	*** value;
	*** addBefore(io.netty.handler.codec.http.DefaultHttpHeaders$HeaderEntry);
	*** getKey();
	*** getValue();
	*** remove();
	*** setValue(java.lang.String);
}

-keep class io.netty.handler.codec.http.DefaultHttpMessage {
	*** headers;
	*** version;
	io.netty.handler.codec.http.DefaultHttpMessage(io.netty.handler.codec.http.HttpVersion);
	*** appendHeaders(java.lang.StringBuilder);
	*** getProtocolVersion();
	*** headers();
	*** setProtocolVersion(io.netty.handler.codec.http.HttpVersion);
}

-keep class io.netty.handler.codec.http.DefaultHttpObject {
	*** decoderResult;
	io.netty.handler.codec.http.DefaultHttpObject();
	*** getDecoderResult();
}

-keep class io.netty.handler.codec.http.DefaultHttpRequest {
	*** method;
	*** uri;
	io.netty.handler.codec.http.DefaultHttpRequest(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpMethod,java.lang.String);
	*** getMethod();
	*** getUri();
	*** setMethod(io.netty.handler.codec.http.HttpMethod);
	*** setProtocolVersion(io.netty.handler.codec.http.HttpVersion);
	*** setUri(java.lang.String);
}

-keep class io.netty.handler.codec.http.DefaultHttpResponse {
	*** status;
	io.netty.handler.codec.http.DefaultHttpResponse(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpResponseStatus);
	*** getStatus();
	*** setProtocolVersion(io.netty.handler.codec.http.HttpVersion);
	*** setStatus(io.netty.handler.codec.http.HttpResponseStatus);
}

-keep class io.netty.handler.codec.http.DefaultLastHttpContent {
	*** trailingHeaders;
	io.netty.handler.codec.http.DefaultLastHttpContent(io.netty.buffer.ByteBuf);
	*** appendHeaders(java.lang.StringBuilder);
	*** copy();
	*** duplicate();
	*** retain();
	*** retain(int);
	*** trailingHeaders();
}

-keep class io.netty.handler.codec.http.DefaultLastHttpContent$1 {
	*** this$0;
}

-keep class io.netty.handler.codec.http.HttpHeaderDateFormat {
	*** get();
}

-keep class io.netty.handler.codec.http.HttpHeaders {
	*** EMPTY_HEADERS;
	io.netty.handler.codec.http.HttpHeaders();
	*** add(java.lang.String,java.lang.Object);
	*** addHeader(io.netty.handler.codec.http.HttpMessage,java.lang.String,java.lang.Object);
	*** clear();
	*** contains(java.lang.String);
	*** get(java.lang.String);
	*** getAll(java.lang.String);
	*** getContentLength(io.netty.handler.codec.http.HttpMessage,long);
	*** getDateHeader(io.netty.handler.codec.http.HttpMessage,java.lang.String);
	*** getDateHeader(io.netty.handler.codec.http.HttpMessage,java.lang.String,java.util.Date);
	*** getHeader(io.netty.handler.codec.http.HttpMessage,java.lang.String);
	*** getHeader(io.netty.handler.codec.http.HttpMessage,java.lang.String,java.lang.String);
	*** getWebSocketContentLength(io.netty.handler.codec.http.HttpMessage);
	*** is100ContinueExpected(io.netty.handler.codec.http.HttpMessage);
	*** isEmpty();
	*** isKeepAlive(io.netty.handler.codec.http.HttpMessage);
	*** isTransferEncodingChunked(io.netty.handler.codec.http.HttpMessage);
	*** names();
	*** remove(java.lang.String);
	*** removeHeader(io.netty.handler.codec.http.HttpMessage,java.lang.String);
	*** removeTransferEncodingChunked(io.netty.handler.codec.http.HttpMessage);
	*** set(io.netty.handler.codec.http.HttpHeaders);
	*** set(java.lang.String,java.lang.Iterable);
	*** set(java.lang.String,java.lang.Object);
	*** set100ContinueExpected(io.netty.handler.codec.http.HttpMessage,boolean);
	*** validateHeaderName(java.lang.String);
	*** validateHeaderValue(java.lang.String);
}

-keep class io.netty.handler.codec.http.HttpHeaders$1 {
	*** entries();
}

-keep class io.netty.handler.codec.http.HttpMessage {
	*** getProtocolVersion();
	*** headers();
}

-keep class io.netty.handler.codec.http.HttpMethod {
	*** CONNECT;
	*** DELETE;
	*** GET;
	*** HEAD;
	*** OPTIONS;
	*** PATCH;
	*** POST;
	*** PUT;
	*** TRACE;
	*** methodMap;
	*** name;
	*** compareTo(io.netty.handler.codec.http.HttpMethod);
	*** equals(java.lang.Object);
	*** name();
	*** toString();
	*** valueOf(java.lang.String);
}

-keep class io.netty.handler.codec.http.HttpObject {
	*** setDecoderResult(io.netty.handler.codec.DecoderResult);
}

-keep class io.netty.handler.codec.http.HttpObjectDecoder {
	*** $assertionsDisabled;
	*** BUILDERS;
	*** chunkSize;
	*** chunkedSupported;
	*** content;
	*** contentRead;
	*** headerSize;
	*** maxChunkSize;
	*** maxHeaderSize;
	*** maxInitialLineLength;
	*** message;
	io.netty.handler.codec.http.HttpObjectDecoder();
	io.netty.handler.codec.http.HttpObjectDecoder(int,int,int,boolean);
	*** createInvalidMessage();
	*** createMessage(java.lang.String[]);
	*** decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List);
	*** findEndOfString(java.lang.CharSequence);
	*** findNonWhitespace(java.lang.CharSequence,int);
	*** findWhitespace(java.lang.CharSequence,int);
	*** getChunkSize(java.lang.String);
	*** invalidChunk(java.lang.Exception);
	*** invalidMessage(java.lang.Exception);
	*** isContentAlwaysEmpty(io.netty.handler.codec.http.HttpMessage);
	*** isDecodingRequest();
	*** readFixedLengthContent(io.netty.buffer.ByteBuf,java.util.List);
	*** readHeader(io.netty.buffer.ByteBuf);
	*** readHeaders(io.netty.buffer.ByteBuf);
	*** readLine(io.netty.buffer.ByteBuf,int);
	*** readTrailingHeaders(io.netty.buffer.ByteBuf);
	*** reset();
	*** reset(java.util.List);
	*** skipControlCharacters(io.netty.buffer.ByteBuf);
	*** splitHeader(java.lang.StringBuilder);
	*** splitInitialLine(java.lang.StringBuilder);
}

-keep class io.netty.handler.codec.http.HttpObjectDecoder$1 {
	*** get();
	*** initialValue();
}

-keep class io.netty.handler.codec.http.HttpObjectDecoder$2 {
	*** $SwitchMap$io$netty$handler$codec$http$HttpObjectDecoder$State;
}

-keep class io.netty.handler.codec.http.HttpObjectDecoder$State {
	*** $VALUES;
	*** BAD_MESSAGE;
	*** READ_CHUNKED_CONTENT;
	*** READ_CHUNKED_CONTENT_AS_CHUNKS;
	*** READ_CHUNK_DELIMITER;
	*** READ_CHUNK_FOOTER;
	*** READ_CHUNK_SIZE;
	*** READ_FIXED_LENGTH_CONTENT;
	*** READ_FIXED_LENGTH_CONTENT_AS_CHUNKS;
	*** READ_HEADER;
	*** READ_INITIAL;
	*** READ_VARIABLE_LENGTH_CONTENT;
	*** READ_VARIABLE_LENGTH_CONTENT_AS_CHUNKS;
	*** SKIP_CONTROL_CHARS;
	*** values();
}

-keep class io.netty.handler.codec.http.HttpObjectEncoder {
	*** CRLF;
	*** HEADER_SEPARATOR;
	*** ZERO_CRLF;
	*** ZERO_CRLF_CRLF;
	*** state;
	io.netty.handler.codec.http.HttpObjectEncoder();
	*** acceptOutboundMessage(java.lang.Object);
	*** contentLength(java.lang.Object);
	*** encodeAndRetain(java.lang.Object);
	*** encodeAscii(java.lang.String,io.netty.buffer.ByteBuf);
	*** encodeHeader(io.netty.buffer.ByteBuf,java.lang.String,java.lang.String);
	*** encodeHeaders(io.netty.buffer.ByteBuf,io.netty.handler.codec.http.HttpHeaders);
	*** encodeInitialLine(io.netty.buffer.ByteBuf,io.netty.handler.codec.http.HttpMessage);
}

-keep class io.netty.handler.codec.http.HttpRequest {
	*** getMethod();
	*** getUri();
	*** setUri(java.lang.String);
}

-keep class io.netty.handler.codec.http.HttpRequestEncoder {
	*** CRLF;
	*** encodeInitialLine(io.netty.buffer.ByteBuf,io.netty.handler.codec.http.HttpRequest);
}

-keep class io.netty.handler.codec.http.HttpResponse {
	*** getStatus();
	*** setProtocolVersion(io.netty.handler.codec.http.HttpVersion);
}

-keep class io.netty.handler.codec.http.HttpResponseDecoder {
	*** UNKNOWN_STATUS;
	io.netty.handler.codec.http.HttpResponseDecoder(int,int,int);
}

-keep class io.netty.handler.codec.http.HttpResponseEncoder {
	*** CRLF;
	*** encodeInitialLine(io.netty.buffer.ByteBuf,io.netty.handler.codec.http.HttpResponse);
}

-keep class io.netty.handler.codec.http.HttpResponseStatus {
	*** ACCEPTED;
	*** BAD_GATEWAY;
	*** BAD_REQUEST;
	*** CONFLICT;
	*** CONTINUE;
	*** CREATED;
	*** EXPECTATION_FAILED;
	*** FAILED_DEPENDENCY;
	*** FORBIDDEN;
	*** FOUND;
	*** GATEWAY_TIMEOUT;
	*** GONE;
	*** HTTP_VERSION_NOT_SUPPORTED;
	*** INSUFFICIENT_STORAGE;
	*** INTERNAL_SERVER_ERROR;
	*** LENGTH_REQUIRED;
	*** LOCKED;
	*** METHOD_NOT_ALLOWED;
	*** MOVED_PERMANENTLY;
	*** MULTIPLE_CHOICES;
	*** MULTI_STATUS;
	*** NETWORK_AUTHENTICATION_REQUIRED;
	*** NON_AUTHORITATIVE_INFORMATION;
	*** NOT_ACCEPTABLE;
	*** NOT_EXTENDED;
	*** NOT_FOUND;
	*** NOT_IMPLEMENTED;
	*** NOT_MODIFIED;
	*** NO_CONTENT;
	*** OK;
	*** PARTIAL_CONTENT;
	*** PAYMENT_REQUIRED;
	*** PRECONDITION_FAILED;
	*** PRECONDITION_REQUIRED;
	*** PROCESSING;
	*** PROXY_AUTHENTICATION_REQUIRED;
	*** REQUESTED_RANGE_NOT_SATISFIABLE;
	*** REQUEST_ENTITY_TOO_LARGE;
	*** REQUEST_HEADER_FIELDS_TOO_LARGE;
	*** REQUEST_TIMEOUT;
	*** REQUEST_URI_TOO_LONG;
	*** RESET_CONTENT;
	*** SEE_OTHER;
	*** SERVICE_UNAVAILABLE;
	*** SWITCHING_PROTOCOLS;
	*** TEMPORARY_REDIRECT;
	*** TOO_MANY_REQUESTS;
	*** UNAUTHORIZED;
	*** UNORDERED_COLLECTION;
	*** UNPROCESSABLE_ENTITY;
	*** UNSUPPORTED_MEDIA_TYPE;
	*** UPGRADE_REQUIRED;
	*** USE_PROXY;
	*** VARIANT_ALSO_NEGOTIATES;
	*** code;
	*** reasonPhrase;
	*** code();
	*** compareTo(io.netty.handler.codec.http.HttpResponseStatus);
	*** reasonPhrase();
	*** toString();
}

-keep class io.netty.handler.codec.http.HttpVersion {
	*** HTTP_1_0;
	*** HTTP_1_1;
	*** VERSION_PATTERN;
	*** keepAliveDefault;
	*** majorVersion;
	*** minorVersion;
	*** protocolName;
	*** text;
	*** compareTo(io.netty.handler.codec.http.HttpVersion);
	*** isKeepAliveDefault();
	*** majorVersion();
	*** minorVersion();
	*** protocolName();
	*** text();
	*** toString();
	*** valueOf(java.lang.String);
	*** version0(java.lang.String);
}

-keep class io.netty.handler.codec.http.LastHttpContent {
	*** EMPTY_LAST_CONTENT;
	*** trailingHeaders();
}

-keep class io.netty.handler.codec.http.LastHttpContent$1 {
	*** copy();
	*** duplicate();
	*** retain();
	*** retain(int);
}

-keep class io.netty.handler.ssl.SslHandler {
	*** $assertionsDisabled;
	*** CHANNEL_CLOSED;
	*** HANDSHAKE_TIMED_OUT;
	*** IGNORABLE_CLASS_IN_STACK;
	*** IGNORABLE_ERROR_MESSAGE;
	*** SSLENGINE_CLOSED;
	*** closeNotifyTimeoutMillis;
	*** ctx;
	*** decodeOut;
	*** delegatedTaskExecutor;
	*** engine;
	*** handshakePromise;
	*** handshakeTimeoutMillis;
	*** logger;
	*** packetLength;
	*** pendingUnencryptedWrites;
	*** sentFirstMessage;
	*** sslCloseFuture;
	*** startTls;
	io.netty.handler.ssl.SslHandler(javax.net.ssl.SSLEngine,boolean,java.util.concurrent.Executor);
	io.netty.handler.ssl.SslHandler(javax.net.ssl.SSLEngine,java.util.concurrent.Executor);
	*** access$200();
	*** access$300(io.netty.handler.ssl.SslHandler);
	*** access$400();
	*** access$500(io.netty.handler.ssl.SslHandler,java.lang.Throwable);
	*** access$600(io.netty.handler.ssl.SslHandler);
	*** close(io.netty.channel.ChannelPromise);
	*** closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean);
	*** flush(io.netty.channel.ChannelHandlerContext);
	*** flush0(io.netty.channel.ChannelHandlerContext);
	*** flushNonAppData0(io.netty.channel.ChannelHandlerContext,boolean);
	*** getEncryptedPacketLength(io.netty.buffer.ByteBuf);
	*** handshake0();
	*** handshakeFuture();
	*** ignoreException(java.lang.Throwable);
	*** notifyHandshakeFailure(java.lang.Throwable);
	*** runDelegatedTasks();
	*** safeClose(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise);
	*** setCloseNotifyTimeoutMillis(long);
	*** setHandshakeFailure(java.lang.Throwable);
	*** setHandshakeSuccess();
	*** setHandshakeTimeoutMillis(long);
	*** unwrap(io.netty.channel.ChannelHandlerContext);
	*** unwrap(io.netty.channel.ChannelHandlerContext,java.nio.ByteBuffer,java.util.List);
	*** unwrap(javax.net.ssl.SSLEngine,java.nio.ByteBuffer,io.netty.buffer.ByteBuf);
	*** wrap(javax.net.ssl.SSLEngine,io.netty.buffer.ByteBuf,io.netty.buffer.ByteBuf);
	*** write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise);
}

-keep class io.netty.handler.ssl.SslHandler$2 {
	*** this$0;
}

-keep class io.netty.handler.ssl.SslHandler$3 {
	*** this$0;
	*** val$timeoutFuture;
}

-keep class io.netty.handler.ssl.SslHandler$5 {
	*** this$0;
	*** val$ctx;
	*** val$promise;
}

-keep class io.netty.handler.ssl.SslHandler$6 {
	*** this$0;
	*** val$ctx;
	*** val$promise;
	*** val$timeoutFuture;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.handler.ssl.SslHandler$7 {
	*** $SwitchMap$javax$net$ssl$SSLEngineResult$HandshakeStatus;
	*** $SwitchMap$javax$net$ssl$SSLEngineResult$Status;
}

-keep class io.netty.handler.ssl.SslHandler$LazyChannelPromise {
	*** this$0;
	io.netty.handler.ssl.SslHandler$LazyChannelPromise(io.netty.handler.ssl.SslHandler);
}

-keep class io.netty.handler.ssl.SslHandshakeCompletionEvent {
	*** SUCCESS;
	*** cause;
}

-keep class io.netty.handler.timeout.IdleState {
	*** $VALUES;
	*** ALL_IDLE;
	*** READER_IDLE;
	*** WRITER_IDLE;
}

-keep class io.netty.handler.timeout.IdleStateEvent {
	*** ALL_IDLE_STATE_EVENT;
	*** FIRST_ALL_IDLE_STATE_EVENT;
	*** FIRST_READER_IDLE_STATE_EVENT;
	*** FIRST_WRITER_IDLE_STATE_EVENT;
	*** READER_IDLE_STATE_EVENT;
	*** WRITER_IDLE_STATE_EVENT;
	*** first;
	*** state;
}

-keep class io.netty.handler.timeout.IdleStateHandler {
	*** allIdleTimeMillis;
	*** allIdleTimeout;
	*** firstAllIdleEvent;
	*** firstReaderIdleEvent;
	*** firstWriterIdleEvent;
	*** lastReadTime;
	*** lastWriteTime;
	*** readerIdleTimeMillis;
	*** readerIdleTimeout;
	*** state;
	*** writerIdleTimeMillis;
	*** writerIdleTimeout;
	io.netty.handler.timeout.IdleStateHandler(long,long,long,java.util.concurrent.TimeUnit);
	*** access$002(io.netty.handler.timeout.IdleStateHandler,boolean);
	*** access$100(io.netty.handler.timeout.IdleStateHandler);
	*** access$102(io.netty.handler.timeout.IdleStateHandler,boolean);
	*** access$500(io.netty.handler.timeout.IdleStateHandler);
	*** channelIdle(io.netty.channel.ChannelHandlerContext,io.netty.handler.timeout.IdleStateEvent);
	*** destroy();
	*** initialize(io.netty.channel.ChannelHandlerContext);
}

-keep class io.netty.handler.timeout.IdleStateHandler$1 {
	*** this$0;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class io.netty.handler.timeout.IdleStateHandler$AllIdleTimeoutTask {
	*** ctx;
	*** this$0;
}

-keep class io.netty.util.Attribute {
	*** set(java.lang.Object);
}

-keep class io.netty.util.AttributeMap {
	*** attr(io.netty.util.AttributeKey);
}

-keep class io.netty.util.CharsetUtil {
	*** ISO_8859_1;
	*** US_ASCII;
	*** UTF_16;
	*** UTF_16BE;
	*** UTF_16LE;
	*** UTF_8;
	*** decoders;
	*** encoders;
}

-keep class io.netty.util.CharsetUtil$1 {
	*** initialValue();
}

-keep class io.netty.util.CharsetUtil$2 {
	*** initialValue();
}

-keep class io.netty.util.DefaultAttributeMap {
	*** map;
	*** updater;
	io.netty.util.DefaultAttributeMap();
}

-keep class io.netty.util.IllegalReferenceCountException {
	io.netty.util.IllegalReferenceCountException(java.lang.String);
}

-keep class io.netty.util.NetUtil {
	*** LOCALHOST;
	*** LOCALHOST4;
	*** LOCALHOST6;
	*** LOOPBACK_IF;
	*** SOMAXCONN;
	*** logger;
	*** convertToBytes(java.lang.String,byte[],int);
	*** getIntValue(char);
	*** isValidHexChar(char);
	*** isValidIp4Word(java.lang.String);
	*** isValidIpV4Address(java.lang.String);
	*** isValidIpV6Address(java.lang.String);
}

-keep class io.netty.util.Recycler {
	*** threadLocal;
	io.netty.util.Recycler();
	*** get();
	*** newObject(io.netty.util.Recycler$Handle);
	*** recycle(java.lang.Object,io.netty.util.Recycler$Handle);
}

-keep class io.netty.util.Recycler$1 {
	*** this$0;
	*** initialValue();
}

-keep class io.netty.util.Recycler$Stack {
	*** elements;
	*** map;
	*** parent;
	*** size;
	*** thread;
	*** newArray(int);
	*** pop();
	*** push(java.lang.Object);
}

-keep class io.netty.util.ReferenceCountUtil {
	*** release(java.lang.Object);
	*** retain(java.lang.Object);
}

-keep class io.netty.util.ReferenceCounted {
	*** refCnt();
	*** release();
	*** release(int);
	*** retain();
	*** retain(int);
}

-keep class io.netty.util.ResourceLeak {
	*** close();
}

-keep class io.netty.util.ResourceLeakDetector {
	*** active;
	*** disabled;
	*** head;
	*** leakCheckCnt;
	*** loggedTooManyActive;
	*** logger;
	*** maxActive;
	*** refQueue;
	*** reportedLeaks;
	*** resourceType;
	*** samplingInterval;
	*** tail;
	io.netty.util.ResourceLeakDetector(java.lang.String);
	io.netty.util.ResourceLeakDetector(java.lang.String,int,long);
	*** access$300(io.netty.util.ResourceLeakDetector);
	*** access$400(io.netty.util.ResourceLeakDetector);
	*** access$508(io.netty.util.ResourceLeakDetector);
	*** access$510(io.netty.util.ResourceLeakDetector);
	*** open(java.lang.Object);
	*** reportLeak();
}

-keep class io.netty.util.ResourceLeakDetector$DefaultResourceLeak {
	*** exception;
	*** freed;
	*** next;
	*** prev;
	*** this$0;
	*** access$002(io.netty.util.ResourceLeakDetector$DefaultResourceLeak,io.netty.util.ResourceLeakDetector$DefaultResourceLeak);
	*** access$102(io.netty.util.ResourceLeakDetector$DefaultResourceLeak,io.netty.util.ResourceLeakDetector$DefaultResourceLeak);
	*** access$200(io.netty.util.ResourceLeakDetector$DefaultResourceLeak);
	*** close();
}

-keep class io.netty.util.ResourceLeakException {
	*** cachedStackTrace;
}

-keep class io.netty.util.Signal {
	*** map;
	*** uname;
	*** expect(io.netty.util.Signal);
}

-keep class io.netty.util.Timer$$EnhancerByMockitoWithCGLIB$$1ec383d4 {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$clone$4$Method;
	*** CGLIB$clone$4$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$1$Method;
	*** CGLIB$equals$1$Proxy;
	*** CGLIB$finalize$0$Method;
	*** CGLIB$finalize$0$Proxy;
	*** CGLIB$hashCode$3$Method;
	*** CGLIB$hashCode$3$Proxy;
	*** CGLIB$newTimeout$6$Method;
	*** CGLIB$newTimeout$6$Proxy;
	*** CGLIB$stop$5$Method;
	*** CGLIB$stop$5$Proxy;
	*** CGLIB$toString$2$Method;
	*** CGLIB$toString$2$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK4();
}

-keep class io.netty.util.UniqueName {
	*** id;
	*** name;
	*** nextId;
	io.netty.util.UniqueName(java.util.concurrent.ConcurrentMap,java.lang.String,java.lang.Object[]);
	*** compareTo(io.netty.util.UniqueName);
	*** name();
	*** validateArgs(java.lang.Object[]);
}

-keep class io.netty.util.concurrent.AbstractEventExecutor {
	io.netty.util.concurrent.AbstractEventExecutor();
	*** inEventLoop();
	*** next();
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** shutdown();
	*** submit(java.lang.Runnable);
	*** submit(java.lang.Runnable,java.lang.Object);
	*** submit(java.util.concurrent.Callable);
}

-keep class io.netty.util.concurrent.AbstractEventExecutorGroup {
	io.netty.util.concurrent.AbstractEventExecutorGroup();
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** shutdown();
	*** submit(java.lang.Runnable);
	*** submit(java.lang.Runnable,java.lang.Object);
	*** submit(java.util.concurrent.Callable);
}

-keep class io.netty.util.concurrent.AbstractFuture {
	io.netty.util.concurrent.AbstractFuture();
}

-keep class io.netty.util.concurrent.CompleteFuture {
	*** executor;
	io.netty.util.concurrent.CompleteFuture(io.netty.util.concurrent.EventExecutor);
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** addListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** executor();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
	*** removeListeners(io.netty.util.concurrent.GenericFutureListener[]);
}

-keep class io.netty.util.concurrent.DefaultFutureListeners {
	*** listeners;
	*** progressiveSize;
	*** size;
	*** add(io.netty.util.concurrent.GenericFutureListener);
	*** listeners();
	*** progressiveSize();
	*** remove(io.netty.util.concurrent.GenericFutureListener);
	*** size();
}

-keep class io.netty.util.concurrent.DefaultPromise {
	*** LISTENER_STACK_DEPTH;
	*** SUCCESS;
	*** UNCANCELLABLE;
	*** executor;
	*** listeners;
	*** logger;
	*** result;
	*** waiters;
	io.netty.util.concurrent.DefaultPromise();
	io.netty.util.concurrent.DefaultPromise(io.netty.util.concurrent.EventExecutor);
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** addListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** await();
	*** await0(long,boolean);
	*** awaitUninterruptibly();
	*** cancel(boolean);
	*** cause();
	*** checkDeadLock();
	*** decWaiters();
	*** executor();
	*** hasWaiters();
	*** incWaiters();
	*** isCancelled();
	*** isCancelled0(java.lang.Object);
	*** isDone();
	*** isDone0(java.lang.Object);
	*** notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener);
	*** notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener);
	*** notifyListeners();
	*** notifyListeners0(io.netty.util.concurrent.Future,io.netty.util.concurrent.DefaultFutureListeners);
	*** notifyProgressiveListener0(io.netty.util.concurrent.ProgressiveFuture,io.netty.util.concurrent.GenericProgressiveFutureListener,long,long);
	*** notifyProgressiveListeners0(io.netty.util.concurrent.ProgressiveFuture,io.netty.util.concurrent.GenericProgressiveFutureListener[],long,long);
	*** progressiveListeners();
	*** removeListener(io.netty.util.concurrent.GenericFutureListener);
	*** removeListeners(io.netty.util.concurrent.GenericFutureListener[]);
	*** rethrowIfFailed();
	*** setFailure(java.lang.Throwable);
	*** setFailure0(java.lang.Throwable);
	*** setSuccess(java.lang.Object);
	*** setSuccess0(java.lang.Object);
	*** setUncancellable();
	*** sync();
	*** syncUninterruptibly();
	*** toString();
	*** toStringBuilder();
	*** tryFailure(java.lang.Throwable);
	*** trySuccess(java.lang.Object);
}

-keep class io.netty.util.concurrent.DefaultPromise$1 {
	*** initialValue();
}

-keep class io.netty.util.concurrent.DefaultPromise$3 {
	*** this$0;
	*** val$l;
}

-keep class io.netty.util.concurrent.DefaultPromise$4 {
	*** val$future;
	*** val$l;
}

-keep class io.netty.util.concurrent.DefaultPromise$CauseHolder {
	*** cause;
	io.netty.util.concurrent.DefaultPromise$CauseHolder(java.lang.Throwable);
}

-keep class io.netty.util.concurrent.DefaultThreadFactory {
	*** daemon;
	*** nextId;
	*** poolId;
	*** prefix;
	*** priority;
	io.netty.util.concurrent.DefaultThreadFactory(java.lang.Class,boolean,int);
	io.netty.util.concurrent.DefaultThreadFactory(java.lang.String,boolean,int);
	*** toPoolName(java.lang.Class);
}

-keep class io.netty.util.concurrent.EventExecutor {
	*** inEventLoop();
	*** inEventLoop(java.lang.Thread);
}

-keep class io.netty.util.concurrent.EventExecutorGroup {
	*** isShuttingDown();
	*** next();
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** shutdown();
	*** shutdownGracefully();
	*** shutdownGracefully(long,long,java.util.concurrent.TimeUnit);
	*** submit(java.lang.Runnable);
	*** submit(java.lang.Runnable,java.lang.Object);
	*** submit(java.util.concurrent.Callable);
	*** terminationFuture();
}

-keep class io.netty.util.concurrent.FailedFuture {
	*** cause;
}

-keep class io.netty.util.concurrent.Future {
	*** addListener(io.netty.util.concurrent.GenericFutureListener);
	*** await();
	*** await(long,java.util.concurrent.TimeUnit);
	*** awaitUninterruptibly(long);
	*** cause();
	*** getNow();
	*** isSuccess();
}

-keep class io.netty.util.concurrent.GenericFutureListener {
	*** operationComplete(io.netty.util.concurrent.Future);
}

-keep class io.netty.util.concurrent.GenericProgressiveFutureListener {
	*** operationProgressed(io.netty.util.concurrent.ProgressiveFuture,long,long);
}

-keep class io.netty.util.concurrent.GlobalEventExecutor {
	*** INSTANCE;
	*** SCHEDULE_PURGE_INTERVAL;
	*** delayedTaskQueue;
	*** logger;
	*** purgeTask;
	*** state;
	*** stateLock;
	*** taskQueue;
	*** taskRunner;
	*** terminationFuture;
	*** thread;
	*** threadFactory;
	*** access$100();
	*** access$200(io.netty.util.concurrent.GlobalEventExecutor);
	*** access$302(io.netty.util.concurrent.GlobalEventExecutor,int);
	*** addTask(java.lang.Runnable);
	*** execute(java.lang.Runnable);
	*** fetchFromDelayedQueue();
	*** schedule(io.netty.util.concurrent.ScheduledFutureTask);
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** startThread();
	*** takeTask();
	*** terminationFuture();
}

-keep class io.netty.util.concurrent.GlobalEventExecutor$PurgeTask {
	*** this$0;
	io.netty.util.concurrent.GlobalEventExecutor$PurgeTask(io.netty.util.concurrent.GlobalEventExecutor);
}

-keep class io.netty.util.concurrent.GlobalEventExecutor$TaskRunner {
	*** this$0;
}

-keep class io.netty.util.concurrent.ImmediateEventExecutor {
	*** INSTANCE;
	*** terminationFuture;
	*** terminationFuture();
}

-keep class io.netty.util.concurrent.ImmediateExecutor {
	*** INSTANCE;
}

-keep class io.netty.util.concurrent.MultithreadEventExecutorGroup {
	*** childIndex;
	*** children;
	*** terminatedChildren;
	*** terminationFuture;
	io.netty.util.concurrent.MultithreadEventExecutorGroup(int,java.util.concurrent.ThreadFactory,java.lang.Object[]);
	*** access$000(io.netty.util.concurrent.MultithreadEventExecutorGroup);
	*** access$100(io.netty.util.concurrent.MultithreadEventExecutorGroup);
	*** access$200(io.netty.util.concurrent.MultithreadEventExecutorGroup);
	*** children();
	*** isTerminated();
	*** newChild(java.util.concurrent.ThreadFactory,java.lang.Object[]);
	*** newDefaultThreadFactory();
	*** next();
	*** terminationFuture();
}

-keep class io.netty.util.concurrent.MultithreadEventExecutorGroup$1 {
	*** this$0;
}

-keep class io.netty.util.concurrent.ProgressivePromise {
	*** tryProgress(long,long);
}

-keep class io.netty.util.concurrent.Promise {
	*** setFailure(java.lang.Throwable);
	*** setSuccess(java.lang.Object);
	*** tryFailure(java.lang.Throwable);
}

-keep class io.netty.util.concurrent.PromiseTask {
	*** task;
	io.netty.util.concurrent.PromiseTask(io.netty.util.concurrent.EventExecutor,java.util.concurrent.Callable);
	*** setFailureInternal(java.lang.Throwable);
	*** setSuccessInternal(java.lang.Object);
	*** setUncancellableInternal();
	*** toCallable(java.lang.Runnable,java.lang.Object);
	*** toStringBuilder();
}

-keep class io.netty.util.concurrent.PromiseTask$RunnableAdapter {
	*** result;
	*** task;
}

-keep class io.netty.util.concurrent.ScheduledFutureTask {
	*** $assertionsDisabled;
	*** START_TIME;
	*** deadlineNanos;
	*** delayedTaskQueue;
	*** id;
	*** nextTaskId;
	*** periodNanos;
	io.netty.util.concurrent.ScheduledFutureTask(io.netty.util.concurrent.EventExecutor,java.util.Queue,java.util.concurrent.Callable,long);
	*** compareTo(java.util.concurrent.Delayed);
	*** deadlineNanos();
	*** deadlineNanos(long);
	*** delayNanos();
	*** delayNanos(long);
	*** executor();
	*** nanoTime();
}

-keep class io.netty.util.concurrent.SingleThreadEventExecutor {
	*** $assertionsDisabled;
	*** SCHEDULE_PURGE_INTERVAL;
	*** WAKEUP_TASK;
	*** addTaskWakesUp;
	*** delayedTaskQueue;
	*** gracefulShutdownQuietPeriod;
	*** gracefulShutdownStartTime;
	*** gracefulShutdownTimeout;
	*** lastExecutionTime;
	*** logger;
	*** parent;
	*** shutdownHooks;
	*** state;
	*** stateLock;
	*** taskQueue;
	*** terminationFuture;
	*** thread;
	*** threadLock;
	io.netty.util.concurrent.SingleThreadEventExecutor(io.netty.util.concurrent.EventExecutorGroup,java.util.concurrent.ThreadFactory,boolean);
	*** access$000();
	*** access$100(io.netty.util.concurrent.SingleThreadEventExecutor);
	*** access$102(io.netty.util.concurrent.SingleThreadEventExecutor,int);
	*** access$200(io.netty.util.concurrent.SingleThreadEventExecutor);
	*** access$300(io.netty.util.concurrent.SingleThreadEventExecutor);
	*** access$400(io.netty.util.concurrent.SingleThreadEventExecutor);
	*** access$500(io.netty.util.concurrent.SingleThreadEventExecutor);
	*** access$600(io.netty.util.concurrent.SingleThreadEventExecutor);
	*** addTask(java.lang.Runnable);
	*** cancelDelayedTasks();
	*** cleanup();
	*** confirmShutdown();
	*** delayNanos(long);
	*** execute(java.lang.Runnable);
	*** fetchFromDelayedQueue();
	*** hasTasks();
	*** isShutdown();
	*** isShuttingDown();
	*** isTerminated();
	*** newTaskQueue();
	*** parent();
	*** pollTask();
	*** reject();
	*** removeTask(java.lang.Runnable);
	*** run();
	*** runAllTasks();
	*** runAllTasks(long);
	*** runShutdownHooks();
	*** schedule(io.netty.util.concurrent.ScheduledFutureTask);
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** startThread();
	*** terminationFuture();
	*** updateLastExecutionTime();
	*** wakeup(boolean);
}

-keep class io.netty.util.concurrent.SingleThreadEventExecutor$2 {
	*** this$0;
}

-keep class io.netty.util.concurrent.SingleThreadEventExecutor$PurgeTask {
	*** this$0;
	io.netty.util.concurrent.SingleThreadEventExecutor$PurgeTask(io.netty.util.concurrent.SingleThreadEventExecutor);
}

-keep class io.netty.util.internal.ConcurrentSet {
	*** map;
	*** add(java.lang.Object);
	*** clear();
	*** contains(java.lang.Object);
	*** iterator();
	*** remove(java.lang.Object);
	*** size();
}

-keep class io.netty.util.internal.EmptyArrays {
	*** EMPTY_BOOLEANS;
	*** EMPTY_BYTES;
	*** EMPTY_BYTE_BUFFERS;
	*** EMPTY_DOUBLES;
	*** EMPTY_FLOATS;
	*** EMPTY_INTS;
	*** EMPTY_LONGS;
	*** EMPTY_OBJECTS;
	*** EMPTY_SHORTS;
	*** EMPTY_STACK_TRACE;
	*** EMPTY_STRINGS;
}

-keep class io.netty.util.internal.JavassistTypeParameterMatcherGenerator {
	*** classPool;
	*** logger;
	*** generate(java.lang.Class);
	*** generate(java.lang.Class,java.lang.ClassLoader);
	*** typeName(java.lang.Class);
}

-keep class io.netty.util.internal.PendingWrite {
	*** RECYCLER;
	*** handle;
	*** msg;
	*** promise;
	io.netty.util.internal.PendingWrite(io.netty.util.Recycler$Handle);
	*** failAndRecycle(java.lang.Throwable);
	*** msg();
	*** newInstance(java.lang.Object,io.netty.util.concurrent.Promise);
	*** recycle();
	*** recycleAndGet();
}

-keep class io.netty.util.internal.PendingWrite$1 {
	*** newObject(io.netty.util.Recycler$Handle);
}

-keep class io.netty.util.internal.PlatformDependent {
	*** ARRAY_BASE_OFFSET;
	*** CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;
	*** CAN_USE_CHM_V8;
	*** DIRECT_BUFFER_PREFERRED;
	*** HAS_JAVASSIST;
	*** HAS_UNSAFE;
	*** IS_ANDROID;
	*** IS_ROOT;
	*** IS_WINDOWS;
	*** JAVA_VERSION;
	*** MAX_DIRECT_MEMORY;
	*** MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN;
	*** logger;
	*** arrayBaseOffset0();
	*** canEnableTcpNoDelayByDefault();
	*** copyMemory(byte[],int,long,long);
	*** copyMemory(long,byte[],int,long);
	*** copyMemory(long,long,long);
	*** directBufferAddress(java.nio.ByteBuffer);
	*** directBufferPreferred();
	*** freeDirectBuffer(java.nio.ByteBuffer);
	*** getByte(long);
	*** getInt(java.lang.Object,long);
	*** getInt(long);
	*** getLong(long);
	*** getShort(long);
	*** hasJavassist();
	*** hasJavassist0();
	*** hasUnsafe();
	*** hasUnsafe0();
	*** isAndroid();
	*** isAndroid0();
	*** isRoot();
	*** isRoot0();
	*** isWindows();
	*** isWindows0();
	*** javaVersion();
	*** javaVersion0();
	*** maxDirectMemory0();
	*** newConcurrentHashMap();
	*** objectFieldOffset(java.lang.reflect.Field);
	*** putByte(long,byte);
	*** putInt(long,int);
	*** putLong(long,long);
	*** putShort(long,short);
	*** throwException(java.lang.Throwable);
	*** throwException0(java.lang.Throwable);
}

-keep class io.netty.util.internal.PlatformDependent0 {
	*** ADDRESS_FIELD_OFFSET;
	*** BIG_ENDIAN;
	*** CLEANER_FIELD_OFFSET;
	*** UNALIGNED;
	*** UNSAFE;
	*** logger;
	*** arrayBaseOffset();
	*** copyMemory(java.lang.Object,long,java.lang.Object,long,long);
	*** copyMemory(long,long,long);
	*** directBufferAddress(java.nio.ByteBuffer);
	*** freeDirectBuffer(java.nio.ByteBuffer);
	*** getByte(long);
	*** getInt(java.lang.Object,long);
	*** getInt(long);
	*** getLong(java.lang.Object,long);
	*** getLong(long);
	*** getObject(java.lang.Object,long);
	*** getShort(long);
	*** hasUnsafe();
	*** objectFieldOffset(java.lang.reflect.Field);
	*** putByte(long,byte);
	*** putInt(long,int);
	*** putLong(long,long);
	*** putShort(long,short);
	*** throwException(java.lang.Throwable);
}

-keep class io.netty.util.internal.RecyclableArrayList {
	*** RECYCLER;
	*** handle;
	io.netty.util.internal.RecyclableArrayList(io.netty.util.Recycler$Handle);
	io.netty.util.internal.RecyclableArrayList(io.netty.util.Recycler$Handle,int);
	*** add(java.lang.Object);
	*** checkNullElements(java.util.Collection);
	*** newInstance();
	*** newInstance(int);
	*** recycle();
}

-keep class io.netty.util.internal.RecyclableArrayList$1 {
	*** newObject(io.netty.util.Recycler$Handle);
}

-keep class io.netty.util.internal.StringUtil {
	*** NEWLINE;
	*** simpleClassName(java.lang.Class);
	*** simpleClassName(java.lang.Object);
}

-keep class io.netty.util.internal.SystemPropertyUtil {
	*** INTEGER_PATTERN;
	*** initializedLogger;
	*** loggedException;
	*** logger;
	*** contains(java.lang.String);
	*** get(java.lang.String);
	*** get(java.lang.String,java.lang.String);
	*** getBoolean(java.lang.String,boolean);
	*** getInt(java.lang.String,int);
	*** log(java.lang.String);
	*** log(java.lang.String,java.lang.Exception);
}

-keep class io.netty.util.internal.ThreadLocalRandom {
	*** initialized;
	*** localRandom;
	*** rnd;
	*** current();
	*** next(int);
	*** nextLong(long);
}

-keep class io.netty.util.internal.ThreadLocalRandom$1 {
	*** initialValue();
}

-keep class io.netty.util.internal.TypeParameterMatcher {
	*** NOOP;
	*** TEST_OBJECT;
	*** findCache;
	*** getCache;
	io.netty.util.internal.TypeParameterMatcher();
	*** fail(java.lang.Class,java.lang.String);
	*** find(java.lang.Object,java.lang.Class,java.lang.String);
	*** find0(java.lang.Object,java.lang.Class,java.lang.String);
	*** get(java.lang.Class);
	*** match(java.lang.Object);
}

-keep class io.netty.util.internal.TypeParameterMatcher$1 {
	*** initialValue();
}

-keep class io.netty.util.internal.TypeParameterMatcher$2 {
	*** initialValue();
}

-keep class io.netty.util.internal.TypeParameterMatcher$ReflectiveMatcher {
	*** type;
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8 {
	*** ABASE;
	*** ASHIFT;
	*** BASECOUNT;
	*** CELLSBUSY;
	*** CELLVALUE;
	*** NCPU;
	*** SIZECTL;
	*** TRANSFERINDEX;
	*** TRANSFERORIGIN;
	*** U;
	*** baseCount;
	*** cellsBusy;
	*** counterCells;
	*** counterHashCodeGenerator;
	*** entrySet;
	*** keySet;
	*** nextTable;
	*** serialPersistentFields;
	*** sizeCtl;
	*** table;
	*** threadCounterHashCode;
	*** transferIndex;
	*** transferOrigin;
	*** values;
	io.netty.util.internal.chmv8.ConcurrentHashMapV8(int,float,int);
	*** access$000();
	*** addCount(long,int);
	*** batchFor(long);
	*** casTabAt(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],int,io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node,io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node);
	*** clear();
	*** comparableClassFor(java.lang.Object);
	*** compareComparables(java.lang.Class,java.lang.Object,java.lang.Object);
	*** containsKey(java.lang.Object);
	*** containsValue(java.lang.Object);
	*** fullAddCount(long,io.netty.util.internal.chmv8.ConcurrentHashMapV8$CounterHashCode,boolean);
	*** get(java.lang.Object);
	*** getUnsafe();
	*** helpTransfer(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node);
	*** initTable();
	*** isEmpty();
	*** keySet();
	*** mappingCount();
	*** putAll(java.util.Map);
	*** putVal(java.lang.Object,java.lang.Object,boolean);
	*** remove(java.lang.Object);
	*** remove(java.lang.Object,java.lang.Object);
	*** replaceNode(java.lang.Object,java.lang.Object,java.lang.Object);
	*** setTabAt(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],int,io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node);
	*** size();
	*** spread(int);
	*** sumCount();
	*** tabAt(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],int);
	*** tableSizeFor(int);
	*** transfer(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[]);
	*** treeifyBin(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],int);
	*** tryPresize(int);
	*** untreeify(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$1 {
	*** run();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$Action {
	*** apply(java.lang.Object);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$BaseIterator {
	*** lastReturned;
	*** map;
	io.netty.util.internal.chmv8.ConcurrentHashMapV8$BaseIterator(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],int,int,int,io.netty.util.internal.chmv8.ConcurrentHashMapV8);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$BiAction {
	*** apply(java.lang.Object,java.lang.Object);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$BiFun {
	*** apply(java.lang.Object,java.lang.Object);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$CollectionView {
	*** map;
	io.netty.util.internal.chmv8.ConcurrentHashMapV8$CollectionView(io.netty.util.internal.chmv8.ConcurrentHashMapV8);
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** getMap();
	*** iterator();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$CounterCell {
	*** value;
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$CounterHashCode {
	*** code;
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$EntrySetView {
	*** add(java.util.Map$Entry);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$ForwardingNode {
	*** nextTable;
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$Fun {
	*** apply(java.lang.Object);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$KeyIterator {
	*** next();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$KeySetView {
	*** value;
	*** iterator();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node {
	*** hash;
	*** key;
	*** next;
	*** val;
	io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node(int,java.lang.Object,java.lang.Object,io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node);
	*** find(int,java.lang.Object);
	*** hashCode();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$Segment {
	*** loadFactor;
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$Traverser {
	*** baseIndex;
	*** baseLimit;
	*** baseSize;
	*** index;
	*** next;
	*** tab;
	io.netty.util.internal.chmv8.ConcurrentHashMapV8$Traverser(io.netty.util.internal.chmv8.ConcurrentHashMapV8$Node[],int,int,int);
	*** advance();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeBin {
	*** $assertionsDisabled;
	*** LOCKSTATE;
	*** U;
	*** first;
	*** lockState;
	*** root;
	*** waiter;
	*** balanceDeletion(io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode,io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode);
	*** balanceInsertion(io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode,io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode);
	*** checkInvariants(io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode);
	*** contendedLock();
	*** lockRoot();
	*** putTreeVal(int,java.lang.Object,java.lang.Object);
	*** removeTreeNode(io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode);
	*** rotateLeft(io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode,io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode);
	*** rotateRight(io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode,io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode);
	*** unlockRoot();
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$TreeNode {
	*** left;
	*** parent;
	*** prev;
	*** red;
	*** right;
	*** findTreeNode(int,java.lang.Object,java.lang.Class);
}

-keep class io.netty.util.internal.chmv8.ConcurrentHashMapV8$ValuesView {
	*** iterator();
}

-keep class io.netty.util.internal.chmv8.ForkJoinPool {
	*** getCommonPoolParallelism();
}

-keep class io.netty.util.internal.chmv8.ForkJoinTask {
	*** invoke();
}

-keep class io.netty.util.internal.logging.AbstractInternalLogger {
	*** name;
	io.netty.util.internal.logging.AbstractInternalLogger(java.lang.String);
	*** name();
}

-keep class io.netty.util.internal.logging.AbstractInternalLogger$1 {
	*** $SwitchMap$io$netty$util$internal$logging$InternalLogLevel;
}

-keep class io.netty.util.internal.logging.InternalLogger {
	*** debug(java.lang.String);
	*** debug(java.lang.String,java.lang.Object);
	*** debug(java.lang.String,java.lang.Object,java.lang.Object);
	*** debug(java.lang.String,java.lang.Object[]);
	*** debug(java.lang.String,java.lang.Throwable);
	*** error(java.lang.String);
	*** error(java.lang.String,java.lang.Object);
	*** error(java.lang.String,java.lang.Object,java.lang.Object);
	*** error(java.lang.String,java.lang.Object[]);
	*** error(java.lang.String,java.lang.Throwable);
	*** info(java.lang.String);
	*** info(java.lang.String,java.lang.Object);
	*** info(java.lang.String,java.lang.Object,java.lang.Object);
	*** info(java.lang.String,java.lang.Object[]);
	*** info(java.lang.String,java.lang.Throwable);
	*** isDebugEnabled();
	*** isErrorEnabled();
	*** isInfoEnabled();
	*** isTraceEnabled();
	*** isWarnEnabled();
	*** trace(java.lang.String);
	*** trace(java.lang.String,java.lang.Object);
	*** trace(java.lang.String,java.lang.Object,java.lang.Object);
	*** trace(java.lang.String,java.lang.Object[]);
	*** trace(java.lang.String,java.lang.Throwable);
	*** warn(java.lang.String);
	*** warn(java.lang.String,java.lang.Object);
	*** warn(java.lang.String,java.lang.Object,java.lang.Object);
	*** warn(java.lang.String,java.lang.Object[]);
	*** warn(java.lang.String,java.lang.Throwable);
}

-keep class io.netty.util.internal.logging.InternalLoggerFactory {
	*** defaultFactory;
	io.netty.util.internal.logging.InternalLoggerFactory();
	*** getDefaultFactory();
	*** getInstance(java.lang.Class);
	*** getInstance(java.lang.String);
	*** newInstance(java.lang.String);
}

-keep class io.netty.util.internal.logging.Slf4JLogger {
	*** logger;
}

-keep class io.netty.util.internal.logging.Slf4JLoggerFactory {
	*** $assertionsDisabled;
}

-keep class io.netty.util.internal.logging.Slf4JLoggerFactory$1 {
	*** this$0;
	*** val$buf;
}

-keep class it.unimi.dsi.fastutil.Arrays {
	*** ensureFromTo(int,int,int);
	*** ensureOffsetLength(int,int,int);
}

-keep class it.unimi.dsi.fastutil.BidirectionalIterator {
	*** hasPrevious();
}

-keep class it.unimi.dsi.fastutil.ints.AbstractIntBidirectionalIterator {
	it.unimi.dsi.fastutil.ints.AbstractIntBidirectionalIterator();
	*** previous();
	*** previousInt();
}

-keep class it.unimi.dsi.fastutil.ints.AbstractIntCollection {
	it.unimi.dsi.fastutil.ints.AbstractIntCollection();
	*** add(int);
	*** add(java.lang.Integer);
	*** contains(int);
	*** contains(java.lang.Object);
	*** isEmpty();
	*** iterator();
	*** rem(int);
	*** remove(java.lang.Object);
	*** toIntArray(int[]);
}

-keep class it.unimi.dsi.fastutil.ints.AbstractIntIterator {
	it.unimi.dsi.fastutil.ints.AbstractIntIterator();
	*** next();
	*** nextInt();
}

-keep class it.unimi.dsi.fastutil.ints.AbstractIntList {
	it.unimi.dsi.fastutil.ints.AbstractIntList();
	*** add(int);
	*** add(int,int);
	*** add(int,java.lang.Integer);
	*** addAll(int,it.unimi.dsi.fastutil.ints.IntCollection);
	*** addAll(int,it.unimi.dsi.fastutil.ints.IntList);
	*** addAll(int,java.util.Collection);
	*** addElements(int,int[],int,int);
	*** compareTo(java.util.List);
	*** ensureIndex(int);
	*** get(int);
	*** indexOf(int);
	*** iterator();
	*** lastIndexOf(int);
	*** listIterator();
	*** listIterator(int);
	*** peek(int);
	*** peekInt(int);
	*** pop();
	*** popInt();
	*** push(int);
	*** push(java.lang.Integer);
	*** rem(int);
	*** remove(int);
	*** removeInt(int);
	*** set(int,int);
	*** set(int,java.lang.Integer);
	*** subList(int,int);
	*** top();
	*** topInt();
	*** valEquals(java.lang.Object,java.lang.Object);
}

-keep class it.unimi.dsi.fastutil.ints.AbstractIntListIterator {
	it.unimi.dsi.fastutil.ints.AbstractIntListIterator();
	*** add(int);
	*** add(java.lang.Integer);
	*** set(int);
	*** set(java.lang.Integer);
}

-keep class it.unimi.dsi.fastutil.ints.IntArrayList {
	*** a;
	*** size;
	it.unimi.dsi.fastutil.ints.IntArrayList();
	it.unimi.dsi.fastutil.ints.IntArrayList(int);
	it.unimi.dsi.fastutil.ints.IntArrayList(int[],int,int);
	*** add(int);
	*** add(int,int);
	*** clone();
	*** ensureCapacity(int);
	*** grow(int);
	*** indexOf(int);
	*** listIterator(int);
	*** removeInt(int);
	*** set(int,int);
	*** size();
	*** trim(int);
	*** wrap(int[],int);
}

-keep class it.unimi.dsi.fastutil.ints.IntArrayList$1 {
	*** last;
	*** pos;
	*** this$0;
	*** val$index;
	*** hasNext();
	*** hasPrevious();
}

-keep class it.unimi.dsi.fastutil.ints.IntArrays {
	*** EMPTY_ARRAY;
	*** HASH_STRATEGY;
	*** binarySearch(int[],int,int,int);
	*** binarySearch(int[],int,int,int,it.unimi.dsi.fastutil.ints.IntComparator);
	*** ensureCapacity(int[],int);
	*** ensureCapacity(int[],int,int);
	*** ensureFromTo(int[],int,int);
	*** ensureOffsetLength(int[],int,int);
	*** equals(int[],int[]);
	*** fill(int[],int);
	*** fill(int[],int,int,int);
	*** grow(int[],int,int);
	*** insertionSort(int[],int,int);
	*** insertionSort(int[],int,int,it.unimi.dsi.fastutil.ints.IntComparator);
	*** insertionSortIndirect(int[],int[],int,int);
	*** insertionSortIndirect(int[],int[],int[],int,int);
	*** med3(int[],int,int,int);
	*** med3(int[],int,int,int,it.unimi.dsi.fastutil.ints.IntComparator);
	*** mergeSort(int[],int,int);
	*** mergeSort(int[],int,int,int[]);
	*** mergeSort(int[],int,int,it.unimi.dsi.fastutil.ints.IntComparator);
	*** mergeSort(int[],int,int,it.unimi.dsi.fastutil.ints.IntComparator,int[]);
	*** quickSort(int[],int,int);
	*** quickSort(int[],int,int,it.unimi.dsi.fastutil.ints.IntComparator);
	*** radixSort(int[],int,int);
	*** radixSort(int[],int[],int,int);
	*** radixSort(int[][],int,int);
	*** radixSortIndirect(int[],int[],int,int,boolean);
	*** radixSortIndirect(int[],int[],int[],int,int,boolean);
	*** selectionSort(int[],int,int);
	*** selectionSort(int[],int,int,it.unimi.dsi.fastutil.ints.IntComparator);
	*** selectionSort(int[],int[],int,int);
	*** selectionSort(int[][],int,int,int);
	*** swap(int[],int,int);
	*** trim(int[],int);
	*** vecSwap(int[],int,int,int);
}

-keep class it.unimi.dsi.fastutil.ints.IntArrays$ArrayHashStrategy {
	it.unimi.dsi.fastutil.ints.IntArrays$ArrayHashStrategy();
	*** equals(int[],int[]);
	*** hashCode(int[]);
}

-keep class it.unimi.dsi.fastutil.ints.IntBidirectionalIterator {
	*** previousInt();
}

-keep class it.unimi.dsi.fastutil.ints.IntCollection {
	*** contains(int);
	*** iterator();
}

-keep class it.unimi.dsi.fastutil.ints.IntComparator {
	*** compare(int,int);
}

-keep class it.unimi.dsi.fastutil.ints.IntIterator {
	*** nextInt();
}

-keep class it.unimi.dsi.fastutil.ints.IntIterators {
	*** asIntIterator(java.util.Iterator);
	*** unwrap(it.unimi.dsi.fastutil.ints.IntIterator,int[]);
}

-keep class it.unimi.dsi.fastutil.ints.IntList {
	*** add(int);
	*** getElements(int,int[],int,int);
	*** getInt(int);
	*** listIterator();
}

-keep class it.unimi.dsi.fastutil.objects.ObjectIterators {
	*** unwrap(java.util.Iterator,java.lang.Object[]);
}

-keep class java.awt.AWTEvent {
	*** acc;
	*** bdata;
	*** consumed;
	*** focusManagerIsDispatching;
	*** id;
	*** inputEvent_CanAccessSystemClipboard_Field;
	*** isPosted;
	*** isSystemGenerated;
	*** log;
	java.awt.AWTEvent(java.lang.Object,int);
	*** access$000(java.awt.AWTEvent);
	*** access$002(java.awt.AWTEvent,boolean);
	*** access$100(java.awt.AWTEvent);
	*** access$102(java.awt.AWTEvent,byte[]);
	*** consume();
	*** convertToOld();
	*** copyPrivateDataInto(java.awt.AWTEvent);
	*** dispatched();
	*** getAccessControlContext();
	*** getID();
	*** get_InputEvent_CanAccessSystemClipboard();
	*** initIDs();
	*** isConsumed();
	*** nativeSetSource(java.awt.peer.ComponentPeer);
	*** paramString();
	*** setSource(java.lang.Object);
}

-keep class java.awt.AWTEventMulticaster {
	*** a;
	*** b;
	*** add(java.awt.event.ActionListener,java.awt.event.ActionListener);
	*** add(java.awt.event.ComponentListener,java.awt.event.ComponentListener);
	*** add(java.awt.event.ContainerListener,java.awt.event.ContainerListener);
	*** add(java.awt.event.FocusListener,java.awt.event.FocusListener);
	*** add(java.awt.event.HierarchyBoundsListener,java.awt.event.HierarchyBoundsListener);
	*** add(java.awt.event.HierarchyListener,java.awt.event.HierarchyListener);
	*** add(java.awt.event.InputMethodListener,java.awt.event.InputMethodListener);
	*** add(java.awt.event.KeyListener,java.awt.event.KeyListener);
	*** add(java.awt.event.MouseListener,java.awt.event.MouseListener);
	*** add(java.awt.event.MouseMotionListener,java.awt.event.MouseMotionListener);
	*** add(java.awt.event.MouseWheelListener,java.awt.event.MouseWheelListener);
	*** add(java.awt.event.WindowFocusListener,java.awt.event.WindowFocusListener);
	*** add(java.awt.event.WindowListener,java.awt.event.WindowListener);
	*** add(java.awt.event.WindowStateListener,java.awt.event.WindowStateListener);
	*** addInternal(java.util.EventListener,java.util.EventListener);
	*** getListenerCount(java.util.EventListener,java.lang.Class);
	*** getListeners(java.util.EventListener,java.lang.Class);
	*** populateListenerArray(java.util.EventListener[],java.util.EventListener,int);
	*** remove(java.awt.event.ActionListener,java.awt.event.ActionListener);
	*** remove(java.awt.event.ComponentListener,java.awt.event.ComponentListener);
	*** remove(java.awt.event.ContainerListener,java.awt.event.ContainerListener);
	*** remove(java.awt.event.FocusListener,java.awt.event.FocusListener);
	*** remove(java.awt.event.HierarchyBoundsListener,java.awt.event.HierarchyBoundsListener);
	*** remove(java.awt.event.HierarchyListener,java.awt.event.HierarchyListener);
	*** remove(java.awt.event.InputMethodListener,java.awt.event.InputMethodListener);
	*** remove(java.awt.event.KeyListener,java.awt.event.KeyListener);
	*** remove(java.awt.event.MouseListener,java.awt.event.MouseListener);
	*** remove(java.awt.event.MouseMotionListener,java.awt.event.MouseMotionListener);
	*** remove(java.awt.event.MouseWheelListener,java.awt.event.MouseWheelListener);
	*** remove(java.awt.event.WindowFocusListener,java.awt.event.WindowFocusListener);
	*** remove(java.awt.event.WindowListener,java.awt.event.WindowListener);
	*** remove(java.awt.event.WindowStateListener,java.awt.event.WindowStateListener);
	*** remove(java.util.EventListener);
	*** removeInternal(java.util.EventListener,java.util.EventListener);
	*** save(java.io.ObjectOutputStream,java.lang.String,java.util.EventListener);
	*** saveInternal(java.io.ObjectOutputStream,java.lang.String);
}

-keep class java.awt.AWTKeyStroke {
	*** $assertionsDisabled;
	*** APP_CONTEXT_CACHE_KEY;
	*** APP_CONTEXT_KEYSTROKE_KEY;
	*** keyChar;
	*** keyCode;
	*** modifierKeywords;
	*** modifiers;
	*** onKeyRelease;
	*** vks;
	java.awt.AWTKeyStroke();
	java.awt.AWTKeyStroke(char,int,int,boolean);
	*** getAWTKeyStroke(char);
	*** getAWTKeyStroke(int,int);
	*** getAWTKeyStroke(int,int,boolean);
	*** getAWTKeyStroke(java.lang.Character,int);
	*** getAWTKeyStroke(java.lang.String);
	*** getAWTKeyStrokeClass();
	*** getAWTKeyStrokeForEvent(java.awt.event.KeyEvent);
	*** getCachedStroke(char,int,int,boolean);
	*** getCtor(java.lang.Class);
	*** getKeyChar();
	*** getKeyCode();
	*** getModifiers();
	*** getModifiersText(int);
	*** getVKCollection();
	*** getVKText(int);
	*** getVKValue(java.lang.String);
	*** isOnKeyRelease();
	*** mapNewModifiers(int);
	*** mapOldModifiers(int);
	*** registerSubclass(java.lang.Class);
}

-keep class java.awt.AWTKeyStroke$1 {
	*** val$clazz;
}

-keep class java.awt.ActiveEvent {
	*** dispatch();
}

-keep class java.awt.AlphaComposite {
	*** Clear;
	*** Dst;
	*** DstAtop;
	*** DstIn;
	*** DstOut;
	*** DstOver;
	*** Src;
	*** SrcAtop;
	*** SrcIn;
	*** SrcOut;
	*** SrcOver;
	*** Xor;
	*** extraAlpha;
	*** rule;
	java.awt.AlphaComposite(int,float);
	*** getAlpha();
	*** getInstance(int);
	*** getInstance(int,float);
	*** getRule();
}

-keep class java.awt.BasicStroke {
	*** cap;
	*** dash;
	*** dash_phase;
	*** join;
	*** miterlimit;
	*** width;
	java.awt.BasicStroke(float,int,int,float,float[],float);
	*** getDashArray();
	*** getDashPhase();
	*** getEndCap();
	*** getLineJoin();
	*** getLineWidth();
	*** getMiterLimit();
}

-keep class java.awt.BorderLayout {
	*** center;
	*** east;
	*** firstItem;
	*** firstLine;
	*** hgap;
	*** lastItem;
	*** lastLine;
	*** north;
	*** south;
	*** vgap;
	*** west;
	java.awt.BorderLayout();
	java.awt.BorderLayout(int,int);
	*** addLayoutComponent(java.awt.Component,java.lang.Object);
	*** addLayoutComponent(java.lang.String,java.awt.Component);
	*** getChild(java.lang.String,boolean);
}

-keep class java.awt.BufferCapabilities {
	*** getFlipContents();
	*** isPageFlipping();
}

-keep class java.awt.BufferCapabilities$FlipContents {
	*** BACKGROUND;
	*** COPIED;
	*** PRIOR;
	*** UNDEFINED;
}

-keep class java.awt.Button {
	*** getLabel();
}

-keep class java.awt.Color {
	*** BLACK;
	*** BLUE;
	*** CYAN;
	*** DARK_GRAY;
	*** GRAY;
	*** GREEN;
	*** LIGHT_GRAY;
	*** MAGENTA;
	*** ORANGE;
	*** PINK;
	*** RED;
	*** WHITE;
	*** YELLOW;
	*** black;
	*** blue;
	*** cs;
	*** cyan;
	*** darkGray;
	*** falpha;
	*** frgbvalue;
	*** fvalue;
	*** gray;
	*** green;
	*** lightGray;
	*** magenta;
	*** orange;
	*** pink;
	*** red;
	*** value;
	*** white;
	*** yellow;
	java.awt.Color(float,float,float);
	java.awt.Color(int);
	java.awt.Color(int,boolean);
	java.awt.Color(int,int,int);
	java.awt.Color(int,int,int,int);
	*** HSBtoRGB(float,float,float);
	*** brighter();
	*** darker();
	*** decode(java.lang.String);
	*** equals(java.lang.Object);
	*** getAlpha();
	*** getBlue();
	*** getColor(java.lang.String,java.awt.Color);
	*** getGreen();
	*** getRGB();
	*** getRGBColorComponents(float[]);
	*** getRGBComponents(float[]);
	*** getRed();
	*** getTransparency();
	*** initIDs();
	*** testColorValueRange(float,float,float,float);
	*** testColorValueRange(int,int,int,int);
	*** toString();
}

-keep class java.awt.Component {
	*** $assertionsDisabled;
	*** LOCK;
	*** acc;
	*** accessibleContext;
	*** appContext;
	*** autoFocusTransferOnDisposal;
	*** background;
	*** backgroundEraseDisabled;
	*** boundsOp;
	*** bufferStrategy;
	*** changeSupport;
	*** coalesceEventsParams;
	*** coalesceMap;
	*** coalescingEnabled;
	*** componentListener;
	*** componentOrientation;
	*** componentSerializedDataVersion;
	*** compoundShape;
	*** cursor;
	*** dropTarget;
	*** enabled;
	*** eventCache;
	*** eventLog;
	*** eventMask;
	*** focusListener;
	*** focusLog;
	*** focusTraversalKeyPropertyNames;
	*** focusTraversalKeys;
	*** focusTraversalKeysEnabled;
	*** focusable;
	*** font;
	*** foreground;
	*** graphicsConfig;
	*** height;
	*** hierarchyBoundsListener;
	*** hierarchyListener;
	*** ignoreRepaint;
	*** incRate;
	*** inputMethodListener;
	*** isAddNotifyComplete;
	*** isFocusTraversableOverridden;
	*** isInc;
	*** isPacked;
	*** keyListener;
	*** locale;
	*** log;
	*** maxSize;
	*** maxSizeSet;
	*** minSize;
	*** minSizeSet;
	*** mixingCutoutRegion;
	*** mixingLog;
	*** mouseListener;
	*** mouseMotionListener;
	*** mouseWheelListener;
	*** name;
	*** nameExplicitlySet;
	*** newEventsOnly;
	*** objectLock;
	*** parent;
	*** peer;
	*** peerFont;
	*** popups;
	*** prefSize;
	*** prefSizeSet;
	*** requestFocusController;
	*** valid;
	*** visible;
	*** width;
	*** windowClosingException;
	*** x;
	*** y;
	java.awt.Component();
	*** access$002(java.awt.Component,sun.java2d.pipe.Region);
	*** access$100(java.awt.Component);
	*** action(java.awt.Event,java.lang.Object);
	*** addComponentListener(java.awt.event.ComponentListener);
	*** addFocusListener(java.awt.event.FocusListener);
	*** addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener);
	*** addHierarchyListener(java.awt.event.HierarchyListener);
	*** addInputMethodListener(java.awt.event.InputMethodListener);
	*** addKeyListener(java.awt.event.KeyListener);
	*** addMouseListener(java.awt.event.MouseListener);
	*** addMouseMotionListener(java.awt.event.MouseMotionListener);
	*** addMouseWheelListener(java.awt.event.MouseWheelListener);
	*** addNotify();
	*** addPropertyChangeListener(java.beans.PropertyChangeListener);
	*** addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** adjustListeningChildrenOnParent(long,int);
	*** applyComponentOrientation(java.awt.ComponentOrientation);
	*** applyCompoundShape(sun.java2d.pipe.Region);
	*** applyCurrentShape();
	*** applyCurrentShapeBelowMe();
	*** areBoundsValid();
	*** areInputMethodsEnabled();
	*** autoProcessMouseWheel(java.awt.event.MouseWheelEvent);
	*** bounds();
	*** calculateCurrentShape();
	*** canBeFocusOwner();
	*** canBeFocusOwnerRecursively();
	*** checkCoalescing();
	*** checkGD(java.lang.String);
	*** checkImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** checkTreeLock();
	*** checkWindowClosingException();
	*** clearCurrentFocusCycleRootOnHide();
	*** clearMostRecentFocusOwnerOnHide();
	*** coalesceEvents(java.awt.AWTEvent,java.awt.AWTEvent);
	*** constructComponentName();
	*** contains(int,int);
	*** containsFocus();
	*** countHierarchyMembers();
	*** createBufferStrategy(int);
	*** createBufferStrategy(int,java.awt.BufferCapabilities);
	*** createHierarchyEvents(int,java.awt.Component,java.awt.Container,long,boolean);
	*** createImage(int,int);
	*** createVolatileImage(int,int);
	*** deliverEvent(java.awt.Event);
	*** disable();
	*** dispatchEvent(java.awt.AWTEvent);
	*** dispatchEventImpl(java.awt.AWTEvent);
	*** dispatchMouseWheelToAncestor(java.awt.event.MouseWheelEvent);
	*** doSwingSerialization();
	*** enable();
	*** enable(boolean);
	*** enableEvents(long);
	*** enableInputMethods(boolean);
	*** eventEnabled(java.awt.AWTEvent);
	*** eventTypeEnabled(int);
	*** findUnderMouseInWindow(java.awt.PointerInfo);
	*** firePropertyChange(java.lang.String,boolean,boolean);
	*** firePropertyChange(java.lang.String,char,char);
	*** firePropertyChange(java.lang.String,int,int);
	*** firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** getAccessControlContext();
	*** getAccessibleContext();
	*** getAlignmentX();
	*** getAlignmentY();
	*** getAppliedShape();
	*** getBackground();
	*** getBaseline(int,int);
	*** getBounds();
	*** getBounds(java.awt.Rectangle);
	*** getBoundsOp();
	*** getBufferStrategy();
	*** getComponentAt(int,int);
	*** getComponentOrientation();
	*** getContainer();
	*** getContainingWindow();
	*** getCursor();
	*** getCursor_NoClientCode();
	*** getDropTarget();
	*** getFocusCycleRootAncestor();
	*** getFocusTraversalKeys(int);
	*** getFocusTraversalKeysEnabled();
	*** getFocusTraversalKeys_NoIDCheck(int);
	*** getFont();
	*** getFontMetrics(java.awt.Font);
	*** getFont_NoClientCode();
	*** getForeground();
	*** getGraphics();
	*** getGraphicsConfiguration();
	*** getGraphicsConfiguration_NoClientCode();
	*** getGraphics_NoClientCode();
	*** getHWPeerAboveMe();
	*** getHeight();
	*** getInputContext();
	*** getInsets_NoClientCode();
	*** getListeners(java.lang.Class);
	*** getLocale();
	*** getLocation();
	*** getLocationOnScreen();
	*** getLocationOnScreen_NoTreeLock();
	*** getLocationOnWindow();
	*** getMaximumSize();
	*** getMinimumSize();
	*** getName();
	*** getNativeContainer();
	*** getNextFocusCandidate();
	*** getNormalShape();
	*** getObjectLock();
	*** getOpaqueShape();
	*** getParent();
	*** getParent_NoClientCode();
	*** getPeer();
	*** getPreferredSize();
	*** getPropertyChangeListeners();
	*** getSiblingIndexAbove();
	*** getSiblingIndexBelow();
	*** getSize();
	*** getToolkit();
	*** getToolkitImpl();
	*** getTraversalRoot();
	*** getTreeLock();
	*** getWidth();
	*** getX();
	*** getY();
	*** gotFocus(java.awt.Event,java.lang.Object);
	*** handleEvent(java.awt.Event);
	*** hasFocus();
	*** hide();
	*** imageUpdate(java.awt.Image,int,int,int,int,int);
	*** initIDs();
	*** initializeFocusTraversalKeys();
	*** inside(int,int);
	*** invalidate();
	*** invalidateIfValid();
	*** invalidateParent();
	*** isAutoFocusTransferOnDisposal();
	*** isCoalesceEventsOverriden(java.lang.Class);
	*** isCoalescingEnabled();
	*** isDisplayable();
	*** isEnabled();
	*** isEnabledImpl();
	*** isFocusCycleRoot(java.awt.Container);
	*** isFocusOwner();
	*** isFocusTraversable();
	*** isFocusTraversableOverridden();
	*** isFocusable();
	*** isInstanceOf(java.lang.Object,java.lang.String);
	*** isLightweight();
	*** isMaximumSizeSet();
	*** isMinimumSizeSet();
	*** isMixingNeeded();
	*** isNonOpaqueForMixing();
	*** isOpaque();
	*** isPreferredSizeSet();
	*** isRecursivelyVisible();
	*** isRequestFocusAccepted(boolean,boolean,sun.awt.CausedFocusEvent$Cause);
	*** isSameOrAncestorOf(java.awt.Component,boolean);
	*** isShowing();
	*** isValid();
	*** isVisible();
	*** isVisible_NoClientCode();
	*** keyDown(java.awt.Event,int);
	*** keyUp(java.awt.Event,int);
	*** layout();
	*** lightweightPaint(java.awt.Graphics);
	*** lightweightPrint(java.awt.Graphics);
	*** list(java.io.PrintStream,int);
	*** list(java.io.PrintWriter,int);
	*** locate(int,int);
	*** location();
	*** location_NoClientCode();
	*** lostFocus(java.awt.Event,java.lang.Object);
	*** minimumSize();
	*** mixOnHiding(boolean);
	*** mixOnReshaping();
	*** mixOnShowing();
	*** mixOnValidating();
	*** mixOnZOrderChanging(int,int);
	*** mouseDown(java.awt.Event,int,int);
	*** mouseDrag(java.awt.Event,int,int);
	*** mouseEnter(java.awt.Event,int,int);
	*** mouseExit(java.awt.Event,int,int);
	*** mouseMove(java.awt.Event,int,int);
	*** mouseUp(java.awt.Event,int,int);
	*** move(int,int);
	*** nextFocus();
	*** notifyNewBounds(boolean,boolean);
	*** numListening(long);
	*** paint(java.awt.Graphics);
	*** paramString();
	*** pointRelativeToComponent(java.awt.Point);
	*** postEvent(java.awt.Event);
	*** postsOldMouseEvents();
	*** preferredSize();
	*** prepareImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** print(java.awt.Graphics);
	*** printAll(java.awt.Graphics);
	*** processComponentEvent(java.awt.event.ComponentEvent);
	*** processEvent(java.awt.AWTEvent);
	*** processFocusEvent(java.awt.event.FocusEvent);
	*** processHierarchyBoundsEvent(java.awt.event.HierarchyEvent);
	*** processHierarchyEvent(java.awt.event.HierarchyEvent);
	*** processInputMethodEvent(java.awt.event.InputMethodEvent);
	*** processKeyEvent(java.awt.event.KeyEvent);
	*** processMouseEvent(java.awt.event.MouseEvent);
	*** processMouseMotionEvent(java.awt.event.MouseEvent);
	*** processMouseWheelEvent(java.awt.event.MouseWheelEvent);
	*** relocateComponent();
	*** remove(java.awt.MenuComponent);
	*** removeComponentListener(java.awt.event.ComponentListener);
	*** removeNotify();
	*** removePropertyChangeListener(java.beans.PropertyChangeListener);
	*** repaint();
	*** repaint(int,int,int,int);
	*** repaint(long,int,int,int,int);
	*** repaintParentIfNeeded(int,int,int,int);
	*** requestFocus();
	*** requestFocus(boolean);
	*** requestFocus(boolean,sun.awt.CausedFocusEvent$Cause);
	*** requestFocus(sun.awt.CausedFocusEvent$Cause);
	*** requestFocusHelper(boolean,boolean);
	*** requestFocusHelper(boolean,boolean,sun.awt.CausedFocusEvent$Cause);
	*** requestFocusInWindow();
	*** requestFocusInWindow(boolean);
	*** requestFocusInWindow(sun.awt.CausedFocusEvent$Cause);
	*** reshape(int,int,int,int);
	*** reshapeNativePeer(int,int,int,int,int);
	*** resize(int,int);
	*** resize(java.awt.Dimension);
	*** setAutoFocusTransferOnDisposal(boolean);
	*** setBackground(java.awt.Color);
	*** setBounds(int,int,int,int);
	*** setBoundsOp(int);
	*** setComponentOrientation(java.awt.ComponentOrientation);
	*** setCursor(java.awt.Cursor);
	*** setDropTarget(java.awt.dnd.DropTarget);
	*** setEnabled(boolean);
	*** setFocusTraversalKeys_NoIDCheck(int,java.util.Set);
	*** setFocusable(boolean);
	*** setFont(java.awt.Font);
	*** setForeground(java.awt.Color);
	*** setGraphicsConfiguration(java.awt.GraphicsConfiguration);
	*** setLocale(java.util.Locale);
	*** setLocation(int,int);
	*** setLocation(java.awt.Point);
	*** setMaximumSize(java.awt.Dimension);
	*** setMinimumSize(java.awt.Dimension);
	*** setName(java.lang.String);
	*** setPreferredSize(java.awt.Dimension);
	*** setRequestFocusController(sun.awt.RequestFocusController);
	*** setSize(int,int);
	*** setSize(java.awt.Dimension);
	*** setVisible(boolean);
	*** show();
	*** show(boolean);
	*** size();
	*** subtractAndApplyShape(sun.java2d.pipe.Region);
	*** subtractAndApplyShapeBelowMe();
	*** toString();
	*** transferFocus();
	*** transferFocus(boolean);
	*** transferFocusBackward();
	*** transferFocusBackward(boolean);
	*** transferFocusUpCycle();
	*** updateCursorImmediately();
	*** updateGraphicsData(java.awt.GraphicsConfiguration);
	*** updateZOrder();
	*** validate();
}

-keep class java.awt.Component$BaselineResizeBehavior {
	*** OTHER;
}

-keep class java.awt.Component$BltBufferStrategy {
	*** getBackBuffer();
}

-keep class java.awt.Component$DummyRequestFocusController {
	java.awt.Component$DummyRequestFocusController();
}

-keep class java.awt.Component$FlipBufferStrategy {
	*** destroyBuffers();
	*** getBackBuffer();
}

-keep class java.awt.ComponentOrientation {
	*** LEFT_TO_RIGHT;
	*** RIGHT_TO_LEFT;
	*** UNKNOWN;
	*** orientation;
	*** getOrientation(java.util.Locale);
	*** getOrientation(java.util.ResourceBundle);
	*** isHorizontal();
	*** isLeftToRight();
}

-keep class java.awt.Composite {
	*** createContext(java.awt.image.ColorModel,java.awt.image.ColorModel,java.awt.RenderingHints);
}

-keep class java.awt.CompositeContext {
	*** compose(java.awt.image.Raster,java.awt.image.Raster,java.awt.image.WritableRaster);
	*** dispose();
}

-keep class java.awt.Container {
	*** EMPTY_ARRAY;
	*** component;
	*** containerListener;
	*** containerSerializedDataVersion;
	*** descendUnconditionallyWhenValidating;
	*** descendantsCount;
	*** dispatcher;
	*** eventLog;
	*** focusCycleRoot;
	*** focusTraversalPolicy;
	*** focusTraversalPolicyProvider;
	*** isJavaAwtSmartInvalidate;
	*** layoutMgr;
	*** listeningBoundsChildren;
	*** listeningChildren;
	*** log;
	*** mixingLog;
	*** modalAppContext;
	*** modalComp;
	*** numOfHWComponents;
	*** numOfLWComponents;
	*** preserveBackgroundColor;
	*** printing;
	*** printingThreads;
	*** serialPersistentFields;
	java.awt.Container();
	*** add(java.awt.Component);
	*** add(java.awt.Component,int);
	*** add(java.awt.Component,java.lang.Object);
	*** add(java.awt.Component,java.lang.Object,int);
	*** addContainerListener(java.awt.event.ContainerListener);
	*** addDelicately(java.awt.Component,java.awt.Container,int);
	*** addImpl(java.awt.Component,java.lang.Object,int);
	*** addNotify();
	*** addPropertyChangeListener(java.beans.PropertyChangeListener);
	*** addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** adjustDecendantsOnParent(int);
	*** adjustDescendants(int);
	*** adjustListeningChildren(long,int);
	*** applyComponentOrientation(java.awt.ComponentOrientation);
	*** canContainFocusOwner(java.awt.Component);
	*** checkAddToSelf(java.awt.Component);
	*** checkAdding(java.awt.Component,int);
	*** checkNotAWindow(java.awt.Component);
	*** containsFocus();
	*** countComponents();
	*** createChildHierarchyEvents(int,long,boolean);
	*** createHierarchyEvents(int,java.awt.Component,java.awt.Container,long,boolean);
	*** decreaseComponentCount(java.awt.Component);
	*** dispatchEventImpl(java.awt.AWTEvent);
	*** dispatchEventToSelf(java.awt.AWTEvent);
	*** doLayout();
	*** eventEnabled(java.awt.AWTEvent);
	*** findComponentAt(int,int);
	*** findComponentAt(int,int,boolean);
	*** findComponentAtImpl(int,int,boolean);
	*** findTraversalRoot();
	*** getAlignmentX();
	*** getAlignmentY();
	*** getBottommostComponentIndex();
	*** getComponent(int);
	*** getComponentAt(int,int);
	*** getComponentCount();
	*** getComponentZOrder(java.awt.Component);
	*** getComponents();
	*** getComponentsSync();
	*** getComponents_NoClientCode();
	*** getDropTargetEventTarget(int,int,boolean);
	*** getFocusTraversalKeys(int);
	*** getFocusTraversalPolicy();
	*** getHeavyweightContainer();
	*** getInsets();
	*** getLayout();
	*** getListeners(java.lang.Class);
	*** getListenersCount(int,boolean);
	*** getMaximumSize();
	*** getMinimumSize();
	*** getMouseEventTarget(int,int,boolean);
	*** getMouseEventTarget(int,int,boolean,java.awt.Container$EventTargetFilter,boolean);
	*** getMouseEventTargetImpl(int,int,boolean,java.awt.Container$EventTargetFilter,boolean,boolean);
	*** getPreferredSize();
	*** getTopmostComponentIndex();
	*** hasHeavyweightDescendants();
	*** hasLightweightDescendants();
	*** increaseComponentCount(java.awt.Component);
	*** initIDs();
	*** insets();
	*** invalidate();
	*** invalidateTree();
	*** isAncestorOf(java.awt.Component);
	*** isFocusCycleRoot();
	*** isFocusTraversalPolicyProvider();
	*** isParentOf(java.awt.Component);
	*** isRecursivelyVisibleUpToHeavyweightContainer();
	*** isRemoveNotifyNeeded(java.awt.Component,java.awt.Container,java.awt.Container);
	*** isSameOrAncestorOf(java.awt.Component,boolean);
	*** isValidateRoot();
	*** layout();
	*** list(java.io.PrintStream,int);
	*** locate(int,int);
	*** minimumSize();
	*** mixOnShowing();
	*** paint(java.awt.Graphics);
	*** paintHeavyweightComponents(java.awt.Graphics);
	*** paramString();
	*** postProcessKeyEvent(java.awt.event.KeyEvent);
	*** preProcessKeyEvent(java.awt.event.KeyEvent);
	*** preferredSize();
	*** printHeavyweightComponents(java.awt.Graphics);
	*** processContainerEvent(java.awt.event.ContainerEvent);
	*** processEvent(java.awt.AWTEvent);
	*** proxyEnableEvents(long);
	*** recursiveApplyCurrentShape();
	*** recursiveApplyCurrentShape(int);
	*** recursiveApplyCurrentShape(int,int);
	*** recursiveHideHeavyweightChildren();
	*** recursiveRelocateHeavyweightChildren(java.awt.Point);
	*** recursiveShowHeavyweightChildren();
	*** recursiveSubtractAndApplyShape(sun.java2d.pipe.Region);
	*** recursiveSubtractAndApplyShape(sun.java2d.pipe.Region,int);
	*** recursiveSubtractAndApplyShape(sun.java2d.pipe.Region,int,int);
	*** remove(int);
	*** remove(java.awt.Component);
	*** removeAll();
	*** removeContainerListener(java.awt.event.ContainerListener);
	*** removeDelicately(java.awt.Component,java.awt.Container,int);
	*** removeNotify();
	*** reparentChild(java.awt.Component);
	*** reparentTraverse(java.awt.peer.ContainerPeer,java.awt.Container);
	*** setComponentZOrder(java.awt.Component,int);
	*** setFocusCycleRoot(boolean);
	*** setFocusTraversalKeys(int,java.util.Set);
	*** setFocusTraversalPolicy(java.awt.FocusTraversalPolicy);
	*** setFont(java.awt.Font);
	*** setLayout(java.awt.LayoutManager);
	*** transferFocusDownCycle();
	*** validate();
	*** validateTree();
	*** validateUnconditionally();
}

-keep class java.awt.Container$DropTargetEventTargetFilter {
	*** FILTER;
}

-keep class java.awt.Container$EventTargetFilter {
	*** accept(java.awt.Component);
}

-keep class java.awt.Container$MouseEventTargetFilter {
	*** FILTER;
}

-keep class java.awt.ContainerOrderFocusTraversalPolicy {
	*** BACKWARD_TRAVERSAL;
	*** FORWARD_TRAVERSAL;
	*** cachedCycle;
	*** cachedRoot;
	*** implicitDownCycleTraversal;
	*** log;
	java.awt.ContainerOrderFocusTraversalPolicy();
	*** accept(java.awt.Component);
	*** enumerateCycle(java.awt.Container,java.util.List);
	*** getComponentDownCycle(java.awt.Component,int);
	*** getComponentIndex(java.util.List,java.awt.Component);
	*** getFirstComponent(java.awt.Container);
	*** getFocusTraversalCycle(java.awt.Container);
	*** getImplicitDownCycleTraversal();
	*** getLastComponent(java.awt.Container);
	*** getTopmostProvider(java.awt.Container,java.awt.Component);
}

-keep class java.awt.Cursor {
	*** anchor;
	*** cursorProperties;
	*** disposer;
	*** log;
	*** name;
	*** pData;
	*** predefined;
	*** predefinedPrivate;
	*** systemCustomCursorDirPrefix;
	*** systemCustomCursorProperties;
	*** systemCustomCursorPropertiesFile;
	*** systemCustomCursors;
	*** type;
	java.awt.Cursor(java.lang.String);
	*** access$000(java.awt.Cursor);
	*** access$002(java.awt.Cursor,long);
	*** finalizeImpl(long);
	*** getName();
	*** getPredefinedCursor(int);
	*** getType();
	*** initCursorDir();
	*** initIDs();
	*** loadSystemCustomCursorProperties();
}

-keep class java.awt.Cursor$CursorDisposer {
	*** pData;
}

-keep class java.awt.DefaultFocusTraversalPolicy {
	java.awt.DefaultFocusTraversalPolicy();
	*** accept(java.awt.Component);
}

-keep class java.awt.DefaultKeyboardFocusManager {
	*** NULL_COMPONENT_WR;
	*** NULL_WINDOW_WR;
	*** consumeNextKeyTyped;
	*** enqueuedKeyEvents;
	*** focusLog;
	*** inSendMessage;
	*** realOppositeComponentWR;
	*** realOppositeWindowWR;
	*** typeAheadMarkers;
	java.awt.DefaultKeyboardFocusManager();
	*** access$000(java.awt.DefaultKeyboardFocusManager,java.awt.event.KeyEvent);
	*** consumeNextKeyTyped(java.awt.event.KeyEvent);
	*** consumeProcessedKeyEvent(java.awt.event.KeyEvent);
	*** consumeTraversalKey(java.awt.event.KeyEvent);
	*** dequeueKeyEvents(long,java.awt.Component);
	*** dispatchKeyEvent(java.awt.event.KeyEvent);
	*** doRestoreFocus(java.awt.Component,java.awt.Component,boolean);
	*** downFocusCycle(java.awt.Container);
	*** dumpMarkers();
	*** focusNextComponent(java.awt.Component);
	*** focusPreviousComponent(java.awt.Component);
	*** getOwningFrameDialog(java.awt.Window);
	*** hasMarker(java.awt.Component);
	*** postProcessKeyEvent(java.awt.event.KeyEvent);
	*** preDispatchKeyEvent(java.awt.event.KeyEvent);
	*** pumpApprovedKeyEvents();
	*** purgeStampedEvents(long,long);
	*** restoreFocus(java.awt.Component,boolean);
	*** restoreFocus(java.awt.Window,java.awt.Component,boolean);
	*** restoreFocus(java.awt.event.FocusEvent,java.awt.Window);
	*** restoreFocus(java.awt.event.WindowEvent);
	*** sendMessage(java.awt.Component,java.awt.AWTEvent);
	*** typeAheadAssertions(java.awt.Component,java.awt.AWTEvent);
	*** upFocusCycle(java.awt.Component);
}

-keep class java.awt.DefaultKeyboardFocusManager$TypeAheadMarker {
	*** after;
	*** untilFocused;
}

-keep class java.awt.Desktop {
	*** browse(java.net.URI);
	*** getDesktop();
	*** isDesktopSupported();
	*** isSupported(java.awt.Desktop$Action);
}

-keep class java.awt.Desktop$Action {
	*** BROWSE;
}

-keep class java.awt.Dialog {
	*** DEFAULT_MODALITY_TYPE;
	*** blockedWindows;
	*** initialized;
	*** isInDispose;
	*** isInHide;
	*** modal;
	*** modalDialogs;
	*** modalFilter;
	*** modalityType;
	*** nameCounter;
	*** resizable;
	*** secondaryLoop;
	*** title;
	*** undecorated;
	java.awt.Dialog(java.awt.Dialog,java.lang.String,boolean);
	java.awt.Dialog(java.awt.Dialog,java.lang.String,boolean,java.awt.GraphicsConfiguration);
	java.awt.Dialog(java.awt.Frame,java.lang.String,boolean);
	java.awt.Dialog(java.awt.Frame,java.lang.String,boolean,java.awt.GraphicsConfiguration);
	java.awt.Dialog(java.awt.Window,java.lang.String,java.awt.Dialog$ModalityType);
	java.awt.Dialog(java.awt.Window,java.lang.String,java.awt.Dialog$ModalityType,java.awt.GraphicsConfiguration);
	*** addNotify();
	*** blockWindow(java.awt.Window);
	*** blockWindows(java.util.List);
	*** checkModalityPermission(java.awt.Dialog$ModalityType);
	*** checkShouldBeBlocked(java.awt.Window);
	*** conditionalShow(java.awt.Component,java.util.concurrent.atomic.AtomicLong);
	*** getModalityType();
	*** hideAndDisposeHandler();
	*** hideAndDisposePreHandler();
	*** initIDs();
	*** interruptBlocking();
	*** isModal();
	*** isModal_NoClientCode();
	*** isUndecorated();
	*** modalHide();
	*** modalShow();
	*** modalityPopped();
	*** modalityPushed();
	*** paramString();
	*** setModal(boolean);
	*** setModalityType(java.awt.Dialog$ModalityType);
	*** setUndecorated(boolean);
	*** setVisible(boolean);
	*** shouldBlock(java.awt.Window);
	*** unblockWindow(java.awt.Window);
}

-keep class java.awt.Dialog$4 {
	*** $SwitchMap$java$awt$Dialog$ModalityType;
}

-keep class java.awt.Dialog$ModalExclusionType {
	*** $VALUES;
	*** APPLICATION_EXCLUDE;
	*** NO_EXCLUDE;
	*** TOOLKIT_EXCLUDE;
}

-keep class java.awt.Dialog$ModalityType {
	*** $VALUES;
	*** APPLICATION_MODAL;
	*** DOCUMENT_MODAL;
	*** MODELESS;
	*** TOOLKIT_MODAL;
}

-keep class java.awt.Dimension {
	*** height;
	*** width;
	java.awt.Dimension(int,int);
	*** getHeight();
	*** getWidth();
	*** initIDs();
	*** setSize(int,int);
	*** toString();
}

-keep class java.awt.DisplayMode {
	*** getBitDepth();
	*** getHeight();
	*** getRefreshRate();
	*** getWidth();
}

-keep class java.awt.Event {
	*** arg;
	*** clickCount;
	*** id;
	*** key;
	*** modifiers;
	*** target;
	*** x;
	*** y;
	*** consume();
	*** getKeyEventChar();
	*** getOldEventKey(java.awt.event.KeyEvent);
	*** isConsumed();
	*** translate(int,int);
}

-keep class java.awt.EventDispatchThread {
	*** addEventFilter(java.awt.EventFilter);
	*** getEventQueue();
	*** pumpEvents(int,java.awt.Conditional);
	*** removeEventFilter(java.awt.EventFilter);
	*** setEventQueue(java.awt.EventQueue);
	*** stopDispatching();
}

-keep class java.awt.EventQueue {
	*** appContext;
	*** classLoader;
	*** currentEvent;
	*** dispatchThread;
	*** dummyRunnable;
	*** eventLog;
	*** javaSecurityAccess;
	*** mostRecentEventTime;
	*** name;
	*** nextQueue;
	*** previousQueue;
	*** pushPopCond;
	*** pushPopLock;
	*** queues;
	*** threadGroup;
	*** threadInitNumber;
	*** waitForID;
	*** access$000(java.awt.EventQueue);
	*** access$100(java.awt.EventQueue,boolean);
	*** cacheEQItem(sun.awt.EventQueueItem);
	*** coalesceEvent(java.awt.AWTEvent,int);
	*** coalesceMouseEvent(java.awt.event.MouseEvent);
	*** coalesceOtherEvent(java.awt.AWTEvent,int);
	*** coalescePaintEvent(java.awt.event.PaintEvent);
	*** coalescePeerEvent(sun.awt.PeerEvent);
	*** createSecondaryLoop(java.awt.Conditional,java.awt.EventFilter,long);
	*** dispatchEventImpl(java.awt.AWTEvent,java.lang.Object);
	*** eventToCacheIndex(java.awt.AWTEvent);
	*** getAccessControlContextFrom(java.lang.Object);
	*** getCurrentEvent();
	*** getCurrentEventImpl();
	*** getDispatchThread();
	*** getMostRecentEventTime();
	*** getMostRecentEventTimeEx();
	*** getMostRecentEventTimeImpl();
	*** getNextEventPrivate();
	*** getPriority(java.awt.AWTEvent);
	*** initDispatchThread();
	*** invokeAndWait(java.lang.Object,java.lang.Runnable);
	*** invokeAndWait(java.lang.Runnable);
	*** invokeLater(java.lang.Runnable);
	*** isDispatchThread();
	*** isDispatchThreadImpl();
	*** mergePaintEvents(java.awt.event.PaintEvent,java.awt.event.PaintEvent);
	*** noEvents();
	*** peekEvent();
	*** postEvent(java.awt.AWTEvent);
	*** postEvent(java.awt.AWTEvent,int);
	*** postEventPrivate(java.awt.AWTEvent);
	*** removeSourceEvents(java.lang.Object,boolean);
	*** setCurrentEventAndMostRecentTime(java.awt.AWTEvent);
	*** setCurrentEventAndMostRecentTimeImpl(java.awt.AWTEvent);
	*** uncacheEQItem(sun.awt.EventQueueItem);
	*** wakeup(boolean);
}

-keep class java.awt.FlowLayout {
	*** align;
	*** alignOnBaseline;
	*** hgap;
	*** newAlign;
	*** serialVersionOnStream;
	*** vgap;
	java.awt.FlowLayout(int,int,int);
	*** getAlignOnBaseline();
	*** moveComponents(java.awt.Container,int,int,int,int,int,int,boolean,boolean,int[],int[]);
	*** setAlignment(int);
}

-keep class java.awt.FocusManager {
	*** focusOwner;
	*** focusRoot;
}

-keep class java.awt.FocusTraversalPolicy {
	java.awt.FocusTraversalPolicy();
	*** getComponentAfter(java.awt.Container,java.awt.Component);
	*** getComponentBefore(java.awt.Container,java.awt.Component);
	*** getDefaultComponent(java.awt.Container);
	*** getInitialComponent(java.awt.Window);
	*** getLastComponent(java.awt.Container);
}

-keep class java.awt.Font {
	*** EXTRA_MASK;
	*** LAYOUT_MASK;
	*** PRIMARY_MASK;
	*** RECOGNIZED_MASK;
	*** SECONDARY_MASK;
	*** createdFont;
	*** fRequestedAttributes;
	*** flmref;
	*** font2DHandle;
	*** fontSerializedDataVersion;
	*** hasLayoutAttributes;
	*** hash;
	*** identityTx;
	*** name;
	*** nonIdentityTx;
	*** peer;
	*** pointSize;
	*** size;
	*** ssinfo;
	*** style;
	*** values;
	java.awt.Font(java.awt.Font);
	java.awt.Font(java.lang.String,int,float);
	java.awt.Font(java.lang.String,int,int);
	*** access$000(java.awt.Font);
	*** access$102(java.awt.Font,sun.font.Font2DHandle);
	*** access$200(java.awt.Font);
	*** access$202(java.awt.Font,boolean);
	*** applyStyle(int,sun.font.AttributeValues);
	*** applyTransform(java.awt.geom.AffineTransform,sun.font.AttributeValues);
	*** createFont0(int,java.io.InputStream,sun.font.CreatedFontTracker);
	*** createGlyphVector(java.awt.font.FontRenderContext,char[]);
	*** decode(java.lang.String);
	*** defaultLineMetrics(java.awt.font.FontRenderContext);
	*** deriveFont(float);
	*** deriveFont(int);
	*** deriveFont(int,float);
	*** deriveFont(int,java.awt.geom.AffineTransform);
	*** deriveFont(java.awt.geom.AffineTransform);
	*** deriveFont(java.util.Map);
	*** equals(java.lang.Object);
	*** getAttributeValues();
	*** getFamily();
	*** getFamily(java.util.Locale);
	*** getFamily_NoClientCode();
	*** getFont(java.lang.String,java.awt.Font);
	*** getFont2D();
	*** getFontName(java.util.Locale);
	*** getItalicAngle(java.awt.font.FontRenderContext);
	*** getPeer_NoClientCode();
	*** getSize();
	*** getSize2D();
	*** getStringBounds(char[],int,int,java.awt.font.FontRenderContext);
	*** getStringBounds(java.lang.String,java.awt.font.FontRenderContext);
	*** getTransform();
	*** hasLayoutAttributes();
	*** hasTempPermission();
	*** hashCode();
	*** initFromValues(sun.font.AttributeValues);
	*** initIDs();
	*** isBold();
	*** isItalic();
	*** isTransformed();
}

-keep class java.awt.Font$FontAccessImpl {
	java.awt.Font$FontAccessImpl();
}

-keep class java.awt.FontMetrics {
	*** charWidth(char);
	*** charsWidth(char[],int,int);
	*** getAscent();
	*** getFont();
	*** getFontRenderContext();
	*** getHeight();
	*** stringWidth(java.lang.String);
}

-keep class java.awt.Frame {
	*** frameSerializedDataVersion;
	*** maximizedBounds;
	*** mbManagement;
	*** menuBar;
	*** nameCounter;
	*** ownedWindows;
	*** resizable;
	*** state;
	*** title;
	*** undecorated;
	java.awt.Frame();
	java.awt.Frame(java.awt.GraphicsConfiguration);
	java.awt.Frame(java.lang.String);
	java.awt.Frame(java.lang.String,java.awt.GraphicsConfiguration);
	*** access$000(java.awt.Frame);
	*** access$002(java.awt.Frame,int);
	*** addNotify();
	*** getExtendedState();
	*** getFrames();
	*** getMenuBar();
	*** getState();
	*** init(java.lang.String,java.awt.GraphicsConfiguration);
	*** initIDs();
	*** isFrameStateSupported(int);
	*** isUndecorated();
	*** paramString();
	*** remove(java.awt.MenuComponent);
	*** setBackground(java.awt.Color);
	*** setExtendedState(int);
	*** setIconImage(java.awt.Image);
	*** setMenuBar(java.awt.MenuBar);
	*** setUndecorated(boolean);
}

-keep class java.awt.Graphics {
	java.awt.Graphics();
	*** clearRect(int,int,int,int);
	*** clipRect(int,int,int,int);
	*** copyArea(int,int,int,int,int,int);
	*** create();
	*** create(int,int,int,int);
	*** dispose();
	*** drawChars(char[],int,int,int,int);
	*** drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver);
	*** drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** drawLine(int,int,int,int);
	*** drawPolygon(int[],int[],int);
	*** drawRect(int,int,int,int);
	*** drawString(java.lang.String,int,int);
	*** drawString(java.text.AttributedCharacterIterator,int,int);
	*** fillPolygon(int[],int[],int);
	*** fillRect(int,int,int,int);
	*** getClip();
	*** getClipBounds();
	*** getColor();
	*** getFont();
	*** getFontMetrics();
	*** getFontMetrics(java.awt.Font);
	*** hitClip(int,int,int,int);
	*** setClip(int,int,int,int);
	*** setColor(java.awt.Color);
	*** setFont(java.awt.Font);
	*** translate(int,int);
}

-keep class java.awt.Graphics2D {
	java.awt.Graphics2D();
	*** fill(java.awt.Shape);
	*** getBackground();
	*** getComposite();
	*** getDeviceConfiguration();
	*** getFontRenderContext();
	*** getPaint();
	*** getRenderingHint(java.awt.RenderingHints$Key);
	*** setBackground(java.awt.Color);
	*** setComposite(java.awt.Composite);
	*** setPaint(java.awt.Paint);
	*** setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object);
}

-keep class java.awt.GraphicsCallback$PaintAllCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PaintCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PaintHeavyweightComponentsCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PeerPaintCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PeerPrintCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PrintAllCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PrintCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsCallback$PrintHeavyweightComponentsCallback {
	*** getInstance();
}

-keep class java.awt.GraphicsConfigTemplate {
	*** getBestConfiguration(java.awt.GraphicsConfiguration[]);
}

-keep class java.awt.GraphicsConfiguration {
	*** $assertionsDisabled;
	*** defaultBufferCaps;
	*** defaultImageCaps;
	java.awt.GraphicsConfiguration();
	*** createCompatibleImage(int,int);
	*** createCompatibleVolatileImage(int,int,int);
	*** createCompatibleVolatileImage(int,int,java.awt.ImageCapabilities,int);
	*** getBounds();
	*** getColorModel();
	*** getColorModel(int);
	*** getDevice();
	*** getImageCapabilities();
	*** isTranslucencyCapable();
}

-keep class java.awt.GraphicsDevice {
	*** fsAppContextLock;
	*** fullScreenAppContext;
	*** fullScreenWindow;
	*** windowedModeBounds;
	java.awt.GraphicsDevice();
	*** getConfigurations();
	*** getDefaultConfiguration();
	*** getDisplayMode();
	*** getFullScreenWindow();
	*** getIDstring();
	*** getTranslucencyCapableGC();
	*** getType();
	*** isWindowOpacitySupported();
	*** isWindowPerpixelTranslucencySupported();
	*** isWindowShapingSupported();
	*** isWindowTranslucencySupported(java.awt.GraphicsDevice$WindowTranslucency);
	*** setFullScreenWindow(java.awt.Window);
}

-keep class java.awt.GraphicsDevice$1 {
	*** $SwitchMap$java$awt$GraphicsDevice$WindowTranslucency;
}

-keep class java.awt.GraphicsDevice$WindowTranslucency {
	*** PERPIXEL_TRANSPARENT;
	*** TRANSLUCENT;
}

-keep class java.awt.GraphicsEnvironment {
	*** defaultHeadless;
	*** headless;
	*** localEnv;
	java.awt.GraphicsEnvironment();
	*** access$002(java.lang.Boolean);
	*** access$102(java.lang.Boolean);
	*** checkHeadless();
	*** createGE();
	*** getCenterPoint();
	*** getDefaultScreenDevice();
	*** getHeadlessProperty();
	*** getLocalGraphicsEnvironment();
	*** getScreenDevices();
	*** isHeadless();
}

-keep class java.awt.Image {
	*** UndefinedProperty;
	*** accelerationPriority;
	*** defaultImageCaps;
	*** surfaceManager;
	*** flush();
	*** getAccelerationPriority();
	*** getGraphics();
	*** getHeight(java.awt.image.ImageObserver);
	*** getSource();
	*** getWidth(java.awt.image.ImageObserver);
}

-keep class java.awt.ImageCapabilities {
	*** accelerated;
	java.awt.ImageCapabilities(boolean);
	*** isAccelerated();
}

-keep class java.awt.Insets {
	*** bottom;
	*** left;
	*** right;
	*** top;
	java.awt.Insets(int,int,int,int);
	*** clone();
	*** equals(java.lang.Object);
	*** initIDs();
	*** set(int,int,int,int);
	*** toString();
}

-keep class java.awt.KeyEventDispatcher {
	*** dispatchKeyEvent(java.awt.event.KeyEvent);
}

-keep class java.awt.KeyEventPostProcessor {
	*** postProcessKeyEvent(java.awt.event.KeyEvent);
}

-keep class java.awt.KeyboardFocusManager {
	*** $assertionsDisabled;
	*** activeWindow;
	*** allowSyncFocusRequests;
	*** changeSupport;
	*** clearingCurrentLightweightRequests;
	*** currentFocusCycleRoot;
	*** currentLightweightRequests;
	*** currentSequencedEvent;
	*** defaultFocusTraversalKeyPropertyNames;
	*** defaultFocusTraversalKeyStrokes;
	*** defaultFocusTraversalKeys;
	*** defaultPolicy;
	*** disableRestoreFocus;
	*** focusLog;
	*** focusOwner;
	*** focusedWindow;
	*** heavyweightRequests;
	*** keyEventDispatchers;
	*** keyEventPostProcessors;
	*** log;
	*** mostRecentFocusOwners;
	*** newFocusOwner;
	*** peer;
	*** permanentFocusOwner;
	*** proxyActive;
	*** replaceKeyboardFocusManagerPermission;
	*** vetoableSupport;
	java.awt.KeyboardFocusManager();
	*** _clearGlobalFocusOwner();
	*** access$000();
	*** addKeyEventPostProcessor(java.awt.KeyEventPostProcessor);
	*** checkCurrentKFMSecurity();
	*** clearGlobalFocusOwner();
	*** clearMarkers();
	*** clearMostRecentFocusOwner(java.awt.Component);
	*** dequeueKeyEvents(long,java.awt.Component);
	*** discardKeyEvents(java.awt.Component);
	*** dispatchAndCatchException(java.lang.Throwable,java.awt.Component,java.awt.event.FocusEvent);
	*** dispatchEvent(java.awt.AWTEvent);
	*** downFocusCycle(java.awt.Container);
	*** enqueueKeyEvents(long,java.awt.Component);
	*** firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** fireVetoableChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** focusNextComponent(java.awt.Component);
	*** focusPreviousComponent(java.awt.Component);
	*** focusedWindowChanged(java.awt.Component,java.awt.Component);
	*** getActiveWindow();
	*** getCurrentFocusCycleRoot();
	*** getCurrentKeyboardFocusManager();
	*** getCurrentKeyboardFocusManager(sun.awt.AppContext);
	*** getCurrentSequencedEvent();
	*** getDefaultFocusTraversalKeys(int);
	*** getDefaultFocusTraversalPolicy();
	*** getFirstHWRequest();
	*** getFocusOwner();
	*** getFocusedWindow();
	*** getGlobalActiveWindow();
	*** getGlobalFocusOwner();
	*** getGlobalFocusedWindow();
	*** getGlobalPermanentFocusOwner();
	*** getHeavyweight(java.awt.Component);
	*** getKeyEventDispatchers();
	*** getKeyEventPostProcessors();
	*** getLastHWRequest();
	*** getMostRecentFocusOwner(java.awt.Window);
	*** getNativeFocusOwner();
	*** getNativeFocusedWindow();
	*** getPermanentFocusOwner();
	*** handleException(java.lang.Throwable);
	*** initIDs();
	*** initPeer();
	*** isAutoFocusTransferEnabled();
	*** isAutoFocusTransferEnabledFor(java.awt.Component);
	*** isProxyActive(java.awt.event.KeyEvent);
	*** isProxyActiveImpl(java.awt.event.KeyEvent);
	*** isTemporary(java.awt.Component,java.awt.Component);
	*** markClearGlobalFocusOwner();
	*** processCurrentLightweightRequests();
	*** processKeyEvent(java.awt.Component,java.awt.event.KeyEvent);
	*** processSynchronousLightweightTransfer(java.awt.Component,java.awt.Component,boolean,boolean,long);
	*** redispatchEvent(java.awt.Component,java.awt.AWTEvent);
	*** removeFirstRequest();
	*** removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor);
	*** removeLastFocusRequest(java.awt.Component);
	*** retargetFocusEvent(java.awt.AWTEvent);
	*** retargetFocusGained(java.awt.event.FocusEvent);
	*** retargetFocusLost(java.awt.event.FocusEvent);
	*** retargetUnexpectedFocusEvent(java.awt.event.FocusEvent);
	*** setCurrentKeyboardFocusManager(java.awt.KeyboardFocusManager);
	*** setDefaultFocusTraversalPolicy(java.awt.FocusTraversalPolicy);
	*** setGlobalActiveWindow(java.awt.Window);
	*** setGlobalCurrentFocusCycleRoot(java.awt.Container);
	*** setGlobalFocusOwner(java.awt.Component);
	*** setGlobalFocusedWindow(java.awt.Window);
	*** setGlobalPermanentFocusOwner(java.awt.Component);
	*** setMostRecentFocusOwner(java.awt.Component);
	*** setMostRecentFocusOwner(java.awt.Window,java.awt.Component);
	*** setNativeFocusOwner(java.awt.Component);
	*** shouldNativelyFocusHeavyweight(java.awt.Component,java.awt.Component,boolean,boolean,long,sun.awt.CausedFocusEvent$Cause);
	*** upFocusCycle(java.awt.Component);
}

-keep class java.awt.KeyboardFocusManager$HeavyweightFocusRequest {
	*** CLEAR_GLOBAL_FOCUS_OWNER;
	*** heavyweight;
	*** lightweightRequests;
	*** addLightweightRequest(java.awt.Component,boolean,sun.awt.CausedFocusEvent$Cause);
	*** getFirstLightweightRequest();
}

-keep class java.awt.KeyboardFocusManager$LightweightFocusRequest {
	*** cause;
	*** component;
	*** temporary;
}

-keep class java.awt.LayoutManager {
	*** addLayoutComponent(java.lang.String,java.awt.Component);
	*** layoutContainer(java.awt.Container);
	*** minimumLayoutSize(java.awt.Container);
	*** preferredLayoutSize(java.awt.Container);
	*** removeLayoutComponent(java.awt.Component);
}

-keep class java.awt.LayoutManager2 {
	*** addLayoutComponent(java.awt.Component,java.lang.Object);
	*** getLayoutAlignmentX(java.awt.Container);
	*** getLayoutAlignmentY(java.awt.Container);
	*** invalidateLayout(java.awt.Container);
	*** maximumLayoutSize(java.awt.Container);
}

-keep class java.awt.LightweightDispatcher {
	*** $assertionsDisabled;
	*** eventLog;
	*** eventMask;
	*** isMouseInNativeContainer;
	*** mouseEventTarget;
	*** nativeContainer;
	*** targetLastEntered;
	*** dispatchEvent(java.awt.AWTEvent);
	*** dispose();
	*** enableEvents(long);
	*** isMouseGrab(java.awt.event.MouseEvent);
	*** processDropTargetEvent(sun.awt.dnd.SunDropTargetEvent);
	*** processMouseEvent(java.awt.event.MouseEvent);
	*** retargetMouseEvent(java.awt.Component,int,java.awt.event.MouseEvent);
	*** startListeningForOtherDrags();
	*** stopListeningForOtherDrags();
	*** trackMouseEnterExit(java.awt.Component,java.awt.event.MouseEvent);
}

-keep class java.awt.Menu {
	*** isHelpMenu;
	*** items;
	*** menuSerializedDataVersion;
	*** nameCounter;
	*** tearOff;
	java.awt.Menu(java.lang.String);
	java.awt.Menu(java.lang.String,boolean);
	*** add(java.awt.MenuItem);
	*** add(java.lang.String);
	*** addNotify();
	*** addSeparator();
	*** countItems();
	*** countItemsImpl();
	*** getItem(int);
	*** getItemCount();
	*** getItemImpl(int);
	*** initIDs();
	*** insert(java.awt.MenuItem,int);
	*** remove(int);
	*** removeNotify();
	*** shortcuts();
}

-keep class java.awt.MenuBar {
	*** addNotify();
	*** handleShortcut(java.awt.event.KeyEvent);
	*** removeNotify();
}

-keep class java.awt.MenuComponent {
	*** acc;
	*** accessibleContext;
	*** appContext;
	*** font;
	*** name;
	*** nameExplicitlySet;
	*** newEventsOnly;
	*** parent;
	*** peer;
	java.awt.MenuComponent();
	*** constructComponentName();
	*** dispatchEvent(java.awt.AWTEvent);
	*** dispatchEventImpl(java.awt.AWTEvent);
	*** eventEnabled(java.awt.AWTEvent);
	*** getAccessControlContext();
	*** getAccessibleChildIndex(java.awt.MenuComponent);
	*** getFont_NoClientCode();
	*** getName();
	*** getParent();
	*** getParent_NoClientCode();
	*** getTreeLock();
	*** initIDs();
	*** paramString();
	*** postEvent(java.awt.Event);
	*** processEvent(java.awt.AWTEvent);
	*** removeNotify();
}

-keep class java.awt.MenuContainer {
	*** getFont();
	*** postEvent(java.awt.Event);
	*** remove(java.awt.MenuComponent);
}

-keep class java.awt.MenuItem {
	*** actionCommand;
	*** actionListener;
	*** enabled;
	*** eventMask;
	*** label;
	*** menuItemSerializedDataVersion;
	*** nameCounter;
	*** shortcut;
	java.awt.MenuItem(java.lang.String);
	java.awt.MenuItem(java.lang.String,java.awt.MenuShortcut);
	*** addActionListener(java.awt.event.ActionListener);
	*** addNotify();
	*** deleteShortcut(java.awt.MenuShortcut);
	*** disable();
	*** doMenuEvent(long,int);
	*** enable();
	*** enable(boolean);
	*** getActionCommand();
	*** getActionCommandImpl();
	*** getLabel();
	*** getListeners(java.lang.Class);
	*** getShortcut();
	*** getShortcutMenuItem(java.awt.MenuShortcut);
	*** handleShortcut(java.awt.event.KeyEvent);
	*** initIDs();
	*** isEnabled();
	*** isItemEnabled();
	*** paramString();
	*** processActionEvent(java.awt.event.ActionEvent);
}

-keep class java.awt.MenuShortcut {
	*** equals(java.awt.MenuShortcut);
}

-keep class java.awt.ModalEventFilter {
	*** createFilterForDialog(java.awt.Dialog);
	*** disable();
}

-keep class java.awt.Paint {
	*** createContext(java.awt.image.ColorModel,java.awt.Rectangle,java.awt.geom.Rectangle2D,java.awt.geom.AffineTransform,java.awt.RenderingHints);
}

-keep class java.awt.PaintContext {
	*** dispose();
	*** getColorModel();
	*** getRaster(int,int,int,int);
}

-keep class java.awt.Point {
	*** x;
	*** y;
	java.awt.Point(int,int);
	*** getX();
	*** getY();
	*** move(int,int);
	*** setLocation(int,int);
	*** translate(int,int);
}

-keep class java.awt.PointerInfo {
	*** getLocation();
}

-keep class java.awt.Polygon {
	*** npoints;
	*** xpoints;
	*** ypoints;
}

-keep class java.awt.PopupMenu {
	*** isTrayIconPopup;
	*** nameCounter;
	java.awt.PopupMenu(java.lang.String);
	*** addNotify();
}

-keep class java.awt.Queue {
	*** head;
	*** tail;
}

-keep class java.awt.Rectangle {
	*** height;
	*** width;
	*** x;
	*** y;
	java.awt.Rectangle(int,int,int,int);
	*** add(int,int);
	*** clip(double,boolean);
	*** contains(int,int);
	*** contains(int,int,int,int);
	*** contains(java.awt.Point);
	*** contains(java.awt.Rectangle);
	*** initIDs();
	*** inside(int,int);
	*** intersection(java.awt.Rectangle);
	*** intersects(java.awt.Rectangle);
	*** isEmpty();
	*** move(int,int);
	*** reshape(int,int,int,int);
	*** resize(int,int);
	*** setBounds(int,int,int,int);
	*** setBounds(java.awt.Rectangle);
	*** setLocation(int,int);
	*** setSize(int,int);
	*** translate(int,int);
	*** union(java.awt.Rectangle);
}

-keep class java.awt.RenderingHints {
	*** KEY_ALPHA_INTERPOLATION;
	*** KEY_ANTIALIASING;
	*** KEY_COLOR_RENDERING;
	*** KEY_DITHERING;
	*** KEY_FRACTIONALMETRICS;
	*** KEY_INTERPOLATION;
	*** KEY_RENDERING;
	*** KEY_STROKE_CONTROL;
	*** KEY_TEXT_ANTIALIASING;
	*** KEY_TEXT_LCD_CONTRAST;
	*** VALUE_ALPHA_INTERPOLATION_DEFAULT;
	*** VALUE_ALPHA_INTERPOLATION_QUALITY;
	*** VALUE_ALPHA_INTERPOLATION_SPEED;
	*** VALUE_ANTIALIAS_DEFAULT;
	*** VALUE_ANTIALIAS_OFF;
	*** VALUE_ANTIALIAS_ON;
	*** VALUE_COLOR_RENDER_DEFAULT;
	*** VALUE_COLOR_RENDER_QUALITY;
	*** VALUE_COLOR_RENDER_SPEED;
	*** VALUE_DITHER_DEFAULT;
	*** VALUE_DITHER_DISABLE;
	*** VALUE_DITHER_ENABLE;
	*** VALUE_FRACTIONALMETRICS_DEFAULT;
	*** VALUE_FRACTIONALMETRICS_OFF;
	*** VALUE_FRACTIONALMETRICS_ON;
	*** VALUE_INTERPOLATION_BICUBIC;
	*** VALUE_INTERPOLATION_BILINEAR;
	*** VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
	*** VALUE_RENDER_DEFAULT;
	*** VALUE_RENDER_QUALITY;
	*** VALUE_RENDER_SPEED;
	*** VALUE_STROKE_DEFAULT;
	*** VALUE_STROKE_NORMALIZE;
	*** VALUE_STROKE_PURE;
	*** VALUE_TEXT_ANTIALIAS_DEFAULT;
	*** VALUE_TEXT_ANTIALIAS_GASP;
	*** VALUE_TEXT_ANTIALIAS_LCD_HBGR;
	*** VALUE_TEXT_ANTIALIAS_LCD_HRGB;
	*** VALUE_TEXT_ANTIALIAS_LCD_VBGR;
	*** VALUE_TEXT_ANTIALIAS_LCD_VRGB;
	*** VALUE_TEXT_ANTIALIAS_OFF;
	*** VALUE_TEXT_ANTIALIAS_ON;
	*** hintmap;
	*** clone();
	*** get(java.lang.Object);
	*** hashCode();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
}

-keep class java.awt.RenderingHints$Key {
	*** identitymap;
	*** privatekey;
	java.awt.RenderingHints$Key(int);
	*** getIdentity();
	*** intKey();
	*** isCompatibleValue(java.lang.Object);
	*** recordIdentity(java.awt.RenderingHints$Key);
}

-keep class java.awt.SecondaryLoop {
	*** enter();
	*** exit();
}

-keep class java.awt.SentEvent {
	*** dispatched;
	*** dispatch();
	*** dispose();
}

-keep class java.awt.SequencedEvent {
	*** dispose();
}

-keep class java.awt.Shape {
	*** contains(double,double);
	*** contains(double,double,double,double);
	*** getBounds();
	*** getBounds2D();
	*** getPathIterator(java.awt.geom.AffineTransform);
	*** intersects(double,double,double,double);
	*** intersects(java.awt.geom.Rectangle2D);
}

-keep class java.awt.SplashScreen {
	*** markClosed();
}

-keep class java.awt.Stroke {
	*** createStrokedShape(java.awt.Shape);
}

-keep class java.awt.SystemColor {
	*** activeCaption;
	*** activeCaptionBorder;
	*** activeCaptionText;
	*** control;
	*** controlDkShadow;
	*** controlHighlight;
	*** controlLtHighlight;
	*** controlShadow;
	*** controlText;
	*** desktop;
	*** inactiveCaption;
	*** inactiveCaptionBorder;
	*** inactiveCaptionText;
	*** index;
	*** info;
	*** infoText;
	*** menu;
	*** menuText;
	*** scrollbar;
	*** systemColorObjects;
	*** systemColors;
	*** text;
	*** textHighlight;
	*** textHighlightText;
	*** textInactiveText;
	*** textText;
	*** window;
	*** windowBorder;
	*** windowText;
	*** updateSystemColors();
}

-keep class java.awt.Toolkit {
	*** $assertionsDisabled;
	*** atNames;
	*** calls;
	*** desktopProperties;
	*** desktopPropsSupport;
	*** enabledOnToolkitMask;
	*** eventListener;
	*** lightweightMarker;
	*** listener2SelectiveListener;
	*** loaded;
	*** resources;
	*** toolkit;
	java.awt.Toolkit();
	*** access$000();
	*** access$002(java.awt.Toolkit);
	*** access$102(java.util.ResourceBundle);
	*** addAWTEventListener(java.awt.event.AWTEventListener,long);
	*** addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** areExtraMouseButtonsEnabled();
	*** beep();
	*** checkImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** createComponent(java.awt.Component);
	*** createCustomCursor(java.awt.Image,java.awt.Point,java.lang.String);
	*** createDialog(java.awt.Dialog);
	*** createFrame(java.awt.Frame);
	*** createImage(byte[]);
	*** createImage(byte[],int,int);
	*** createImage(java.awt.image.ImageProducer);
	*** createImage(java.lang.String);
	*** createImage(java.net.URL);
	*** createMenu(java.awt.Menu);
	*** createMenuItem(java.awt.MenuItem);
	*** createPopupMenu(java.awt.PopupMenu);
	*** createPropertyChangeSupport(java.awt.Toolkit);
	*** createWindow(java.awt.Window);
	*** deProxyAWTEventListener(java.awt.event.AWTEventListener);
	*** enabledOnToolkit(long);
	*** getAWTEventListeners();
	*** getAWTEventListeners(long);
	*** getBestCursorSize(int,int);
	*** getColorModel();
	*** getDefaultToolkit();
	*** getDesktopProperty(java.lang.String);
	*** getEventQueue();
	*** getFontList();
	*** getFontMetrics(java.awt.Font);
	*** getFontPeer(java.lang.String,int);
	*** getImage(java.lang.String);
	*** getImage(java.net.URL);
	*** getMaximumCursorColors();
	*** getMouseInfoPeer();
	*** getNativeContainer(java.awt.Component);
	*** getPrintJob(java.awt.Frame,java.lang.String,java.awt.JobAttributes,java.awt.PageAttributes);
	*** getPrintJob(java.awt.Frame,java.lang.String,java.util.Properties);
	*** getProperty(java.lang.String,java.lang.String);
	*** getScreenInsets(java.awt.GraphicsConfiguration);
	*** getScreenSize();
	*** getSystemEventQueue();
	*** getSystemEventQueueImpl();
	*** getSystemSelection();
	*** initAssistiveTechnologies();
	*** initIDs();
	*** initializeDesktopProperties();
	*** isAlwaysOnTopSupported();
	*** isDynamicLayoutActive();
	*** isDynamicLayoutSet();
	*** isFrameStateSupported(int);
	*** isModalExclusionTypeSupported(java.awt.Dialog$ModalExclusionType);
	*** isModalityTypeSupported(java.awt.Dialog$ModalityType);
	*** lazilyLoadDesktopProperty(java.lang.String);
	*** loadAssistiveTechnologies();
	*** loadLibraries();
	*** loadSystemColors(int[]);
	*** mapInputMethodHighlight(java.awt.im.InputMethodHighlight);
	*** notifyAWTEventListeners(java.awt.AWTEvent);
	*** prepareImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** removeAWTEventListener(java.awt.event.AWTEventListener);
	*** removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** setDesktopProperty(java.lang.String,java.lang.Object);
	*** sync();
}

-keep class java.awt.Toolkit$1 {
	*** val$properties;
	*** val$sep;
}

-keep class java.awt.Toolkit$DesktopPropertyChangeSupport {
	*** PROP_CHANGE_SUPPORT_KEY;
	*** source;
}

-keep class java.awt.Toolkit$SelectiveAWTEventListener {
	*** getCalls();
	*** getEventMask();
	*** getListener();
	*** orEventMasks(long);
}

-keep class java.awt.Toolkit$ToolkitEventMulticaster {
	*** add(java.awt.event.AWTEventListener,java.awt.event.AWTEventListener);
	*** remove(java.awt.event.AWTEventListener,java.awt.event.AWTEventListener);
}

-keep class java.awt.Transparency {
	*** getTransparency();
}

-keep class java.awt.TrayIcon {
	*** dispatchEvent(java.awt.AWTEvent);
	*** getAccessControlContext();
}

-keep class java.awt.VKCollection {
	*** $assertionsDisabled;
	*** code2name;
	*** name2code;
	*** findCode(java.lang.String);
	*** findName(java.lang.Integer);
	*** put(java.lang.String,java.lang.Integer);
}

-keep class java.awt.Window {
	*** allWindows;
	*** alwaysOnTop;
	*** anchor;
	*** autoRequestFocus;
	*** beforeFirstShow;
	*** beforeFirstWindowShown;
	*** disposing;
	*** focusMgr;
	*** focusableWindowState;
	*** icons;
	*** inputContext;
	*** inputContextLock;
	*** isInShow;
	*** isTrayIconWindow;
	*** locationByPlatform;
	*** locationByPlatformProp;
	*** log;
	*** modalBlocker;
	*** modalExclusionType;
	*** nameCounter;
	*** opacity;
	*** ownedWindowList;
	*** securityWarningAlignmentX;
	*** securityWarningAlignmentY;
	*** securityWarningHeight;
	*** securityWarningPointX;
	*** securityWarningPointY;
	*** securityWarningWidth;
	*** shape;
	*** showWithParent;
	*** state;
	*** syncLWRequests;
	*** systemSyncLWRequests;
	*** temporaryLostComponent;
	*** type;
	*** warningString;
	*** weakThis;
	*** windowFocusListener;
	*** windowListener;
	*** windowSerializedDataVersion;
	*** windowStateListener;
	java.awt.Window();
	java.awt.Window(java.awt.Frame);
	java.awt.Window(java.awt.GraphicsConfiguration);
	java.awt.Window(java.awt.Window);
	java.awt.Window(java.awt.Window,java.awt.GraphicsConfiguration);
	*** access$000(java.awt.Window);
	*** access$100(sun.awt.AppContext,java.lang.ref.WeakReference);
	*** access$1002(java.awt.Window,float);
	*** access$1102(java.awt.Window,float);
	*** access$1200(java.awt.Window,double,double,double,double);
	*** access$1300(java.awt.Window);
	*** access$400(java.awt.Window);
	*** access$500(java.awt.Window);
	*** access$600(java.awt.Window);
	*** access$602(java.awt.Window,int);
	*** access$700(java.awt.Window);
	*** access$702(java.awt.Window,int);
	*** access$802(java.awt.Window,double);
	*** access$902(java.awt.Window,double);
	*** addNotify();
	*** addOwnedWindow(java.lang.ref.WeakReference);
	*** addToWindowList();
	*** addWindowFocusListener(java.awt.event.WindowFocusListener);
	*** addWindowListener(java.awt.event.WindowListener);
	*** addWindowStateListener(java.awt.event.WindowStateListener);
	*** applyResourceBundle(java.util.ResourceBundle);
	*** calculateSecurityWarningPosition(double,double,double,double);
	*** closeSplashScreen();
	*** connectOwnedWindow(java.awt.Window);
	*** deserializeResources(java.io.ObjectInputStream);
	*** dispose();
	*** disposeImpl();
	*** doDispose();
	*** getAllUnblockedWindows();
	*** getBackground();
	*** getDocumentRoot();
	*** getFocusOwner();
	*** getFocusableWindowState();
	*** getListeners(java.lang.Class);
	*** getModalBlocker();
	*** getModalExclusionType();
	*** getMostRecentFocusOwner();
	*** getOpacity();
	*** getOwnedWindows();
	*** getOwnedWindows_NoClientCode();
	*** getOwner();
	*** getOwner_NoClientCode();
	*** getShape();
	*** getTemporaryLostComponent();
	*** getToolkit();
	*** getWindows();
	*** getWindows(sun.awt.AppContext);
	*** hide();
	*** init(java.awt.GraphicsConfiguration);
	*** initDeserializedWindow();
	*** initGC(java.awt.GraphicsConfiguration);
	*** initIDs();
	*** isAlwaysOnTop();
	*** isAlwaysOnTopSupported();
	*** isDisposing();
	*** isFocusableWindow();
	*** isFocused();
	*** isModalBlocked();
	*** isModalExcluded(java.awt.Dialog$ModalExclusionType);
	*** isOpaque();
	*** isShowing();
	*** limit(double,double,double);
	*** ownedInit(java.awt.Window);
	*** pack();
	*** paint(java.awt.Graphics);
	*** postProcessKeyEvent(java.awt.event.KeyEvent);
	*** postWindowEvent(int);
	*** processWindowEvent(java.awt.event.WindowEvent);
	*** processWindowFocusEvent(java.awt.event.WindowEvent);
	*** processWindowStateEvent(java.awt.event.WindowEvent);
	*** removeFromWindowList(sun.awt.AppContext,java.lang.ref.WeakReference);
	*** removeNotify();
	*** removeOwnedWindow(java.lang.ref.WeakReference);
	*** removeWindowListener(java.awt.event.WindowListener);
	*** setAlwaysOnTop(boolean);
	*** setBackground(java.awt.Color);
	*** setBounds(int,int,int,int);
	*** setBounds(java.awt.Rectangle);
	*** setClientSize(int,int);
	*** setCursor(java.awt.Cursor);
	*** setFocusableWindowState(boolean);
	*** setGraphicsConfiguration(java.awt.GraphicsConfiguration);
	*** setIconImage(java.awt.Image);
	*** setIconImages(java.util.List);
	*** setLayersOpaque(java.awt.Component,boolean);
	*** setLocation(int,int);
	*** setLocationByPlatform(boolean);
	*** setLocationRelativeTo(java.awt.Component);
	*** setModalBlocked(java.awt.Dialog,boolean,boolean);
	*** setModalExclusionType(java.awt.Dialog$ModalExclusionType);
	*** setOpacity(float);
	*** setShape(java.awt.Shape);
	*** setSize(int,int);
	*** setTemporaryLostComponent(java.awt.Component);
	*** setVisible(boolean);
	*** setWarningString();
	*** show();
	*** toBack();
	*** toBack_NoClientCode();
	*** toFront();
	*** toFront_NoClientCode();
	*** updateChildFocusableWindowState(java.awt.Window);
	*** updateChildrenBlocking();
	*** updateWindow();
}

-keep class java.awt.Window$1DisposeAction {
	*** run();
}

-keep class java.awt.Window$Type {
	*** $VALUES;
	*** NORMAL;
	*** POPUP;
	*** UTILITY;
}

-keep class java.awt.Window$WindowDisposerRecord {
	*** context;
	*** owner;
	*** weakThis;
}

-keep class java.awt.color.ColorSpace {
	*** GRAYspace;
	*** LINEAR_RGBspace;
	*** PYCCspace;
	*** XYZspace;
	*** compName;
	*** numComponents;
	*** sRGBspace;
	*** type;
	java.awt.color.ColorSpace(int,int);
	*** fromCIEXYZ(float[]);
	*** fromRGB(float[]);
	*** getInstance(int);
	*** getMaxValue(int);
	*** getMinValue(int);
	*** getName(int);
	*** getNumComponents();
	*** getType();
	*** toCIEXYZ(float[]);
	*** toRGB(float[]);
}

-keep class java.awt.color.ICC_ColorSpace {
	*** diffMinMax;
	*** invDiffMinMax;
	*** maxVal;
	*** minVal;
	*** needScaleInit;
	*** srgb2this;
	*** this2srgb;
	*** this2xyz;
	*** thisProfile;
	*** xyz2this;
	*** getMaxValue(int);
	*** getMinValue(int);
	*** getProfile();
	*** setComponentScaling();
	*** setMinMax();
}

-keep class java.awt.color.ICC_Profile {
	*** GRAYprofile;
	*** ID;
	*** LINEAR_RGBprofile;
	*** PYCCprofile;
	*** XYZprofile;
	*** deferralInfo;
	*** iccProfileSerializedDataVersion;
	*** profileActivator;
	*** resolvedDeserializedProfile;
	*** sRGBprofile;
	java.awt.color.ICC_Profile(long);
	java.awt.color.ICC_Profile(sun.java2d.cmm.ProfileDeferralInfo);
	*** activateDeferredProfile();
	*** getColorSpaceType();
	*** getColorSpaceType(long);
	*** getData();
	*** getData(int);
	*** getData(long,int);
	*** getDeferredInstance(sun.java2d.cmm.ProfileDeferralInfo);
	*** getGamma(int);
	*** getInstance(byte[]);
	*** getInstance(int);
	*** getInstance(java.io.InputStream);
	*** getMediaWhitePoint();
	*** getNumComponents();
	*** getPCSType(long);
	*** getProfileClass();
	*** getProfileDataFromStream(java.io.InputStream);
	*** getProfileFile(java.lang.String);
	*** getStandardProfile(java.lang.String);
	*** getStandardProfileFile(java.lang.String);
	*** getTRC(int);
	*** getXYZTag(int);
	*** iccCStoJCS(int);
	*** intFromBigEndian(byte[],int);
	*** intToBigEndian(int,byte[],int);
	*** isChildOf(java.io.File,java.lang.String);
	*** setData(int,byte[]);
	*** shortFromBigEndian(byte[],int);
	*** standardProfileExists(java.lang.String);
}

-keep class java.awt.color.ICC_Profile$1 {
	*** this$0;
}

-keep class java.awt.dnd.DropTarget {
	*** addNotify(java.awt.peer.ComponentPeer);
	*** removeNotify(java.awt.peer.ComponentPeer);
	*** setComponent(java.awt.Component);
}

-keep class java.awt.event.AWTEventListener {
	*** eventDispatched(java.awt.AWTEvent);
}

-keep class java.awt.event.ActionEvent {
	*** getActionCommand();
	*** getModifiers();
	*** getWhen();
}

-keep class java.awt.event.ActionListener {
	*** actionPerformed(java.awt.event.ActionEvent);
}

-keep class java.awt.event.AdjustmentEvent {
	*** getAdjustmentType();
	*** getValue();
	*** getValueIsAdjusting();
}

-keep class java.awt.event.AdjustmentListener {
	*** adjustmentValueChanged(java.awt.event.AdjustmentEvent);
}

-keep class java.awt.event.ComponentEvent {
	java.awt.event.ComponentEvent(java.awt.Component,int);
	*** getComponent();
}

-keep class java.awt.event.ComponentListener {
	*** componentHidden(java.awt.event.ComponentEvent);
	*** componentMoved(java.awt.event.ComponentEvent);
	*** componentResized(java.awt.event.ComponentEvent);
	*** componentShown(java.awt.event.ComponentEvent);
}

-keep class java.awt.event.ContainerEvent {
	*** child;
	*** getChild();
	*** getContainer();
}

-keep class java.awt.event.ContainerListener {
	*** componentAdded(java.awt.event.ContainerEvent);
	*** componentRemoved(java.awt.event.ContainerEvent);
}

-keep class java.awt.event.FocusEvent {
	*** getOppositeComponent();
	*** isTemporary();
}

-keep class java.awt.event.FocusListener {
	*** focusGained(java.awt.event.FocusEvent);
	*** focusLost(java.awt.event.FocusEvent);
}

-keep class java.awt.event.HierarchyBoundsListener {
	*** ancestorMoved(java.awt.event.HierarchyEvent);
	*** ancestorResized(java.awt.event.HierarchyEvent);
}

-keep class java.awt.event.HierarchyListener {
	*** hierarchyChanged(java.awt.event.HierarchyEvent);
}

-keep class java.awt.event.InputEvent {
	*** BUTTON_DOWN_MASK;
	*** canAccessSystemClipboard;
	*** logger;
	*** modifiers;
	*** when;
	java.awt.event.InputEvent(java.awt.Component,int,long,int);
	*** access$000();
	*** canAccessSystemClipboard();
	*** consume();
	*** getButtonDownMasks();
	*** getModifiers();
	*** getModifiersEx();
	*** getModifiersExText(int);
	*** getWhen();
	*** initIDs();
	*** isConsumed();
	*** isControlDown();
	*** isShiftDown();
}

-keep class java.awt.event.InputMethodEvent {
	*** consume();
	*** getCaret();
	*** getCommittedCharacterCount();
	*** getText();
	*** getWhen();
	*** isConsumed();
}

-keep class java.awt.event.InputMethodListener {
	*** caretPositionChanged(java.awt.event.InputMethodEvent);
	*** inputMethodTextChanged(java.awt.event.InputMethodEvent);
}

-keep class java.awt.event.InvocationEvent {
	*** getException();
	*** getThrowable();
	*** getWhen();
	*** isDispatched();
}

-keep class java.awt.event.ItemEvent {
	*** getItem();
	*** getStateChange();
}

-keep class java.awt.event.ItemListener {
	*** itemStateChanged(java.awt.event.ItemEvent);
}

-keep class java.awt.event.KeyEvent {
	*** extendedKeyCode;
	*** isProxyActive;
	*** keyChar;
	*** keyCode;
	*** keyLocation;
	*** primaryLevelUnicode;
	*** rawCode;
	*** scancode;
	java.awt.event.KeyEvent(java.awt.Component,int,long,int,int,char);
	java.awt.event.KeyEvent(java.awt.Component,int,long,int,int,char,int);
	*** access$002(java.awt.event.KeyEvent,long);
	*** access$102(java.awt.event.KeyEvent,long);
	*** access$202(java.awt.event.KeyEvent,long);
	*** getExtendedKeyCode();
	*** getExtendedKeyCodeForChar(int);
	*** getKeyChar();
	*** getKeyCode();
	*** getKeyModifiersText(int);
	*** getKeyText(int);
	*** initIDs();
	*** isActionKey();
	*** setKeyChar(char);
	*** setModifiers(int);
	*** setNewModifiers();
	*** setOldModifiers();
}

-keep class java.awt.event.KeyListener {
	*** keyPressed(java.awt.event.KeyEvent);
	*** keyReleased(java.awt.event.KeyEvent);
	*** keyTyped(java.awt.event.KeyEvent);
}

-keep class java.awt.event.MouseEvent {
	*** getButton();
	*** getClickCount();
	*** getModifiersEx();
	*** getX();
	*** getXOnScreen();
	*** getY();
	*** getYOnScreen();
	*** isPopupTrigger();
	*** translatePoint(int,int);
}

-keep class java.awt.event.MouseListener {
	*** mouseClicked(java.awt.event.MouseEvent);
	*** mouseEntered(java.awt.event.MouseEvent);
	*** mouseExited(java.awt.event.MouseEvent);
	*** mousePressed(java.awt.event.MouseEvent);
	*** mouseReleased(java.awt.event.MouseEvent);
}

-keep class java.awt.event.MouseMotionListener {
	*** mouseDragged(java.awt.event.MouseEvent);
	*** mouseMoved(java.awt.event.MouseEvent);
}

-keep class java.awt.event.MouseWheelEvent {
	*** getPreciseWheelRotation();
	*** getScrollAmount();
	*** getScrollType();
	*** getWheelRotation();
}

-keep class java.awt.event.MouseWheelListener {
	*** mouseWheelMoved(java.awt.event.MouseWheelEvent);
}

-keep class java.awt.event.NativeLibLoader {
	*** loadLibraries();
}

-keep class java.awt.event.PaintEvent {
	*** getUpdateRect();
}

-keep class java.awt.event.TextListener {
	*** textValueChanged(java.awt.event.TextEvent);
}

-keep class java.awt.event.WindowAdapter {
	java.awt.event.WindowAdapter();
}

-keep class java.awt.event.WindowEvent {
	*** newState;
	*** oldState;
	*** opposite;
	java.awt.event.WindowEvent(java.awt.Window,int,java.awt.Window,int,int);
	*** getOppositeWindow();
	*** getWindow();
}

-keep class java.awt.event.WindowFocusListener {
	*** windowGainedFocus(java.awt.event.WindowEvent);
	*** windowLostFocus(java.awt.event.WindowEvent);
}

-keep class java.awt.event.WindowListener {
	*** windowActivated(java.awt.event.WindowEvent);
	*** windowClosed(java.awt.event.WindowEvent);
	*** windowClosing(java.awt.event.WindowEvent);
	*** windowDeactivated(java.awt.event.WindowEvent);
	*** windowDeiconified(java.awt.event.WindowEvent);
	*** windowIconified(java.awt.event.WindowEvent);
	*** windowOpened(java.awt.event.WindowEvent);
}

-keep class java.awt.event.WindowStateListener {
	*** windowStateChanged(java.awt.event.WindowEvent);
}

-keep class java.awt.font.FontRenderContext {
	*** aaHintValue;
	*** defaulting;
	*** fmHintValue;
	*** tx;
	*** equals(java.awt.font.FontRenderContext);
	*** getAntiAliasingHint();
	*** getFractionalMetricsHint();
	*** getTransform();
	*** hashCode();
	*** isAntiAliased();
	*** isTransformed();
	*** usesFractionalMetrics();
}

-keep class java.awt.font.GlyphVector {
	*** getFont();
	*** getFontRenderContext();
	*** getGlyphPixelBounds(int,java.awt.font.FontRenderContext,float,float);
	*** getLogicalBounds();
	*** getOutline(float,float);
}

-keep class java.awt.font.LineBreakMeasurer {
	*** nextOffset(float);
}

-keep class java.awt.font.TextAttribute {
	*** BACKGROUND;
	*** BIDI_EMBEDDING;
	*** CHAR_REPLACEMENT;
	*** FAMILY;
	*** FONT;
	*** FOREGROUND;
	*** INPUT_METHOD_HIGHLIGHT;
	*** INPUT_METHOD_UNDERLINE;
	*** JUSTIFICATION;
	*** JUSTIFICATION_FULL;
	*** JUSTIFICATION_NONE;
	*** KERNING;
	*** KERNING_ON;
	*** LIGATURES;
	*** LIGATURES_ON;
	*** NUMERIC_SHAPING;
	*** POSTURE;
	*** POSTURE_OBLIQUE;
	*** POSTURE_REGULAR;
	*** RUN_DIRECTION;
	*** RUN_DIRECTION_LTR;
	*** RUN_DIRECTION_RTL;
	*** SIZE;
	*** STRIKETHROUGH;
	*** STRIKETHROUGH_ON;
	*** SUPERSCRIPT;
	*** SUPERSCRIPT_SUB;
	*** SUPERSCRIPT_SUPER;
	*** SWAP_COLORS;
	*** SWAP_COLORS_ON;
	*** TRACKING;
	*** TRACKING_LOOSE;
	*** TRACKING_TIGHT;
	*** TRANSFORM;
	*** UNDERLINE;
	*** UNDERLINE_LOW_DASHED;
	*** UNDERLINE_LOW_DOTTED;
	*** UNDERLINE_LOW_GRAY;
	*** UNDERLINE_LOW_ONE_PIXEL;
	*** UNDERLINE_LOW_TWO_PIXEL;
	*** UNDERLINE_ON;
	*** WEIGHT;
	*** WEIGHT_BOLD;
	*** WEIGHT_DEMIBOLD;
	*** WEIGHT_DEMILIGHT;
	*** WEIGHT_EXTRABOLD;
	*** WEIGHT_EXTRA_LIGHT;
	*** WEIGHT_HEAVY;
	*** WEIGHT_LIGHT;
	*** WEIGHT_MEDIUM;
	*** WEIGHT_REGULAR;
	*** WEIGHT_SEMIBOLD;
	*** WEIGHT_ULTRABOLD;
	*** WIDTH;
	*** WIDTH_CONDENSED;
	*** WIDTH_EXTENDED;
	*** WIDTH_REGULAR;
	*** WIDTH_SEMI_CONDENSED;
	*** WIDTH_SEMI_EXTENDED;
	*** instanceMap;
}

-keep class java.awt.font.TextHitInfo {
	*** getInsertionIndex();
	*** leading(int);
	*** trailing(int);
}

-keep class java.awt.font.TextLayout {
	*** draw(java.awt.Graphics2D,float,float);
	*** getAdvance();
	*** getAscent();
	*** getDescent();
	*** getJustifiedLayout(float);
	*** getLeading();
	*** getOutline(java.awt.geom.AffineTransform);
	*** getVisualHighlightShape(java.awt.font.TextHitInfo,java.awt.font.TextHitInfo);
}

-keep class java.awt.font.TransformAttribute {
	*** IDENTITY;
	*** getTransform();
	*** isIdentity();
}

-keep class java.awt.geom.AffineTransform {
	*** m00;
	*** m01;
	*** m02;
	*** m10;
	*** m11;
	*** m12;
	*** rot90conversion;
	*** state;
	*** type;
	*** _matround(double);
	*** calculateType();
	*** clone();
	*** concatenate(java.awt.geom.AffineTransform);
	*** createInverse();
	*** createTransformedShape(java.awt.Shape);
	*** deltaTransform(double[],int,double[],int,int);
	*** deltaTransform(java.awt.geom.Point2D,java.awt.geom.Point2D);
	*** equals(java.lang.Object);
	*** getDeterminant();
	*** getMatrix(double[]);
	*** getRotateInstance(double,double);
	*** getScaleX();
	*** getScaleY();
	*** getShearX();
	*** getShearY();
	*** getTranslateInstance(double,double);
	*** getTranslateX();
	*** getTranslateY();
	*** getType();
	*** hashCode();
	*** inverseTransform(double[],int,double[],int,int);
	*** isIdentity();
	*** preConcatenate(java.awt.geom.AffineTransform);
	*** rotate(double);
	*** rotate(double,double);
	*** rotate(double,double,double);
	*** rotate180();
	*** rotate270();
	*** rotate90();
	*** scale(double,double);
	*** setToQuadrantRotation(int);
	*** setToQuadrantRotation(int,double,double);
	*** setToRotation(double);
	*** setToRotation(double,double);
	*** setToRotation(double,double,double);
	*** setToRotation(double,double,double,double);
	*** setToScale(double,double);
	*** setToShear(double,double);
	*** setToTranslation(double,double);
	*** setTransform(double,double,double,double,double,double);
	*** setTransform(java.awt.geom.AffineTransform);
	*** shear(double,double);
	*** stateError();
	*** transform(double[],int,double[],int,int);
	*** transform(float[],int,double[],int,int);
	*** transform(float[],int,float[],int,int);
	*** translate(double,double);
	*** updateState();
}

-keep class java.awt.geom.Area {
	*** getBounds();
	*** intersect(java.awt.geom.Area);
	*** isRectangular();
}

-keep class java.awt.geom.Dimension2D {
	java.awt.geom.Dimension2D();
	*** getHeight();
	*** getWidth();
	*** setSize(double,double);
}

-keep class java.awt.geom.Line2D {
	*** getX1();
	*** getX2();
	*** getY1();
	*** getY2();
}

-keep class java.awt.geom.Path2D {
	*** numCoords;
	*** numTypes;
	*** pointTypes;
	*** windingRule;
	java.awt.geom.Path2D();
	java.awt.geom.Path2D(int,int);
	*** append(double,double);
	*** append(float,float);
	*** append(java.awt.Shape,boolean);
	*** append(java.awt.geom.PathIterator,boolean);
	*** clone();
	*** cloneCoordsFloat(java.awt.geom.AffineTransform);
	*** closePath();
	*** contains(double,double);
	*** contains(double,double,double,double);
	*** contains(java.awt.geom.PathIterator,double,double);
	*** contains(java.awt.geom.PathIterator,double,double,double,double);
	*** getPoint(int);
	*** intersects(double,double,double,double);
	*** intersects(java.awt.geom.PathIterator,double,double,double,double);
	*** needRoom(boolean,int);
	*** pointCrossings(double,double);
	*** readObject(java.io.ObjectInputStream,boolean);
	*** rectCrossings(double,double,double,double);
	*** setWindingRule(int);
	*** transform(java.awt.geom.AffineTransform);
	*** writeObject(java.io.ObjectOutputStream,boolean);
}

-keep class java.awt.geom.Path2D$Double {
	*** doubleCoords;
}

-keep class java.awt.geom.Path2D$Float {
	*** floatCoords;
	java.awt.geom.Path2D$Float(int,int);
	java.awt.geom.Path2D$Float(java.awt.Shape,java.awt.geom.AffineTransform);
	*** append(java.awt.geom.PathIterator,boolean);
	*** curveTo(float,float,float,float,float,float);
	*** lineTo(float,float);
	*** moveTo(float,float);
	*** needRoom(boolean,int);
	*** quadTo(float,float,float,float);
}

-keep class java.awt.geom.PathIterator {
	*** currentSegment(float[]);
	*** getWindingRule();
	*** isDone();
	*** next();
}

-keep class java.awt.geom.Point2D {
	java.awt.geom.Point2D();
	*** equals(java.lang.Object);
	*** getX();
	*** getY();
	*** setLocation(double,double);
}

-keep class java.awt.geom.Point2D$Double {
	*** x;
	*** y;
}

-keep class java.awt.geom.Point2D$Float {
	*** y;
	*** setLocation(float,float);
}

-keep class java.awt.geom.Rectangle2D {
	java.awt.geom.Rectangle2D();
	*** add(double,double);
	*** equals(java.lang.Object);
	*** intersect(java.awt.geom.Rectangle2D,java.awt.geom.Rectangle2D,java.awt.geom.Rectangle2D);
	*** intersects(double,double,double,double);
	*** intersectsLine(double,double,double,double);
	*** outcode(double,double);
	*** setFrame(double,double,double,double);
	*** setRect(double,double,double,double);
	*** union(java.awt.geom.Rectangle2D,java.awt.geom.Rectangle2D,java.awt.geom.Rectangle2D);
}

-keep class java.awt.geom.Rectangle2D$Double {
	*** height;
	*** width;
	*** x;
	*** y;
	*** setRect(double,double,double,double);
}

-keep class java.awt.geom.RectangularShape {
	java.awt.geom.RectangularShape();
	*** clone();
	*** contains(java.awt.geom.Rectangle2D);
	*** getBounds();
	*** getHeight();
	*** getMaxX();
	*** getMaxY();
	*** getMinX();
	*** getMinY();
	*** getWidth();
	*** getX();
	*** getY();
	*** isEmpty();
	*** setFrame(double,double,double,double);
	*** setFrame(java.awt.geom.Rectangle2D);
	*** setFrameFromCenter(double,double,double,double);
	*** setFrameFromDiagonal(double,double,double,double);
}

-keep class java.awt.im.InputContext {
	*** dispatchEvent(java.awt.AWTEvent);
	*** endComposition();
	*** getInstance();
	*** removeNotify(java.awt.Component);
}

-keep class java.awt.im.InputMethodHighlight {
	*** getStyle();
}

-keep class java.awt.image.AffineTransformOp {
	*** getInterpolationType();
	*** getTransform();
}

-keep class java.awt.image.BufferStrategy {
	*** dispose();
}

-keep class java.awt.image.BufferedImage {
	*** createGraphics();
	*** getColorModel();
	*** getGraphics();
	*** getRaster();
}

-keep class java.awt.image.BufferedImageOp {
	*** filter(java.awt.image.BufferedImage,java.awt.image.BufferedImage);
}

-keep class java.awt.image.ColorModel {
	*** RGBdefault;
	*** colorSpace;
	*** colorSpaceType;
	*** g16Tos8Map;
	*** g8Tos8Map;
	*** isAlphaPremultiplied;
	*** is_sRGB;
	*** l16Tos8;
	*** l8Tos8;
	*** lg16Toog16Map;
	*** lg16Toog8Map;
	*** loaded;
	*** maxBits;
	*** nBits;
	*** numColorComponents;
	*** numComponents;
	*** pixel_bits;
	*** s8Tol16;
	*** s8Tol8;
	*** supportsAlpha;
	*** transferType;
	*** transparency;
	java.awt.image.ColorModel(int,int[],java.awt.color.ColorSpace,boolean,boolean,int,int);
	*** createCompatibleWritableRaster(int,int);
	*** equals(java.lang.Object);
	*** getAlpha(int);
	*** getAlpha(java.lang.Object);
	*** getBlue(int);
	*** getBlue(java.lang.Object);
	*** getComponentSize();
	*** getComponents(java.lang.Object,int[],int);
	*** getDataElement(int[],int);
	*** getDataElements(int,java.lang.Object);
	*** getDataElements(int[],int,java.lang.Object);
	*** getDefaultTransferType(int);
	*** getGreen(int);
	*** getGreen(java.lang.Object);
	*** getLinearRGB16TosRGB8LUT();
	*** getLinearRGB8TosRGB8LUT();
	*** getNormalizedComponents(int[],int,float[],int);
	*** getNumComponents();
	*** getPixelSize();
	*** getRGBdefault();
	*** getRed(int);
	*** getRed(java.lang.Object);
	*** getTransferType();
	*** getTransparency();
	*** getUnnormalizedComponents(float[],int,int[],int);
	*** getsRGB8ToLinearRGB16LUT();
	*** getsRGB8ToLinearRGB8LUT();
	*** hasAlpha();
	*** initIDs();
	*** isAlphaPremultiplied();
	*** isLinearGRAYspace(java.awt.color.ColorSpace);
	*** isLinearRGBspace(java.awt.color.ColorSpace);
	*** loadLibraries();
}

-keep class java.awt.image.DataBuffer {
	*** getDataTypeSize(int);
	*** toIntArray(java.lang.Object);
}

-keep class java.awt.image.DirectColorModel {
	*** alpha_mask;
	*** alpha_offset;
	*** alpha_scale;
	*** blue_mask;
	*** blue_offset;
	*** blue_scale;
	*** fromsRGB8LUT16;
	*** fromsRGB8LUT8;
	*** green_mask;
	*** green_offset;
	*** green_scale;
	*** is_LinearRGB;
	*** lRGBprecision;
	*** red_mask;
	*** red_offset;
	*** red_scale;
	*** tosRGB8LUT;
	java.awt.image.DirectColorModel(int,int,int,int,int);
	*** getAlpha(int);
	*** getBlue(int);
	*** getComponents(int,int[],int);
	*** getDefaultRGBComponents(int);
	*** getGreen(int);
	*** getRGB(int);
	*** getRed(int);
	*** getsRGBComponentFromLinearRGB(int,int);
	*** getsRGBComponentFromsRGB(int,int);
	*** setFields();
}

-keep class java.awt.image.ImageObserver {
	*** imageUpdate(java.awt.Image,int,int,int,int,int);
}

-keep class java.awt.image.IndexColorModel {
	*** allgrayopaque;
	*** alphaBits;
	*** colorData;
	*** lookupcache;
	*** map_size;
	*** opaqueBits;
	*** pixel_mask;
	*** rgb;
	*** transparent_index;
	*** validBits;
	java.awt.image.IndexColorModel(int,int,byte[],int,boolean,int);
	*** calcRealMapSize(int,int);
	*** calculatePixelMask();
	*** getAllValid();
	*** getAlpha(int);
	*** getBlue(int);
	*** getComponents(int,int[],int);
	*** getDataElements(int,java.lang.Object);
	*** getGreen(int);
	*** getMapSize();
	*** getRGBs(int[]);
	*** getRed(int);
	*** initIDs();
	*** installpixel(java.lang.Object,int);
	*** isCompatibleRaster(java.awt.image.Raster);
	*** setRGBs(int,byte[],byte[],byte[],byte[]);
	*** setRGBs(int,int[],int,boolean);
	*** setTransparency(int);
	*** setTransparentPixel(int);
}

-keep class java.awt.image.PackedColorModel {
	*** maskArray;
	*** maskOffsets;
	*** scaleFactors;
	java.awt.image.PackedColorModel(java.awt.color.ColorSpace,int,int,int,int,int,boolean,int,int);
	*** DecomposeMask(int,int,java.lang.String);
	*** countBits(int);
	*** createBitsArray(int,int,int,int);
	*** createBitsArray(int[],int);
	*** equals(java.lang.Object);
	*** getMask(int);
}

-keep class java.awt.image.Raster {
	*** createChild(int,int,int,int,int,int,int[]);
	*** createCompatibleWritableRaster();
	*** createInterleavedRaster(int,int,int,int,java.awt.Point);
	*** createPackedRaster(int,int,int,int,int,java.awt.Point);
	*** createPackedRaster(int,int,int,int[],java.awt.Point);
	*** createTranslatedChild(int,int);
	*** createWritableRaster(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Point);
	*** getDataBuffer();
	*** getDataElements(int,int,int,int,java.lang.Object);
	*** getHeight();
	*** getMinX();
	*** getMinY();
	*** getNumBands();
	*** getParent();
	*** getPixel(int,int,int[]);
	*** getSampleModel();
	*** getSampleModelTranslateX();
	*** getSampleModelTranslateY();
	*** getTransferType();
	*** getWidth();
}

-keep class java.awt.image.RenderedImage {
	*** getColorModel();
	*** getData(java.awt.Rectangle);
	*** getHeight();
	*** getMinX();
	*** getMinY();
	*** getTile(int,int);
	*** getTileGridXOffset();
	*** getTileGridYOffset();
	*** getTileHeight();
	*** getTileWidth();
	*** getWidth();
}

-keep class java.awt.image.SampleModel {
	*** getNumBands();
	*** getSampleSize(int);
	*** getTransferType();
}

-keep class java.awt.image.SinglePixelPackedSampleModel {
	*** getBitMasks();
}

-keep class java.awt.image.VolatileImage {
	*** contentsLost();
	*** getCapabilities();
	*** getGraphics();
	*** getHeight();
	*** getSnapshot();
	*** getWidth();
	*** validate(java.awt.GraphicsConfiguration);
}

-keep class java.awt.image.WritableRaster {
	*** createWritableChild(int,int,int,int,int,int,int[]);
	*** setDataElements(int,int,int,int,java.lang.Object);
	*** setDataElements(int,int,java.awt.image.Raster);
	*** setPixel(int,int,int[]);
}

-keep class java.awt.image.renderable.RenderableImage {
	*** createRendering(java.awt.image.renderable.RenderContext);
}

-keep class java.awt.peer.ComponentPeer {
	*** applyShape(sun.java2d.pipe.Region);
	*** checkImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** coalescePaintEvent(java.awt.event.PaintEvent);
	*** createImage(int,int);
	*** createImage(java.awt.image.ImageProducer);
	*** createVolatileImage(int,int);
	*** dispose();
	*** getColorModel();
	*** getFontMetrics(java.awt.Font);
	*** getGraphics();
	*** getLocationOnScreen();
	*** getMinimumSize();
	*** getPreferredSize();
	*** getToolkit();
	*** handleEvent(java.awt.AWTEvent);
	*** handlesWheelScrolling();
	*** isFocusable();
	*** isReparentSupported();
	*** layout();
	*** prepareImage(java.awt.Image,int,int,java.awt.image.ImageObserver);
	*** reparent(java.awt.peer.ContainerPeer);
	*** requestFocus(java.awt.Component,boolean,boolean,long,sun.awt.CausedFocusEvent$Cause);
	*** setBackground(java.awt.Color);
	*** setBounds(int,int,int,int,int);
	*** setEnabled(boolean);
	*** setFont(java.awt.Font);
	*** setForeground(java.awt.Color);
	*** setVisible(boolean);
	*** setZOrder(java.awt.peer.ComponentPeer);
	*** updateCursorImmediately();
	*** updateGraphicsData(java.awt.GraphicsConfiguration);
}

-keep class java.awt.peer.ContainerPeer {
	*** beginLayout();
	*** beginValidate();
	*** endLayout();
	*** endValidate();
	*** getInsets();
}

-keep class java.awt.peer.DialogPeer {
	*** blockWindows(java.util.List);
	*** setResizable(boolean);
	*** setTitle(java.lang.String);
}

-keep class java.awt.peer.FramePeer {
	*** setMaximizedBounds(java.awt.Rectangle);
	*** setMenuBar(java.awt.MenuBar);
	*** setResizable(boolean);
	*** setState(int);
	*** setTitle(java.lang.String);
}

-keep class java.awt.peer.KeyboardFocusManagerPeer {
	*** clearGlobalFocusOwner(java.awt.Window);
	*** getCurrentFocusOwner();
	*** getCurrentFocusedWindow();
	*** setCurrentFocusOwner(java.awt.Component);
}

-keep class java.awt.peer.MenuComponentPeer {
	*** dispose();
	*** setFont(java.awt.Font);
}

-keep class java.awt.peer.MenuItemPeer {
	*** setEnabled(boolean);
	*** setLabel(java.lang.String);
}

-keep class java.awt.peer.MenuPeer {
	*** addItem(java.awt.MenuItem);
	*** delItem(int);
}

-keep class java.awt.peer.MouseInfoPeer {
	*** isWindowUnderMouse(java.awt.Window);
}

-keep class java.awt.peer.PopupMenuPeer {
	*** show(java.awt.Event);
}

-keep class java.awt.peer.WindowPeer {
	*** repositionSecurityWarning();
	*** setModalBlocked(java.awt.Dialog,boolean);
	*** setOpacity(float);
	*** setOpaque(boolean);
	*** toBack();
	*** toFront();
	*** updateAlwaysOnTopState();
	*** updateFocusableWindowState();
	*** updateIconImages();
	*** updateMinimumSize();
	*** updateWindow();
}

-keep class java.awt.print.PrinterJob {
	*** getPrinterJob();
	*** printDialog(javax.print.attribute.PrintRequestAttributeSet);
	*** setPrintService(javax.print.PrintService);
	*** setPrintable(java.awt.print.Printable);
}

-keep class java.beans.BeanDescriptor {
	*** beanClassRef;
	*** customizerClassRef;
	java.beans.BeanDescriptor(java.lang.Class,java.lang.Class);
	*** getBeanClass();
}

-keep class java.beans.BeanInfo {
	*** getAdditionalBeanInfo();
	*** getBeanDescriptor();
	*** getDefaultEventIndex();
	*** getDefaultPropertyIndex();
	*** getEventSetDescriptors();
	*** getIcon(int);
	*** getMethodDescriptors();
	*** getPropertyDescriptors();
}

-keep class java.beans.ChangeListenerMap {
	*** map;
	java.beans.ChangeListenerMap();
	*** add(java.lang.String,java.util.EventListener);
	*** get(java.lang.String);
	*** getEntries();
	*** getListeners();
	*** getListeners(java.lang.String);
	*** hasListeners(java.lang.String);
	*** newArray(int);
	*** newProxy(java.lang.String,java.util.EventListener);
	*** remove(java.lang.String,java.util.EventListener);
	*** set(java.lang.String,java.util.EventListener[]);
}

-keep class java.beans.EventSetDescriptor {
	*** addMethodDescriptor;
	*** getMethodDescriptor;
	*** inDefaultEventSet;
	*** listenerMethodDescriptors;
	*** listenerMethodsRef;
	*** listenerTypeRef;
	*** removeMethodDescriptor;
	*** unicast;
	java.beans.EventSetDescriptor(java.lang.Class,java.lang.String,java.lang.Class,java.lang.String[],java.lang.String,java.lang.String,java.lang.String);
	java.beans.EventSetDescriptor(java.lang.String,java.lang.Class,java.lang.reflect.Method[],java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method);
	*** getListenerClassName(java.lang.Class);
	*** getListenerMethods();
	*** getListenerMethods0();
	*** getMethod(java.beans.MethodDescriptor);
	*** getMethod(java.lang.Class,java.lang.String,int);
	*** setAddListenerMethod(java.lang.reflect.Method);
	*** setGetListenerMethod(java.lang.reflect.Method);
	*** setListenerMethods(java.lang.reflect.Method[]);
	*** setListenerType(java.lang.Class);
	*** setRemoveListenerMethod(java.lang.reflect.Method);
	*** setUnicast(boolean);
}

-keep class java.beans.FeatureDescriptor {
	*** classRef;
	*** displayName;
	*** expert;
	*** hidden;
	*** name;
	*** preferred;
	*** shortDescription;
	*** table;
	java.beans.FeatureDescriptor();
	java.beans.FeatureDescriptor(java.beans.FeatureDescriptor);
	java.beans.FeatureDescriptor(java.beans.FeatureDescriptor,java.beans.FeatureDescriptor);
	*** addTable(java.util.Hashtable);
	*** appendTo(java.lang.StringBuilder);
	*** appendTo(java.lang.StringBuilder,java.lang.String,boolean);
	*** appendTo(java.lang.StringBuilder,java.lang.String,java.lang.Object);
	*** appendTo(java.lang.StringBuilder,java.lang.String,java.lang.ref.Reference);
	*** getClass0();
	*** getDisplayName();
	*** getName();
	*** getParameterTypes(java.lang.Class,java.lang.reflect.Method);
	*** getReturnType(java.lang.Class,java.lang.reflect.Method);
	*** getSoftReference(java.lang.Object);
	*** getTable();
	*** getValue(java.lang.String);
	*** getWeakReference(java.lang.Object);
	*** setClass0(java.lang.Class);
	*** setName(java.lang.String);
	*** setTransient(java.beans.Transient);
	*** setValue(java.lang.String,java.lang.Object);
}

-keep class java.beans.GenericBeanInfo {
	*** beanDescriptor;
	*** defaultEvent;
	*** defaultProperty;
	*** events;
	*** methods;
	*** properties;
	*** targetBeanInfoRef;
	*** getTargetBeanInfo();
}

-keep class java.beans.IndexedPropertyDescriptor {
	*** indexedPropertyTypeRef;
	*** indexedReadMethodName;
	*** indexedReadMethodRef;
	*** indexedWriteMethodName;
	*** indexedWriteMethodRef;
	java.beans.IndexedPropertyDescriptor(java.lang.String,java.lang.Class,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** findIndexedPropertyType(java.lang.reflect.Method,java.lang.reflect.Method);
	*** getIndexedPropertyType();
	*** getIndexedPropertyType0();
	*** getIndexedReadMethod();
	*** getIndexedReadMethod0();
	*** getIndexedWriteMethod();
	*** getIndexedWriteMethod0();
	*** setIndexedPropertyType(java.lang.Class);
	*** setIndexedReadMethod(java.lang.reflect.Method);
	*** setIndexedReadMethod0(java.lang.reflect.Method);
	*** setIndexedWriteMethod(java.lang.reflect.Method);
	*** setIndexedWriteMethod0(java.lang.reflect.Method);
}

-keep class java.beans.Introspector {
	*** EMPTY_EVENTSETDESCRIPTORS;
	*** additionalBeanInfo;
	*** beanClass;
	*** declaredMethodCache;
	*** defaultEventIndex;
	*** defaultEventName;
	*** defaultPropertyIndex;
	*** defaultPropertyName;
	*** eventListenerType;
	*** events;
	*** explicitBeanInfo;
	*** methods;
	*** pdStore;
	*** properties;
	*** propertyChangeSource;
	*** superBeanInfo;
	*** addEvent(java.beans.EventSetDescriptor);
	*** addMethod(java.beans.MethodDescriptor);
	*** addPropertyDescriptor(java.beans.PropertyDescriptor);
	*** addPropertyDescriptors(java.beans.PropertyDescriptor[]);
	*** decapitalize(java.lang.String);
	*** findCustomizerClass(java.lang.Class);
	*** findExplicitBeanInfo(java.lang.Class);
	*** findMethod(java.lang.Class,java.lang.String,int);
	*** findMethod(java.lang.Class,java.lang.String,int,java.lang.Class[]);
	*** flushCaches();
	*** getBeanInfo();
	*** getBeanInfo(java.lang.Class);
	*** getBeanInfo(java.lang.Class,java.lang.Class);
	*** getBeanInfo(java.lang.Class,java.lang.Class,int);
	*** getPropertyDescriptors(java.beans.BeanInfo);
	*** getPublicDeclaredMethods(java.lang.Class);
	*** getTargetBeanDescriptor();
	*** getTargetDefaultEventIndex();
	*** getTargetDefaultPropertyIndex();
	*** getTargetEventInfo();
	*** getTargetMethodInfo();
	*** getTargetPropertyInfo();
	*** internalFindMethod(java.lang.Class,java.lang.String,int,java.lang.Class[]);
	*** isEventHandler(java.lang.reflect.Method);
	*** isSubclass(java.lang.Class,java.lang.Class);
	*** makeQualifiedMethodName(java.lang.String,java.lang.String[]);
	*** mergePropertyDescriptor(java.beans.IndexedPropertyDescriptor,java.beans.IndexedPropertyDescriptor);
	*** mergePropertyDescriptor(java.beans.IndexedPropertyDescriptor,java.beans.PropertyDescriptor);
	*** mergePropertyDescriptor(java.beans.PropertyDescriptor,java.beans.PropertyDescriptor);
	*** processPropertyDescriptors();
	*** throwsException(java.lang.reflect.Method,java.lang.Class);
}

-keep class java.beans.MethodDescriptor {
	*** methodRef;
	*** paramNames;
	*** parameterDescriptors;
	*** params;
	java.beans.MethodDescriptor(java.lang.reflect.Method,java.beans.ParameterDescriptor[]);
	*** getMethod();
	*** getMethod0();
	*** getParamNames();
	*** getParams();
	*** setMethod(java.lang.reflect.Method);
	*** setParams(java.lang.Class[]);
}

-keep class java.beans.NameGenerator {
	*** capitalize(java.lang.String);
}

-keep class java.beans.PropertyChangeEvent {
	*** newValue;
	*** oldValue;
	*** propagationId;
	*** propertyName;
	*** appendTo(java.lang.StringBuilder);
	*** getNewValue();
	*** getOldValue();
	*** getPropagationId();
	*** getPropertyName();
}

-keep class java.beans.PropertyChangeListener {
	*** propertyChange(java.beans.PropertyChangeEvent);
}

-keep class java.beans.PropertyChangeListenerProxy {
	*** propertyName;
	*** getPropertyName();
}

-keep class java.beans.PropertyChangeSupport {
	*** map;
	*** serialPersistentFields;
	*** source;
	java.beans.PropertyChangeSupport(java.lang.Object);
	*** addPropertyChangeListener(java.beans.PropertyChangeListener);
	*** addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** fire(java.beans.PropertyChangeListener[],java.beans.PropertyChangeEvent);
	*** fireIndexedPropertyChange(java.lang.String,int,java.lang.Object,java.lang.Object);
	*** firePropertyChange(java.beans.PropertyChangeEvent);
	*** firePropertyChange(java.lang.String,boolean,boolean);
	*** firePropertyChange(java.lang.String,int,int);
	*** firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** getPropertyChangeListeners();
	*** getPropertyChangeListeners(java.lang.String);
	*** removePropertyChangeListener(java.beans.PropertyChangeListener);
	*** removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
}

-keep class java.beans.PropertyChangeSupport$PropertyChangeListenerMap {
	*** EMPTY;
	java.beans.PropertyChangeSupport$PropertyChangeListenerMap();
	*** extract(java.beans.PropertyChangeListener);
	*** newArray(int);
	*** newProxy(java.lang.String,java.beans.PropertyChangeListener);
}

-keep class java.beans.PropertyDescriptor {
	*** baseName;
	*** bound;
	*** constrained;
	*** propertyEditorClassRef;
	*** propertyTypeRef;
	*** readMethodName;
	*** readMethodRef;
	*** writeMethodName;
	*** writeMethodRef;
	java.beans.PropertyDescriptor(java.beans.PropertyDescriptor);
	java.beans.PropertyDescriptor(java.beans.PropertyDescriptor,java.beans.PropertyDescriptor);
	java.beans.PropertyDescriptor(java.lang.Class,java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method);
	java.beans.PropertyDescriptor(java.lang.String,java.lang.Class,java.lang.String,java.lang.String);
	java.beans.PropertyDescriptor(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method);
	*** appendTo(java.lang.StringBuilder);
	*** compareMethods(java.lang.reflect.Method,java.lang.reflect.Method);
	*** equals(java.lang.Object);
	*** findPropertyType(java.lang.reflect.Method,java.lang.reflect.Method);
	*** getBaseName();
	*** getPropertyEditorClass();
	*** getPropertyType();
	*** getPropertyType0();
	*** getReadMethod();
	*** getReadMethod0();
	*** getWriteMethod();
	*** getWriteMethod0();
	*** hashCode();
	*** isAssignable(java.lang.reflect.Method,java.lang.reflect.Method);
	*** isBound();
	*** isConstrained();
	*** setBound(boolean);
	*** setClass0(java.lang.Class);
	*** setConstrained(boolean);
	*** setPropertyEditorClass(java.lang.Class);
	*** setPropertyType(java.lang.Class);
	*** setReadMethod(java.lang.reflect.Method);
	*** setWriteMethod(java.lang.reflect.Method);
	*** updateGenericsFor(java.lang.Class);
}

-keep class java.beans.PropertyVetoException {
	*** evt;
}

-keep class java.beans.SimpleBeanInfo {
	java.beans.SimpleBeanInfo();
	*** getIcon(int);
}

-keep class java.beans.ThreadGroupContext {
	*** beanInfoCache;
	*** beanInfoFinder;
	*** contexts;
	*** isDesignTime;
	*** isGuiAvailable;
	*** propertyEditorFinder;
	*** clearBeanInfoCache();
	*** getBeanInfo(java.lang.Class);
	*** getBeanInfoFinder();
	*** getContext();
	*** putBeanInfo(java.lang.Class,java.beans.BeanInfo);
	*** removeBeanInfo(java.lang.Class);
}

-keep class java.beans.Transient {
	*** value();
}

-keep class java.beans.VetoableChangeSupport {
	*** addVetoableChangeListener(java.beans.VetoableChangeListener);
	*** addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener);
	*** fireVetoableChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** getVetoableChangeListeners();
	*** getVetoableChangeListeners(java.lang.String);
	*** removeVetoableChangeListener(java.beans.VetoableChangeListener);
	*** removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener);
}

-keep class java.beans.WeakIdentityMap {
	*** NULL;
	*** queue;
	*** size;
	*** table;
	*** threshold;
	*** get(java.lang.Object);
	*** getIndex(java.beans.WeakIdentityMap$Entry[],int);
	*** newTable(int);
	*** put(java.lang.Object,java.lang.Object);
	*** removeStaleEntries();
	*** transfer(java.beans.WeakIdentityMap$Entry[],java.beans.WeakIdentityMap$Entry[]);
}

-keep class java.beans.WeakIdentityMap$Entry {
	*** hash;
	*** next;
	*** value;
	*** access$000(java.beans.WeakIdentityMap$Entry);
	*** access$002(java.beans.WeakIdentityMap$Entry,java.beans.WeakIdentityMap$Entry);
	*** access$100(java.beans.WeakIdentityMap$Entry);
	*** access$102(java.beans.WeakIdentityMap$Entry,java.lang.Object);
	*** access$200(java.beans.WeakIdentityMap$Entry);
	*** isMatched(java.lang.Object,int);
}

-keep class java.io.BufferedInputStream {
	*** buf;
	java.io.BufferedInputStream(java.io.InputStream);
	*** close();
	*** mark(int);
	*** reset();
}

-keep class java.io.BufferedOutputStream {
	java.io.BufferedOutputStream(java.io.OutputStream);
	*** flush();
	*** write(byte[],int,int);
	*** write(int);
}

-keep class java.io.BufferedReader {
	java.io.BufferedReader(java.io.Reader);
	java.io.BufferedReader(java.io.Reader,int);
	*** close();
	*** mark(int);
	*** read();
	*** read(char[],int,int);
	*** readLine();
	*** readLine(boolean);
	*** reset();
}

-keep class java.io.BufferedWriter {
	*** close();
}

-keep class java.io.ByteArrayInputStream {
	*** buf;
	*** count;
	*** mark;
	*** pos;
	java.io.ByteArrayInputStream(byte[]);
	java.io.ByteArrayInputStream(byte[],int,int);
	*** available();
	*** close();
	*** mark(int);
	*** read();
	*** read(byte[],int,int);
	*** reset();
	*** skip(long);
}

-keep class java.io.ByteArrayOutputStream {
	*** buf;
	*** count;
	java.io.ByteArrayOutputStream();
	java.io.ByteArrayOutputStream(int);
	*** close();
	*** reset();
	*** size();
	*** toByteArray();
	*** toString();
	*** toString(java.lang.String);
	*** write(byte[],int,int);
	*** write(int);
	*** writeTo(java.io.OutputStream);
}

-keep class java.io.CharArrayWriter {
	*** buf;
	*** count;
	java.io.CharArrayWriter(int);
	*** append(char);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
	*** flush();
	*** reset();
	*** toCharArray();
	*** write(int);
	*** write(java.lang.String,int,int);
}

-keep class java.io.CharConversionException {
	java.io.CharConversionException();
}

-keep class java.io.Closeable {
	*** close();
}

-keep class java.io.Console {
	*** readLine();
	*** readPassword();
}

-keep class java.io.DataInput {
	*** readBoolean();
	*** readFully(byte[],int,int);
}

-keep class java.io.DataInputStream {
	*** readFully(byte[]);
	*** readFully(byte[],int,int);
	*** readInt();
	*** readLong();
	*** readUTF();
}

-keep class java.io.DataOutput {
	*** writeBoolean(boolean);
}

-keep class java.io.DataOutputStream {
	*** flush();
	*** writeBytes(java.lang.String);
	*** writeInt(int);
	*** writeLong(long);
	*** writeUTF(java.lang.String);
}

-keep class java.io.DeleteOnExitHook {
	*** files;
	*** runHooks();
}

-keep class java.io.EOFException {
	java.io.EOFException();
	java.io.EOFException(java.lang.String);
}

-keep class java.io.ExpiringCache {
	*;
}

-keep class java.io.ExpiringCache$1 {
	*;
}

-keep class java.io.ExpiringCache$Entry {
	*;
}

-keep class java.io.Externalizable {
	*** readExternal(java.io.ObjectInput);
	*** writeExternal(java.io.ObjectOutput);
}

-keep class java.io.File {
	*** pathSeparator;
	*** pathSeparatorChar;
	*** separator;
	*** separatorChar;
	*** canExecute();
	*** canRead();
	*** canWrite();
	*** createNewFile();
	*** createTempFile(java.lang.String,java.lang.String);
	*** createTempFile(java.lang.String,java.lang.String,java.io.File);
	*** delete();
	*** deleteOnExit();
	*** equals(java.lang.Object);
	*** exists();
	*** getAbsoluteFile();
	*** getAbsolutePath();
	*** getCanonicalFile();
	*** getCanonicalPath();
	*** getName();
	*** getParent();
	*** getParentFile();
	*** getPath();
	*** hashCode();
	*** isAbsolute();
	*** isDirectory();
	*** isFile();
	*** lastModified();
	*** length();
	*** list();
	*** listFiles();
	*** listFiles(java.io.FileFilter);
	*** listFiles(java.io.FilenameFilter);
	*** mkdir();
	*** mkdirs();
	*** renameTo(java.io.File);
	*** setLastModified(long);
	*** toPath();
	*** toString();
	*** toURI();
}

-keep class java.io.File$PathStatus {
	*;
}

-keep class java.io.File$TempDirectory {
	*** random;
	*** tmpdir;
}

-keep class java.io.FileDescriptor {
	*** valid();
}

-keep class java.io.FileDescriptor$1 {
	*;
}

-keep class java.io.FileInputStream {
	java.io.FileInputStream(java.io.FileDescriptor);
	*** close();
	*** getChannel();
	*** getFD();
	*** read(byte[]);
}

-keep class java.io.FileOutputStream {
	java.io.FileOutputStream(java.io.FileDescriptor);
	*** close();
	*** getChannel();
	*** getFD();
	*** write(byte[]);
	*** write(byte[],int,int);
}

-keep class java.io.FilePermission {
	*** getMask();
	*** impliesIgnoreMask(java.io.FilePermission);
}

-keep class java.io.FilePermissionCollection {
	*** perms;
	*** serialPersistentFields;
}

-keep class java.io.FileReader {
	*;
}

-keep class java.io.FileSystem {
	*;
}

-keep class java.io.FilterInputStream {
	*** in;
	java.io.FilterInputStream(java.io.InputStream);
	*** available();
	*** close();
	*** read();
	*** read(byte[]);
	*** read(byte[],int,int);
	*** skip(long);
}

-keep class java.io.FilterOutputStream {
	*** out;
	java.io.FilterOutputStream(java.io.OutputStream);
	*** close();
	*** write(byte[]);
}

-keep class java.io.FilterWriter {
	*** out;
	java.io.FilterWriter(java.io.Writer);
	*** close();
}

-keep class java.io.Flushable {
	*** flush();
}

-keep class java.io.IOException {
	java.io.IOException();
	java.io.IOException(java.lang.String);
}

-keep class java.io.InputStream {
	java.io.InputStream();
	*** available();
	*** close();
	*** mark(int);
	*** markSupported();
	*** read();
	*** read(byte[]);
	*** read(byte[],int,int);
	*** reset();
	*** skip(long);
}

-keep class java.io.InputStreamReader {
	*** close();
}

-keep class java.io.InterruptedIOException {
	*** bytesTransferred;
	java.io.InterruptedIOException();
	java.io.InterruptedIOException(java.lang.String);
}

-keep class java.io.LineNumberReader {
	*** lineNumber;
	*** markedLineNumber;
	*** markedSkipLF;
	*** skipBuffer;
	*** skipLF;
	*** read(char[],int,int);
	*** readLine();
}

-keep class java.io.ObjectInput {
	*** readObject();
}

-keep class java.io.ObjectInputStream {
	*** bin;
	*** closed;
	*** curContext;
	*** defaultDataEnd;
	*** depth;
	*** enableOverride;
	*** enableResolve;
	*** handles;
	*** passHandle;
	*** primClasses;
	*** primVals;
	*** unsharedMarker;
	*** vlist;
	java.io.ObjectInputStream(java.io.InputStream);
	*** auditSubclass(java.lang.Class);
	*** bytesToDoubles(byte[],int,double[],int,int);
	*** bytesToFloats(byte[],int,float[],int,int);
	*** checkResolve(java.lang.Object);
	*** clear();
	*** cloneArray(java.lang.Object);
	*** close();
	*** defaultReadFields(java.lang.Object,java.io.ObjectStreamClass);
	*** defaultReadObject();
	*** handleReset();
	*** isCustomSubclass();
	*** latestUserDefinedLoader();
	*** read();
	*** readArray(boolean);
	*** readBoolean();
	*** readByte();
	*** readClass(boolean);
	*** readClassDesc(boolean);
	*** readClassDescriptor();
	*** readDouble();
	*** readEnum(boolean);
	*** readExternalData(java.io.Externalizable,java.io.ObjectStreamClass);
	*** readFatalException();
	*** readFields();
	*** readFloat();
	*** readFully(byte[]);
	*** readHandle(boolean);
	*** readInt();
	*** readLong();
	*** readNonProxyDesc(boolean);
	*** readNull();
	*** readObject();
	*** readObject0(boolean);
	*** readObjectOverride();
	*** readOrdinaryObject(boolean);
	*** readProxyDesc(boolean);
	*** readSerialData(java.lang.Object,java.io.ObjectStreamClass);
	*** readStreamHeader();
	*** readString(boolean);
	*** readUTF();
	*** resolveClass(java.io.ObjectStreamClass);
	*** resolveObject(java.lang.Object);
	*** resolveProxyClass(java.lang.String[]);
	*** skipCustomData();
	*** verifySubclass();
}

-keep class java.io.ObjectInputStream$BlockDataInputStream {
	*** available();
	*** close();
	*** currentBlockRemaining();
	*** getBlockDataMode();
	*** peek();
	*** peekByte();
	*** read();
	*** read(byte[],int,int,boolean);
	*** readBoolean();
	*** readBooleans(boolean[],int,int);
	*** readByte();
	*** readChar();
	*** readChars(char[],int,int);
	*** readDouble();
	*** readDoubles(double[],int,int);
	*** readFloat();
	*** readFloats(float[],int,int);
	*** readFully(byte[],int,int,boolean);
	*** readInt();
	*** readInts(int[],int,int);
	*** readLine();
	*** readLong();
	*** readLongUTF();
	*** readLongs(long[],int,int);
	*** readShort();
	*** readShorts(short[],int,int);
	*** readUTF();
	*** readUnsignedByte();
	*** readUnsignedShort();
	*** setBlockDataMode(boolean);
	*** skipBlockData();
	*** skipBytes(int);
}

-keep class java.io.ObjectInputStream$Caches {
	*** subclassAudits;
	*** subclassAuditsQueue;
}

-keep class java.io.ObjectInputStream$GetField {
	*** defaulted(java.lang.String);
	*** get(java.lang.String,boolean);
	*** get(java.lang.String,float);
	*** get(java.lang.String,int);
	*** get(java.lang.String,java.lang.Object);
}

-keep class java.io.ObjectInputStream$GetFieldImpl {
	*** readFields();
}

-keep class java.io.ObjectInputStream$HandleTable {
	*** assign(java.lang.Object);
	*** clear();
	*** finish(int);
	*** lookupException(int);
	*** lookupObject(int);
	*** markDependency(int,int);
	*** markException(int,java.lang.ClassNotFoundException);
	*** setObject(int,java.lang.Object);
	*** size();
}

-keep class java.io.ObjectInputStream$ValidationList {
	*** clear();
	*** doCallbacks();
	*** register(java.io.ObjectInputValidation,int);
}

-keep class java.io.ObjectOutput {
	*** writeObject(java.lang.Object);
}

-keep class java.io.ObjectOutputStream {
	*** bout;
	*** curContext;
	*** curPut;
	*** debugInfoStack;
	*** depth;
	*** enableOverride;
	*** enableReplace;
	*** extendedDebugInfo;
	*** handles;
	*** primVals;
	*** protocol;
	*** subs;
	java.io.ObjectOutputStream(java.io.OutputStream);
	*** annotateClass(java.lang.Class);
	*** annotateProxyClass(java.lang.Class);
	*** auditSubclass(java.lang.Class);
	*** clear();
	*** close();
	*** defaultWriteFields(java.lang.Object,java.io.ObjectStreamClass);
	*** defaultWriteObject();
	*** doublesToBytes(double[],int,byte[],int,int);
	*** floatsToBytes(float[],int,byte[],int,int);
	*** flush();
	*** isCustomSubclass();
	*** putFields();
	*** replaceObject(java.lang.Object);
	*** verifySubclass();
	*** write(byte[]);
	*** write(int);
	*** writeArray(java.lang.Object,java.io.ObjectStreamClass,boolean);
	*** writeBoolean(boolean);
	*** writeByte(int);
	*** writeClass(java.lang.Class,boolean);
	*** writeClassDesc(java.io.ObjectStreamClass,boolean);
	*** writeClassDescriptor(java.io.ObjectStreamClass);
	*** writeDouble(double);
	*** writeEnum(java.lang.Enum,java.io.ObjectStreamClass,boolean);
	*** writeExternalData(java.io.Externalizable);
	*** writeFatalException(java.io.IOException);
	*** writeFields();
	*** writeFloat(float);
	*** writeHandle(int);
	*** writeInt(int);
	*** writeLong(long);
	*** writeNonProxyDesc(java.io.ObjectStreamClass,boolean);
	*** writeNull();
	*** writeObject(java.lang.Object);
	*** writeObject0(java.lang.Object,boolean);
	*** writeObjectOverride(java.lang.Object);
	*** writeOrdinaryObject(java.lang.Object,java.io.ObjectStreamClass,boolean);
	*** writeProxyDesc(java.io.ObjectStreamClass,boolean);
	*** writeSerialData(java.lang.Object,java.io.ObjectStreamClass);
	*** writeStreamHeader();
	*** writeString(java.lang.String,boolean);
	*** writeUTF(java.lang.String);
}

-keep class java.io.ObjectOutputStream$BlockDataOutputStream {
	*** close();
	*** drain();
	*** flush();
	*** getUTFLength(java.lang.String);
	*** setBlockDataMode(boolean);
	*** write(byte[],int,int,boolean);
	*** write(int);
	*** writeBoolean(boolean);
	*** writeBooleans(boolean[],int,int);
	*** writeByte(int);
	*** writeBytes(java.lang.String);
	*** writeChar(int);
	*** writeChars(char[],int,int);
	*** writeChars(java.lang.String);
	*** writeDouble(double);
	*** writeDoubles(double[],int,int);
	*** writeFloat(float);
	*** writeFloats(float[],int,int);
	*** writeInt(int);
	*** writeInts(int[],int,int);
	*** writeLong(long);
	*** writeLongUTF(java.lang.String,long);
	*** writeLongs(long[],int,int);
	*** writeShort(int);
	*** writeShorts(short[],int,int);
	*** writeUTF(java.lang.String);
	*** writeUTF(java.lang.String,long);
}

-keep class java.io.ObjectOutputStream$Caches {
	*** subclassAudits;
	*** subclassAuditsQueue;
}

-keep class java.io.ObjectOutputStream$DebugTraceInfoStack {
	*** pop();
	*** push(java.lang.String);
	*** toString();
}

-keep class java.io.ObjectOutputStream$HandleTable {
	*** assign(java.lang.Object);
	*** clear();
	*** lookup(java.lang.Object);
	*** size();
}

-keep class java.io.ObjectOutputStream$PutField {
	*** put(java.lang.String,boolean);
	*** put(java.lang.String,int);
	*** put(java.lang.String,java.lang.Object);
}

-keep class java.io.ObjectOutputStream$PutFieldImpl {
	*** writeFields();
}

-keep class java.io.ObjectOutputStream$ReplaceTable {
	*** assign(java.lang.Object,java.lang.Object);
	*** clear();
	*** lookup(java.lang.Object);
}

-keep class java.io.ObjectStreamClass {
	*** checkDefaultSerialize();
	*** checkDeserialize();
	*** checkSerialize();
	*** forClass();
	*** getClassDataLayout();
	*** getFields(boolean);
	*** getName();
	*** getNumObjFields();
	*** getObjFieldValues(java.lang.Object,java.lang.Object[]);
	*** getPrimDataSize();
	*** getPrimFieldValues(java.lang.Object,byte[]);
	*** getResolveException();
	*** getSuperDesc();
	*** hasBlockExternalData();
	*** hasReadObjectMethod();
	*** hasReadObjectNoDataMethod();
	*** hasReadResolveMethod();
	*** hasWriteObjectData();
	*** hasWriteObjectMethod();
	*** hasWriteReplaceMethod();
	*** initNonProxy(java.io.ObjectStreamClass,java.lang.Class,java.lang.ClassNotFoundException,java.io.ObjectStreamClass);
	*** initProxy(java.lang.Class,java.lang.ClassNotFoundException,java.io.ObjectStreamClass);
	*** invokeReadObject(java.lang.Object,java.io.ObjectInputStream);
	*** invokeReadObjectNoData(java.lang.Object);
	*** invokeReadResolve(java.lang.Object);
	*** invokeWriteObject(java.lang.Object,java.io.ObjectOutputStream);
	*** invokeWriteReplace(java.lang.Object);
	*** isEnum();
	*** isExternalizable();
	*** isInstantiable();
	*** isProxy();
	*** lookup(java.lang.Class);
	*** lookup(java.lang.Class,boolean);
	*** newInstance();
	*** processQueue(java.lang.ref.ReferenceQueue,java.util.concurrent.ConcurrentMap);
	*** readNonProxy(java.io.ObjectInputStream);
	*** setObjFieldValues(java.lang.Object,java.lang.Object[]);
	*** setPrimFieldValues(java.lang.Object,byte[]);
	*** writeNonProxy(java.io.ObjectOutputStream);
}

-keep class java.io.ObjectStreamClass$ClassDataSlot {
	*** desc;
	*** hasData;
}

-keep class java.io.ObjectStreamConstants {
	*** SUBCLASS_IMPLEMENTATION_PERMISSION;
	*** SUBSTITUTION_PERMISSION;
}

-keep class java.io.ObjectStreamException {
	java.io.ObjectStreamException(java.lang.String);
}

-keep class java.io.ObjectStreamField {
	*** getField();
	*** getName();
	*** getType();
	*** isUnshared();
}

-keep class java.io.OptionalDataException {
	*** eof;
}

-keep class java.io.OutputStream {
	java.io.OutputStream();
	*** close();
	*** flush();
	*** write(byte[]);
	*** write(byte[],int,int);
	*** write(int);
}

-keep class java.io.OutputStreamWriter {
	java.io.OutputStreamWriter(java.io.OutputStream);
	*** close();
	*** flush();
}

-keep class java.io.PrintStream {
	*** flush();
	*** format(java.lang.String,java.lang.Object[]);
	*** print(char);
	*** print(int);
	*** print(java.lang.Object);
	*** print(java.lang.String);
	*** printf(java.lang.String,java.lang.Object[]);
	*** println();
	*** println(java.lang.Object);
	*** println(java.lang.String);
	*** write(byte[],int,int);
	*** write(int);
}

-keep class java.io.PrintWriter {
	*** out;
	java.io.PrintWriter(java.io.Writer);
	java.io.PrintWriter(java.io.Writer,boolean);
	*** append(char);
	*** append(java.lang.CharSequence);
	*** checkError();
	*** close();
	*** flush();
	*** print(char);
	*** print(java.lang.String);
	*** println();
	*** println(java.lang.Object);
	*** println(java.lang.String);
	*** setError();
	*** write(int);
	*** write(java.lang.String);
}

-keep class java.io.PushbackInputStream {
	*** buf;
	*** pos;
	java.io.PushbackInputStream(java.io.InputStream,int);
	*** ensureOpen();
	*** unread(byte[],int,int);
}

-keep class java.io.RandomAccessFile {
	*** getChannel();
}

-keep class java.io.Reader {
	*** lock;
	java.io.Reader();
	*** close();
	*** mark(int);
	*** markSupported();
	*** read();
	*** read(char[]);
	*** read(char[],int,int);
	*** reset();
	*** skip(long);
}

-keep class java.io.SequenceInputStream {
	*** e;
	*** in;
	*** nextStream();
	*** read();
	*** read(byte[],int,int);
}

-keep class java.io.SerialCallbackContext {
	*** getDesc();
	*** getObj();
	*** setUsed();
}

-keep class java.io.Serializable {
	*;
}

-keep class java.io.StreamTokenizer {
	*** LINENO;
	*** buf;
	*** ctype;
	*** eolIsSignificantP;
	*** forceLower;
	*** input;
	*** nval;
	*** peekc;
	*** pushedBack;
	*** reader;
	*** slashSlashCommentsP;
	*** slashStarCommentsP;
	*** sval;
	*** ttype;
	java.io.StreamTokenizer();
	*** commentChar(int);
	*** lineno();
	*** lowerCaseMode(boolean);
	*** nextToken();
	*** ordinaryChar(int);
	*** ordinaryChars(int,int);
	*** parseNumbers();
	*** quoteChar(int);
	*** read();
	*** resetSyntax();
	*** slashSlashComments(boolean);
	*** slashStarComments(boolean);
	*** whitespaceChars(int,int);
	*** wordChars(int,int);
}

-keep class java.io.StringReader {
	*** length;
	*** mark;
	*** next;
	*** str;
	*** ensureOpen();
}

-keep class java.io.StringWriter {
	*** buf;
	*** append(char);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
	*** getBuffer();
	*** toString();
	*** write(int);
	*** write(java.lang.String);
}

-keep class java.io.UnixFileSystem {
	*;
}

-keep class java.io.Writer {
	*** lock;
	java.io.Writer();
	java.io.Writer(java.lang.Object);
	*** append(java.lang.CharSequence);
	*** close();
	*** flush();
	*** write(char[]);
	*** write(char[],int,int);
	*** write(int);
	*** write(java.lang.String);
	*** write(java.lang.String,int,int);
}

-keep class java.lang.AbstractStringBuilder {
	*;
}

-keep class java.lang.Appendable {
	*** append(char);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
}

-keep class java.lang.ApplicationShutdownHooks {
	*** hooks;
	*** runHooks();
}

-keep class java.lang.ArithmeticException {
	*;
}

-keep class java.lang.ArrayStoreException {
	*;
}

-keep class java.lang.AssertionError {
	java.lang.AssertionError();
	java.lang.AssertionError(java.lang.Object);
	java.lang.AssertionError(java.lang.String);
}

-keep class java.lang.AssertionStatusDirectives {
	*;
}

-keep class java.lang.AutoCloseable {
	*;
}

-keep class java.lang.Boolean {
	*** FALSE;
	*** TRUE;
	*** TYPE;
	*** booleanValue();
	*** equals(java.lang.Object);
	*** getBoolean(java.lang.String);
	*** parseBoolean(java.lang.String);
	*** toString();
	*** toString(boolean);
	*** valueOf(boolean);
	*** valueOf(java.lang.String);
}

-keep class java.lang.BootstrapMethodError {
	*;
}

-keep class java.lang.Byte {
	*** TYPE;
	*** byteValue();
	*** intValue();
	*** parseByte(java.lang.String);
	*** toString();
	*** toString(byte);
	*** valueOf(byte);
	*** valueOf(java.lang.String);
}

-keep class java.lang.Byte$ByteCache {
	*** cache;
}

-keep class java.lang.CharSequence {
	*** charAt(int);
	*** length();
	*** subSequence(int,int);
	*** toString();
}

-keep class java.lang.Character {
	*** TYPE;
	*** charCount(int);
	*** charValue();
	*** codePointAt(char[],int,int);
	*** digit(char,int);
	*** forDigit(int,int);
	*** getType(char);
	*** highSurrogate(int);
	*** isDefined(char);
	*** isDefined(int);
	*** isDigit(char);
	*** isHighSurrogate(char);
	*** isISOControl(char);
	*** isISOControl(int);
	*** isJavaIdentifierPart(char);
	*** isJavaIdentifierPart(int);
	*** isJavaIdentifierStart(char);
	*** isJavaIdentifierStart(int);
	*** isLetter(char);
	*** isLetterOrDigit(char);
	*** isLowSurrogate(char);
	*** isLowerCase(char);
	*** isSpaceChar(char);
	*** isSupplementaryCodePoint(int);
	*** isTitleCase(char);
	*** isUpperCase(char);
	*** isValidCodePoint(int);
	*** isWhitespace(char);
	*** isWhitespace(int);
	*** lowSurrogate(int);
	*** toChars(int);
	*** toCodePoint(char,char);
	*** toLowerCase(char);
	*** toString();
	*** toString(char);
	*** toTitleCase(char);
	*** toUpperCase(char);
	*** valueOf(char);
}

-keep class java.lang.Character$CharacterCache {
	*** cache;
}

-keep class java.lang.CharacterData {
	java.lang.CharacterData();
}

-keep class java.lang.CharacterData00 {
	*** $assertionsDisabled;
	*** A;
	*** B;
	*** X;
	*** Y;
	*** charMap;
	*** instance;
	*** findInCharMap(int);
	*** getProperties(int);
	*** getPropertiesEx(int);
	*** toUpperCase(int);
}

-keep class java.lang.CharacterDataLatin1 {
	*;
}

-keep class java.lang.Class {
	*** access$100(java.lang.Object[],java.lang.Object[]);
	*** asSubclass(java.lang.Class);
	*** cast(java.lang.Object);
	*** desiredAssertionStatus();
	*** forName(java.lang.String);
	*** forName(java.lang.String,boolean,java.lang.ClassLoader);
	*** getAnnotation(java.lang.Class);
	*** getAnnotations();
	*** getCanonicalName();
	*** getClassLoader();
	*** getComponentType();
	*** getConstructor(java.lang.Class[]);
	*** getConstructors();
	*** getDeclaredAnnotations();
	*** getDeclaredConstructor(java.lang.Class[]);
	*** getDeclaredConstructors();
	*** getDeclaredField(java.lang.String);
	*** getDeclaredFields();
	*** getDeclaredMethod(java.lang.String,java.lang.Class[]);
	*** getDeclaredMethods();
	*** getDeclaringClass();
	*** getEnclosingClass();
	*** getEnclosingMethod();
	*** getEnumConstants();
	*** getField(java.lang.String);
	*** getFields();
	*** getGenericInterfaces();
	*** getGenericSuperclass();
	*** getInterfaces();
	*** getMethod(java.lang.String,java.lang.Class[]);
	*** getMethods();
	*** getModifiers();
	*** getName();
	*** getPackage();
	*** getProtectionDomain();
	*** getResource(java.lang.String);
	*** getResourceAsStream(java.lang.String);
	*** getSigners();
	*** getSimpleName();
	*** getSuperclass();
	*** getTypeParameters();
	*** isAnnotation();
	*** isAnnotationPresent(java.lang.Class);
	*** isAnonymousClass();
	*** isArray();
	*** isAssignableFrom(java.lang.Class);
	*** isEnum();
	*** isInstance(java.lang.Object);
	*** isInterface();
	*** isLocalClass();
	*** isMemberClass();
	*** isPrimitive();
	*** newInstance();
	*** toString();
}

-keep class java.lang.Class$1 {
	*;
}

-keep class java.lang.Class$3 {
	*;
}

-keep class java.lang.Class$4 {
	*** this$0;
	*** val$values;
	*** run();
}

-keep class java.lang.Class$EnclosingMethodInfo {
	*** $assertionsDisabled;
	*** descriptor;
	*** enclosingClass;
	*** name;
	java.lang.Class$EnclosingMethodInfo(java.lang.Object[]);
	*** isConstructor();
	*** isPartial();
}

-keep class java.lang.Class$MethodArray {
	*** length;
	*** methods;
	*** add(java.lang.reflect.Method);
	*** addIfNotPresent(java.lang.reflect.Method);
	*** get(int);
	*** length();
}

-keep class java.lang.ClassCastException {
	*;
}

-keep class java.lang.ClassFormatError {
	*;
}

-keep class java.lang.ClassLoader {
	java.lang.ClassLoader();
	java.lang.ClassLoader(java.lang.ClassLoader);
	*** findClass(java.lang.String);
	*** getParent();
	*** getResource(java.lang.String);
	*** getResourceAsStream(java.lang.String);
	*** getResources(java.lang.String);
	*** getSystemClassLoader();
	*** getSystemResource(java.lang.String);
	*** getSystemResourceAsStream(java.lang.String);
	*** getSystemResources(java.lang.String);
	*** loadClass(java.lang.String);
	*** loadClass(java.lang.String,boolean);
	*** resolveClass(java.lang.Class);
}

-keep class java.lang.ClassLoader$2 {
	*** val$e;
	*** nextElement();
}

-keep class java.lang.ClassLoader$3 {
	*;
}

-keep class java.lang.ClassLoader$NativeLibrary {
	*;
}

-keep class java.lang.ClassLoader$ParallelLoaders {
	*;
}

-keep class java.lang.ClassNotFoundException {
	*;
}

-keep class java.lang.Cloneable {
	*;
}

-keep class java.lang.Comparable {
	*** compareTo(java.lang.Object);
}

-keep class java.lang.Compiler {
	*** disable();
	*** enable();
}

-keep class java.lang.Compiler$1 {
	*;
}

-keep class java.lang.Double {
	*** TYPE;
	*** compare(double,double);
	*** doubleToLongBits(double);
	*** doubleToRawLongBits(double);
	*** doubleValue();
	*** floatValue();
	*** intValue();
	*** isInfinite();
	*** isInfinite(double);
	*** isNaN();
	*** isNaN(double);
	*** longBitsToDouble(long);
	*** longValue();
	*** parseDouble(java.lang.String);
	*** toHexString(double);
	*** toString(double);
	*** valueOf(double);
	*** valueOf(java.lang.String);
}

-keep class java.lang.Enum {
	java.lang.Enum(java.lang.String,int);
	*** compareTo(java.lang.Enum);
	*** equals(java.lang.Object);
	*** getDeclaringClass();
	*** hashCode();
	*** name();
	*** ordinal();
	*** toString();
	*** valueOf(java.lang.Class,java.lang.String);
}

-keep class java.lang.Error {
	java.lang.Error();
	java.lang.Error(java.lang.String);
	java.lang.Error(java.lang.String,java.lang.Throwable);
	java.lang.Error(java.lang.Throwable);
}

-keep class java.lang.Exception {
	java.lang.Exception();
	java.lang.Exception(java.lang.String);
	java.lang.Exception(java.lang.String,java.lang.Throwable);
	java.lang.Exception(java.lang.Throwable);
}

-keep class java.lang.ExceptionInInitializerError {
	*** exception;
	*** getException();
}

-keep class java.lang.Float {
	*** TYPE;
	*** compare(float,float);
	*** compareTo(java.lang.Float);
	*** doubleValue();
	*** floatToIntBits(float);
	*** floatToRawIntBits(float);
	*** floatValue();
	*** intBitsToFloat(int);
	*** isInfinite();
	*** isInfinite(float);
	*** isNaN();
	*** isNaN(float);
	*** parseFloat(java.lang.String);
	*** valueOf(float);
	*** valueOf(java.lang.String);
}

-keep class java.lang.IllegalArgumentException {
	java.lang.IllegalArgumentException();
	java.lang.IllegalArgumentException(java.lang.String);
}

-keep class java.lang.IllegalMonitorStateException {
	*;
}

-keep class java.lang.IllegalStateException {
	java.lang.IllegalStateException();
	java.lang.IllegalStateException(java.lang.String);
	java.lang.IllegalStateException(java.lang.String,java.lang.Throwable);
	java.lang.IllegalStateException(java.lang.Throwable);
}

-keep class java.lang.IncompatibleClassChangeError {
	java.lang.IncompatibleClassChangeError();
	java.lang.IncompatibleClassChangeError(java.lang.String);
}

-keep class java.lang.IndexOutOfBoundsException {
	java.lang.IndexOutOfBoundsException();
	java.lang.IndexOutOfBoundsException(java.lang.String);
}

-keep class java.lang.Integer {
	*** TYPE;
	*** bitCount(int);
	*** compare(int,int);
	*** compareTo(java.lang.Integer);
	*** decode(java.lang.String);
	*** equals(java.lang.Object);
	*** getInteger(java.lang.String);
	*** getInteger(java.lang.String,int);
	*** highestOneBit(int);
	*** intValue();
	*** numberOfLeadingZeros(int);
	*** numberOfTrailingZeros(int);
	*** parseInt(java.lang.String);
	*** parseInt(java.lang.String,int);
	*** reverseBytes(int);
	*** rotateLeft(int,int);
	*** toBinaryString(int);
	*** toHexString(int);
	*** toString();
	*** toString(int);
	*** toString(int,int);
	*** valueOf(int);
	*** valueOf(java.lang.String);
	*** valueOf(java.lang.String,int);
}

-keep class java.lang.Integer$IntegerCache {
	*** cache;
	*** high;
}

-keep class java.lang.InternalError {
	*;
}

-keep class java.lang.Iterable {
	*** iterator();
}

-keep class java.lang.LinkageError {
	java.lang.LinkageError();
	java.lang.LinkageError(java.lang.String);
}

-keep class java.lang.Long {
	*** TYPE;
	*** bitCount(long);
	*** compareTo(java.lang.Long);
	*** decode(java.lang.String);
	*** longValue();
	*** parseLong(java.lang.String);
	*** parseLong(java.lang.String,int);
	*** reverseBytes(long);
	*** signum(long);
	*** toHexString(long);
	*** toOctalString(long);
	*** toString(long);
	*** toString(long,int);
	*** valueOf(java.lang.String);
	*** valueOf(long);
}

-keep class java.lang.Long$LongCache {
	*** cache;
}

-keep class java.lang.Math {
	*** abs(double);
	*** abs(float);
	*** abs(int);
	*** abs(long);
	*** ceil(double);
	*** cos(double);
	*** floor(double);
	*** getExponent(double);
	*** max(double,double);
	*** max(float,float);
	*** max(int,int);
	*** max(long,long);
	*** min(double,double);
	*** min(float,float);
	*** min(int,int);
	*** min(long,long);
	*** pow(double,double);
	*** rint(double);
	*** round(double);
	*** round(float);
	*** sin(double);
	*** sqrt(double);
	*** ulp(double);
}

-keep class java.lang.NoClassDefFoundError {
	*;
}

-keep class java.lang.NoSuchMethodError {
	*;
}

-keep class java.lang.NullPointerException {
	java.lang.NullPointerException(java.lang.String);
}

-keep class java.lang.Number {
	java.lang.Number();
	*** byteValue();
	*** doubleValue();
	*** floatValue();
	*** intValue();
	*** longValue();
	*** shortValue();
}

-keep class java.lang.Object {
	java.lang.Object();
	*** clone();
	*** equals(java.lang.Object);
	*** finalize();
	*** getClass();
	*** hashCode();
	*** notify();
	*** notifyAll();
	*** toString();
	*** wait();
	*** wait(long);
	*** wait(long,int);
}

-keep class java.lang.OutOfMemoryError {
	*;
}

-keep class java.lang.Package {
	*** access$000();
	*** access$100(java.lang.String);
	*** access$200();
	*** access$400();
	*** getImplementationVendor();
	*** getImplementationVersion();
	*** getName();
	*** getPackage(java.lang.String);
	*** getSpecificationTitle();
	*** getSpecificationVersion();
}

-keep class java.lang.Package$1 {
	*** val$fn;
	*** val$iname;
	*** run();
}

-keep class java.lang.Process {
	java.lang.Process();
	*** destroy();
	*** exitValue();
	*** getErrorStream();
	*** getInputStream();
	*** getOutputStream();
	*** waitFor();
}

-keep class java.lang.ProcessBuilder {
	*** $assertionsDisabled;
	*** command;
	*** directory;
	*** environment;
	*** redirectErrorStream;
	*** redirects;
	*** environment();
	*** redirectError(java.lang.ProcessBuilder$Redirect);
	*** redirectErrorStream(boolean);
	*** redirectInput(java.lang.ProcessBuilder$Redirect);
	*** redirectOutput(java.lang.ProcessBuilder$Redirect);
	*** redirects();
	*** start();
}

-keep class java.lang.ProcessBuilder$NullInputStream {
	*** INSTANCE;
}

-keep class java.lang.ProcessBuilder$NullOutputStream {
	*** INSTANCE;
}

-keep class java.lang.ProcessBuilder$Redirect {
	*** INHERIT;
	*** PIPE;
	*** append();
	*** file();
	*** from(java.io.File);
	*** to(java.io.File);
	*** type();
}

-keep class java.lang.ProcessBuilder$Redirect$Type {
	*** APPEND;
	*** READ;
	*** WRITE;
}

-keep class java.lang.ProcessEnvironment {
	*** theEnvironment;
	*** theUnmodifiableEnvironment;
	*** access$000(byte[],byte[]);
	*** access$100(byte[]);
	*** access$200(java.lang.String);
	*** access$300(byte[],byte[]);
	*** access$400(java.lang.String);
	*** arrayCompare(byte[],byte[]);
	*** arrayEquals(byte[],byte[]);
	*** arrayHash(byte[]);
	*** emptyEnvironment(int);
	*** environ();
	*** environment();
	*** toEnvironmentBlock(java.util.Map,int[]);
	*** validateValue(java.lang.String);
	*** validateVariable(java.lang.String);
}

-keep class java.lang.ProcessEnvironment$ExternalData {
	*** bytes;
	*** str;
	java.lang.ProcessEnvironment$ExternalData(java.lang.String,byte[]);
	*** equals(java.lang.Object);
	*** getBytes();
	*** toString();
}

-keep class java.lang.ProcessEnvironment$StringEnvironment {
	*** m;
	*** get(java.lang.Object);
	*** put(java.lang.String,java.lang.String);
	*** remove(java.lang.Object);
	*** toEnvironmentBlock(int[]);
	*** toString(java.lang.ProcessEnvironment$Value);
}

-keep class java.lang.ProcessEnvironment$Value {
	*** compareTo(java.lang.ProcessEnvironment$Value);
	*** valueOf(byte[]);
	*** valueOf(java.lang.String);
	*** valueOfQueryOnly(java.lang.Object);
	*** valueOfQueryOnly(java.lang.String);
}

-keep class java.lang.ProcessEnvironment$Variable {
	*** compareTo(java.lang.ProcessEnvironment$Variable);
	*** valueOf(byte[]);
	*** valueOf(java.lang.String);
	*** valueOfQueryOnly(java.lang.Object);
	*** valueOfQueryOnly(java.lang.String);
}

-keep class java.lang.ProcessImpl {
	*** $assertionsDisabled;
	*** fdAccess;
	*** start(java.lang.String[],java.util.Map,java.lang.String,java.lang.ProcessBuilder$Redirect[],boolean);
	*** toCString(java.lang.String);
}

-keep class java.lang.Readable {
	*** read(java.nio.CharBuffer);
}

-keep class java.lang.ReflectiveOperationException {
	java.lang.ReflectiveOperationException();
	java.lang.ReflectiveOperationException(java.lang.String);
	java.lang.ReflectiveOperationException(java.lang.String,java.lang.Throwable);
	java.lang.ReflectiveOperationException(java.lang.Throwable);
}

-keep class java.lang.Runnable {
	*** run();
}

-keep class java.lang.Runtime {
	*** addShutdownHook(java.lang.Thread);
	*** availableProcessors();
	*** exec(java.lang.String);
	*** exec(java.lang.String[]);
	*** freeMemory();
	*** gc();
	*** getRuntime();
	*** maxMemory();
	*** removeShutdownHook(java.lang.Thread);
}

-keep class java.lang.RuntimeException {
	java.lang.RuntimeException();
	java.lang.RuntimeException(java.lang.String);
	java.lang.RuntimeException(java.lang.String,java.lang.Throwable);
	java.lang.RuntimeException(java.lang.Throwable);
}

-keep class java.lang.RuntimePermission {
	*;
}

-keep class java.lang.SecurityManager {
	java.lang.SecurityManager();
	*** checkAccept(java.lang.String,int);
	*** checkAccess(java.lang.Thread);
	*** checkAwtEventQueueAccess();
	*** checkConnect(java.lang.String,int);
	*** checkDelete(java.lang.String);
	*** checkExec(java.lang.String);
	*** checkExit(int);
	*** checkListen(int);
	*** checkMulticast(java.net.InetAddress);
	*** checkMulticast(java.net.InetAddress,byte);
	*** checkPackageAccess(java.lang.String);
	*** checkPermission(java.security.Permission);
	*** checkPermission(java.security.Permission,java.lang.Object);
	*** checkPropertiesAccess();
	*** checkPropertyAccess(java.lang.String);
	*** checkRead(java.lang.String);
	*** checkSecurityAccess(java.lang.String);
	*** checkSetFactory();
	*** checkSystemClipboardAccess();
	*** checkTopLevelWindow(java.lang.Object);
	*** checkWrite(java.lang.String);
	*** getClassContext();
	*** getSecurityContext();
	*** getThreadGroup();
}

-keep class java.lang.Short {
	*** TYPE;
	*** compare(short,short);
	*** intValue();
	*** parseShort(java.lang.String);
	*** reverseBytes(short);
	*** shortValue();
	*** valueOf(java.lang.String);
	*** valueOf(short);
}

-keep class java.lang.Short$ShortCache {
	*** cache;
}

-keep class java.lang.Shutdown {
	*** currentRunningHook;
	*** haltLock;
	*** hooks;
	*** lock;
	*** runFinalizersOnExit;
	*** state;
	*** add(int,boolean,java.lang.Runnable);
	*** halt(int);
	*** halt0(int);
	*** runAllFinalizers();
	*** runHooks();
	*** sequence();
}

-keep class java.lang.Shutdown$Lock {
	java.lang.Shutdown$Lock();
}

-keep class java.lang.StackOverflowError {
	*;
}

-keep class java.lang.StackTraceElement {
	*** getClassName();
	*** getMethodName();
	*** hashCode();
	*** toString();
}

-keep class java.lang.StrictMath {
	*** $assertionsDisabled;
	*** negativeZeroDoubleBits;
	*** negativeZeroFloatBits;
	*** randomNumberGenerator;
	*** floorOrCeil(double,double,double,double);
	*** initRNG();
}

-keep class java.lang.String {
	*** CASE_INSENSITIVE_ORDER;
	*** charAt(int);
	*** codePointAt(int);
	*** compareTo(java.lang.String);
	*** compareToIgnoreCase(java.lang.String);
	*** concat(java.lang.String);
	*** contains(java.lang.CharSequence);
	*** copyValueOf(char[],int,int);
	*** endsWith(java.lang.String);
	*** equals(java.lang.Object);
	*** equalsIgnoreCase(java.lang.String);
	*** format(java.lang.String,java.lang.Object[]);
	*** getBytes();
	*** getBytes(java.lang.String);
	*** getBytes(java.nio.charset.Charset);
	*** getChars(int,int,char[],int);
	*** hashCode();
	*** indexOf(int);
	*** indexOf(int,int);
	*** indexOf(java.lang.String);
	*** indexOf(java.lang.String,int);
	*** intern();
	*** isEmpty();
	*** lastIndexOf(int);
	*** lastIndexOf(int,int);
	*** lastIndexOf(java.lang.String);
	*** lastIndexOf(java.lang.String,int);
	*** length();
	*** matches(java.lang.String);
	*** regionMatches(boolean,int,java.lang.String,int,int);
	*** regionMatches(int,java.lang.String,int,int);
	*** replace(char,char);
	*** replace(java.lang.CharSequence,java.lang.CharSequence);
	*** replaceAll(java.lang.String,java.lang.String);
	*** replaceFirst(java.lang.String,java.lang.String);
	*** split(java.lang.String);
	*** split(java.lang.String,int);
	*** startsWith(java.lang.String);
	*** startsWith(java.lang.String,int);
	*** substring(int);
	*** substring(int,int);
	*** toCharArray();
	*** toLowerCase();
	*** toLowerCase(java.util.Locale);
	*** toString();
	*** toUpperCase();
	*** toUpperCase(java.util.Locale);
	*** trim();
	*** valueOf(boolean);
	*** valueOf(char);
	*** valueOf(double);
	*** valueOf(float);
	*** valueOf(int);
	*** valueOf(java.lang.Object);
	*** valueOf(long);
}

-keep class java.lang.String$CaseInsensitiveComparator {
	*;
}

-keep class java.lang.StringBuffer {
	*** append(boolean);
	*** append(char);
	*** append(char[]);
	*** append(char[],int,int);
	*** append(double);
	*** append(float);
	*** append(int);
	*** append(java.lang.CharSequence,int,int);
	*** append(java.lang.Object);
	*** append(java.lang.String);
	*** append(long);
	*** capacity();
	*** charAt(int);
	*** delete(int,int);
	*** ensureCapacity(int);
	*** getChars(int,int,char[],int);
	*** insert(int,char);
	*** insert(int,char[]);
	*** insert(int,java.lang.String);
	*** lastIndexOf(java.lang.String);
	*** length();
	*** setCharAt(int,char);
	*** setLength(int);
	*** substring(int);
	*** substring(int,int);
	*** toString();
}

-keep class java.lang.StringBuilder {
	*** append(boolean);
	*** append(char);
	*** append(char[]);
	*** append(char[],int,int);
	*** append(double);
	*** append(float);
	*** append(int);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
	*** append(java.lang.Object);
	*** append(java.lang.String);
	*** append(long);
	*** charAt(int);
	*** delete(int,int);
	*** deleteCharAt(int);
	*** getChars(int,int,char[],int);
	*** insert(int,char);
	*** insert(int,java.lang.String);
	*** length();
	*** reverse();
	*** setCharAt(int,char);
	*** setLength(int);
	*** substring(int);
	*** substring(int,int);
	*** toString();
}

-keep class java.lang.StringCoding {
	*;
}

-keep class java.lang.StringCoding$StringDecoder {
	*;
}

-keep class java.lang.StringCoding$StringEncoder {
	*;
}

-keep class java.lang.System {
	*** err;
	*** in;
	*** out;
	*** arraycopy(java.lang.Object,int,java.lang.Object,int,int);
	*** console();
	*** currentTimeMillis();
	*** exit(int);
	*** gc();
	*** getProperties();
	*** getProperty(java.lang.String);
	*** getProperty(java.lang.String,java.lang.String);
	*** getSecurityManager();
	*** getenv();
	*** getenv(java.lang.String);
	*** identityHashCode(java.lang.Object);
	*** lineSeparator();
	*** load(java.lang.String);
	*** loadLibrary(java.lang.String);
	*** mapLibraryName(java.lang.String);
	*** nanoTime();
	*** setErr(java.io.PrintStream);
	*** setProperty(java.lang.String,java.lang.String);
}

-keep class java.lang.System$2 {
	*;
}

-keep class java.lang.SystemClassLoaderAction {
	*;
}

-keep class java.lang.Terminator {
	*;
}

-keep class java.lang.Terminator$1 {
	*;
}

-keep class java.lang.Thread {
	*** inheritableThreadLocals;
	java.lang.Thread();
	java.lang.Thread(java.lang.String);
	java.lang.Thread(java.lang.ThreadGroup,java.lang.String);
	*** activeCount();
	*** checkAccess();
	*** countStackFrames();
	*** currentThread();
	*** destroy();
	*** dumpStack();
	*** enumerate(java.lang.Thread[]);
	*** getAllStackTraces();
	*** getContextClassLoader();
	*** getDefaultUncaughtExceptionHandler();
	*** getId();
	*** getName();
	*** getPriority();
	*** getStackTrace();
	*** getState();
	*** getThreadGroup();
	*** getUncaughtExceptionHandler();
	*** holdsLock(java.lang.Object);
	*** interrupt();
	*** interrupted();
	*** isAlive();
	*** isDaemon();
	*** isInterrupted();
	*** join();
	*** join(long);
	*** join(long,int);
	*** resume();
	*** setContextClassLoader(java.lang.ClassLoader);
	*** setDaemon(boolean);
	*** setDefaultUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler);
	*** setName(java.lang.String);
	*** setPriority(int);
	*** setUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler);
	*** sleep(long);
	*** sleep(long,int);
	*** start();
	*** stop();
	*** stop(java.lang.Throwable);
	*** suspend();
	*** toString();
	*** yield();
}

-keep class java.lang.Thread$State {
	*** $VALUES;
	*** BLOCKED;
	*** NEW;
	*** RUNNABLE;
	*** TERMINATED;
	*** TIMED_WAITING;
	*** WAITING;
}

-keep class java.lang.Thread$UncaughtExceptionHandler {
	*;
}

-keep class java.lang.ThreadDeath {
	*;
}

-keep class java.lang.ThreadGroup {
	*** activeCount();
	*** activeGroupCount();
	*** destroy();
	*** enumerate(java.lang.ThreadGroup[]);
	*** getName();
	*** getParent();
	*** interrupt();
	*** isDestroyed();
	*** parentOf(java.lang.ThreadGroup);
	*** stop();
}

-keep class java.lang.ThreadLocal {
	java.lang.ThreadLocal();
	*** get();
	*** remove();
	*** set(java.lang.Object);
}

-keep class java.lang.ThreadLocal$ThreadLocalMap {
	*;
}

-keep class java.lang.ThreadLocal$ThreadLocalMap$Entry {
	*;
}

-keep class java.lang.Throwable {
	java.lang.Throwable();
	*** addSuppressed(java.lang.Throwable);
	*** fillInStackTrace();
	*** getCause();
	*** getLocalizedMessage();
	*** getMessage();
	*** getStackTrace();
	*** initCause(java.lang.Throwable);
	*** printStackTrace();
	*** printStackTrace(java.io.PrintStream);
	*** printStackTrace(java.io.PrintWriter);
	*** setStackTrace(java.lang.StackTraceElement[]);
	*** toString();
}

-keep class java.lang.Throwable$PrintStreamOrWriter {
	java.lang.Throwable$PrintStreamOrWriter();
	java.lang.Throwable$PrintStreamOrWriter(java.lang.Throwable$1);
}

-keep class java.lang.Throwable$WrappedPrintStream {
	*** printStream;
}

-keep class java.lang.Throwable$WrappedPrintWriter {
	*** printWriter;
}

-keep class java.lang.UNIXProcess {
	*** exitcode;
	*** fdAccess;
	*** hasExited;
	*** pid;
	*** processReaperExecutor;
	*** stderr;
	*** stdin;
	*** stdout;
	*** access$100(java.lang.UNIXProcess);
	*** access$200(java.lang.UNIXProcess,int);
	*** destroyProcess(int);
	*** forkAndExec(byte[],byte[],int,byte[],int,byte[],int[],boolean);
	*** initIDs();
	*** initStreams(int[]);
	*** newFileDescriptor(int);
	*** processExited(int);
	*** waitForProcessExit(int);
}

-keep class java.lang.UNIXProcess$1 {
	*** run();
}

-keep class java.lang.UNIXProcess$2 {
	*** this$0;
	*** val$fds;
	*** run();
}

-keep class java.lang.UNIXProcess$3 {
	*** this$0;
}

-keep class java.lang.UNIXProcess$ProcessPipeInputStream {
	*** drainInputStream(java.io.InputStream);
	*** processExited();
}

-keep class java.lang.UNIXProcess$ProcessPipeOutputStream {
	*** processExited();
}

-keep class java.lang.UNIXProcess$ProcessReaperThreadFactory {
	*** group;
	java.lang.UNIXProcess$ProcessReaperThreadFactory();
	*** getRootThreadGroup();
}

-keep class java.lang.UNIXProcess$ProcessReaperThreadFactory$1 {
	*** run();
}

-keep class java.lang.UnsupportedOperationException {
	java.lang.UnsupportedOperationException();
}

-keep class java.lang.VirtualMachineError {
	*;
}

-keep class java.lang.Void {
	*** TYPE;
}

-keep class java.lang.annotation.Annotation {
	*** annotationType();
}

-keep class java.lang.annotation.ElementType {
	*** $VALUES;
	*** ANNOTATION_TYPE;
	*** CONSTRUCTOR;
	*** FIELD;
	*** LOCAL_VARIABLE;
	*** METHOD;
	*** PACKAGE;
	*** PARAMETER;
	*** TYPE;
}

-keep class java.lang.annotation.Retention {
	*** value();
}

-keep class java.lang.annotation.RetentionPolicy {
	*** $VALUES;
	*** CLASS;
	*** RUNTIME;
	*** SOURCE;
}

-keep class java.lang.instrument.ClassFileTransformer {
	*;
}

-keep class java.lang.instrument.IllegalClassFormatException {
	*;
}

-keep class java.lang.instrument.Instrumentation {
	*** removeTransformer(java.lang.instrument.ClassFileTransformer);
}

-keep class java.lang.invoke.CallSite {
	*;
}

-keep class java.lang.invoke.ConstantCallSite {
	*;
}

-keep class java.lang.invoke.LambdaForm {
	*;
}

-keep class java.lang.invoke.MemberName {
	*;
}

-keep class java.lang.invoke.MethodHandle {
	*;
}

-keep class java.lang.invoke.MethodHandleNatives {
	*;
}

-keep class java.lang.invoke.MethodType {
	*;
}

-keep class java.lang.invoke.MutableCallSite {
	*;
}

-keep class java.lang.invoke.VolatileCallSite {
	*;
}

-keep class java.lang.management.ManagementFactory {
	*** platformMBeanServer;
	*** addMXBean(javax.management.MBeanServer,java.lang.management.PlatformManagedObject);
	*** getMemoryMXBean();
	*** getOperatingSystemMXBean();
}

-keep class java.lang.management.MemoryMXBean {
	*** getHeapMemoryUsage();
	*** getNonHeapMemoryUsage();
}

-keep class java.lang.management.MemoryUsage {
	*** getCommitted();
}

-keep class java.lang.management.OperatingSystemMXBean {
	*** getSystemLoadAverage();
}

-keep class java.lang.management.PlatformComponent {
	*** getMXBeanInterface();
	*** getMXBeans(java.lang.Class);
	*** getMXBeans(javax.management.MBeanServerConnection,java.lang.Class);
	*** getPlatformComponent(java.lang.Class);
	*** getSingletonMXBean(java.lang.Class);
	*** getSingletonMXBean(javax.management.MBeanServerConnection,java.lang.Class);
	*** isSingleton();
	*** values();
}

-keep class java.lang.management.PlatformManagedObject {
	*** getObjectName();
}

-keep class java.lang.ref.FinalReference {
	*;
}

-keep class java.lang.ref.Finalizer {
	*;
}

-keep class java.lang.ref.Finalizer$FinalizerThread {
	*;
}

-keep class java.lang.ref.PhantomReference {
	java.lang.ref.PhantomReference(java.lang.Object,java.lang.ref.ReferenceQueue);
}

-keep class java.lang.ref.Reference {
	*** clear();
	*** get();
}

-keep class java.lang.ref.Reference$Lock {
	*;
}

-keep class java.lang.ref.Reference$ReferenceHandler {
	*;
}

-keep class java.lang.ref.ReferenceQueue {
	*** poll();
	*** remove();
}

-keep class java.lang.ref.ReferenceQueue$Lock {
	*;
}

-keep class java.lang.ref.ReferenceQueue$Null {
	*;
}

-keep class java.lang.ref.SoftReference {
	java.lang.ref.SoftReference(java.lang.Object,java.lang.ref.ReferenceQueue);
	*** get();
}

-keep class java.lang.ref.WeakReference {
	java.lang.ref.WeakReference(java.lang.Object);
	java.lang.ref.WeakReference(java.lang.Object,java.lang.ref.ReferenceQueue);
}

-keep class java.lang.reflect.AccessibleObject {
	java.lang.reflect.AccessibleObject();
	*** getAnnotation(java.lang.Class);
	*** getAnnotations();
	*** getDeclaredAnnotations();
	*** isAccessible();
	*** isAnnotationPresent(java.lang.Class);
	*** setAccessible(boolean);
}

-keep class java.lang.reflect.AnnotatedElement {
	*** getAnnotation(java.lang.Class);
	*** getAnnotations();
	*** isAnnotationPresent(java.lang.Class);
}

-keep class java.lang.reflect.Array {
	*** get(java.lang.Object,int);
	*** getBoolean(java.lang.Object,int);
	*** getLength(java.lang.Object);
	*** getLong(java.lang.Object,int);
	*** newInstance(java.lang.Class,int);
	*** newInstance(java.lang.Class,int[]);
	*** set(java.lang.Object,int,java.lang.Object);
}

-keep class java.lang.reflect.Constructor {
	*** getAnnotation(java.lang.Class);
	*** getDeclaredAnnotations();
	*** getDeclaringClass();
	*** getExceptionTypes();
	*** getGenericExceptionTypes();
	*** getGenericParameterTypes();
	*** getModifiers();
	*** getName();
	*** getParameterAnnotations();
	*** getParameterTypes();
	*** getTypeParameters();
	*** isVarArgs();
	*** newInstance(java.lang.Object[]);
}

-keep class java.lang.reflect.Field {
	*** get(java.lang.Object);
	*** getAnnotation(java.lang.Class);
	*** getBoolean(java.lang.Object);
	*** getDeclaredAnnotations();
	*** getDeclaringClass();
	*** getGenericType();
	*** getInt(java.lang.Object);
	*** getLong(java.lang.Object);
	*** getModifiers();
	*** getName();
	*** getType();
	*** isEnumConstant();
	*** isSynthetic();
	*** set(java.lang.Object,java.lang.Object);
	*** setBoolean(java.lang.Object,boolean);
}

-keep class java.lang.reflect.GenericArrayType {
	*** getGenericComponentType();
}

-keep class java.lang.reflect.GenericDeclaration {
	*** getTypeParameters();
}

-keep class java.lang.reflect.InvocationHandler {
	*** invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[]);
}

-keep class java.lang.reflect.InvocationTargetException {
	*** target;
	*** getCause();
	*** getTargetException();
}

-keep class java.lang.reflect.Member {
	*** getDeclaringClass();
	*** getModifiers();
	*** getName();
	*** isSynthetic();
}

-keep class java.lang.reflect.Method {
	*** equals(java.lang.Object);
	*** getAnnotation(java.lang.Class);
	*** getDeclaredAnnotations();
	*** getDeclaringClass();
	*** getExceptionTypes();
	*** getGenericExceptionTypes();
	*** getGenericParameterTypes();
	*** getGenericReturnType();
	*** getModifiers();
	*** getName();
	*** getParameterAnnotations();
	*** getParameterTypes();
	*** getReturnType();
	*** getTypeParameters();
	*** hashCode();
	*** invoke(java.lang.Object,java.lang.Object[]);
	*** isBridge();
	*** isSynthetic();
	*** isVarArgs();
	*** toString();
}

-keep class java.lang.reflect.Modifier {
	*** isAbstract(int);
	*** isFinal(int);
	*** isInterface(int);
	*** isNative(int);
	*** isPrivate(int);
	*** isProtected(int);
	*** isPublic(int);
	*** isStatic(int);
	*** isSynchronized(int);
	*** isTransient(int);
	*** isVolatile(int);
}

-keep class java.lang.reflect.ParameterizedType {
	*** getActualTypeArguments();
	*** getOwnerType();
	*** getRawType();
}

-keep class java.lang.reflect.Proxy {
	*** h;
	java.lang.reflect.Proxy(java.lang.reflect.InvocationHandler);
	*** getInvocationHandler(java.lang.Object);
	*** getProxyClass(java.lang.ClassLoader,java.lang.Class[]);
	*** isProxyClass(java.lang.Class);
	*** newProxyInstance(java.lang.ClassLoader,java.lang.Class[],java.lang.reflect.InvocationHandler);
}

-keep class java.lang.reflect.ReflectAccess {
	*;
}

-keep class java.lang.reflect.ReflectPermission {
	*;
}

-keep class java.lang.reflect.Type {
	*;
}

-keep class java.lang.reflect.TypeVariable {
	*** getBounds();
	*** getGenericDeclaration();
	*** getName();
}

-keep class java.lang.reflect.UndeclaredThrowableException {
	*** undeclaredThrowable;
	*** getUndeclaredThrowable();
}

-keep class java.lang.reflect.WildcardType {
	*** getLowerBounds();
	*** getUpperBounds();
}

-keep class java.math.BigDecimal {
	*** $assertionsDisabled;
	*** BIG_TEN_POWERS_TABLE;
	*** BIG_TEN_POWERS_TABLE_INITLEN;
	*** BIG_TEN_POWERS_TABLE_MAX;
	*** LONG_TEN_POWERS_TABLE;
	*** ONE;
	*** TEN;
	*** THRESHOLDS_TABLE;
	*** ZERO;
	*** ZERO_SCALED_BY;
	*** intCompact;
	*** intVal;
	*** precision;
	*** scale;
	*** stringCache;
	*** threadLocalStringBuilderHelper;
	*** zeroThroughTen;
	java.math.BigDecimal(char[],int,int);
	java.math.BigDecimal(char[],int,int,java.math.MathContext);
	java.math.BigDecimal(double);
	java.math.BigDecimal(java.math.BigInteger);
	java.math.BigDecimal(long);
	*** abs();
	*** add(java.math.BigDecimal);
	*** add(java.math.BigDecimal,java.math.MathContext);
	*** bigDigitLength(java.math.BigInteger);
	*** bigMultiplyPowerTen(int);
	*** bigTenToThe(int);
	*** checkScale(long);
	*** compactValFor(java.math.BigInteger);
	*** compareMagnitude(java.math.BigDecimal);
	*** compareTo(java.math.BigDecimal);
	*** divide(java.math.BigDecimal);
	*** divide(java.math.BigDecimal,int,int);
	*** divide(java.math.BigDecimal,java.math.MathContext);
	*** divide(java.math.BigDecimal,java.math.RoundingMode);
	*** divideAndRemainder(java.math.BigDecimal);
	*** divideAndRemainder(java.math.BigDecimal,java.math.MathContext);
	*** divideAndRound(long,java.math.BigInteger,long,java.math.BigInteger,int,int,int);
	*** divideToIntegralValue(java.math.BigDecimal);
	*** divideToIntegralValue(java.math.BigDecimal,java.math.MathContext);
	*** doRound(java.math.BigDecimal,java.math.MathContext);
	*** doubleValue();
	*** equals(java.lang.Object);
	*** expandBigIntegerTenPowers(int);
	*** getValueString(int,java.lang.String,int);
	*** hashCode();
	*** inflate();
	*** intValue();
	*** layoutChars(boolean);
	*** longCompareMagnitude(long,long);
	*** longDigitLength(long);
	*** longMultiplyPowerTen(long,int);
	*** longValue();
	*** longValueExact();
	*** matchScale(java.math.BigDecimal[]);
	*** multiply(java.math.BigDecimal);
	*** multiply(java.math.BigDecimal,java.math.MathContext);
	*** negate();
	*** negate(java.math.MathContext);
	*** plus(java.math.MathContext);
	*** pow(int);
	*** preAlign(java.math.BigDecimal,java.math.BigDecimal,long,java.math.MathContext);
	*** precision();
	*** print(java.lang.String,java.math.BigDecimal);
	*** roundThis(java.math.MathContext);
	*** saturateLong(long);
	*** scale();
	*** scaleByPowerOfTen(int);
	*** setScale(int);
	*** setScale(int,int);
	*** setScale(int,java.math.RoundingMode);
	*** signum();
	*** stripZerosToMatchScale(long);
	*** subtract(java.math.BigDecimal);
	*** toBigInteger();
	*** toString();
	*** unscaledValue();
	*** valueOf(double);
	*** valueOf(long);
	*** valueOf(long,int);
}

-keep class java.math.BigDecimal$1 {
	*** initialValue();
}

-keep class java.math.BigDecimal$LongOverflow {
	*** check(java.math.BigDecimal);
}

-keep class java.math.BigDecimal$StringBuilderHelper {
	*** getCompactCharArray();
	*** getStringBuilder();
	*** putIntCompact(long);
}

-keep class java.math.BigInteger {
	*** $assertionsDisabled;
	*** ONE;
	*** SMALL_PRIME_PRODUCT;
	*** TEN;
	*** TWO;
	*** ZERO;
	*** bitCount;
	*** bitLength;
	*** bitsPerDigit;
	*** bnExpModThreshTable;
	*** digitsPerInt;
	*** digitsPerLong;
	*** firstNonzeroIntNum;
	*** intRadix;
	*** longRadix;
	*** lowestSetBit;
	*** mag;
	*** magOffset;
	*** negConst;
	*** posConst;
	*** serialPersistentFields;
	*** signum;
	*** signumOffset;
	*** staticRandom;
	*** unsafe;
	*** zeros;
	java.math.BigInteger(int,byte[]);
	java.math.BigInteger(java.lang.String,int);
	*** abs();
	*** add(int[],int[]);
	*** add(java.math.BigInteger);
	*** addOne(int[],int,int,int);
	*** bitCount();
	*** bitLength();
	*** bitLength(int[],int);
	*** bitLengthForInt(int);
	*** clearBit(int);
	*** compareMagnitude(java.math.BigInteger);
	*** compareTo(java.math.BigInteger);
	*** destructiveMulAdd(int[],int,int);
	*** divide(java.math.BigInteger);
	*** divideAndRemainder(java.math.BigInteger);
	*** doubleValue();
	*** equals(java.lang.Object);
	*** firstNonzeroIntNum();
	*** getInt(int);
	*** getLowestSetBit();
	*** getSecureRandom();
	*** hashCode();
	*** intArrayCmpToLen(int[],int[],int);
	*** intLength();
	*** intValue();
	*** jacobiSymbol(int,java.math.BigInteger);
	*** javaIncrement(int[]);
	*** largePrime(int,int,java.util.Random);
	*** leftShift(int[],int,int);
	*** longValue();
	*** lucasLehmerSequence(int,java.math.BigInteger,java.math.BigInteger);
	*** magSerializedForm();
	*** makePositive(byte[]);
	*** makePositive(int[]);
	*** mod(java.math.BigInteger);
	*** mod2(int);
	*** modInverse(java.math.BigInteger);
	*** modPow(java.math.BigInteger,java.math.BigInteger);
	*** modPow2(java.math.BigInteger,int);
	*** montReduce(int[],int[],int,int);
	*** mulAdd(int[],int[],int,int,int);
	*** multiply(java.math.BigInteger);
	*** multiply(long);
	*** multiplyToLen(int[],int,int[],int,int[]);
	*** negate();
	*** oddModPow(java.math.BigInteger,java.math.BigInteger);
	*** or(java.math.BigInteger);
	*** parseInt(char[],int,int);
	*** passesLucasLehmer();
	*** passesMillerRabin(int,java.util.Random);
	*** pow(int);
	*** primeToCertainty(int,java.util.Random);
	*** primitiveLeftShift(int[],int,int);
	*** primitiveRightShift(int[],int,int);
	*** randomBits(int,java.util.Random);
	*** remainder(java.math.BigInteger);
	*** setBit(int);
	*** shiftLeft(int);
	*** shiftRight(int);
	*** signInt();
	*** signum();
	*** smallPrime(int,int,java.util.Random);
	*** square();
	*** squareToLen(int[],int,int[]);
	*** stripLeadingZeroBytes(byte[]);
	*** stripLeadingZeroInts(int[]);
	*** subN(int[],int[],int);
	*** subtract(int[],int[]);
	*** subtract(java.math.BigInteger);
	*** testBit(int);
	*** toByteArray();
	*** toString();
	*** toString(int);
	*** trustedStripLeadingZeroInts(int[]);
	*** valueOf(int[]);
	*** valueOf(long);
}

-keep class java.math.BitSieve {
	*** retrieve(java.math.BigInteger,int,java.util.Random);
}

-keep class java.math.MathContext {
	*** precision;
	*** roundingMode;
}

-keep class java.math.MutableBigInteger {
	*** $assertionsDisabled;
	*** ONE;
	*** intLen;
	*** offset;
	*** value;
	java.math.MutableBigInteger();
	java.math.MutableBigInteger(int);
	java.math.MutableBigInteger(java.math.MutableBigInteger);
	*** add(java.math.MutableBigInteger);
	*** binaryGCD(java.math.MutableBigInteger);
	*** binaryGcd(int,int);
	*** clear();
	*** compare(java.math.MutableBigInteger);
	*** compareHalf(java.math.MutableBigInteger);
	*** copyValue(java.math.MutableBigInteger);
	*** difference(java.math.MutableBigInteger);
	*** divWord(int[],long,int);
	*** divadd(int[],int[],int);
	*** divide(java.math.MutableBigInteger,java.math.MutableBigInteger);
	*** divide(long,java.math.MutableBigInteger);
	*** divideMagnitude(int[],java.math.MutableBigInteger);
	*** divideOneWord(int,java.math.MutableBigInteger);
	*** euclidModInverse(int);
	*** fixup(java.math.MutableBigInteger,java.math.MutableBigInteger,int);
	*** getLowestSetBit();
	*** getMagnitudeArray();
	*** hybridGCD(java.math.MutableBigInteger);
	*** inverseMod32(int);
	*** isEven();
	*** isOdd();
	*** isOne();
	*** isZero();
	*** leftShift(int);
	*** modInverse(java.math.MutableBigInteger);
	*** modInverseBP2(java.math.MutableBigInteger,int);
	*** modInverseMP2(int);
	*** mul(int,java.math.MutableBigInteger);
	*** mulsub(int[],int[],int,int,int);
	*** multiply(java.math.MutableBigInteger,java.math.MutableBigInteger);
	*** mutableModInverse(java.math.MutableBigInteger);
	*** normalize();
	*** primitiveLeftShift(int);
	*** primitiveRightShift(int);
	*** reset();
	*** rightShift(int);
	*** setValue(int[],int);
	*** subtract(java.math.MutableBigInteger);
	*** toBigDecimal(int,int);
	*** toBigInteger(int);
	*** toIntArray();
	*** toLong();
	*** unsignedLongCompare(long,long);
}

-keep class java.math.RoundingMode {
	*** $VALUES;
	*** CEILING;
	*** DOWN;
	*** FLOOR;
	*** HALF_DOWN;
	*** HALF_EVEN;
	*** HALF_UP;
	*** UNNECESSARY;
	*** UP;
	*** oldMode;
}

-keep class java.math.SignedMutableBigInteger {
	*** sign;
	*** signedAdd(java.math.MutableBigInteger);
	*** signedAdd(java.math.SignedMutableBigInteger);
	*** signedSubtract(java.math.SignedMutableBigInteger);
}

-keep class java.net.AbstractPlainDatagramSocketImpl {
	*** connectDisabled;
	*** connected;
	*** connectedAddress;
	*** connectedPort;
	*** loopbackMode;
	*** multicastInterface;
	*** os;
	*** timeout;
	*** trafficClass;
	*** ttl;
	java.net.AbstractPlainDatagramSocketImpl();
	*** bind0(int,java.net.InetAddress);
	*** close();
	*** connect0(java.net.InetAddress,int);
	*** datagramSocketClose();
	*** datagramSocketCreate();
	*** disconnect0(int);
	*** isClosed();
	*** join(java.net.InetAddress,java.net.NetworkInterface);
	*** leave(java.net.InetAddress,java.net.NetworkInterface);
	*** nativeConnectDisabled();
	*** receive0(java.net.DatagramPacket);
	*** socketGetOption(int);
	*** socketSetOption(int,java.lang.Object);
}

-keep class java.net.AbstractPlainSocketImpl {
	*** CONNECTION_NOT_RESET;
	*** CONNECTION_RESET;
	*** CONNECTION_RESET_PENDING;
	*** closePending;
	*** fdLock;
	*** fdUseCount;
	*** resetLock;
	*** resetState;
	*** shut_rd;
	*** shut_wr;
	*** socketInputStream;
	*** stream;
	*** timeout;
	*** trafficClass;
	java.net.AbstractPlainSocketImpl();
	*** acquireFD();
	*** available();
	*** bind(java.net.InetAddress,int);
	*** close();
	*** connect(java.net.SocketAddress,int);
	*** connectToAddress(java.net.InetAddress,int,int);
	*** doConnect(java.net.InetAddress,int,int);
	*** getTimeout();
	*** isClosedOrPending();
	*** isConnectionReset();
	*** isConnectionResetPending();
	*** releaseFD();
	*** setAddress(java.net.InetAddress);
	*** setConnectionReset();
	*** setConnectionResetPending();
	*** setFileDescriptor(java.io.FileDescriptor);
	*** setInputStream(java.net.SocketInputStream);
	*** setLocalPort(int);
	*** setPort(int);
	*** socketAccept(java.net.SocketImpl);
	*** socketAvailable();
	*** socketBind(java.net.InetAddress,int);
	*** socketClose();
	*** socketClose0(boolean);
	*** socketConnect(java.net.InetAddress,int,int);
	*** socketCreate(boolean);
	*** socketGetOption(int,java.lang.Object);
	*** socketListen(int);
	*** socketPreClose();
	*** socketSendUrgentData(int);
	*** socketSetOption(int,boolean,java.lang.Object);
	*** socketShutdown(int);
}

-keep class java.net.ConnectException {
	java.net.ConnectException();
	java.net.ConnectException(java.lang.String);
}

-keep class java.net.DatagramPacket {
	*** address;
	*** buf;
	*** bufLength;
	*** length;
	*** offset;
	*** port;
	java.net.DatagramPacket(byte[],int,int);
	java.net.DatagramPacket(byte[],int,int,java.net.InetAddress,int);
	java.net.DatagramPacket(byte[],int,int,java.net.SocketAddress);
	*** getAddress();
	*** getData();
	*** getLength();
	*** getOffset();
	*** getPort();
	*** getSocketAddress();
	*** init();
	*** setAddress(java.net.InetAddress);
	*** setData(byte[],int,int);
	*** setLength(int);
	*** setPort(int);
	*** setSocketAddress(java.net.SocketAddress);
}

-keep class java.net.DatagramSocket {
	*** bound;
	*** closeLock;
	*** closed;
	*** connectState;
	*** connectedAddress;
	*** connectedPort;
	*** created;
	*** factory;
	*** impl;
	*** implClass;
	*** oldImpl;
	java.net.DatagramSocket(int,java.net.InetAddress);
	java.net.DatagramSocket(java.net.DatagramSocketImpl);
	java.net.DatagramSocket(java.net.SocketAddress);
	*** bind(java.net.SocketAddress);
	*** checkAddress(java.net.InetAddress,java.lang.String);
	*** checkOldImpl();
	*** close();
	*** connect(java.net.SocketAddress);
	*** connectInternal(java.net.InetAddress,int);
	*** createImpl();
	*** getBroadcast();
	*** getImpl();
	*** getInetAddress();
	*** getLocalAddress();
	*** getLocalPort();
	*** getLocalSocketAddress();
	*** getPort();
	*** getReceiveBufferSize();
	*** getRemoteSocketAddress();
	*** getReuseAddress();
	*** getSendBufferSize();
	*** getTrafficClass();
	*** isBound();
	*** isClosed();
	*** isConnected();
	*** setBroadcast(boolean);
	*** setReceiveBufferSize(int);
	*** setReuseAddress(boolean);
	*** setSendBufferSize(int);
	*** setTrafficClass(int);
}

-keep class java.net.DatagramSocket$1 {
	*** this$0;
	*** run();
}

-keep class java.net.DatagramSocketImpl {
	*** fd;
	*** localPort;
	java.net.DatagramSocketImpl();
	*** bind(int,java.net.InetAddress);
	*** close();
	*** connect(java.net.InetAddress,int);
	*** create();
	*** disconnect();
	*** getLocalPort();
	*** getTTL();
	*** getTimeToLive();
	*** join(java.net.InetAddress);
	*** joinGroup(java.net.SocketAddress,java.net.NetworkInterface);
	*** leave(java.net.InetAddress);
	*** leaveGroup(java.net.SocketAddress,java.net.NetworkInterface);
	*** peek(java.net.InetAddress);
	*** peekData(java.net.DatagramPacket);
	*** receive(java.net.DatagramPacket);
	*** send(java.net.DatagramPacket);
	*** setTTL(byte);
	*** setTimeToLive(int);
}

-keep class java.net.DatagramSocketImplFactory {
	*** createDatagramSocketImpl();
}

-keep class java.net.DefaultDatagramSocketImplFactory {
	*** prefixImplClass;
	*** createDatagramSocketImpl(boolean);
}

-keep class java.net.DefaultInterface {
	*** defaultInterface;
	*** chooseDefaultInterface();
	*** getDefault();
}

-keep class java.net.FileNameMap {
	*** getContentTypeFor(java.lang.String);
}

-keep class java.net.HttpURLConnection {
	*** chunkLength;
	*** fixedContentLength;
	*** fixedContentLengthLong;
	*** followRedirects;
	*** instanceFollowRedirects;
	*** method;
	*** methods;
	*** responseCode;
	*** responseMessage;
	*** disconnect();
	*** getHeaderField(int);
	*** getResponseCode();
	*** setInstanceFollowRedirects(boolean);
	*** setRequestMethod(java.lang.String);
}

-keep class java.net.Inet4Address {
	*** equals(java.lang.Object);
	*** getAddress();
	*** hashCode();
	*** init();
	*** numericToTextFormat(byte[]);
}

-keep class java.net.Inet4AddressImpl {
	*** anyLocalAddress;
	*** loopbackAddress;
	*** anyLocalAddress();
	*** isReachable0(byte[],int,byte[],int);
	*** loopbackAddress();
}

-keep class java.net.Inet6Address {
	*** cached_scope_id;
	*** ifname;
	*** ipaddress;
	*** scope_id;
	*** scope_id_set;
	*** scope_ifname;
	*** scope_ifname_set;
	*** deriveNumericScope(java.net.NetworkInterface);
	*** differentLocalAddressTypes(java.net.Inet6Address);
	*** getScopeId();
	*** init();
	*** initif(java.lang.String,byte[],java.net.NetworkInterface);
	*** initstr(java.lang.String,byte[],java.lang.String);
	*** isLinkLocalAddress();
	*** isSiteLocalAddress();
	*** numericToTextFormat(byte[]);
}

-keep class java.net.Inet6AddressImpl {
	*** anyLocalAddress;
	*** loopbackAddress;
	*** isReachable0(byte[],int,int,byte[],int,int);
}

-keep class java.net.InetAddress {
	*** $assertionsDisabled;
	*** FIELDS_OFFSET;
	*** UNSAFE;
	*** addressCache;
	*** addressCacheInit;
	*** cacheLock;
	*** cacheTime;
	*** cachedLocalHost;
	*** canonicalHostName;
	*** holder;
	*** impl;
	*** lookupTable;
	*** nameServices;
	*** negativeCache;
	*** preferIPv6Address;
	*** serialPersistentFields;
	*** unknown_array;
	java.net.InetAddress();
	*** anyLocalAddress();
	*** cacheAddresses(java.lang.String,java.net.InetAddress[],boolean);
	*** cacheInitIfNeeded();
	*** checkLookupTable(java.lang.String);
	*** checkNumericZone(java.lang.String);
	*** createNSProvider(java.lang.String);
	*** equals(java.lang.Object);
	*** getAddress();
	*** getAddressesFromNameService(java.lang.String,java.net.InetAddress);
	*** getAllByName(java.lang.String);
	*** getAllByName(java.lang.String,java.net.InetAddress);
	*** getAllByName0(java.lang.String,boolean);
	*** getAllByName0(java.lang.String,java.net.InetAddress,boolean);
	*** getByAddress(byte[]);
	*** getByAddress(java.lang.String,byte[]);
	*** getByName(java.lang.String);
	*** getCachedAddresses(java.lang.String);
	*** getCanonicalHostName();
	*** getHostAddress();
	*** getHostFromNameService(java.net.InetAddress,boolean);
	*** getHostName();
	*** getHostName(boolean);
	*** getLocalHost();
	*** getLoopbackAddress();
	*** hashCode();
	*** holder();
	*** init();
	*** isAnyLocalAddress();
	*** isLinkLocalAddress();
	*** isLoopbackAddress();
	*** isMulticastAddress();
	*** isReachable(java.net.NetworkInterface,int,int);
	*** isSiteLocalAddress();
	*** loadImpl(java.lang.String);
	*** toString();
	*** updateLookupTable(java.lang.String);
}

-keep class java.net.InetAddress$Cache {
	*** cache;
	*** type;
	*** get(java.lang.String);
	*** getPolicy();
	*** put(java.lang.String,java.net.InetAddress[]);
}

-keep class java.net.InetAddress$Cache$Type {
	*** $VALUES;
	*** Negative;
	*** Positive;
}

-keep class java.net.InetAddress$CacheEntry {
	*** addresses;
	*** expiration;
}

-keep class java.net.InetAddress$InetAddressHolder {
	*** address;
	*** family;
	*** hostName;
	*** getAddress();
	*** getFamily();
	*** getHostName();
}

-keep class java.net.InetAddressContainer {
	*** addr;
}

-keep class java.net.InetAddressImpl {
	*** anyLocalAddress();
	*** getHostByAddr(byte[]);
	*** getLocalHostName();
	*** isReachable(java.net.InetAddress,int,java.net.NetworkInterface,int);
	*** lookupAllHostAddr(java.lang.String);
	*** loopbackAddress();
}

-keep class java.net.InetAddressImplFactory {
	*** create();
	*** isIPv6Supported();
}

-keep class java.net.InetSocketAddress {
	*** FIELDS_OFFSET;
	*** UNSAFE;
	*** holder;
	*** serialPersistentFields;
	java.net.InetSocketAddress(java.net.InetAddress,int);
	*** checkHost(java.lang.String);
	*** checkPort(int);
	*** createUnresolved(java.lang.String,int);
	*** equals(java.lang.Object);
	*** getAddress();
	*** getHostName();
	*** getHostString();
	*** getPort();
	*** hashCode();
	*** isUnresolved();
	*** toString();
}

-keep class java.net.InetSocketAddress$InetSocketAddressHolder {
	*** addr;
	*** hostname;
	*** port;
	java.net.InetSocketAddress$InetSocketAddressHolder(java.lang.String,java.net.InetAddress,int);
	*** access$100(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$200(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$300(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$400(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$500(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$600(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$700(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** access$800(java.net.InetSocketAddress$InetSocketAddressHolder);
	*** equals(java.lang.Object);
	*** getAddress();
	*** getHostName();
	*** getHostString();
	*** getPort();
	*** hashCode();
	*** isUnresolved();
	*** toString();
}

-keep class java.net.InterfaceAddress {
	*** address;
	*** broadcast;
	*** maskLength;
	*** getAddress();
	*** getNetworkPrefixLength();
}

-keep class java.net.JarURLConnection {
	*** getJarEntry();
	*** getJarFile();
}

-keep class java.net.MulticastSocket {
	*** infAddress;
	*** infLock;
	*** interfaceSet;
	*** ttlLock;
	java.net.MulticastSocket(java.net.SocketAddress);
	*** getTTL();
	*** setNetworkInterface(java.net.NetworkInterface);
}

-keep class java.net.NetUtil {
	*** doRevealLocalAddress();
}

-keep class java.net.NetworkInterface {
	*** addrs;
	*** bindings;
	*** childs;
	*** defaultIndex;
	*** defaultInterface;
	*** displayName;
	*** index;
	*** name;
	*** parent;
	*** virtual;
	*** access$000(java.net.NetworkInterface);
	*** getAll();
	*** getByIndex(int);
	*** getByIndex0(int);
	*** getByInetAddress(java.net.InetAddress);
	*** getByInetAddress0(java.net.InetAddress);
	*** getByName(java.lang.String);
	*** getByName0(java.lang.String);
	*** getDefault();
	*** getDisplayName();
	*** getIndex();
	*** getInetAddresses();
	*** getInterfaceAddresses();
	*** getMTU0(java.lang.String,int);
	*** getMacAddr0(byte[],java.lang.String,int);
	*** getName();
	*** getNetworkInterfaces();
	*** init();
	*** isLoopback();
	*** isLoopback0(java.lang.String,int);
	*** isP2P0(java.lang.String,int);
	*** isPointToPoint();
	*** isUp();
	*** isUp0(java.lang.String,int);
	*** supportsMulticast();
	*** supportsMulticast0(java.lang.String,int);
}

-keep class java.net.NetworkInterface$1 {
	*** i;
	*** val$netifs;
	*** nextElement();
}

-keep class java.net.NetworkInterface$1checkedAddresses {
	*** count;
	*** i;
	*** local_addrs;
	*** this$0;
	*** nextElement();
}

-keep class java.net.Parts {
	*;
}

-keep class java.net.PasswordAuthentication {
	*** getPassword();
	*** getUserName();
}

-keep class java.net.PlainDatagramSocketImpl {
	*** init();
}

-keep class java.net.PlainSocketImpl {
	java.net.PlainSocketImpl();
	*** initProto();
}

-keep class java.net.Proxy {
	*** NO_PROXY;
	*** sa;
	*** type;
	*** address();
	*** type();
}

-keep class java.net.Proxy$Type {
	*** $VALUES;
	*** DIRECT;
	*** HTTP;
	*** SOCKS;
}

-keep class java.net.ProxySelector {
	*** theProxySelector;
	java.net.ProxySelector();
	*** connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException);
	*** getDefault();
	*** select(java.net.URI);
}

-keep class java.net.ServerSocket {
	*** bound;
	*** closeLock;
	*** closed;
	*** created;
	*** factory;
	*** impl;
	*** oldImpl;
	java.net.ServerSocket();
	java.net.ServerSocket(int);
	java.net.ServerSocket(int,int);
	java.net.ServerSocket(int,int,java.net.InetAddress);
	*** accept();
	*** bind(java.net.SocketAddress);
	*** bind(java.net.SocketAddress,int);
	*** checkOldImpl();
	*** close();
	*** createImpl();
	*** getImpl();
	*** getInetAddress();
	*** getLocalPort();
	*** getLocalSocketAddress();
	*** getReceiveBufferSize();
	*** getReuseAddress();
	*** implAccept(java.net.Socket);
	*** isBound();
	*** isClosed();
	*** setBound();
	*** setCreated();
	*** setImpl();
	*** setPerformancePreferences(int,int,int);
	*** setReceiveBufferSize(int);
	*** setReuseAddress(boolean);
	*** setSoTimeout(int);
	*** toString();
}

-keep class java.net.Socket {
	*** bound;
	*** closeLock;
	*** closed;
	*** connected;
	*** created;
	*** factory;
	*** impl;
	*** oldImpl;
	*** shutIn;
	*** shutOut;
	java.net.Socket();
	java.net.Socket(java.lang.String,int);
	java.net.Socket(java.lang.String,int,java.net.InetAddress,int);
	java.net.Socket(java.net.InetAddress,int);
	java.net.Socket(java.net.InetAddress,int,java.net.InetAddress,int);
	java.net.Socket(java.net.SocketAddress,java.net.SocketAddress,boolean);
	java.net.Socket(java.net.SocketImpl);
	*** bind(java.net.SocketAddress);
	*** checkAddress(java.net.InetAddress,java.lang.String);
	*** checkOldImpl();
	*** close();
	*** connect(java.net.SocketAddress);
	*** connect(java.net.SocketAddress,int);
	*** createImpl(boolean);
	*** getChannel();
	*** getImpl();
	*** getInetAddress();
	*** getInputStream();
	*** getKeepAlive();
	*** getLocalAddress();
	*** getLocalPort();
	*** getLocalSocketAddress();
	*** getOutputStream();
	*** getPort();
	*** getReceiveBufferSize();
	*** getRemoteSocketAddress();
	*** getReuseAddress();
	*** getSendBufferSize();
	*** getSoLinger();
	*** getSoTimeout();
	*** getTcpNoDelay();
	*** getTrafficClass();
	*** isBound();
	*** isClosed();
	*** isConnected();
	*** isInputShutdown();
	*** isOutputShutdown();
	*** postAccept();
	*** setBound();
	*** setConnected();
	*** setCreated();
	*** setImpl();
	*** setKeepAlive(boolean);
	*** setPerformancePreferences(int,int,int);
	*** setReceiveBufferSize(int);
	*** setReuseAddress(boolean);
	*** setSendBufferSize(int);
	*** setSoLinger(boolean,int);
	*** setSoTimeout(int);
	*** setTcpNoDelay(boolean);
	*** setTrafficClass(int);
	*** shutdownInput();
	*** shutdownOutput();
	*** toString();
}

-keep class java.net.Socket$2 {
	*** this$0;
	*** run();
}

-keep class java.net.Socket$3 {
	*** this$0;
	*** run();
}

-keep class java.net.SocketAddress {
	java.net.SocketAddress();
}

-keep class java.net.SocketException {
	java.net.SocketException();
	java.net.SocketException(java.lang.String);
}

-keep class java.net.SocketImpl {
	*** address;
	*** fd;
	*** localport;
	*** port;
	*** serverSocket;
	*** socket;
	java.net.SocketImpl();
	*** accept(java.net.SocketImpl);
	*** bind(java.net.InetAddress,int);
	*** close();
	*** connect(java.lang.String,int);
	*** connect(java.net.InetAddress,int);
	*** connect(java.net.SocketAddress,int);
	*** create(boolean);
	*** getFileDescriptor();
	*** getInetAddress();
	*** getInputStream();
	*** getLocalPort();
	*** getOutputStream();
	*** getPort();
	*** getSocket();
	*** listen(int);
	*** reset();
	*** sendUrgentData(int);
	*** setServerSocket(java.net.ServerSocket);
	*** setSocket(java.net.Socket);
	*** shutdownInput();
	*** shutdownOutput();
	*** supportsUrgentData();
}

-keep class java.net.SocketImplFactory {
	*** createSocketImpl();
}

-keep class java.net.SocketInputStream {
	*** closing;
	*** eof;
	*** impl;
	*** socket;
	*** temp;
	*** init();
	*** read(byte[],int,int);
	*** read(byte[],int,int,int);
	*** setEOF(boolean);
	*** socketRead0(java.io.FileDescriptor,byte[],int,int,int);
}

-keep class java.net.SocketOption {
	*** type();
}

-keep class java.net.SocketOptions {
	*** getOption(int);
	*** setOption(int,java.lang.Object);
}

-keep class java.net.SocketOutputStream {
	*** closing;
	*** impl;
	*** socket;
	*** temp;
	*** init();
	*** socketWrite(byte[],int,int);
	*** socketWrite0(java.io.FileDescriptor,byte[],int,int);
}

-keep class java.net.SocketPermission {
	*** actions;
	*** addresses;
	*** cdomain;
	*** cname;
	*** debug;
	*** debugInit;
	*** defaultDeny;
	*** hdomain;
	*** hostname;
	*** init_with_ip;
	*** invalid;
	*** mask;
	*** portrange;
	*** trustNameService;
	*** trusted;
	*** untrusted;
	*** wildcard;
	*** authorized(java.lang.String,byte[]);
	*** authorizedIPv4(java.lang.String,byte[]);
	*** authorizedIPv6(java.lang.String,byte[]);
	*** compareHostnames(java.net.SocketPermission);
	*** getActions();
	*** getActions(int);
	*** getCanonName();
	*** getDebug();
	*** getHost(java.lang.String);
	*** getIP();
	*** getMask(java.lang.String);
	*** impliesIgnoreMask(java.net.SocketPermission);
	*** init(java.lang.String,int);
	*** isUntrusted();
	*** match(java.lang.String,java.lang.String);
	*** parsePort(java.lang.String);
}

-keep class java.net.SocksSocketImpl {
	*** $assertionsDisabled;
	*** applicationSetProxy;
	*** cmdIn;
	*** cmdOut;
	*** cmdsock;
	*** external_address;
	*** server;
	*** serverPort;
	*** useV4;
	*** authenticate(byte,java.io.InputStream,java.io.BufferedOutputStream);
	*** authenticate(byte,java.io.InputStream,java.io.BufferedOutputStream,long);
	*** bindV4(java.io.InputStream,java.io.OutputStream,java.net.InetAddress,int);
	*** connectV4(java.io.InputStream,java.io.OutputStream,java.net.InetSocketAddress,long);
	*** getUserName();
	*** privilegedConnect(java.lang.String,int,int);
	*** readSocksReply(java.io.InputStream,byte[]);
	*** readSocksReply(java.io.InputStream,byte[],long);
	*** remainingMillis(long);
	*** socksBind(java.net.InetSocketAddress);
	*** superConnectServer(java.lang.String,int,int);
}

-keep class java.net.SocksSocketImpl$3 {
	*** this$0;
	*** run();
}

-keep class java.net.StandardProtocolFamily {
	*** $VALUES;
	*** INET;
	*** INET6;
}

-keep class java.net.StandardSocketOptions {
	*** IP_MULTICAST_IF;
	*** IP_MULTICAST_LOOP;
	*** IP_MULTICAST_TTL;
	*** IP_TOS;
	*** SO_BROADCAST;
	*** SO_KEEPALIVE;
	*** SO_LINGER;
	*** SO_RCVBUF;
	*** SO_REUSEADDR;
	*** SO_SNDBUF;
	*** TCP_NODELAY;
}

-keep class java.net.StandardSocketOptions$StdSocketOption {
	*** name;
	*** type;
}

-keep class java.net.URI {
	*** $assertionsDisabled;
	*** H_ALPHA;
	*** H_ALPHANUM;
	*** H_DASH;
	*** H_DOT;
	*** H_HEX;
	*** H_LEFT_BRACKET;
	*** H_LOWALPHA;
	*** H_MARK;
	*** H_PATH;
	*** H_PCHAR;
	*** H_REG_NAME;
	*** H_RESERVED;
	*** H_SCHEME;
	*** H_SERVER;
	*** H_SERVER_PERCENT;
	*** H_UNRESERVED;
	*** H_UPALPHA;
	*** H_URIC;
	*** H_URIC_NO_SLASH;
	*** H_USERINFO;
	*** L_ALPHANUM;
	*** L_DASH;
	*** L_DIGIT;
	*** L_DOT;
	*** L_HEX;
	*** L_LEFT_BRACKET;
	*** L_MARK;
	*** L_PATH;
	*** L_PCHAR;
	*** L_REG_NAME;
	*** L_RESERVED;
	*** L_SCHEME;
	*** L_SERVER;
	*** L_SERVER_PERCENT;
	*** L_UNRESERVED;
	*** L_URIC;
	*** L_URIC_NO_SLASH;
	*** L_USERINFO;
	*** authority;
	*** decodedAuthority;
	*** decodedFragment;
	*** decodedPath;
	*** decodedQuery;
	*** decodedSchemeSpecificPart;
	*** decodedUserInfo;
	*** fragment;
	*** hash;
	*** hexDigits;
	*** host;
	*** path;
	*** port;
	*** query;
	*** scheme;
	*** schemeSpecificPart;
	*** string;
	*** userInfo;
	java.net.URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String);
	*** access$002(java.net.URI,java.lang.String);
	*** access$100();
	*** access$1002(java.net.URI,java.lang.String);
	*** access$1102(java.net.URI,java.lang.String);
	*** access$1200();
	*** access$1300();
	*** access$1402(java.net.URI,java.lang.String);
	*** access$1502(java.net.URI,java.lang.String);
	*** access$1600();
	*** access$1700();
	*** access$1800();
	*** access$1900();
	*** access$200();
	*** access$2000();
	*** access$2100();
	*** access$2202(java.net.URI,java.lang.String);
	*** access$2302(java.net.URI,java.lang.String);
	*** access$2402(java.net.URI,java.lang.String);
	*** access$2502(java.net.URI,int);
	*** access$2600();
	*** access$2700();
	*** access$2800();
	*** access$2900();
	*** access$300(char,long,long);
	*** access$3000();
	*** access$3100();
	*** access$3200();
	*** access$3300();
	*** access$3400();
	*** access$400();
	*** access$500();
	*** access$600();
	*** access$702(java.net.URI,java.lang.String);
	*** access$800();
	*** access$900();
	*** appendAuthority(java.lang.StringBuffer,java.lang.String,java.lang.String,java.lang.String,int);
	*** appendEncoded(java.lang.StringBuffer,char);
	*** appendEscape(java.lang.StringBuffer,byte);
	*** appendFragment(java.lang.StringBuffer,java.lang.String);
	*** appendSchemeSpecificPart(java.lang.StringBuffer,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String);
	*** checkPath(java.lang.String,java.lang.String,java.lang.String);
	*** compare(java.lang.String,java.lang.String);
	*** compareIgnoringCase(java.lang.String,java.lang.String);
	*** compareTo(java.net.URI);
	*** create(java.lang.String);
	*** decode(char);
	*** decode(char,char);
	*** decode(java.lang.String);
	*** defineSchemeSpecificPart();
	*** defineString();
	*** encode(java.lang.String);
	*** equal(java.lang.String,java.lang.String);
	*** equalIgnoringCase(java.lang.String,java.lang.String);
	*** equals(java.lang.Object);
	*** getAuthority();
	*** getFragment();
	*** getHost();
	*** getPath();
	*** getPort();
	*** getQuery();
	*** getRawAuthority();
	*** getRawFragment();
	*** getRawPath();
	*** getRawQuery();
	*** getRawSchemeSpecificPart();
	*** getRawUserInfo();
	*** getScheme();
	*** getSchemeSpecificPart();
	*** getUserInfo();
	*** hash(int,java.lang.String);
	*** hashCode();
	*** hashIgnoringCase(int,java.lang.String);
	*** highMask(char,char);
	*** highMask(java.lang.String);
	*** isAbsolute();
	*** isOpaque();
	*** join(char[],int[]);
	*** lowMask(char,char);
	*** lowMask(java.lang.String);
	*** match(char,long,long);
	*** maybeAddLeadingDot(char[],int[]);
	*** needsNormalization(java.lang.String);
	*** normalize();
	*** normalize(java.lang.String);
	*** normalize(java.net.URI);
	*** quote(java.lang.String,long,long);
	*** relativize(java.net.URI,java.net.URI);
	*** removeDots(char[],int[]);
	*** resolve(java.net.URI);
	*** resolve(java.net.URI,java.net.URI);
	*** resolvePath(java.lang.String,java.lang.String,boolean);
	*** split(char[],int[]);
	*** toASCIIString();
	*** toLower(char);
	*** toString();
	*** toString(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String);
	*** toURL();
}

-keep class java.net.URI$Parser {
	*** input;
	*** ipv6byteCount;
	*** requireServerAuthority;
	*** this$0;
	*** at(int,int,char);
	*** at(int,int,java.lang.String);
	*** charAt(int);
	*** checkChar(int,long,long,java.lang.String);
	*** checkChars(int,int,long,long,java.lang.String);
	*** fail(java.lang.String);
	*** fail(java.lang.String,int);
	*** failExpecting(java.lang.String,int);
	*** parse(boolean);
	*** parseAuthority(int,int);
	*** parseHierarchical(int,int);
	*** parseHostname(int,int);
	*** parseIPv4Address(int,int);
	*** parseIPv6Reference(int,int);
	*** parseServer(int,int);
	*** scan(int,int,char);
	*** scan(int,int,java.lang.String,java.lang.String);
	*** scan(int,int,long,long);
	*** scanByte(int,int);
	*** scanEscape(int,int,char);
	*** scanHexPost(int,int);
	*** scanHexSeq(int,int);
	*** scanIPv4Address(int,int,boolean);
	*** substring(int,int);
	*** takeIPv4Address(int,int,java.lang.String);
}

-keep class java.net.URISyntaxException {
	*** index;
	*** input;
	java.net.URISyntaxException(java.lang.String,java.lang.String,int);
	*** getMessage();
	*** getReason();
}

-keep class java.net.URL {
	*** equals(java.lang.Object);
	*** getFile();
	*** getHost();
	*** getPath();
	*** getPort();
	*** getProtocol();
	*** getQuery();
	*** getRef();
	*** getUserInfo();
	*** openConnection();
	*** openConnection(java.net.Proxy);
	*** openStream();
	*** sameFile(java.net.URL);
	*** toExternalForm();
	*** toString();
	*** toURI();
}

-keep class java.net.URL$1 {
	*;
}

-keep class java.net.URLClassLoader {
	*** access$000(java.net.URLClassLoader);
	*** access$100(java.net.URLClassLoader,java.lang.String,sun.misc.Resource);
	*** access$200(java.net.URLClassLoader);
	*** getURLs();
}

-keep class java.net.URLClassLoader$1 {
	*** this$0;
	*** val$name;
	*** run();
}

-keep class java.net.URLClassLoader$3 {
	*** this$0;
	*** url;
	*** val$e;
	*** next();
	*** nextElement();
}

-keep class java.net.URLClassLoader$3$1 {
	*** this$1;
	*** run();
}

-keep class java.net.URLClassLoader$7 {
	*;
}

-keep class java.net.URLConnection {
	*** connected;
	*** url;
	java.net.URLConnection(java.net.URL);
	*** access$000();
	*** getContent();
	*** getContentEncoding();
	*** getContentLength();
	*** getContentType();
	*** getHeaderField(java.lang.String);
	*** getInputStream();
	*** getLastModified();
	*** getOutputStream();
	*** getPermission();
	*** getURL();
	*** setConnectTimeout(int);
	*** setDoInput(boolean);
	*** setDoOutput(boolean);
	*** setFileNameMap(java.net.FileNameMap);
	*** setReadTimeout(int);
	*** setRequestProperty(java.lang.String,java.lang.String);
	*** setUseCaches(boolean);
}

-keep class java.net.URLConnection$1 {
	*** map;
}

-keep class java.net.URLDecoder {
	*** dfltEncName;
	*** decode(java.lang.String,java.lang.String);
}

-keep class java.net.URLEncoder {
	*** dfltEncName;
	*** dontNeedEncoding;
	*** encode(java.lang.String,java.lang.String);
}

-keep class java.net.URLStreamHandler {
	java.net.URLStreamHandler();
}

-keep class java.net.URLStreamHandlerFactory {
	*;
}

-keep class java.nio.Bits {
	*** copyFromArray(java.lang.Object,long,long,long,long);
	*** copyFromIntArray(java.lang.Object,long,long,long);
	*** copyToArray(long,java.lang.Object,long,long,long);
	*** copyToIntArray(long,java.lang.Object,long,long);
	*** unaligned();
	*** unreserveMemory(long,int);
	*** unsafe();
}

-keep class java.nio.Bits$1 {
	*;
}

-keep class java.nio.Buffer {
	*** address;
	java.nio.Buffer(int,int,int,int);
	*** capacity();
	*** checkBounds(int,int,int);
	*** checkIndex(int);
	*** checkIndex(int,int);
	*** clear();
	*** discardMark();
	*** flip();
	*** hasRemaining();
	*** isReadOnly();
	*** limit();
	*** limit(int);
	*** mark();
	*** markValue();
	*** nextGetIndex();
	*** nextPutIndex();
	*** position();
	*** position(int);
	*** remaining();
	*** reset();
	*** rewind();
}

-keep class java.nio.ByteBuffer {
	*** bigEndian;
	*** hb;
	*** isReadOnly;
	*** nativeByteOrder;
	*** offset;
	*** allocate(int);
	*** allocateDirect(int);
	*** array();
	*** arrayOffset();
	*** asCharBuffer();
	*** asDoubleBuffer();
	*** asFloatBuffer();
	*** asIntBuffer();
	*** asLongBuffer();
	*** asReadOnlyBuffer();
	*** asShortBuffer();
	*** compact();
	*** duplicate();
	*** get();
	*** get(byte[]);
	*** get(byte[],int,int);
	*** get(int);
	*** getChar();
	*** getChar(int);
	*** getDouble();
	*** getDouble(int);
	*** getFloat();
	*** getFloat(int);
	*** getInt();
	*** getInt(int);
	*** getLong();
	*** getLong(int);
	*** getShort();
	*** getShort(int);
	*** hasArray();
	*** isDirect();
	*** order();
	*** order(java.nio.ByteOrder);
	*** put(byte);
	*** put(byte[]);
	*** put(byte[],int,int);
	*** put(int,byte);
	*** put(java.nio.ByteBuffer);
	*** putChar(char);
	*** putChar(int,char);
	*** putDouble(double);
	*** putDouble(int,double);
	*** putFloat(float);
	*** putFloat(int,float);
	*** putInt(int);
	*** putInt(int,int);
	*** putLong(int,long);
	*** putLong(long);
	*** putShort(int,short);
	*** putShort(short);
	*** slice();
	*** wrap(byte[]);
	*** wrap(byte[],int,int);
}

-keep class java.nio.ByteOrder {
	*** BIG_ENDIAN;
	*** LITTLE_ENDIAN;
	*** nativeOrder();
}

-keep class java.nio.CharBuffer {
	*** offset;
	java.nio.CharBuffer(int,int,int,int);
	java.nio.CharBuffer(int,int,int,int,char[],int);
	*** allocate(int);
	*** array();
	*** arrayOffset();
	*** compact();
	*** get();
	*** hasArray();
	*** put(char);
	*** put(java.nio.CharBuffer);
	*** slice();
	*** subSequence(int,int);
	*** toString();
	*** wrap(char[]);
	*** wrap(char[],int,int);
	*** wrap(java.lang.CharSequence);
	*** wrap(java.lang.CharSequence,int,int);
}

-keep class java.nio.DirectByteBuffer {
	*** unaligned;
	*** unsafe;
	java.nio.DirectByteBuffer(int);
	java.nio.DirectByteBuffer(int,long,java.io.FileDescriptor,java.lang.Runnable);
	java.nio.DirectByteBuffer(sun.nio.ch.DirectBuffer,int,int,int,int,int);
}

-keep class java.nio.DirectByteBuffer$Deallocator {
	*** $assertionsDisabled;
	*** address;
	*** capacity;
	*** size;
	*** unsafe;
	java.nio.DirectByteBuffer$Deallocator(long,long,int);
}

-keep class java.nio.DirectByteBufferR {
	*** $assertionsDisabled;
	*** duplicate();
}

-keep class java.nio.DirectIntBufferU {
	*** $assertionsDisabled;
	*** arrayBaseOffset;
	*** att;
	*** unaligned;
	*** unsafe;
	*** ix(int);
	*** order();
	*** put(int[],int,int);
}

-keep class java.nio.DoubleBuffer {
	*** hb;
	*** isReadOnly;
	*** offset;
	java.nio.DoubleBuffer(int,int,int,int,double[],int);
	*** array();
	*** compare(double,double);
	*** compareTo(java.nio.DoubleBuffer);
	*** equals(double,double);
	*** get();
	*** get(double[],int,int);
	*** get(int);
	*** put(double);
	*** put(double[],int,int);
	*** wrap(double[],int,int);
}

-keep class java.nio.FloatBuffer {
	*** hb;
	*** isReadOnly;
	*** offset;
	java.nio.FloatBuffer(int,int,int,int,float[],int);
	*** array();
	*** compare(float,float);
	*** compareTo(java.nio.FloatBuffer);
	*** equals(float,float);
	*** get();
	*** get(float[],int,int);
	*** get(int);
	*** put(float);
	*** put(float[],int,int);
	*** wrap(float[],int,int);
}

-keep class java.nio.HeapByteBuffer {
	java.nio.HeapByteBuffer(byte[],int,int);
	java.nio.HeapByteBuffer(byte[],int,int,int,int,int);
	java.nio.HeapByteBuffer(int,int);
}

-keep class java.nio.HeapByteBufferR {
	*** duplicate();
}

-keep class java.nio.HeapCharBuffer {
	*;
}

-keep class java.nio.HeapIntBuffer {
	*** ix(int);
}

-keep class java.nio.IntBuffer {
	*** hb;
	*** isReadOnly;
	*** offset;
	java.nio.IntBuffer(int,int,int,int);
	java.nio.IntBuffer(int,int,int,int,int[],int);
	*** allocate(int);
	*** array();
	*** compare(int,int);
	*** compareTo(java.nio.IntBuffer);
	*** equals(int,int);
	*** get();
	*** get(int);
	*** get(int[],int,int);
	*** isDirect();
	*** put(int);
	*** put(int[],int,int);
	*** put(java.nio.IntBuffer);
	*** wrap(int[],int,int);
}

-keep class java.nio.ShortBuffer {
	*** hb;
	*** isReadOnly;
	*** offset;
	java.nio.ShortBuffer(int,int,int,int,short[],int);
	*** array();
	*** compare(short,short);
	*** compareTo(java.nio.ShortBuffer);
	*** equals(short,short);
	*** get();
	*** get(int);
	*** get(short[],int,int);
	*** put(short);
	*** put(short[],int,int);
	*** wrap(short[],int,int);
}

-keep class java.nio.StringCharBuffer {
	*** str;
	*** duplicate();
	*** subSequence(int,int);
}

-keep class java.nio.channels.Channel {
	*** close();
	*** isOpen();
}

-keep class java.nio.channels.Channels {
	*** newChannel(java.io.InputStream);
	*** newChannel(java.io.OutputStream);
	*** newInputStream(java.nio.channels.ReadableByteChannel);
	*** newOutputStream(java.nio.channels.WritableByteChannel);
}

-keep class java.nio.channels.ClosedChannelException {
	java.nio.channels.ClosedChannelException();
}

-keep class java.nio.channels.DatagramChannel {
	java.nio.channels.DatagramChannel(java.nio.channels.spi.SelectorProvider);
	*** bind(java.net.SocketAddress);
	*** connect(java.net.SocketAddress);
	*** disconnect();
	*** isConnected();
	*** open();
	*** read(java.nio.ByteBuffer);
	*** read(java.nio.ByteBuffer[],int,int);
	*** setOption(java.net.SocketOption,java.lang.Object);
	*** socket();
	*** write(java.nio.ByteBuffer);
	*** write(java.nio.ByteBuffer[],int,int);
}

-keep class java.nio.channels.FileChannel {
	*** NO_ATTRIBUTES;
	java.nio.channels.FileChannel();
	*** lock(long,long,boolean);
	*** map(java.nio.channels.FileChannel$MapMode,long,long);
	*** open(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute[]);
	*** position(long);
	*** read(java.nio.ByteBuffer[],int,int);
	*** size();
	*** transferFrom(java.nio.channels.ReadableByteChannel,long,long);
	*** truncate(long);
	*** tryLock(long,long,boolean);
	*** write(java.nio.ByteBuffer[],int,int);
}

-keep class java.nio.channels.FileChannel$MapMode {
	*** PRIVATE;
	*** READ_ONLY;
	*** READ_WRITE;
	*** name;
}

-keep class java.nio.channels.FileLock {
	*** isValid();
	*** position();
	*** size();
}

-keep class java.nio.channels.GatheringByteChannel {
	*** write(java.nio.ByteBuffer[]);
}

-keep class java.nio.channels.ReadableByteChannel {
	*** read(java.nio.ByteBuffer);
}

-keep class java.nio.channels.SelectableChannel {
	java.nio.channels.SelectableChannel();
	*** configureBlocking(boolean);
	*** isBlocking();
	*** isRegistered();
	*** keyFor(java.nio.channels.Selector);
	*** provider();
	*** register(java.nio.channels.Selector,int);
	*** register(java.nio.channels.Selector,int,java.lang.Object);
	*** validOps();
}

-keep class java.nio.channels.SelectionKey {
	*** attachment;
	*** attachmentUpdater;
	java.nio.channels.SelectionKey();
	*** attach(java.lang.Object);
	*** attachment();
	*** cancel();
	*** channel();
	*** interestOps();
	*** interestOps(int);
	*** isAcceptable();
	*** isConnectable();
	*** isReadable();
	*** isValid();
	*** isWritable();
	*** readyOps();
	*** selector();
}

-keep class java.nio.channels.Selector {
	java.nio.channels.Selector();
	*** close();
	*** isOpen();
	*** keys();
	*** open();
	*** provider();
	*** select();
	*** select(long);
	*** selectNow();
	*** selectedKeys();
	*** wakeup();
}

-keep class java.nio.channels.ServerSocketChannel {
	java.nio.channels.ServerSocketChannel(java.nio.channels.spi.SelectorProvider);
	*** accept();
	*** bind(java.net.SocketAddress);
	*** bind(java.net.SocketAddress,int);
	*** open();
	*** setOption(java.net.SocketOption,java.lang.Object);
	*** socket();
}

-keep class java.nio.channels.SocketChannel {
	*** $assertionsDisabled;
	java.nio.channels.SocketChannel(java.nio.channels.spi.SelectorProvider);
	*** bind(java.net.SocketAddress);
	*** connect(java.net.SocketAddress);
	*** finishConnect();
	*** isConnected();
	*** open();
	*** read(java.nio.ByteBuffer[],int,int);
	*** setOption(java.net.SocketOption,java.lang.Object);
	*** socket();
	*** write(java.nio.ByteBuffer[],int,int);
}

-keep class java.nio.channels.WritableByteChannel {
	*** write(java.nio.ByteBuffer);
}

-keep class java.nio.channels.spi.AbstractInterruptibleChannel {
	*** closeLock;
	*** interrupted;
	*** interruptor;
	*** open;
	java.nio.channels.spi.AbstractInterruptibleChannel();
	*** access$000(java.nio.channels.spi.AbstractInterruptibleChannel);
	*** access$100(java.nio.channels.spi.AbstractInterruptibleChannel);
	*** access$102(java.nio.channels.spi.AbstractInterruptibleChannel,boolean);
	*** access$202(java.nio.channels.spi.AbstractInterruptibleChannel,java.lang.Thread);
	*** begin();
	*** blockedOn(sun.nio.ch.Interruptible);
	*** close();
	*** end(boolean);
	*** implCloseChannel();
	*** isOpen();
}

-keep class java.nio.channels.spi.AbstractInterruptibleChannel$1 {
	*** this$0;
}

-keep class java.nio.channels.spi.AbstractSelectableChannel {
	*** $assertionsDisabled;
	*** blocking;
	*** keyCount;
	*** keyLock;
	*** keys;
	*** provider;
	*** regLock;
	java.nio.channels.spi.AbstractSelectableChannel(java.nio.channels.spi.SelectorProvider);
	*** addKey(java.nio.channels.SelectionKey);
	*** blockingLock();
	*** configureBlocking(boolean);
	*** findKey(java.nio.channels.Selector);
	*** haveValidKeys();
	*** implCloseSelectableChannel();
	*** implConfigureBlocking(boolean);
	*** isBlocking();
	*** isRegistered();
	*** provider();
	*** register(java.nio.channels.Selector,int,java.lang.Object);
	*** removeKey(java.nio.channels.SelectionKey);
}

-keep class java.nio.channels.spi.AbstractSelectionKey {
	*** valid;
	java.nio.channels.spi.AbstractSelectionKey();
	*** invalidate();
	*** isValid();
}

-keep class java.nio.channels.spi.AbstractSelector {
	*** cancelledKeys;
	*** interruptor;
	*** provider;
	*** selectorOpen;
	java.nio.channels.spi.AbstractSelector(java.nio.channels.spi.SelectorProvider);
	*** begin();
	*** cancel(java.nio.channels.SelectionKey);
	*** cancelledKeys();
	*** deregister(java.nio.channels.spi.AbstractSelectionKey);
	*** end();
	*** implCloseSelector();
	*** isOpen();
	*** register(java.nio.channels.spi.AbstractSelectableChannel,int,java.lang.Object);
}

-keep class java.nio.channels.spi.AbstractSelector$1 {
	*** this$0;
}

-keep class java.nio.channels.spi.SelectorProvider {
	*** lock;
	*** provider;
	java.nio.channels.spi.SelectorProvider();
	*** access$000();
	*** access$100();
	*** access$102(java.nio.channels.spi.SelectorProvider);
	*** access$200();
	*** loadProviderAsService();
	*** loadProviderFromProperty();
	*** openDatagramChannel();
	*** openDatagramChannel(java.net.ProtocolFamily);
	*** openSelector();
	*** openServerSocketChannel();
	*** openSocketChannel();
	*** provider();
}

-keep class java.nio.channels.spi.SelectorProvider$1 {
	*** run();
}

-keep class java.nio.charset.Charset {
	*** decode(java.nio.ByteBuffer);
	*** defaultCharset();
	*** encode(java.lang.String);
	*** equals(java.lang.Object);
	*** forName(java.lang.String);
	*** isSupported(java.lang.String);
	*** name();
	*** newDecoder();
	*** newEncoder();
}

-keep class java.nio.charset.CharsetDecoder {
	java.nio.charset.CharsetDecoder(java.nio.charset.Charset,float,float);
	*** averageCharsPerByte();
	*** charset();
	*** decode(java.nio.ByteBuffer,java.nio.CharBuffer,boolean);
	*** flush(java.nio.CharBuffer);
	*** onMalformedInput(java.nio.charset.CodingErrorAction);
	*** onUnmappableCharacter(java.nio.charset.CodingErrorAction);
	*** reset();
}

-keep class java.nio.charset.CharsetEncoder {
	java.nio.charset.CharsetEncoder(java.nio.charset.Charset,float,float);
	*** averageBytesPerChar();
	*** charset();
	*** encode(java.nio.CharBuffer);
	*** encode(java.nio.CharBuffer,java.nio.ByteBuffer,boolean);
	*** flush(java.nio.ByteBuffer);
	*** isLegalReplacement(byte[]);
	*** maxBytesPerChar();
	*** onMalformedInput(java.nio.charset.CodingErrorAction);
	*** onUnmappableCharacter(java.nio.charset.CodingErrorAction);
	*** reset();
}

-keep class java.nio.charset.CoderResult {
	*** OVERFLOW;
	*** UNDERFLOW;
	*** isError();
	*** isOverflow();
	*** isUnderflow();
	*** malformedForLength(int);
	*** throwException();
	*** unmappableForLength(int);
}

-keep class java.nio.charset.CoderResult$1 {
	*;
}

-keep class java.nio.charset.CoderResult$2 {
	*;
}

-keep class java.nio.charset.CoderResult$Cache {
	*;
}

-keep class java.nio.charset.CodingErrorAction {
	*** REPLACE;
	*** REPORT;
}

-keep class java.nio.charset.StandardCharsets {
	*** UTF_8;
}

-keep class java.nio.charset.UnsupportedCharsetException {
	*** charsetName;
}

-keep class java.nio.charset.spi.CharsetProvider {
	*;
}

-keep class java.nio.file.DirectoryStream {
	*** iterator();
}

-keep class java.nio.file.FileSystem {
	java.nio.file.FileSystem();
	*** getPath(java.lang.String,java.lang.String[]);
	*** provider();
}

-keep class java.nio.file.FileSystems {
	*** getDefault();
	*** newFileSystem(java.net.URI,java.util.Map,java.lang.ClassLoader);
}

-keep class java.nio.file.FileSystems$DefaultFileSystemHolder {
	*** defaultFileSystem;
	*** access$000();
	*** defaultFileSystem();
	*** getDefaultProvider();
}

-keep class java.nio.file.FileSystems$DefaultFileSystemHolder$1 {
	*** run();
}

-keep class java.nio.file.Files {
	*** createTempFile(java.lang.String,java.lang.String,java.nio.file.attribute.FileAttribute[]);
	*** newByteChannel(java.nio.file.Path,java.nio.file.OpenOption[]);
	*** newDirectoryStream(java.nio.file.Path,java.lang.String);
}

-keep class java.nio.file.LinkOption {
	*** $VALUES;
	*** NOFOLLOW_LINKS;
}

-keep class java.nio.file.Path {
	*** endsWith(java.nio.file.Path);
	*** getFileSystem();
	*** getParent();
	*** normalize();
	*** register(java.nio.file.WatchService,java.nio.file.WatchEvent$Kind[],java.nio.file.WatchEvent$Modifier[]);
	*** resolve(java.nio.file.Path);
	*** startsWith(java.nio.file.Path);
	*** toFile();
	*** toRealPath(java.nio.file.LinkOption[]);
	*** toString();
}

-keep class java.nio.file.StandardOpenOption {
	*** CREATE;
	*** READ;
	*** TRUNCATE_EXISTING;
	*** WRITE;
}

-keep class java.nio.file.attribute.BasicFileAttributeView {
	*** readAttributes();
}

-keep class java.nio.file.attribute.FileTime {
	*** from(long,java.util.concurrent.TimeUnit);
}

-keep class java.nio.file.attribute.PosixFilePermission {
	*** GROUP_EXECUTE;
	*** GROUP_READ;
	*** GROUP_WRITE;
	*** OTHERS_EXECUTE;
	*** OTHERS_READ;
	*** OTHERS_WRITE;
	*** OWNER_EXECUTE;
	*** OWNER_READ;
	*** OWNER_WRITE;
}

-keep class java.nio.file.spi.FileSystemProvider {
	*** installedProviders;
	*** loadingProviders;
	*** lock;
	java.nio.file.spi.FileSystemProvider();
	java.nio.file.spi.FileSystemProvider(java.lang.Void);
	*** checkPermission();
	*** delete(java.nio.file.Path);
	*** getFileSystem(java.net.URI);
	*** getScheme();
	*** installedProviders();
	*** loadInstalledProviders();
	*** newByteChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute[]);
	*** newFileChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute[]);
	*** newFileSystem(java.net.URI,java.util.Map);
	*** newFileSystem(java.nio.file.Path,java.util.Map);
}

-keep class java.security.AccessControlContext {
	*;
}

-keep class java.security.AccessController {
	*** checkPermission(java.security.Permission);
	*** doPrivileged(java.security.PrivilegedAction);
	*** doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext);
	*** doPrivileged(java.security.PrivilegedExceptionAction);
	*** doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext);
	*** getContext();
}

-keep class java.security.AlgorithmConstraints {
	*** permits(java.util.Set,java.lang.String,java.security.AlgorithmParameters);
	*** permits(java.util.Set,java.lang.String,java.security.Key,java.security.AlgorithmParameters);
	*** permits(java.util.Set,java.security.Key);
}

-keep class java.security.AlgorithmParameters {
	*** algorithm;
	*** initialized;
	*** paramSpi;
	*** provider;
	*** getAlgorithm();
	*** getEncoded();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getParameterSpec(java.lang.Class);
	*** init(byte[]);
	*** init(java.security.spec.AlgorithmParameterSpec);
	*** toString();
}

-keep class java.security.AlgorithmParametersSpi {
	java.security.AlgorithmParametersSpi();
	*** engineGetEncoded();
	*** engineGetEncoded(java.lang.String);
	*** engineGetParameterSpec(java.lang.Class);
	*** engineInit(byte[]);
	*** engineInit(byte[],java.lang.String);
	*** engineInit(java.security.spec.AlgorithmParameterSpec);
	*** engineToString();
}

-keep class java.security.AllPermission {
	java.security.AllPermission();
}

-keep class java.security.AllPermissionCollection {
	*** all_allowed;
}

-keep class java.security.BasicPermission {
	java.security.BasicPermission(java.lang.String);
	java.security.BasicPermission(java.lang.String,java.lang.String);
	*** getCanonicalName();
	*** implies(java.security.Permission);
}

-keep class java.security.BasicPermissionCollection {
	*** all_allowed;
	*** permClass;
	*** perms;
	*** serialPersistentFields;
}

-keep class java.security.CodeSigner {
	*** myhash;
	*** signerCertPath;
	*** timestamp;
	*** equals(java.lang.Object);
	*** getSignerCertPath();
	*** getTimestamp();
}

-keep class java.security.CodeSource {
	*** getCertificates();
	*** getLocation();
}

-keep class java.security.CryptoPrimitive {
	*** $VALUES;
	*** BLOCK_CIPHER;
	*** KEY_AGREEMENT;
	*** KEY_ENCAPSULATION;
	*** KEY_WRAP;
	*** MAC;
	*** MESSAGE_DIGEST;
	*** PUBLIC_KEY_ENCRYPTION;
	*** SECURE_RANDOM;
	*** SIGNATURE;
	*** STREAM_CIPHER;
}

-keep class java.security.DigestInputStream {
	*** digest;
	*** on;
	*** setMessageDigest(java.security.MessageDigest);
}

-keep class java.security.GeneralSecurityException {
	java.security.GeneralSecurityException();
	java.security.GeneralSecurityException(java.lang.String);
	java.security.GeneralSecurityException(java.lang.String,java.lang.Throwable);
	java.security.GeneralSecurityException(java.lang.Throwable);
}

-keep class java.security.Guard {
	*;
}

-keep class java.security.Key {
	*** getAlgorithm();
	*** getEncoded();
	*** getFormat();
}

-keep class java.security.KeyException {
	java.security.KeyException();
	java.security.KeyException(java.lang.String);
	java.security.KeyException(java.lang.String,java.lang.Throwable);
	java.security.KeyException(java.lang.Throwable);
}

-keep class java.security.KeyFactory {
	*** algorithm;
	*** debug;
	*** lock;
	*** provider;
	*** serviceIterator;
	*** spi;
	*** generatePrivate(java.security.spec.KeySpec);
	*** generatePublic(java.security.spec.KeySpec);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getKeySpec(java.security.Key,java.lang.Class);
	*** nextSpi(java.security.KeyFactorySpi);
	*** translateKey(java.security.Key);
}

-keep class java.security.KeyFactorySpi {
	java.security.KeyFactorySpi();
	*** engineGeneratePrivate(java.security.spec.KeySpec);
	*** engineGeneratePublic(java.security.spec.KeySpec);
	*** engineGetKeySpec(java.security.Key,java.lang.Class);
	*** engineTranslateKey(java.security.Key);
}

-keep class java.security.KeyPair {
	*** privateKey;
	*** publicKey;
	*** getPrivate();
	*** getPublic();
}

-keep class java.security.KeyPairGenerator {
	*** algorithm;
	*** provider;
	java.security.KeyPairGenerator(java.lang.String);
	*** disableFailover();
	*** genKeyPair();
	*** generateKeyPair();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getInstance(sun.security.jca.GetInstance$Instance,java.lang.String);
	*** initialize(int,java.security.SecureRandom);
	*** initialize(java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
}

-keep class java.security.KeyPairGenerator$Delegate {
	*** initKeySize;
	*** initParams;
	*** initRandom;
	*** initType;
	*** lock;
	*** serviceIterator;
	*** spi;
	*** disableFailover();
	*** nextSpi(java.security.KeyPairGeneratorSpi,boolean);
}

-keep class java.security.KeyPairGeneratorSpi {
	java.security.KeyPairGeneratorSpi();
	*** generateKeyPair();
	*** initialize(int,java.security.SecureRandom);
	*** initialize(java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
}

-keep class java.security.KeyRep$Type {
	*** PRIVATE;
	*** PUBLIC;
}

-keep class java.security.KeyStore {
	*** initialized;
	*** keyStoreSpi;
	*** provider;
	*** type;
	*** aliases();
	*** deleteEntry(java.lang.String);
	*** getCertificate(java.lang.String);
	*** getCertificateChain(java.lang.String);
	*** getDefaultType();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getKey(java.lang.String,char[]);
	*** getProvider();
	*** isCertificateEntry(java.lang.String);
	*** isKeyEntry(java.lang.String);
	*** load(java.io.InputStream,char[]);
	*** setCertificateEntry(java.lang.String,java.security.cert.Certificate);
}

-keep class java.security.KeyStore$1 {
	*** run();
}

-keep class java.security.KeyStore$CallbackHandlerProtection {
	*** getCallbackHandler();
}

-keep class java.security.KeyStore$LoadStoreParameter {
	*** getProtectionParameter();
}

-keep class java.security.KeyStore$PasswordProtection {
	*** getPassword();
}

-keep class java.security.KeyStore$PrivateKeyEntry {
	*** getCertificateChain();
	*** getPrivateKey();
}

-keep class java.security.KeyStore$SecretKeyEntry {
	*** getSecretKey();
}

-keep class java.security.KeyStore$TrustedCertificateEntry {
	*** getTrustedCertificate();
}

-keep class java.security.KeyStoreSpi {
	java.security.KeyStoreSpi();
	*** engineAliases();
	*** engineContainsAlias(java.lang.String);
	*** engineDeleteEntry(java.lang.String);
	*** engineEntryInstanceOf(java.lang.String,java.lang.Class);
	*** engineGetCertificate(java.lang.String);
	*** engineGetCertificateAlias(java.security.cert.Certificate);
	*** engineGetCertificateChain(java.lang.String);
	*** engineGetCreationDate(java.lang.String);
	*** engineGetEntry(java.lang.String,java.security.KeyStore$ProtectionParameter);
	*** engineGetKey(java.lang.String,char[]);
	*** engineIsCertificateEntry(java.lang.String);
	*** engineIsKeyEntry(java.lang.String);
	*** engineLoad(java.io.InputStream,char[]);
	*** engineLoad(java.security.KeyStore$LoadStoreParameter);
	*** engineSetCertificateEntry(java.lang.String,java.security.cert.Certificate);
	*** engineSetEntry(java.lang.String,java.security.KeyStore$Entry,java.security.KeyStore$ProtectionParameter);
	*** engineSetKeyEntry(java.lang.String,byte[],java.security.cert.Certificate[]);
	*** engineSetKeyEntry(java.lang.String,java.security.Key,char[],java.security.cert.Certificate[]);
	*** engineSize();
	*** engineStore(java.io.OutputStream,char[]);
	*** engineStore(java.security.KeyStore$LoadStoreParameter);
}

-keep class java.security.MessageDigest {
	*** algorithm;
	*** provider;
	*** state;
	java.security.MessageDigest(java.lang.String);
	*** access$000(java.security.MessageDigest);
	*** access$100(java.security.MessageDigest);
	*** access$102(java.security.MessageDigest,java.security.Provider);
	*** access$200(java.security.MessageDigest);
	*** access$202(java.security.MessageDigest,int);
	*** clone();
	*** digest();
	*** digest(byte[]);
	*** digest(byte[],int,int);
	*** getAlgorithm();
	*** getDigestLength();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** isEqual(byte[],byte[]);
	*** reset();
	*** toString();
	*** update(byte);
	*** update(byte[]);
	*** update(byte[],int,int);
	*** update(java.nio.ByteBuffer);
}

-keep class java.security.MessageDigest$Delegate {
	*** digestSpi;
}

-keep class java.security.MessageDigestSpi {
	*** tempArray;
	java.security.MessageDigestSpi();
	*** clone();
	*** engineDigest();
	*** engineDigest(byte[],int,int);
	*** engineGetDigestLength();
	*** engineReset();
	*** engineUpdate(byte);
	*** engineUpdate(byte[],int,int);
	*** engineUpdate(java.nio.ByteBuffer);
}

-keep class java.security.Permission {
	java.security.Permission(java.lang.String);
	*** getActions();
	*** getName();
	*** implies(java.security.Permission);
	*** newPermissionCollection();
	*** toString();
}

-keep class java.security.PermissionCollection {
	*** readOnly;
	java.security.PermissionCollection();
	*** add(java.security.Permission);
	*** elements();
	*** implies(java.security.Permission);
	*** isReadOnly();
	*** setReadOnly();
}

-keep class java.security.Permissions {
	*** allPermission;
	*** hasUnresolved;
	*** permsMap;
	*** serialPersistentFields;
	*** add(java.security.Permission);
	*** elements();
	*** getPermissionCollection(java.security.Permission,boolean);
	*** getUnresolvedPermissions(java.security.Permission);
	*** implies(java.security.Permission);
}

-keep class java.security.Policy {
	*** UNSUPPORTED_EMPTY_COLLECTION;
	*** debug;
	*** pdMapping;
	*** policy;
	java.security.Policy();
	*** addStaticPerms(java.security.PermissionCollection,java.security.PermissionCollection);
	*** checkPermission(java.lang.String);
	*** getPermissions(java.security.CodeSource);
	*** getPermissions(java.security.ProtectionDomain);
	*** getPolicy();
	*** getPolicyNoCheck();
	*** handleException(java.security.NoSuchAlgorithmException);
	*** initPolicy(java.security.Policy);
	*** refresh();
}

-keep class java.security.Policy$1 {
	*** run();
}

-keep class java.security.Policy$PolicyInfo {
	*** initialized;
	*** policy;
}

-keep class java.security.Policy$UnsupportedEmptyCollection {
	*** perms;
}

-keep class java.security.Principal {
	*** equals(java.lang.Object);
	*** getName();
}

-keep class java.security.PrivilegedAction {
	*;
}

-keep class java.security.PrivilegedActionException {
	*** getCause();
	*** getException();
	*** toString();
}

-keep class java.security.PrivilegedExceptionAction {
	*;
}

-keep class java.security.ProtectionDomain {
	*** key;
	*** getClassLoader();
	*** getCodeSource();
	*** getPermissions();
	*** getPrincipals();
}

-keep class java.security.ProtectionDomain$1 {
	*;
}

-keep class java.security.ProtectionDomain$3 {
	*;
}

-keep class java.security.ProtectionDomain$3$1 {
	*** map;
	*** this$0;
}

-keep class java.security.ProtectionDomain$Key {
	*;
}

-keep class java.security.Provider {
	*** ALIAS_LENGTH;
	*** debug;
	*** entrySet;
	*** entrySetCallCount;
	*** info;
	*** initialized;
	*** knownEngines;
	*** legacyChanged;
	*** legacyMap;
	*** legacyStrings;
	*** name;
	*** previousKey;
	*** serviceMap;
	*** serviceSet;
	*** servicesChanged;
	*** version;
	java.security.Provider(java.lang.String,double,java.lang.String);
	*** access$1000();
	*** access$900(java.lang.String);
	*** addEngine(java.lang.String,boolean,java.lang.String);
	*** check(java.lang.String);
	*** checkInitialized();
	*** ensureLegacyParsed();
	*** getEngineName(java.lang.String);
	*** getName();
	*** getProperty(java.lang.String);
	*** getService(java.lang.String,java.lang.String);
	*** getServices();
	*** getTypeAndAlgorithm(java.lang.String);
	*** implClear();
	*** implPut(java.lang.Object,java.lang.Object);
	*** implPutAll(java.util.Map);
	*** implRemove(java.lang.Object);
	*** implRemoveService(java.security.Provider$Service);
	*** keys();
	*** parseLegacyPut(java.lang.String,java.lang.String);
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** putId();
	*** putPropertyStrings(java.security.Provider$Service);
	*** removeInvalidServices(java.util.Map);
	*** removePropertyStrings(java.security.Provider$Service);
}

-keep class java.security.Provider$EngineDescription {
	*** constructorParameterClass;
	*** constructorParameterClassName;
	*** name;
	*** supportsParameter;
	*** getConstructorParameterClass();
}

-keep class java.security.Provider$Service {
	*** CLASS0;
	*** algorithm;
	*** aliases;
	*** attributes;
	*** className;
	*** classRef;
	*** hasKeyAttributes;
	*** provider;
	*** registered;
	*** supportedClasses;
	*** supportedFormats;
	*** type;
	java.security.Provider$Service(java.security.Provider);
	*** access$000(java.security.Provider$Service);
	*** access$302(java.security.Provider$Service,java.lang.String);
	*** access$402(java.security.Provider$Service,java.lang.String);
	*** access$500(java.security.Provider$Service,java.lang.String);
	*** access$602(java.security.Provider$Service,java.lang.String);
	*** access$700(java.security.Provider$Service);
	*** access$800(java.security.Provider$Service);
	*** addAlias(java.lang.String);
	*** addAttribute(java.lang.String,java.lang.String);
	*** getAlgorithm();
	*** getAliases();
	*** getAttribute(java.lang.String);
	*** getClassName();
	*** getImplClass();
	*** getKeyClass(java.lang.String);
	*** getProvider();
	*** getType();
	*** hasKeyAttributes();
	*** isValid();
	*** newInstance(java.lang.Object);
	*** newInstanceGeneric(java.lang.Object);
	*** supportsKeyClass(java.security.Key);
	*** supportsKeyFormat(java.security.Key);
	*** supportsParameter(java.lang.Object);
}

-keep class java.security.Provider$ServiceKey {
	*** algorithm;
	*** originalAlgorithm;
	*** type;
	java.security.Provider$ServiceKey(java.lang.String,java.lang.String,boolean);
	*** matches(java.lang.String,java.lang.String);
}

-keep class java.security.Provider$UString {
	*** lowerString;
	*** string;
}

-keep class java.security.SecureClassLoader {
	*;
}

-keep class java.security.SecureRandom {
	*** algorithm;
	*** digest;
	*** provider;
	*** secureRandomSpi;
	*** seedGenerator;
	java.security.SecureRandom(java.security.SecureRandomSpi,java.security.Provider,java.lang.String);
	*** generateSeed(int);
	*** getDefaultPRNG(boolean,byte[]);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getPrngAlgorithm();
	*** getProvider();
	*** getSecureRandomSpi();
	*** longToByteArray(long);
	*** nextBytes(byte[]);
}

-keep class java.security.SecureRandomSpi {
	java.security.SecureRandomSpi();
	*** engineGenerateSeed(int);
	*** engineNextBytes(byte[]);
	*** engineSetSeed(byte[]);
}

-keep class java.security.Security {
	*** props;
	*** sdebug;
	*** spiMap;
	*** access$000();
	*** addProvider(java.security.Provider);
	*** check(java.lang.String);
	*** getAllQualifyingCandidates(java.lang.String,java.lang.String,java.security.Provider[]);
	*** getFilterComponents(java.lang.String,java.lang.String);
	*** getImpl(java.lang.String,java.lang.String,java.lang.String);
	*** getImpl(java.lang.String,java.lang.String,java.security.Provider);
	*** getProperty(java.lang.String);
	*** getProvider(java.lang.String);
	*** getProviderProperty(java.lang.String);
	*** getProviderProperty(java.lang.String,java.security.Provider);
	*** getProviders();
	*** getProviders(java.util.Map);
	*** getProvidersNotUsingCache(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.security.Provider[]);
	*** getSpiClass(java.lang.String);
	*** initialize();
	*** initializeStatic();
	*** insertProviderAt(java.security.Provider,int);
	*** invalidateSMCache(java.lang.String);
	*** isConstraintSatisfied(java.lang.String,java.lang.String,java.lang.String);
	*** isCriterionSatisfied(java.security.Provider,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** isStandardAttr(java.lang.String);
	*** securityPropFile(java.lang.String);
}

-keep class java.security.Security$1 {
	*** run();
}

-keep class java.security.Security$ProviderProperty {
	*** className;
	*** provider;
}

-keep class java.security.Signature {
	*** algorithm;
	*** debug;
	*** provider;
	*** rsaIds;
	*** signatureInfo;
	*** state;
	java.security.Signature(java.lang.String);
	*** access$000(java.security.Signature);
	*** access$100();
	*** access$200(java.security.Provider$Service);
	*** chooseFirstProvider();
	*** getAlgorithm();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getInstance(sun.security.jca.GetInstance$Instance,java.lang.String);
	*** getInstanceRSA(java.security.Provider);
	*** initSign(java.security.PrivateKey);
	*** initSign(java.security.PrivateKey,java.security.SecureRandom);
	*** initVerify(java.security.PublicKey);
	*** isSpi(java.security.Provider$Service);
	*** setParameter(java.lang.String,java.lang.Object);
	*** sign();
	*** update(byte);
	*** update(byte[]);
	*** update(byte[],int,int);
	*** verify(byte[]);
	*** verify(byte[],int,int);
}

-keep class java.security.Signature$CipherAdapter {
	*** cipher;
	*** data;
	*** engineUpdate(byte[],int,int);
}

-keep class java.security.Signature$Delegate {
	*** firstService;
	*** lock;
	*** serviceIterator;
	*** sigSpi;
	*** warnCount;
	*** chooseFirstProvider();
	*** chooseProvider(int,java.security.Key,java.security.SecureRandom);
	*** init(java.security.SignatureSpi,int,java.security.Key,java.security.SecureRandom);
	*** newInstance(java.security.Provider$Service);
}

-keep class java.security.SignatureSpi {
	*** appRandom;
	java.security.SignatureSpi();
	*** clone();
	*** engineGetParameter(java.lang.String);
	*** engineGetParameters();
	*** engineInitSign(java.security.PrivateKey);
	*** engineInitSign(java.security.PrivateKey,java.security.SecureRandom);
	*** engineInitVerify(java.security.PublicKey);
	*** engineSetParameter(java.lang.String,java.lang.Object);
	*** engineSetParameter(java.security.spec.AlgorithmParameterSpec);
	*** engineSign();
	*** engineSign(byte[],int,int);
	*** engineUpdate(byte);
	*** engineUpdate(byte[],int,int);
	*** engineUpdate(java.nio.ByteBuffer);
	*** engineVerify(byte[]);
	*** engineVerify(byte[],int,int);
}

-keep class java.security.Timestamp {
	*** equals(java.lang.Object);
	*** hashCode();
}

-keep class java.security.UnrecoverableEntryException {
	java.security.UnrecoverableEntryException();
	java.security.UnrecoverableEntryException(java.lang.String);
}

-keep class java.security.UnresolvedPermission {
	*** PARAMS0;
	*** PARAMS1;
	*** PARAMS2;
	*** actions;
	*** certs;
	*** debug;
	*** name;
	*** type;
	*** resolve(java.security.Permission,java.security.cert.Certificate[]);
}

-keep class java.security.UnresolvedPermissionCollection {
	*** elements();
	*** getUnresolvedPermissions(java.security.Permission);
}

-keep class java.security.cert.CRLReason {
	*** UNSPECIFIED;
}

-keep class java.security.cert.CRLSelector {
	*** match(java.security.cert.CRL);
}

-keep class java.security.cert.CertPath {
	*** type;
	java.security.cert.CertPath(java.lang.String);
	*** equals(java.lang.Object);
	*** getCertificates();
	*** getEncoded();
	*** getType();
	*** hashCode();
}

-keep class java.security.cert.CertPathBuilder {
	*** algorithm;
	*** builderSpi;
	*** debug;
	*** provider;
	*** build(java.security.cert.CertPathParameters);
	*** getInstance(java.lang.String);
}

-keep class java.security.cert.CertPathBuilderException {
	java.security.cert.CertPathBuilderException();
	java.security.cert.CertPathBuilderException(java.lang.String);
	java.security.cert.CertPathBuilderException(java.lang.String,java.lang.Throwable);
	java.security.cert.CertPathBuilderException(java.lang.Throwable);
}

-keep class java.security.cert.CertPathBuilderSpi {
	java.security.cert.CertPathBuilderSpi();
	*** engineBuild(java.security.cert.CertPathParameters);
}

-keep class java.security.cert.CertPathHelperImpl {
	*** initialize();
}

-keep class java.security.cert.CertPathValidator {
	*** algorithm;
	*** debug;
	*** provider;
	*** validatorSpi;
	*** getInstance(java.lang.String);
	*** validate(java.security.cert.CertPath,java.security.cert.CertPathParameters);
}

-keep class java.security.cert.CertPathValidatorException {
	*** getReason();
}

-keep class java.security.cert.CertPathValidatorException$BasicReason {
	*** ALGORITHM_CONSTRAINED;
	*** EXPIRED;
	*** INVALID_SIGNATURE;
	*** NOT_YET_VALID;
	*** REVOKED;
	*** UNDETERMINED_REVOCATION_STATUS;
}

-keep class java.security.cert.CertPathValidatorSpi {
	java.security.cert.CertPathValidatorSpi();
	*** engineValidate(java.security.cert.CertPath,java.security.cert.CertPathParameters);
}

-keep class java.security.cert.CertSelector {
	*** clone();
	*** match(java.security.cert.Certificate);
}

-keep class java.security.cert.CertStore {
	*** params;
	*** provider;
	*** storeSpi;
	*** type;
	*** getCRLs(java.security.cert.CRLSelector);
	*** getCertStoreParameters();
	*** getCertificates(java.security.cert.CertSelector);
	*** getInstance(java.lang.String,java.security.cert.CertStoreParameters);
	*** getType();
	*** handleException(java.security.NoSuchAlgorithmException);
}

-keep class java.security.cert.CertStoreParameters {
	*** clone();
}

-keep class java.security.cert.CertStoreSpi {
	java.security.cert.CertStoreSpi(java.security.cert.CertStoreParameters);
	*** engineGetCRLs(java.security.cert.CRLSelector);
	*** engineGetCertificates(java.security.cert.CertSelector);
}

-keep class java.security.cert.Certificate {
	java.security.cert.Certificate(java.lang.String);
	*** equals(java.lang.Object);
	*** getEncoded();
	*** getPublicKey();
	*** getType();
	*** toString();
	*** verify(java.security.PublicKey);
	*** verify(java.security.PublicKey,java.lang.String);
}

-keep class java.security.cert.CertificateException {
	java.security.cert.CertificateException();
	java.security.cert.CertificateException(java.lang.String);
	java.security.cert.CertificateException(java.lang.String,java.lang.Throwable);
	java.security.cert.CertificateException(java.lang.Throwable);
}

-keep class java.security.cert.CertificateFactory {
	*** certFacSpi;
	*** provider;
	*** type;
	*** generateCRL(java.io.InputStream);
	*** generateCertPath(java.util.List);
	*** generateCertificate(java.io.InputStream);
	*** getInstance(java.lang.String);
}

-keep class java.security.cert.CertificateFactorySpi {
	java.security.cert.CertificateFactorySpi();
	*** engineGenerateCRL(java.io.InputStream);
	*** engineGenerateCRLs(java.io.InputStream);
	*** engineGenerateCertPath(java.io.InputStream);
	*** engineGenerateCertPath(java.io.InputStream,java.lang.String);
	*** engineGenerateCertPath(java.util.List);
	*** engineGenerateCertificate(java.io.InputStream);
	*** engineGenerateCertificates(java.io.InputStream);
	*** engineGetCertPathEncodings();
}

-keep class java.security.cert.CollectionCertStoreParameters {
	*** coll;
	*** getCollection();
}

-keep class java.security.cert.PKIXBuilderParameters {
	*** maxPathLength;
	java.security.cert.PKIXBuilderParameters(java.security.KeyStore,java.security.cert.CertSelector);
	java.security.cert.PKIXBuilderParameters(java.util.Set,java.security.cert.CertSelector);
	*** getMaxPathLength();
	*** toString();
}

-keep class java.security.cert.PKIXCertPathBuilderResult {
	*** getCertPath();
}

-keep class java.security.cert.PKIXCertPathChecker {
	java.security.cert.PKIXCertPathChecker();
	*** check(java.security.cert.Certificate,java.util.Collection);
	*** clone();
	*** getSupportedExtensions();
	*** init(boolean);
	*** isForwardCheckingSupported();
}

-keep class java.security.cert.PKIXCertPathValidatorResult {
	*** policyTree;
	*** subjectPublicKey;
	*** trustAnchor;
	*** getPublicKey();
	*** getTrustAnchor();
}

-keep class java.security.cert.PKIXParameters {
	*** anyPolicyInhibited;
	*** certPathCheckers;
	*** certSelector;
	*** certStores;
	*** date;
	*** explicitPolicyRequired;
	*** policyMappingInhibited;
	*** policyQualifiersRejected;
	*** revocationEnabled;
	*** sigProvider;
	*** unmodInitialPolicies;
	*** unmodTrustAnchors;
	java.security.cert.PKIXParameters(java.security.KeyStore);
	java.security.cert.PKIXParameters(java.util.Set);
	*** addCertPathChecker(java.security.cert.PKIXCertPathChecker);
	*** addCertStore(java.security.cert.CertStore);
	*** clone();
	*** getCertPathCheckers();
	*** getCertStores();
	*** getDate();
	*** getInitialPolicies();
	*** getPolicyQualifiersRejected();
	*** getSigProvider();
	*** getTargetCertConstraints();
	*** getTrustAnchors();
	*** isAnyPolicyInhibited();
	*** isExplicitPolicyRequired();
	*** isPolicyMappingInhibited();
	*** isRevocationEnabled();
	*** setAnyPolicyInhibited(boolean);
	*** setCertPathCheckers(java.util.List);
	*** setCertStores(java.util.List);
	*** setDate(java.util.Date);
	*** setExplicitPolicyRequired(boolean);
	*** setInitialPolicies(java.util.Set);
	*** setPolicyMappingInhibited(boolean);
	*** setPolicyQualifiersRejected(boolean);
	*** setRevocationEnabled(boolean);
	*** setSigProvider(java.lang.String);
	*** setTargetCertConstraints(java.security.cert.CertSelector);
	*** setTrustAnchors(java.util.Set);
	*** toString();
}

-keep class java.security.cert.PKIXReason {
	*** INVALID_KEY_USAGE;
	*** INVALID_NAME;
	*** INVALID_POLICY;
	*** NAME_CHAINING;
	*** NOT_CA_CERT;
	*** NO_TRUST_ANCHOR;
	*** PATH_TOO_LONG;
	*** UNRECOGNIZED_CRIT_EXT;
}

-keep class java.security.cert.PolicyQualifierInfo {
	*** mData;
	*** mEncoded;
	*** mId;
	*** pqiString;
	*** getEncoded();
}

-keep class java.security.cert.TrustAnchor {
	*** caName;
	*** caPrincipal;
	*** nc;
	*** ncBytes;
	*** pubKey;
	*** trustedCert;
	*** getCA();
	*** getCAPublicKey();
	*** getNameConstraints();
	*** getTrustedCert();
	*** setNameConstraints(byte[]);
	*** toString();
}

-keep class java.security.cert.X509CRL {
	*** getEncoded();
	*** getIssuerX500Principal();
	*** getRevokedCertificate(java.security.cert.X509Certificate);
}

-keep class java.security.cert.X509CRLSelector {
	*** setCertificateChecking(java.security.cert.X509Certificate);
	*** setDateAndTime(java.util.Date,long);
}

-keep class java.security.cert.X509CertSelector {
	*** ANY_EXTENDED_KEY_USAGE;
	*** EXTENSION_OIDS;
	*** FALSE;
	*** authorityKeyID;
	*** basicConstraints;
	*** certificateValid;
	*** debug;
	*** issuer;
	*** keyPurposeOIDSet;
	*** keyPurposeSet;
	*** keyUsage;
	*** matchAllSubjectAltNames;
	*** nc;
	*** ncBytes;
	*** pathToGeneralNames;
	*** pathToNames;
	*** policy;
	*** policySet;
	*** privateKeyValid;
	*** serialNumber;
	*** subject;
	*** subjectAlternativeGeneralNames;
	*** subjectAlternativeNames;
	*** subjectKeyID;
	*** subjectPublicKey;
	*** subjectPublicKeyAlgID;
	*** subjectPublicKeyBytes;
	*** x509Cert;
	java.security.cert.X509CertSelector();
	*** addPathToNameInternal(int,java.lang.Object);
	*** addSubjectAlternativeNameInternal(int,java.lang.Object);
	*** clone();
	*** cloneAndCheckNames(java.util.Collection);
	*** cloneNames(java.util.Collection);
	*** cloneSet(java.util.Set);
	*** getBasicConstraints();
	*** getCertificate();
	*** getExtensionObject(java.security.cert.X509Certificate,int);
	*** getIssuerAsString();
	*** getSerialNumber();
	*** getSubject();
	*** getSubjectAsString();
	*** getSubjectKeyIdentifier();
	*** keyUsageToString(boolean[]);
	*** makeGeneralNameInterface(int,java.lang.Object);
	*** match(java.security.cert.Certificate);
	*** matchAuthorityKeyID(java.security.cert.X509Certificate);
	*** matchBasicConstraints(java.security.cert.X509Certificate);
	*** matchExcluded(sun.security.x509.GeneralSubtrees);
	*** matchExtendedKeyUsage(java.security.cert.X509Certificate);
	*** matchKeyUsage(java.security.cert.X509Certificate);
	*** matchNameConstraints(java.security.cert.X509Certificate);
	*** matchPathToNames(java.security.cert.X509Certificate);
	*** matchPermitted(sun.security.x509.GeneralSubtrees);
	*** matchPolicy(java.security.cert.X509Certificate);
	*** matchPrivateKeyValid(java.security.cert.X509Certificate);
	*** matchSubjectAlternativeNames(java.security.cert.X509Certificate);
	*** matchSubjectKeyID(java.security.cert.X509Certificate);
	*** matchSubjectPublicKeyAlgID(java.security.cert.X509Certificate);
	*** parseNames(java.util.Collection);
	*** setBasicConstraints(int);
	*** setCertificate(java.security.cert.X509Certificate);
	*** setCertificateValid(java.util.Date);
	*** setIssuer(javax.security.auth.x500.X500Principal);
	*** setKeyUsage(boolean[]);
	*** setPathToNamesInternal(java.util.Set);
	*** setPolicy(java.util.Set);
	*** setSerialNumber(java.math.BigInteger);
	*** setSubject(javax.security.auth.x500.X500Principal);
	*** setSubjectKeyIdentifier(byte[]);
	*** toString();
}

-keep class java.security.cert.X509Certificate {
	*** issuerX500Principal;
	*** subjectX500Principal;
	java.security.cert.X509Certificate();
	*** checkValidity(java.util.Date);
	*** getBasicConstraints();
	*** getExtendedKeyUsage();
	*** getIssuerDN();
	*** getIssuerX500Principal();
	*** getKeyUsage();
	*** getNotAfter();
	*** getNotBefore();
	*** getSerialNumber();
	*** getSigAlgName();
	*** getSubjectAlternativeNames();
	*** getSubjectDN();
	*** getSubjectX500Principal();
	*** getTBSCertificate();
	*** getVersion();
}

-keep class java.security.cert.X509Extension {
	*** getCriticalExtensionOIDs();
	*** getExtensionValue(java.lang.String);
	*** hasUnsupportedCriticalExtension();
}

-keep class java.security.interfaces.DSAKey {
	*** getParams();
}

-keep class java.security.interfaces.DSAParams {
	*** getG();
	*** getP();
	*** getQ();
}

-keep class java.security.interfaces.DSAPrivateKey {
	*** getX();
}

-keep class java.security.interfaces.DSAPublicKey {
	*** getY();
}

-keep class java.security.interfaces.ECKey {
	*** getParams();
}

-keep class java.security.interfaces.ECPrivateKey {
	*** getS();
}

-keep class java.security.interfaces.ECPublicKey {
	*** getW();
}

-keep class java.security.interfaces.RSAKey {
	*** getModulus();
}

-keep class java.security.interfaces.RSAPrivateCrtKey {
	*** getCrtCoefficient();
	*** getPrimeExponentP();
	*** getPrimeExponentQ();
	*** getPrimeP();
	*** getPrimeQ();
	*** getPublicExponent();
}

-keep class java.security.interfaces.RSAPrivateKey {
	*** getPrivateExponent();
}

-keep class java.security.interfaces.RSAPublicKey {
	*** getPublicExponent();
}

-keep class java.security.spec.DSAParameterSpec {
	*** g;
	*** p;
	*** q;
	*** getG();
	*** getP();
	*** getQ();
}

-keep class java.security.spec.DSAPrivateKeySpec {
	*** getG();
	*** getP();
	*** getQ();
	*** getX();
}

-keep class java.security.spec.DSAPublicKeySpec {
	*** g;
	*** p;
	*** q;
	*** y;
	*** getG();
	*** getP();
	*** getQ();
	*** getY();
}

-keep class java.security.spec.ECField {
	*** getFieldSize();
}

-keep class java.security.spec.ECFieldF2m {
	*** ks;
	*** m;
	*** rp;
	*** getM();
}

-keep class java.security.spec.ECFieldFp {
	*** p;
	*** getP();
}

-keep class java.security.spec.ECGenParameterSpec {
	*** name;
	*** getName();
}

-keep class java.security.spec.ECParameterSpec {
	*** curve;
	*** g;
	*** h;
	*** n;
	java.security.spec.ECParameterSpec(java.security.spec.EllipticCurve,java.security.spec.ECPoint,java.math.BigInteger,int);
	*** getCofactor();
	*** getCurve();
	*** getGenerator();
	*** getOrder();
}

-keep class java.security.spec.ECPoint {
	*** POINT_INFINITY;
	*** x;
	*** y;
	*** equals(java.lang.Object);
	*** getAffineX();
	*** getAffineY();
}

-keep class java.security.spec.ECPrivateKeySpec {
	*** getParams();
	*** getS();
}

-keep class java.security.spec.ECPublicKeySpec {
	*** params;
	*** w;
	*** getParams();
	*** getW();
}

-keep class java.security.spec.EllipticCurve {
	*** a;
	*** b;
	*** field;
	*** seed;
	java.security.spec.EllipticCurve(java.security.spec.ECField,java.math.BigInteger,java.math.BigInteger,byte[]);
	*** checkValidity(java.security.spec.ECField,java.math.BigInteger,java.lang.String);
	*** equals(java.lang.Object);
	*** getField();
}

-keep class java.security.spec.EncodedKeySpec {
	*** encodedKey;
	java.security.spec.EncodedKeySpec(byte[]);
	*** getEncoded();
}

-keep class java.security.spec.MGF1ParameterSpec {
	*** SHA1;
	*** getDigestAlgorithm();
}

-keep class java.security.spec.PKCS8EncodedKeySpec {
	*** getEncoded();
}

-keep class java.security.spec.RSAPrivateCrtKeySpec {
	*** crtCoefficient;
	*** primeExponentP;
	*** primeExponentQ;
	*** primeP;
	*** primeQ;
	*** publicExponent;
	*** getCrtCoefficient();
	*** getPrimeExponentP();
	*** getPrimeExponentQ();
	*** getPrimeP();
	*** getPrimeQ();
	*** getPublicExponent();
}

-keep class java.security.spec.RSAPrivateKeySpec {
	*** modulus;
	*** privateExponent;
	java.security.spec.RSAPrivateKeySpec(java.math.BigInteger,java.math.BigInteger);
	*** getModulus();
	*** getPrivateExponent();
}

-keep class java.security.spec.RSAPublicKeySpec {
	*** modulus;
	*** publicExponent;
	*** getModulus();
	*** getPublicExponent();
}

-keep class java.security.spec.X509EncodedKeySpec {
	*** getEncoded();
}

-keep class java.sql.Date {
	*** toString();
	*** valueOf(java.lang.String);
}

-keep class java.sql.Time {
	*** toString();
	*** valueOf(java.lang.String);
}

-keep class java.sql.Timestamp {
	*** nanos;
	*** compareTo(java.sql.Timestamp);
	*** compareTo(java.util.Date);
	*** equals(java.sql.Timestamp);
	*** getNanos();
	*** getTime();
	*** valueOf(java.lang.String);
}

-keep class java.text.Annotation {
	*** getValue();
}

-keep class java.text.AttributedCharacterIterator$Attribute {
	*** INPUT_METHOD_SEGMENT;
	*** LANGUAGE;
	*** READING;
	*** instanceMap;
	*** name;
	java.text.AttributedCharacterIterator$Attribute(java.lang.String);
	*** equals(java.lang.Object);
	*** getName();
}

-keep class java.text.AttributedString {
	*** addAttribute(java.text.AttributedCharacterIterator$Attribute,java.lang.Object);
	*** getIterator();
}

-keep class java.text.CalendarBuilder {
	*** field;
	*** maxFieldIndex;
	*** nextStamp;
	*** addYear(int);
	*** clear(int);
	*** establish(java.util.Calendar);
	*** isSet(int);
	*** isValidDayOfWeek(int);
	*** set(int,int);
	*** toCalendarDayOfWeek(int);
	*** toISODayOfWeek(int);
}

-keep class java.text.CharacterIterator {
	*** clone();
	*** current();
	*** first();
	*** getBeginIndex();
	*** getEndIndex();
	*** getIndex();
	*** next();
	*** setIndex(int);
}

-keep class java.text.CharacterIteratorFieldDelegate {
	*** getIterator(java.lang.String);
}

-keep class java.text.ChoiceFormat {
	*** toPattern();
}

-keep class java.text.DateFormat {
	*** calendar;
	*** numberFormat;
	java.text.DateFormat();
	*** clone();
	*** equals(java.lang.Object);
	*** format(java.util.Date);
	*** format(java.util.Date,java.lang.StringBuffer,java.text.FieldPosition);
	*** get(int,int,int,java.util.Locale);
	*** getAvailableLocales();
	*** getCalendar();
	*** getDateInstance(int);
	*** getDateInstance(int,java.util.Locale);
	*** getDateTimeInstance();
	*** getDateTimeInstance(int,int);
	*** getDateTimeInstance(int,int,java.util.Locale);
	*** getTimeInstance(int);
	*** getTimeInstance(int,java.util.Locale);
	*** getTimeZone();
	*** isLenient();
	*** parse(java.lang.String);
	*** parse(java.lang.String,java.text.ParsePosition);
	*** setCalendar(java.util.Calendar);
	*** setLenient(boolean);
	*** setTimeZone(java.util.TimeZone);
}

-keep class java.text.DateFormat$DateFormatGetter {
	*** access$000();
}

-keep class java.text.DateFormat$Field {
	*** AM_PM;
	*** DAY_OF_MONTH;
	*** DAY_OF_WEEK;
	*** DAY_OF_WEEK_IN_MONTH;
	*** DAY_OF_YEAR;
	*** ERA;
	*** HOUR0;
	*** HOUR1;
	*** HOUR_OF_DAY0;
	*** HOUR_OF_DAY1;
	*** MILLISECOND;
	*** MINUTE;
	*** MONTH;
	*** SECOND;
	*** TIME_ZONE;
	*** WEEK_OF_MONTH;
	*** WEEK_OF_YEAR;
	*** YEAR;
	*** calendarField;
	*** calendarToFieldMapping;
	*** instanceMap;
}

-keep class java.text.DateFormatSymbols {
	*** ampms;
	*** cachedInstances;
	*** eras;
	*** isZoneStringsSet;
	*** lastZoneIndex;
	*** localPatternChars;
	*** locale;
	*** months;
	*** shortMonths;
	*** shortWeekdays;
	*** weekdays;
	*** zoneStrings;
	*** clone();
	*** copyMembers(java.text.DateFormatSymbols,java.text.DateFormatSymbols);
	*** equals(java.lang.Object);
	*** getAmPmStrings();
	*** getCachedInstance(java.util.Locale);
	*** getEras();
	*** getInstance(java.util.Locale);
	*** getInstanceRef(java.util.Locale);
	*** getLocalPatternChars();
	*** getMonths();
	*** getProviderInstance(java.util.Locale);
	*** getShortMonths();
	*** getShortWeekdays();
	*** getWeekdays();
	*** getZoneIndex(java.lang.String);
	*** getZoneStrings();
	*** getZoneStringsImpl(boolean);
	*** getZoneStringsWrapper();
	*** initializeData(java.util.Locale);
	*** isSubclassObject();
	*** toOneBasedArray(java.lang.String[]);
}

-keep class java.text.DateFormatSymbols$DateFormatSymbolsGetter {
	*** access$000();
}

-keep class java.text.DecimalFormat {
	*** $assertionsDisabled;
	*** EmptyFieldPositionArray;
	*** bigDecimalMultiplier;
	*** bigIntegerMultiplier;
	*** cachedLocaleData;
	*** decimalSeparatorAlwaysShown;
	*** digitList;
	*** groupingSize;
	*** isCurrencyFormat;
	*** maximumFractionDigits;
	*** maximumIntegerDigits;
	*** minExponentDigits;
	*** minimumFractionDigits;
	*** minimumIntegerDigits;
	*** multiplier;
	*** negPrefixPattern;
	*** negSuffixPattern;
	*** negativePrefix;
	*** negativePrefixFieldPositions;
	*** negativeSuffix;
	*** negativeSuffixFieldPositions;
	*** parseBigDecimal;
	*** posPrefixPattern;
	*** posSuffixPattern;
	*** positivePrefix;
	*** positivePrefixFieldPositions;
	*** positiveSuffix;
	*** positiveSuffixFieldPositions;
	*** roundingMode;
	*** serialVersionOnStream;
	*** symbols;
	*** useExponentialNotation;
	*** adjustForCurrencyDefaultFractionDigits();
	*** append(java.lang.StringBuffer,java.lang.String,java.text.Format$FieldDelegate,java.text.FieldPosition[],java.text.Format$Field);
	*** appendAffix(java.lang.StringBuffer,java.lang.String,boolean);
	*** appendAffix(java.lang.StringBuffer,java.lang.String,java.lang.String,boolean);
	*** applyPattern(java.lang.String,boolean);
	*** expandAffix(java.lang.String);
	*** expandAffix(java.lang.String,java.lang.StringBuffer);
	*** expandAffixes();
	*** format(double,java.lang.StringBuffer,java.text.FieldPosition);
	*** format(double,java.lang.StringBuffer,java.text.Format$FieldDelegate);
	*** format(java.math.BigDecimal,java.lang.StringBuffer,java.text.FieldPosition);
	*** format(java.math.BigDecimal,java.lang.StringBuffer,java.text.Format$FieldDelegate);
	*** format(java.math.BigInteger,java.lang.StringBuffer,java.text.FieldPosition);
	*** format(java.math.BigInteger,java.lang.StringBuffer,java.text.Format$FieldDelegate,boolean);
	*** format(long,java.lang.StringBuffer,java.text.FieldPosition);
	*** format(long,java.lang.StringBuffer,java.text.Format$FieldDelegate);
	*** getBigDecimalMultiplier();
	*** getBigIntegerMultiplier();
	*** getDecimalFormatSymbols();
	*** getGroupingSize();
	*** getMaximumFractionDigits();
	*** getMaximumIntegerDigits();
	*** getMinimumFractionDigits();
	*** getMinimumIntegerDigits();
	*** getNegativePrefixFieldPositions();
	*** getNegativeSuffixFieldPositions();
	*** getPositivePrefixFieldPositions();
	*** getPositiveSuffixFieldPositions();
	*** isParseBigDecimal();
	*** setDecimalSeparatorAlwaysShown(boolean);
	*** setMaximumFractionDigits(int);
	*** setMaximumIntegerDigits(int);
	*** setMinimumFractionDigits(int);
	*** setMinimumIntegerDigits(int);
	*** setRoundingMode(java.math.RoundingMode);
	*** subformat(java.lang.StringBuffer,java.text.Format$FieldDelegate,boolean,boolean,int,int,int,int);
	*** subparse(java.lang.String,java.text.ParsePosition,java.lang.String,java.lang.String,java.text.DigitList,boolean,boolean[]);
	*** toPattern();
	*** toPattern(boolean);
}

-keep class java.text.DecimalFormatSymbols {
	*** NaN;
	*** cachedLocaleData;
	*** currency;
	*** currencySymbol;
	*** decimalSeparator;
	*** digit;
	*** exponential;
	*** exponentialSeparator;
	*** groupingSeparator;
	*** infinity;
	*** intlCurrencySymbol;
	*** locale;
	*** minusSign;
	*** monetarySeparator;
	*** patternSeparator;
	*** perMill;
	*** percent;
	*** serialVersionOnStream;
	*** zeroDigit;
	*** clone();
	*** equals(java.lang.Object);
	*** getCurrency();
	*** getCurrencySymbol();
	*** getDecimalSeparator();
	*** getDigit();
	*** getExponentSeparator();
	*** getGroupingSeparator();
	*** getInfinity();
	*** getInstance(java.util.Locale);
	*** getInternationalCurrencySymbol();
	*** getMinusSign();
	*** getMonetaryDecimalSeparator();
	*** getNaN();
	*** getPatternSeparator();
	*** getPerMill();
	*** getPercent();
	*** getZeroDigit();
	*** initialize(java.util.Locale);
	*** setCurrency(java.util.Currency);
}

-keep class java.text.DecimalFormatSymbols$DecimalFormatSymbolsGetter {
	*** access$000();
}

-keep class java.text.DigitList {
	*** $assertionsDisabled;
	*** LONG_MIN_REP;
	*** count;
	*** data;
	*** decimalAt;
	*** digits;
	*** isNegative;
	*** roundingMode;
	*** tempBuffer;
	*** append(char);
	*** clone();
	*** extendDigits(int);
	*** fitsIntoLong(boolean,boolean);
	*** getBigDecimal();
	*** getDataChars(int);
	*** getDouble();
	*** getLong();
	*** getStringBuffer();
	*** isLongMIN_VALUE();
	*** isZero();
	*** parseInt(char[],int,int);
	*** round(int);
	*** set(boolean,double,int,boolean);
	*** set(boolean,java.lang.String,int,boolean);
	*** set(boolean,java.math.BigDecimal,int,boolean);
	*** set(boolean,java.math.BigInteger,int);
	*** set(boolean,long);
	*** set(boolean,long,int);
	*** setRoundingMode(java.math.RoundingMode);
	*** shouldRoundUp(int);
}

-keep class java.text.DigitList$1 {
	*** $SwitchMap$java$math$RoundingMode;
}

-keep class java.text.DontCareFieldPosition {
	*** INSTANCE;
	*** noDelegate;
}

-keep class java.text.DontCareFieldPosition$1 {
	*** this$0;
}

-keep class java.text.FieldPosition {
	*** attribute;
	*** beginIndex;
	*** endIndex;
	*** field;
	java.text.FieldPosition(int);
	java.text.FieldPosition(java.text.Format$Field,int);
	*** getBeginIndex();
	*** getEndIndex();
	*** getFieldAttribute();
	*** getFieldDelegate();
	*** matchesField(java.text.Format$Field);
	*** matchesField(java.text.Format$Field,int);
	*** setBeginIndex(int);
	*** setEndIndex(int);
}

-keep class java.text.Format {
	java.text.Format();
	*** clone();
	*** createAttributedCharacterIterator(java.lang.String);
	*** createAttributedCharacterIterator(java.lang.String,java.text.AttributedCharacterIterator$Attribute,java.lang.Object);
	*** createAttributedCharacterIterator(java.text.AttributedCharacterIterator,java.text.AttributedCharacterIterator$Attribute,java.lang.Object);
	*** createAttributedCharacterIterator(java.text.AttributedCharacterIterator[]);
	*** format(java.lang.Object);
	*** format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition);
	*** formatToCharacterIterator(java.lang.Object);
	*** parseObject(java.lang.String,java.text.ParsePosition);
}

-keep class java.text.Format$Field {
	java.text.Format$Field(java.lang.String);
}

-keep class java.text.Format$FieldDelegate {
	*** formatted(int,java.text.Format$Field,java.lang.Object,int,int,java.lang.StringBuffer);
	*** formatted(java.text.Format$Field,java.lang.Object,int,int,java.lang.StringBuffer);
}

-keep class java.text.MessageFormat {
	*** DATE_TIME_MODIFIERS;
	*** DATE_TIME_MODIFIER_KEYWORDS;
	*** NUMBER_MODIFIER_KEYWORDS;
	*** TYPE_KEYWORDS;
	*** argumentNumbers;
	*** formats;
	*** locale;
	*** maxOffset;
	*** offsets;
	*** pattern;
	*** append(java.lang.StringBuffer,java.text.CharacterIterator);
	*** applyPattern(java.lang.String);
	*** copyAndFixQuotes(java.lang.String,int,int,java.lang.StringBuilder);
	*** findKeyword(java.lang.String,java.lang.String[]);
	*** format(java.lang.String,java.lang.Object[]);
	*** makeFormat(int,int,java.lang.StringBuilder[]);
	*** parse(java.lang.String,java.text.ParsePosition);
	*** subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List);
}

-keep class java.text.MessageFormat$Field {
	*** ARGUMENT;
}

-keep class java.text.Normalizer {
	*** normalize(java.lang.CharSequence,java.text.Normalizer$Form);
}

-keep class java.text.Normalizer$Form {
	*** $VALUES;
	*** NFC;
	*** NFD;
	*** NFKC;
	*** NFKD;
	*** values();
}

-keep class java.text.NumberFormat {
	*** cachedLocaleData;
	*** groupingUsed;
	*** maxFractionDigits;
	*** maxIntegerDigits;
	*** maximumFractionDigits;
	*** maximumIntegerDigits;
	*** minFractionDigits;
	*** minIntegerDigits;
	*** minimumFractionDigits;
	*** minimumIntegerDigits;
	*** parseIntegerOnly;
	*** serialVersionOnStream;
	java.text.NumberFormat();
	*** clone();
	*** equals(java.lang.Object);
	*** format(double,java.lang.StringBuffer,java.text.FieldPosition);
	*** format(long);
	*** format(long,java.lang.StringBuffer,java.text.FieldPosition);
	*** getCurrencyInstance(java.util.Locale);
	*** getInstance();
	*** getInstance(java.util.Locale);
	*** getInstance(java.util.Locale,int);
	*** getIntegerInstance();
	*** getIntegerInstance(java.util.Locale);
	*** getMaximumFractionDigits();
	*** getMaximumIntegerDigits();
	*** getMinimumFractionDigits();
	*** getMinimumIntegerDigits();
	*** getPercentInstance(java.util.Locale);
	*** hashCode();
	*** isGroupingUsed();
	*** isParseIntegerOnly();
	*** parse(java.lang.String,java.text.ParsePosition);
	*** setGroupingUsed(boolean);
	*** setMaximumFractionDigits(int);
	*** setMaximumIntegerDigits(int);
	*** setMinimumFractionDigits(int);
	*** setMinimumIntegerDigits(int);
	*** setParseIntegerOnly(boolean);
}

-keep class java.text.NumberFormat$Field {
	*** CURRENCY;
	*** DECIMAL_SEPARATOR;
	*** EXPONENT;
	*** EXPONENT_SIGN;
	*** EXPONENT_SYMBOL;
	*** FRACTION;
	*** GROUPING_SEPARATOR;
	*** INTEGER;
	*** PERCENT;
	*** PERMILLE;
	*** SIGN;
}

-keep class java.text.NumberFormat$NumberFormatGetter {
	*** access$000();
}

-keep class java.text.ParseException {
	*** errorOffset;
}

-keep class java.text.ParsePosition {
	*** errorIndex;
	*** index;
	*** getErrorIndex();
	*** getIndex();
	*** setErrorIndex(int);
	*** setIndex(int);
}

-keep class java.text.SimpleDateFormat {
	*** $assertionsDisabled;
	*** PATTERN_INDEX_TO_CALENDAR_FIELD;
	*** PATTERN_INDEX_TO_DATE_FORMAT_FIELD;
	*** PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID;
	*** cachedLocaleData;
	*** cachedNumberFormatData;
	*** compiledPattern;
	*** defaultCenturyStart;
	*** defaultCenturyStartYear;
	*** formatData;
	*** hasFollowingMinusSign;
	*** locale;
	*** minusSign;
	*** originalNumberFormat;
	*** originalNumberPattern;
	*** pattern;
	*** serialVersionOnStream;
	*** useDateFormatSymbols;
	*** zeroDigit;
	java.text.SimpleDateFormat(int,int,java.util.Locale);
	java.text.SimpleDateFormat(java.lang.String,java.util.Locale);
	*** checkNegativeNumberExpression();
	*** compile(java.lang.String);
	*** encode(int,int,java.lang.StringBuilder);
	*** format(java.util.Date,java.lang.StringBuffer,java.text.Format$FieldDelegate);
	*** getCalendarName();
	*** initialize(java.util.Locale);
	*** initializeCalendar(java.util.Locale);
	*** initializeDefaultCentury();
	*** isDigit(char);
	*** isGregorianCalendar();
	*** matchString(java.lang.String,int,int,java.lang.String[],java.text.CalendarBuilder);
	*** matchString(java.lang.String,int,int,java.util.Map,java.text.CalendarBuilder);
	*** matchZoneString(java.lang.String,int,java.lang.String[]);
	*** parse(java.lang.String,java.text.ParsePosition);
	*** parseAmbiguousDatesAsAfter(java.util.Date);
	*** set2DigitYearStart(java.util.Date);
	*** subFormat(int,int,java.text.Format$FieldDelegate,java.lang.StringBuffer,boolean);
	*** subParse(java.lang.String,int,int,int,boolean,boolean[],java.text.ParsePosition,boolean,java.text.CalendarBuilder);
	*** subParseNumericZone(java.lang.String,int,int,int,boolean,java.text.CalendarBuilder);
	*** subParseZoneString(java.lang.String,int,java.text.CalendarBuilder);
	*** toPattern();
	*** translatePattern(java.lang.String,java.lang.String,java.lang.String);
	*** useDateFormatSymbols();
	*** zeroPaddingNumber(int,int,int,java.lang.StringBuffer);
}

-keep class java.util.AbstractCollection {
	java.util.AbstractCollection();
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** isEmpty();
	*** iterator();
	*** retainAll(java.util.Collection);
	*** size();
	*** toArray();
	*** toArray(java.lang.Object[]);
	*** toString();
}

-keep class java.util.AbstractList {
	*** modCount;
	java.util.AbstractList();
	*** add(int,java.lang.Object);
	*** addAll(int,java.util.Collection);
	*** get(int);
	*** iterator();
	*** listIterator();
	*** listIterator(int);
	*** remove(int);
	*** removeRange(int,int);
	*** set(int,java.lang.Object);
}

-keep class java.util.AbstractList$Itr {
	*** cursor;
	*** expectedModCount;
	*** lastRet;
	java.util.AbstractList$Itr(java.util.AbstractList,java.util.AbstractList$1);
	*** checkForComodification();
}

-keep class java.util.AbstractList$ListItr {
	*** this$0;
}

-keep class java.util.AbstractMap {
	*** keySet;
	*** values;
	java.util.AbstractMap();
	*** access$000(java.lang.Object,java.lang.Object);
	*** clear();
	*** clone();
	*** equals(java.lang.Object);
	*** hashCode();
	*** isEmpty();
	*** putAll(java.util.Map);
	*** toString();
}

-keep class java.util.AbstractMap$SimpleEntry {
	*** key;
	*** value;
	java.util.AbstractMap$SimpleEntry(java.lang.Object,java.lang.Object);
	*** getKey();
	*** setValue(java.lang.Object);
}

-keep class java.util.AbstractQueue {
	java.util.AbstractQueue();
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
}

-keep class java.util.AbstractSequentialList {
	java.util.AbstractSequentialList();
	*** iterator();
}

-keep class java.util.AbstractSet {
	java.util.AbstractSet();
	*** equals(java.lang.Object);
	*** hashCode();
	*** removeAll(java.util.Collection);
}

-keep class java.util.ArrayDeque {
	*** add(java.lang.Object);
	*** isEmpty();
	*** poll();
}

-keep class java.util.ArrayList {
	java.util.ArrayList(int);
	*** access$200(java.util.ArrayList);
	*** add(int,java.lang.Object);
	*** add(java.lang.Object);
	*** addAll(int,java.util.Collection);
	*** addAll(java.util.Collection);
	*** clear();
	*** clone();
	*** contains(java.lang.Object);
	*** elementData(int);
	*** ensureCapacity(int);
	*** get(int);
	*** indexOf(java.lang.Object);
	*** isEmpty();
	*** iterator();
	*** listIterator();
	*** remove(int);
	*** remove(java.lang.Object);
	*** set(int,java.lang.Object);
	*** size();
	*** subList(int,int);
	*** subListRangeCheck(int,int,int);
	*** toArray();
	*** toArray(java.lang.Object[]);
	*** trimToSize();
}

-keep class java.util.ArrayList$SubList {
	*** offset;
	*** parent;
	*** parentOffset;
	*** size;
	*** this$0;
	*** add(int,java.lang.Object);
	*** addAll(int,java.util.Collection);
	*** checkForComodification();
	*** outOfBoundsMsg(int);
	*** rangeCheck(int);
	*** rangeCheckForAdd(int);
	*** remove(int);
}

-keep class java.util.ArrayList$SubList$1 {
	*** cursor;
	*** expectedModCount;
	*** lastRet;
	*** this$1;
	*** val$index;
	*** val$offset;
	*** checkForComodification();
}

-keep class java.util.Arrays {
	*** asList(java.lang.Object[]);
	*** binarySearch(int[],int,int,int);
	*** binarySearch(java.lang.Object[],java.lang.Object);
	*** binarySearch(java.lang.Object[],java.lang.Object,java.util.Comparator);
	*** copyOf(byte[],int);
	*** copyOf(char[],int);
	*** copyOf(float[],int);
	*** copyOf(int[],int);
	*** copyOf(java.lang.Object[],int);
	*** copyOf(java.lang.Object[],int,java.lang.Class);
	*** copyOfRange(byte[],int,int);
	*** copyOfRange(int[],int,int);
	*** copyOfRange(java.lang.Object[],int,int);
	*** deepEquals(java.lang.Object[],java.lang.Object[]);
	*** deepEquals0(java.lang.Object,java.lang.Object);
	*** deepToString(java.lang.Object[]);
	*** equals(boolean[],boolean[]);
	*** equals(byte[],byte[]);
	*** equals(char[],char[]);
	*** equals(float[],float[]);
	*** equals(int[],int[]);
	*** equals(java.lang.Object[],java.lang.Object[]);
	*** fill(byte[],byte);
	*** fill(byte[],int,int,byte);
	*** fill(char[],char);
	*** fill(int[],int);
	*** fill(int[],int,int,int);
	*** fill(java.lang.Object[],int,int,java.lang.Object);
	*** fill(java.lang.Object[],java.lang.Object);
	*** hashCode(byte[]);
	*** hashCode(int[]);
	*** hashCode(java.lang.Object[]);
	*** hashCode(long[]);
	*** sort(int[]);
	*** sort(java.lang.Object[]);
	*** sort(java.lang.Object[],int,int);
	*** sort(java.lang.Object[],int,int,java.util.Comparator);
	*** sort(java.lang.Object[],java.util.Comparator);
	*** sort(long[]);
	*** toString(boolean[]);
	*** toString(byte[]);
	*** toString(double[]);
	*** toString(float[]);
	*** toString(int[]);
	*** toString(java.lang.Object[]);
	*** toString(long[]);
	*** toString(short[]);
}

-keep class java.util.Arrays$ArrayList {
	*;
}

-keep class java.util.Arrays$LegacyMergeSort {
	*** userRequested;
}

-keep class java.util.BitSet {
	*** andNot(java.util.BitSet);
	*** clear(int);
	*** get(int);
	*** or(java.util.BitSet);
	*** set(int);
}

-keep class java.util.Calendar {
	*** $assertionsDisabled;
	*** FIELD_NAME;
	*** areAllFieldsSet;
	*** areFieldsSet;
	*** cachedLocaleData;
	*** fields;
	*** firstDayOfWeek;
	*** isSet;
	*** isTimeSet;
	*** lenient;
	*** minimalDaysInFirstWeek;
	*** nextStamp;
	*** serialVersionOnStream;
	*** sharedZone;
	*** stamp;
	*** time;
	*** zone;
	java.util.Calendar();
	java.util.Calendar(java.util.TimeZone,java.util.Locale);
	*** add(int,int);
	*** adjustStamp();
	*** aggregateStamp(int,int);
	*** appendValue(java.lang.StringBuilder,java.lang.String,boolean,long);
	*** before(java.lang.Object);
	*** checkDisplayNameParams(int,int,int,int,java.util.Locale,int);
	*** clear();
	*** clear(int);
	*** clone();
	*** compareTo(java.util.Calendar);
	*** compareTo(long);
	*** complete();
	*** computeFields();
	*** computeTime();
	*** createCalendar(java.util.TimeZone,java.util.Locale);
	*** equals(java.lang.Object);
	*** get(int);
	*** getDisplayName(int,int,java.util.Locale);
	*** getDisplayNames(int,int,java.util.Locale);
	*** getDisplayNamesImpl(int,int,java.util.Locale);
	*** getFieldName(int);
	*** getFieldStrings(int,int,java.text.DateFormatSymbols);
	*** getFirstDayOfWeek();
	*** getGreatestMinimum(int);
	*** getInstance();
	*** getInstance(java.util.Locale);
	*** getInstance(java.util.TimeZone);
	*** getInstance(java.util.TimeZone,java.util.Locale);
	*** getLeastMaximum(int);
	*** getMaximum(int);
	*** getMillisOf(java.util.Calendar);
	*** getMinimalDaysInFirstWeek();
	*** getMinimum(int);
	*** getSetStateFields();
	*** getTime();
	*** getTimeInMillis();
	*** getTimeZone();
	*** getWeekYear();
	*** getZone();
	*** hashCode();
	*** internalGet(int);
	*** internalSet(int,int);
	*** invalidateWeekFields();
	*** isExternallySet(int);
	*** isFieldSet(int,int);
	*** isFullyNormalized();
	*** isLenient();
	*** isPartiallyNormalized();
	*** isSet(int);
	*** isWeekDateSupported();
	*** roll(int,boolean);
	*** selectFields();
	*** set(int,int);
	*** set(int,int,int);
	*** set(int,int,int,int,int,int);
	*** setFieldsComputed(int);
	*** setFieldsNormalized(int);
	*** setLenient(boolean);
	*** setTime(java.util.Date);
	*** setTimeInMillis(long);
	*** setTimeZone(java.util.TimeZone);
	*** setUnnormalized();
	*** setWeekCountData(java.util.Locale);
	*** setWeekDate(int,int,int);
	*** setZoneShared(boolean);
	*** updateTime();
}

-keep class java.util.Calendar$CalendarAccessControlContext {
	*** access$000();
}

-keep class java.util.Collection {
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
	*** clear();
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** equals(java.lang.Object);
	*** hashCode();
	*** isEmpty();
	*** iterator();
	*** remove(java.lang.Object);
	*** removeAll(java.util.Collection);
	*** retainAll(java.util.Collection);
	*** size();
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class java.util.Collections {
	*** EMPTY_LIST;
	*** EMPTY_MAP;
	*** EMPTY_SET;
	*** addAll(java.util.Collection,java.lang.Object[]);
	*** binarySearch(java.util.List,java.lang.Object);
	*** binarySearch(java.util.List,java.lang.Object,java.util.Comparator);
	*** emptyIterator();
	*** emptyList();
	*** emptyMap();
	*** emptySet();
	*** enumeration(java.util.Collection);
	*** eq(java.lang.Object,java.lang.Object);
	*** list(java.util.Enumeration);
	*** newSetFromMap(java.util.Map);
	*** reverse(java.util.List);
	*** shuffle(java.util.List,java.util.Random);
	*** singleton(java.lang.Object);
	*** singletonIterator(java.lang.Object);
	*** singletonList(java.lang.Object);
	*** singletonMap(java.lang.Object,java.lang.Object);
	*** sort(java.util.List);
	*** sort(java.util.List,java.util.Comparator);
	*** swap(java.util.List,int,int);
	*** synchronizedList(java.util.List);
	*** synchronizedMap(java.util.Map);
	*** synchronizedSet(java.util.Set);
	*** synchronizedSortedMap(java.util.SortedMap);
	*** unmodifiableCollection(java.util.Collection);
	*** unmodifiableList(java.util.List);
	*** unmodifiableMap(java.util.Map);
	*** unmodifiableSet(java.util.Set);
	*** unmodifiableSortedMap(java.util.SortedMap);
	*** unmodifiableSortedSet(java.util.SortedSet);
}

-keep class java.util.Collections$1 {
	*** hasNext;
	*** val$e;
}

-keep class java.util.Collections$2 {
	*** i;
	*** val$c;
}

-keep class java.util.Collections$EmptyEnumeration {
	*** EMPTY_ENUMERATION;
}

-keep class java.util.Collections$EmptyIterator {
	*** EMPTY_ITERATOR;
	java.util.Collections$EmptyIterator();
}

-keep class java.util.Collections$EmptyList {
	*;
}

-keep class java.util.Collections$EmptyMap {
	*;
}

-keep class java.util.Collections$EmptySet {
	*;
}

-keep class java.util.Collections$SetFromMap {
	*;
}

-keep class java.util.Collections$SingletonList {
	*** element;
}

-keep class java.util.Collections$SingletonMap {
	*** entrySet;
	*** k;
	*** keySet;
	*** v;
	*** values;
}

-keep class java.util.Collections$SingletonSet {
	*** element;
}

-keep class java.util.Collections$SynchronizedCollection {
	*** mutex;
	java.util.Collections$SynchronizedCollection(java.util.Collection);
	java.util.Collections$SynchronizedCollection(java.util.Collection,java.lang.Object);
}

-keep class java.util.Collections$SynchronizedList {
	*** list;
	java.util.Collections$SynchronizedList(java.util.List);
	java.util.Collections$SynchronizedList(java.util.List,java.lang.Object);
}

-keep class java.util.Collections$SynchronizedMap {
	*** mutex;
	java.util.Collections$SynchronizedMap(java.util.Map);
	java.util.Collections$SynchronizedMap(java.util.Map,java.lang.Object);
}

-keep class java.util.Collections$SynchronizedSet {
	*;
}

-keep class java.util.Collections$SynchronizedSortedMap {
	*** sm;
}

-keep class java.util.Collections$UnmodifiableCollection {
	*** c;
	java.util.Collections$UnmodifiableCollection(java.util.Collection);
}

-keep class java.util.Collections$UnmodifiableCollection$1 {
	*** i;
	*** this$0;
}

-keep class java.util.Collections$UnmodifiableList {
	*;
}

-keep class java.util.Collections$UnmodifiableMap {
	*** entrySet;
	*** keySet;
	*** m;
	*** values;
}

-keep class java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet {
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
}

-keep class java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1 {
	*** i;
	*** this$0;
	*** next();
}

-keep class java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry {
	*** e;
}

-keep class java.util.Collections$UnmodifiableRandomAccessList {
	*;
}

-keep class java.util.Collections$UnmodifiableSet {
	java.util.Collections$UnmodifiableSet(java.util.Set);
}

-keep class java.util.ComparableTimSort {
	*** $assertionsDisabled;
	*** a;
	*** minGallop;
	*** runBase;
	*** runLen;
	*** stackSize;
	*** tmp;
	*** binarySort(java.lang.Object[],int,int,int);
	*** countRunAndMakeAscending(java.lang.Object[],int,int);
	*** ensureCapacity(int);
	*** gallopLeft(java.lang.Comparable,java.lang.Object[],int,int,int);
	*** gallopRight(java.lang.Comparable,java.lang.Object[],int,int,int);
	*** mergeAt(int);
	*** mergeCollapse();
	*** mergeForceCollapse();
	*** mergeHi(int,int,int,int);
	*** mergeLo(int,int,int,int);
	*** minRunLength(int);
	*** pushRun(int,int);
	*** rangeCheck(int,int,int);
	*** reverseRange(java.lang.Object[],int,int);
	*** sort(java.lang.Object[],int,int);
}

-keep class java.util.Comparator {
	*** compare(java.lang.Object,java.lang.Object);
	*** equals(java.lang.Object);
}

-keep class java.util.Currency {
	*** available;
	*** currencyCode;
	*** dataVersion;
	*** defaultFractionDigits;
	*** formatVersion;
	*** instances;
	*** mainTable;
	*** numericCode;
	*** otherCurrencies;
	*** otherCurrenciesDFD;
	*** otherCurrenciesNumericCode;
	*** scCutOverTimes;
	*** scNewCurrencies;
	*** scNewCurrenciesDFD;
	*** scNewCurrenciesNumericCode;
	*** scOldCurrencies;
	*** scOldCurrenciesDFD;
	*** scOldCurrenciesNumericCode;
	*** access$000(java.io.DataInputStream,int);
	*** access$100(java.io.DataInputStream,int);
	*** access$200(java.io.DataInputStream,int);
	*** access$300(java.util.regex.Pattern,java.lang.String,java.lang.String);
	*** access$400(java.lang.String,java.lang.Throwable);
	*** getCurrencyCode();
	*** getDefaultFractionDigits();
	*** getDisplayName(java.util.Locale);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,int,int);
	*** getInstance(java.util.Locale);
	*** getMainTableEntry(char,char);
	*** getSymbol();
	*** getSymbol(java.util.Locale);
	*** info(java.lang.String,java.lang.Throwable);
	*** readIntArray(java.io.DataInputStream,int);
	*** readLongArray(java.io.DataInputStream,int);
	*** readStringArray(java.io.DataInputStream,int);
	*** replaceCurrencyData(java.util.regex.Pattern,java.lang.String,java.lang.String);
	*** setMainTableEntry(char,char,int);
}

-keep class java.util.Currency$CurrencyNameGetter {
	*** access$500();
}

-keep class java.util.Date {
	*** cdate;
	*** defaultCenturyStart;
	*** fastTime;
	*** gcal;
	*** jcal;
	*** ttb;
	*** wtb;
	java.util.Date(int,int,int);
	java.util.Date(int,int,int,int,int,int);
	java.util.Date(long);
	*** after(java.util.Date);
	*** before(java.util.Date);
	*** clone();
	*** compareTo(java.util.Date);
	*** convertToAbbr(java.lang.StringBuilder,java.lang.String);
	*** equals(java.lang.Object);
	*** getCalendarDate();
	*** getCalendarSystem(int);
	*** getCalendarSystem(long);
	*** getCalendarSystem(sun.util.calendar.BaseCalendar$Date);
	*** getDate();
	*** getHours();
	*** getJulianCalendar();
	*** getMillisOf(java.util.Date);
	*** getMinutes();
	*** getMonth();
	*** getSeconds();
	*** getTime();
	*** getTimeImpl();
	*** getYear();
	*** hashCode();
	*** normalize();
	*** normalize(sun.util.calendar.BaseCalendar$Date);
	*** parse(java.lang.String);
	*** setTime(long);
	*** toString();
}

-keep class java.util.Deque {
	*** add(java.lang.Object);
	*** peek();
	*** poll();
	*** pop();
	*** push(java.lang.Object);
	*** remove();
}

-keep class java.util.Dictionary {
	*;
}

-keep class java.util.DualPivotQuicksort {
	*** doSort(char[],int,int);
	*** doSort(double[],int,int);
	*** doSort(float[],int,int);
	*** doSort(short[],int,int);
	*** sort(byte[],int,int);
	*** sort(char[],int,int);
	*** sort(char[],int,int,boolean);
	*** sort(double[],int,int);
	*** sort(double[],int,int,boolean);
	*** sort(float[],int,int);
	*** sort(float[],int,int,boolean);
	*** sort(int[],int,int);
	*** sort(int[],int,int,boolean);
	*** sort(long[],int,int);
	*** sort(long[],int,int,boolean);
	*** sort(short[],int,int);
	*** sort(short[],int,int,boolean);
}

-keep class java.util.EnumMap {
	*** NULL;
	*** ZERO_LENGTH_ENUM_ARRAY;
	*** entrySet;
	*** keyType;
	*** keyUniverse;
	*** size;
	*** vals;
	*** clone();
	*** containsKey(java.lang.Object);
	*** containsMapping(java.lang.Object,java.lang.Object);
	*** entryHashCode(int);
	*** entrySet();
	*** equals(java.util.EnumMap);
	*** get(java.lang.Object);
	*** getKeyUniverse(java.lang.Class);
	*** isValidKey(java.lang.Object);
	*** keySet();
	*** maskNull(java.lang.Object);
	*** put(java.lang.Enum,java.lang.Object);
	*** putAll(java.util.Map);
	*** removeMapping(java.lang.Object,java.lang.Object);
	*** size();
	*** typeCheck(java.lang.Enum);
	*** unmaskNull(java.lang.Object);
	*** values();
}

-keep class java.util.EnumSet {
	*** ZERO_LENGTH_ENUM_ARRAY;
	*** elementType;
	*** universe;
	java.util.EnumSet(java.lang.Class,java.lang.Enum[]);
	*** addAll();
	*** addRange(java.lang.Enum,java.lang.Enum);
	*** allOf(java.lang.Class);
	*** clone();
	*** complement();
	*** complementOf(java.util.EnumSet);
	*** copyOf(java.util.Collection);
	*** copyOf(java.util.EnumSet);
	*** getUniverse(java.lang.Class);
	*** noneOf(java.lang.Class);
	*** of(java.lang.Enum);
	*** of(java.lang.Enum,java.lang.Enum);
	*** of(java.lang.Enum,java.lang.Enum[]);
	*** typeCheck(java.lang.Enum);
}

-keep class java.util.Enumeration {
	*** hasMoreElements();
	*** nextElement();
}

-keep class java.util.EventListenerProxy {
	*** listener;
	java.util.EventListenerProxy(java.util.EventListener);
	*** getListener();
}

-keep class java.util.EventObject {
	*** source;
	java.util.EventObject(java.lang.Object);
	*** getSource();
}

-keep class java.util.Formattable {
	*** formatTo(java.util.Formatter,int,int,int);
}

-keep class java.util.Formatter {
	*** a;
	*** fsPattern;
	*** l;
	*** lastException;
	*** scaleUp;
	*** zero;
	java.util.Formatter(java.io.File,java.lang.String,java.util.Locale);
	java.util.Formatter(java.io.OutputStream,java.lang.String,java.util.Locale);
	java.util.Formatter(java.lang.String,java.lang.String,java.util.Locale);
	java.util.Formatter(java.nio.charset.Charset,java.util.Locale,java.io.File);
	java.util.Formatter(java.util.Locale,java.lang.Appendable);
	*** access$000(java.util.Formatter);
	*** access$200();
	*** access$202(double);
	*** access$300(java.util.Formatter);
	*** checkText(java.lang.String,int,int);
	*** ensureOpen();
	*** format(java.lang.String,java.lang.Object[]);
	*** format(java.util.Locale,java.lang.String,java.lang.Object[]);
	*** getZero(java.util.Locale);
	*** locale();
	*** nonNullAppendable(java.lang.Appendable);
	*** out();
	*** parse(java.lang.String);
	*** toCharset(java.lang.String);
	*** toString();
}

-keep class java.util.Formatter$BigDecimalLayoutForm {
	*** DECIMAL_FLOAT;
	*** SCIENTIFIC;
}

-keep class java.util.Formatter$Conversion {
	*** isCharacter(char);
	*** isFloat(char);
	*** isGeneral(char);
	*** isInteger(char);
	*** isText(char);
	*** isValid(char);
}

-keep class java.util.Formatter$DateTime {
	*** isValid(char);
}

-keep class java.util.Formatter$FixedString {
	*** s;
	*** this$0;
}

-keep class java.util.Formatter$Flags {
	*** ALTERNATE;
	*** GROUP;
	*** LEADING_SPACE;
	*** LEFT_JUSTIFY;
	*** NONE;
	*** PARENTHESES;
	*** PLUS;
	*** PREVIOUS;
	*** UPPERCASE;
	*** ZERO_PAD;
	*** flags;
	*** access$100(java.util.Formatter$Flags,java.util.Formatter$Flags);
	*** add(java.util.Formatter$Flags);
	*** contains(java.util.Formatter$Flags);
	*** dup();
	*** parse(char);
	*** parse(java.lang.String);
	*** remove(java.util.Formatter$Flags);
	*** toString();
	*** valueOf();
}

-keep class java.util.Formatter$FormatSpecifier {
	*** $assertionsDisabled;
	*** c;
	*** dt;
	*** f;
	*** index;
	*** precision;
	*** this$0;
	*** width;
	*** addDot(char[]);
	*** addZeros(char[],int);
	*** adjustWidth(int,java.util.Formatter$Flags,boolean);
	*** checkBadFlags(java.util.Formatter$Flags[]);
	*** checkCharacter();
	*** checkDateTime();
	*** checkFloat();
	*** checkGeneral();
	*** checkInteger();
	*** checkNumeric();
	*** checkText();
	*** conversion(java.lang.String);
	*** exponent(char[],int);
	*** failConversion(char,java.lang.Object);
	*** failMismatch(java.util.Formatter$Flags,char);
	*** flags(java.lang.String);
	*** getZero(java.util.Locale);
	*** hexDouble(double,int);
	*** index(java.lang.String);
	*** justify(java.lang.String);
	*** leadingSign(java.lang.StringBuilder,boolean);
	*** localizedMagnitude(java.lang.StringBuilder,char[],java.util.Formatter$Flags,int,java.util.Locale);
	*** localizedMagnitude(java.lang.StringBuilder,long,java.util.Formatter$Flags,int,java.util.Locale);
	*** mantissa(char[],int);
	*** precision(java.lang.String);
	*** print(byte,java.util.Locale);
	*** print(double,java.util.Locale);
	*** print(float,java.util.Locale);
	*** print(int,java.util.Locale);
	*** print(java.lang.String);
	*** print(java.lang.StringBuilder,double,java.util.Locale,java.util.Formatter$Flags,char,int,boolean);
	*** print(java.lang.StringBuilder,java.math.BigDecimal,java.util.Locale,java.util.Formatter$Flags,char,int,boolean);
	*** print(java.lang.StringBuilder,java.util.Calendar,char,java.util.Locale);
	*** print(java.math.BigDecimal,java.util.Locale);
	*** print(java.math.BigInteger,java.util.Locale);
	*** print(java.util.Calendar,char,java.util.Locale);
	*** print(long,java.util.Locale);
	*** print(short,java.util.Locale);
	*** printBoolean(java.lang.Object);
	*** printCharacter(java.lang.Object);
	*** printDateTime(java.lang.Object,java.util.Locale);
	*** printFloat(java.lang.Object,java.util.Locale);
	*** printHashCode(java.lang.Object);
	*** printInteger(java.lang.Object,java.util.Locale);
	*** printString(java.lang.Object,java.util.Locale);
	*** toString();
	*** trailingSign(java.lang.StringBuilder,boolean);
	*** trailingZeros(char[],int);
	*** width(java.lang.String);
}

-keep class java.util.Formatter$FormatSpecifier$BigDecimalLayout {
	*** exponent();
	*** hasDot();
	*** mantissa();
	*** scale();
}

-keep class java.util.Formatter$FormatString {
	*** index();
	*** print(java.lang.Object,java.util.Locale);
	*** toString();
}

-keep class java.util.GregorianCalendar {
	*** $assertionsDisabled;
	*** LEAP_MONTH_LENGTH;
	*** LEAST_MAX_VALUES;
	*** MAX_VALUES;
	*** MIN_VALUES;
	*** MONTH_LENGTH;
	*** cachedFixedDate;
	*** calsys;
	*** cdate;
	*** gcal;
	*** gdate;
	*** gregorianCutover;
	*** gregorianCutoverDate;
	*** gregorianCutoverYear;
	*** gregorianCutoverYearJulian;
	*** jcal;
	*** jeras;
	*** originalFields;
	*** zoneOffsets;
	java.util.GregorianCalendar(int,int,int,int,int,int,int);
	java.util.GregorianCalendar(java.util.TimeZone,java.util.Locale);
	*** actualMonthLength();
	*** add(int,int);
	*** clone();
	*** computeFields(int,int);
	*** getActualMaximum(int);
	*** getActualMinimum(int);
	*** getCalendarDate(long);
	*** getCurrentFixedDate();
	*** getCutoverCalendarSystem();
	*** getFixedDate(sun.util.calendar.BaseCalendar,int,int);
	*** getFixedDateJan1(sun.util.calendar.BaseCalendar$Date,long);
	*** getFixedDateMonth1(sun.util.calendar.BaseCalendar$Date,long);
	*** getGregorianCutoverDate();
	*** getJulianCalendarSystem();
	*** getLastJulianDate();
	*** getMaximum(int);
	*** getMinimum(int);
	*** getNormalizedCalendar();
	*** getRolledValue(int,int,int,int);
	*** getWeekNumber(long,long);
	*** getWeekYear();
	*** getYearOffsetInMillis();
	*** internalGetEra();
	*** isCutoverYear(int);
	*** isLeapYear(int);
	*** monthLength(int);
	*** monthLength(int,int);
	*** pinDayOfMonth();
	*** roll(int,int);
	*** setGregorianChange(long);
	*** setTimeZone(java.util.TimeZone);
	*** setWeekDate(int,int,int);
	*** yearLength(int);
}

-keep class java.util.HashMap {
	*** size;
	java.util.HashMap();
	java.util.HashMap(int);
	java.util.HashMap(java.util.Map);
	*** clear();
	*** clone();
	*** containsKey(java.lang.Object);
	*** containsValue(java.lang.Object);
	*** entrySet();
	*** get(java.lang.Object);
	*** isEmpty();
	*** keySet();
	*** newValueIterator();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** remove(java.lang.Object);
	*** size();
	*** values();
}

-keep class java.util.HashMap$Entry {
	*** value;
	*** getKey();
}

-keep class java.util.HashMap$EntryIterator {
	*;
}

-keep class java.util.HashMap$EntrySet {
	*;
}

-keep class java.util.HashMap$HashIterator {
	java.util.HashMap$HashIterator(java.util.HashMap);
	*** nextEntry();
}

-keep class java.util.HashMap$Holder {
	*;
}

-keep class java.util.HashMap$KeyIterator {
	*** this$0;
	java.util.HashMap$KeyIterator(java.util.HashMap);
}

-keep class java.util.HashMap$KeySet {
	*;
}

-keep class java.util.HashMap$ValueIterator {
	*** this$0;
	java.util.HashMap$ValueIterator(java.util.HashMap);
}

-keep class java.util.HashMap$Values {
	*** this$0;
	java.util.HashMap$Values(java.util.HashMap);
}

-keep class java.util.HashSet {
	java.util.HashSet(int,float,boolean);
	*** add(java.lang.Object);
	*** clear();
	*** clone();
	*** contains(java.lang.Object);
	*** isEmpty();
	*** iterator();
	*** remove(java.lang.Object);
	*** size();
}

-keep class java.util.Hashtable {
	java.util.Hashtable();
	java.util.Hashtable(int);
	java.util.Hashtable(int,float);
	*** clear();
	*** clone();
	*** containsKey(java.lang.Object);
	*** elements();
	*** entrySet();
	*** get(java.lang.Object);
	*** isEmpty();
	*** keySet();
	*** keys();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** rehash();
	*** remove(java.lang.Object);
	*** size();
	*** toString();
	*** values();
}

-keep class java.util.Hashtable$Entry {
	*;
}

-keep class java.util.Hashtable$EntrySet {
	*;
}

-keep class java.util.Hashtable$Enumerator {
	*;
}

-keep class java.util.Hashtable$Holder {
	*;
}

-keep class java.util.IdentityHashMap {
	*** NULL_KEY;
	*** entrySet;
	*** modCount;
	*** size;
	*** table;
	*** threshold;
	java.util.IdentityHashMap(int);
	*** access$000(java.util.IdentityHashMap);
	*** access$010(java.util.IdentityHashMap);
	*** access$100(java.util.IdentityHashMap);
	*** access$1500(java.util.IdentityHashMap,java.lang.Object,java.lang.Object);
	*** access$1600(java.util.IdentityHashMap,java.lang.Object,java.lang.Object);
	*** access$200(java.util.IdentityHashMap);
	*** access$204(java.util.IdentityHashMap);
	*** access$300(int,int);
	*** access$400(java.lang.Object,int);
	*** access$600(java.lang.Object);
	*** capacity(int);
	*** clear();
	*** closeDeletion(int);
	*** containsKey(java.lang.Object);
	*** containsMapping(java.lang.Object,java.lang.Object);
	*** containsValue(java.lang.Object);
	*** entrySet();
	*** get(java.lang.Object);
	*** hash(java.lang.Object,int);
	*** init(int);
	*** keySet();
	*** maskNull(java.lang.Object);
	*** nextKeyIndex(int,int);
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** putForCreate(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** removeMapping(java.lang.Object,java.lang.Object);
	*** resize(int);
	*** size();
	*** unmaskNull(java.lang.Object);
}

-keep class java.util.IdentityHashMap$EntryIterator {
	*** lastReturnedEntry;
	*** this$0;
	java.util.IdentityHashMap$EntryIterator(java.util.IdentityHashMap);
	*** next();
}

-keep class java.util.IdentityHashMap$EntryIterator$Entry {
	*** index;
	*** this$1;
	java.util.IdentityHashMap$EntryIterator$Entry(java.util.IdentityHashMap$EntryIterator,int);
	*** access$800(java.util.IdentityHashMap$EntryIterator$Entry);
	*** access$802(java.util.IdentityHashMap$EntryIterator$Entry,int);
	*** checkIndexForEntryUse();
}

-keep class java.util.IdentityHashMap$EntrySet {
	*** this$0;
	java.util.IdentityHashMap$EntrySet(java.util.IdentityHashMap);
	*** iterator();
	*** size();
}

-keep class java.util.IdentityHashMap$IdentityHashMapIterator {
	*** expectedModCount;
	*** index;
	*** indexValid;
	*** lastReturnedIndex;
	*** this$0;
	*** traversalTable;
	java.util.IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap);
	java.util.IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap,java.util.IdentityHashMap$1);
	*** hasNext();
	*** nextIndex();
	*** remove();
}

-keep class java.util.IdentityHashMap$KeyIterator {
	*** this$0;
	java.util.IdentityHashMap$KeyIterator(java.util.IdentityHashMap);
}

-keep class java.util.IdentityHashMap$KeySet {
	*** this$0;
	java.util.IdentityHashMap$KeySet(java.util.IdentityHashMap);
	*** iterator();
}

-keep class java.util.IdentityHashMap$ValueIterator {
	*** this$0;
	java.util.IdentityHashMap$ValueIterator(java.util.IdentityHashMap);
}

-keep class java.util.IdentityHashMap$Values {
	*** this$0;
	java.util.IdentityHashMap$Values(java.util.IdentityHashMap);
	*** iterator();
}

-keep class java.util.Iterator {
	*** hasNext();
	*** next();
	*** remove();
}

-keep class java.util.LinkedHashMap {
	java.util.LinkedHashMap(int,float,boolean);
	*** clear();
	*** get(java.lang.Object);
}

-keep class java.util.LinkedHashMap$Entry {
	*;
}

-keep class java.util.LinkedHashMap$EntryIterator {
	*** this$0;
	java.util.LinkedHashMap$EntryIterator(java.util.LinkedHashMap);
	*** next();
}

-keep class java.util.LinkedHashMap$KeyIterator {
	*;
}

-keep class java.util.LinkedHashMap$LinkedHashIterator {
	java.util.LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap,java.util.LinkedHashMap$1);
	*** nextEntry();
}

-keep class java.util.LinkedHashMap$ValueIterator {
	*** this$0;
	java.util.LinkedHashMap$ValueIterator(java.util.LinkedHashMap);
}

-keep class java.util.LinkedList {
	*** last;
	*** size;
	*** add(int,java.lang.Object);
	*** add(java.lang.Object);
	*** addFirst(java.lang.Object);
	*** addLast(java.lang.Object);
	*** clear();
	*** clone();
	*** contains(java.lang.Object);
	*** get(int);
	*** getFirst();
	*** getLast();
	*** linkBefore(java.lang.Object,java.util.LinkedList$Node);
	*** linkLast(java.lang.Object);
	*** listIterator(int);
	*** node(int);
	*** poll();
	*** remove(java.lang.Object);
	*** removeFirst();
	*** removeLast();
	*** size();
	*** toArray(java.lang.Object[]);
	*** unlink(java.util.LinkedList$Node);
}

-keep class java.util.LinkedList$ListItr {
	*** expectedModCount;
	*** lastReturned;
	*** next;
	*** nextIndex;
	*** this$0;
	*** checkForComodification();
	*** hasNext();
	*** hasPrevious();
}

-keep class java.util.LinkedList$Node {
	*** item;
	*** next;
	*** prev;
}

-keep class java.util.List {
	*** add(int,java.lang.Object);
	*** add(java.lang.Object);
	*** addAll(int,java.util.Collection);
	*** addAll(java.util.Collection);
	*** clear();
	*** contains(java.lang.Object);
	*** equals(java.lang.Object);
	*** get(int);
	*** hashCode();
	*** indexOf(java.lang.Object);
	*** isEmpty();
	*** iterator();
	*** lastIndexOf(java.lang.Object);
	*** listIterator();
	*** listIterator(int);
	*** remove(int);
	*** remove(java.lang.Object);
	*** removeAll(java.util.Collection);
	*** set(int,java.lang.Object);
	*** size();
	*** subList(int,int);
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class java.util.ListIterator {
	*** add(java.lang.Object);
	*** hasNext();
	*** hasPrevious();
	*** next();
	*** nextIndex();
	*** previous();
	*** previousIndex();
	*** remove();
	*** set(java.lang.Object);
}

-keep class java.util.ListResourceBundle {
	*** lookup;
	java.util.ListResourceBundle();
	*** getContents();
	*** loadLookup();
}

-keep class java.util.Locale {
	*** CANADA_FRENCH;
	*** CHINA;
	*** CHINESE;
	*** ENGLISH;
	*** FRANCE;
	*** GERMANY;
	*** ITALY;
	*** JAPAN;
	*** KOREA;
	*** ROOT;
	*** US;
	*** equals(java.lang.Object);
	*** forLanguageTag(java.lang.String);
	*** getAvailableLocales();
	*** getBaseLocale();
	*** getCountry();
	*** getDefault();
	*** getDefault(java.util.Locale$Category);
	*** getDisplayLanguage();
	*** getDisplayName();
	*** getExtensionKeys();
	*** getInstance(java.lang.String,java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.lang.String,java.lang.String,java.lang.String,sun.util.locale.LocaleExtensions);
	*** getLanguage();
	*** getScript();
	*** getUnicodeLocaleType(java.lang.String);
	*** getVariant();
	*** hashCode();
	*** setDefault(java.util.Locale);
	*** toLanguageTag();
	*** toString();
}

-keep class java.util.Locale$1 {
	*** $SwitchMap$java$util$Locale$Category;
}

-keep class java.util.Locale$Builder {
	*** build();
	*** clearExtensions();
	*** setLocale(java.util.Locale);
}

-keep class java.util.Locale$Cache {
	*;
}

-keep class java.util.Locale$Category {
	*** $VALUES;
	*** DISPLAY;
	*** FORMAT;
	*** countryKey;
	*** languageKey;
	*** scriptKey;
	*** variantKey;
	*** values();
}

-keep class java.util.Locale$LocaleKey {
	*;
}

-keep class java.util.Map {
	*** clear();
	*** containsKey(java.lang.Object);
	*** containsValue(java.lang.Object);
	*** entrySet();
	*** equals(java.lang.Object);
	*** get(java.lang.Object);
	*** hashCode();
	*** isEmpty();
	*** keySet();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** remove(java.lang.Object);
	*** size();
	*** values();
}

-keep class java.util.Map$Entry {
	*** getKey();
	*** getValue();
	*** hashCode();
	*** setValue(java.lang.Object);
}

-keep class java.util.MissingResourceException {
	*** className;
	*** key;
}

-keep class java.util.NavigableMap {
	*** ceilingKey(java.lang.Object);
	*** descendingMap();
	*** floorKey(java.lang.Object);
	*** headMap(java.lang.Object,boolean);
	*** higherKey(java.lang.Object);
	*** lowerKey(java.lang.Object);
	*** pollFirstEntry();
	*** pollLastEntry();
	*** subMap(java.lang.Object,boolean,java.lang.Object,boolean);
	*** tailMap(java.lang.Object,boolean);
}

-keep class java.util.NavigableSet {
	*** iterator();
}

-keep class java.util.Objects {
	*** equals(java.lang.Object,java.lang.Object);
	*** requireNonNull(java.lang.Object);
	*** requireNonNull(java.lang.Object,java.lang.String);
}

-keep class java.util.PriorityQueue {
	*** $assertionsDisabled;
	*** comparator;
	*** modCount;
	*** queue;
	*** size;
	java.util.PriorityQueue(int,java.util.Comparator);
	*** access$100(java.util.PriorityQueue);
	*** access$200(java.util.PriorityQueue);
	*** access$300(java.util.PriorityQueue);
	*** access$400(java.util.PriorityQueue,int);
	*** comparator();
	*** grow(int);
	*** heapify();
	*** hugeCapacity(int);
	*** indexOf(java.lang.Object);
	*** initElementsFromCollection(java.util.Collection);
	*** initFromCollection(java.util.Collection);
	*** initFromPriorityQueue(java.util.PriorityQueue);
	*** offer(java.lang.Object);
	*** removeAt(int);
	*** removeEq(java.lang.Object);
	*** siftDown(int,java.lang.Object);
	*** siftDownComparable(int,java.lang.Object);
	*** siftDownUsingComparator(int,java.lang.Object);
	*** siftUp(int,java.lang.Object);
	*** siftUpComparable(int,java.lang.Object);
	*** siftUpUsingComparator(int,java.lang.Object);
	*** size();
	*** toArray();
}

-keep class java.util.PriorityQueue$Itr {
	*** cursor;
	*** expectedModCount;
	*** forgetMeNot;
	*** lastRet;
	*** lastRetElt;
	*** this$0;
	java.util.PriorityQueue$Itr(java.util.PriorityQueue);
}

-keep class java.util.Properties {
	*** defaults;
	java.util.Properties();
	*** getProperty(java.lang.String);
	*** getProperty(java.lang.String,java.lang.String);
	*** load(java.io.InputStream);
	*** load(java.io.Reader);
	*** propertyNames();
	*** save(java.io.OutputStream,java.lang.String);
	*** setProperty(java.lang.String,java.lang.String);
	*** store(java.io.OutputStream,java.lang.String);
	*** store(java.io.Writer,java.lang.String);
	*** stringPropertyNames();
}

-keep class java.util.Properties$LineReader {
	*** inByteBuf;
	*** inCharBuf;
	*** inLimit;
	*** inOff;
	*** inStream;
	*** lineBuf;
	*** reader;
	*** this$0;
}

-keep class java.util.PropertyPermission {
	*** actions;
	*** mask;
	*** getActions();
	*** getActions(int);
	*** getMask(java.lang.String);
	*** init(int);
}

-keep class java.util.PropertyResourceBundle {
	*** lookup;
	java.util.PropertyResourceBundle(java.io.InputStream);
	*** getKeys();
}

-keep class java.util.Queue {
	*** add(java.lang.Object);
	*** offer(java.lang.Object);
	*** peek();
	*** poll();
	*** remove();
}

-keep class java.util.Random {
	java.util.Random();
	java.util.Random(long);
	*** nextBoolean();
	*** nextBytes(byte[]);
	*** nextDouble();
	*** nextFloat();
	*** nextInt();
	*** nextInt(int);
	*** nextLong();
	*** setSeed(long);
}

-keep class java.util.RandomAccess {
	*;
}

-keep class java.util.RegularEnumSet {
	*** elements;
	*** add(java.lang.Enum);
	*** isEmpty();
}

-keep class java.util.ResourceBundle {
	*** $assertionsDisabled;
	*** NONEXISTENT_BUNDLE;
	*** cacheKey;
	*** cacheList;
	*** expired;
	*** keySet;
	*** locale;
	*** name;
	*** parent;
	*** referenceQueue;
	java.util.ResourceBundle();
	*** access$200();
	*** checkList(java.util.List);
	*** clearCache(java.lang.ClassLoader);
	*** findBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.List,int,java.util.ResourceBundle$Control,java.util.ResourceBundle);
	*** findBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle$Control);
	*** getBundle(java.lang.String);
	*** getBundle(java.lang.String,java.util.Locale);
	*** getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader);
	*** getBundle(java.lang.String,java.util.Locale,java.util.ResourceBundle$Control);
	*** getBundle(java.lang.String,java.util.ResourceBundle$Control);
	*** getBundleImpl(java.lang.String,java.util.Locale,java.lang.ClassLoader,java.util.ResourceBundle$Control);
	*** getKeys();
	*** getLoader(java.lang.Class);
	*** getLocale();
	*** getObject(java.lang.String);
	*** getString(java.lang.String);
	*** getStringArray(java.lang.String);
	*** handleGetObject(java.lang.String);
	*** handleKeySet();
	*** hasValidParentChain(java.util.ResourceBundle);
	*** isValidBundle(java.util.ResourceBundle);
	*** loadBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.ResourceBundle$Control,boolean);
	*** putBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle,java.util.ResourceBundle$Control);
	*** setExpirationTime(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle$Control);
	*** setParent(java.util.ResourceBundle);
	*** throwMissingResourceException(java.lang.String,java.util.Locale,java.lang.Throwable);
}

-keep class java.util.ResourceBundle$BundleReference {
	*** cacheKey;
	*** getCacheKey();
}

-keep class java.util.ResourceBundle$CacheKey {
	*** cause;
	*** expirationTime;
	*** format;
	*** hashCodeCache;
	*** loadTime;
	*** loaderRef;
	*** locale;
	*** name;
	*** access$400(java.util.ResourceBundle$CacheKey);
	*** access$500(java.util.ResourceBundle$CacheKey,java.lang.Throwable);
	*** access$600(java.util.ResourceBundle$CacheKey);
	*** access$602(java.util.ResourceBundle$CacheKey,long);
	*** access$700(java.util.ResourceBundle$CacheKey);
	*** access$702(java.util.ResourceBundle$CacheKey,long);
	*** calculateHashCode();
	*** clone();
	*** getCause();
	*** getFormat();
	*** getLoader();
	*** getLocale();
	*** getName();
	*** setCause(java.lang.Throwable);
	*** setFormat(java.lang.String);
	*** setLocale(java.util.Locale);
}

-keep class java.util.ResourceBundle$CacheKeyReference {
	*** getCacheKey();
}

-keep class java.util.ResourceBundle$Control {
	*** CANDIDATES_CACHE;
	*** FORMAT_CLASS;
	*** FORMAT_DEFAULT;
	*** FORMAT_PROPERTIES;
	*** INSTANCE;
	java.util.ResourceBundle$Control();
	*** access$300();
	*** getCandidateLocales(java.lang.String,java.util.Locale);
	*** getFallbackLocale(java.lang.String,java.util.Locale);
	*** getFormats(java.lang.String);
	*** getTimeToLive(java.lang.String,java.util.Locale);
	*** needsReload(java.lang.String,java.util.Locale,java.lang.String,java.lang.ClassLoader,java.util.ResourceBundle,long);
	*** newBundle(java.lang.String,java.util.Locale,java.lang.String,java.lang.ClassLoader,boolean);
	*** toBundleName(java.lang.String,java.util.Locale);
	*** toResourceName(java.lang.String,java.lang.String);
}

-keep class java.util.ResourceBundle$Control$1 {
	*** this$0;
	*** val$classLoader;
	*** val$reloadFlag;
	*** val$resourceName;
	*** run();
}

-keep class java.util.ResourceBundle$Control$CandidateListCache {
	java.util.ResourceBundle$Control$CandidateListCache();
	*** createObject(sun.util.locale.BaseLocale);
	*** getDefaultList(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
}

-keep class java.util.ResourceBundle$LoaderReference {
	*** cacheKey;
}

-keep class java.util.ResourceBundle$NoFallbackControl {
	*** access$1000();
	*** access$1100();
	*** access$1200();
}

-keep class java.util.ResourceBundle$RBClassLoader {
	*** INSTANCE;
	*** loader;
	java.util.ResourceBundle$RBClassLoader();
	*** access$000();
}

-keep class java.util.ResourceBundle$RBClassLoader$1 {
	*** run();
}

-keep class java.util.ResourceBundle$SingleFormatControl {
	*** CLASS_ONLY;
	*** PROPERTIES_ONLY;
	*** formats;
	*** access$800();
	*** access$900();
}

-keep class java.util.Scanner {
	*** close();
	*** hasNext();
	*** hasNextLine();
	*** next();
	*** nextLine();
	*** useDelimiter(java.lang.String);
}

-keep class java.util.ServiceLoader {
	*** loader;
	*** lookupIterator;
	*** providers;
	*** service;
	*** access$100(java.lang.Class,java.lang.String,java.lang.Throwable);
	*** access$200(java.util.ServiceLoader,java.lang.Class,java.net.URL);
	*** access$300(java.lang.Class,java.lang.String);
	*** access$400(java.util.ServiceLoader);
	*** access$500(java.util.ServiceLoader);
	*** fail(java.lang.Class,java.lang.String);
	*** fail(java.lang.Class,java.lang.String,java.lang.Throwable);
	*** fail(java.lang.Class,java.net.URL,int,java.lang.String);
	*** iterator();
	*** load(java.lang.Class,java.lang.ClassLoader);
	*** loadInstalled(java.lang.Class);
	*** parse(java.lang.Class,java.net.URL);
	*** parseLine(java.lang.Class,java.net.URL,java.io.BufferedReader,int,java.util.List);
	*** reload();
}

-keep class java.util.ServiceLoader$1 {
	*** knownProviders;
	*** this$0;
}

-keep class java.util.ServiceLoader$LazyIterator {
	*** configs;
	*** loader;
	*** nextName;
	*** pending;
	*** service;
	*** this$0;
	java.util.ServiceLoader$LazyIterator(java.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader);
	*** hasNext();
	*** next();
}

-keep class java.util.Set {
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
	*** clear();
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** equals(java.lang.Object);
	*** hashCode();
	*** isEmpty();
	*** iterator();
	*** remove(java.lang.Object);
	*** removeAll(java.util.Collection);
	*** retainAll(java.util.Collection);
	*** size();
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class java.util.SimpleTimeZone {
	*** getOffset(long);
	*** getRawOffset();
	*** inDaylightTime(java.util.Date);
	*** setRawOffset(int);
}

-keep class java.util.SortedMap {
	*** comparator();
	*** entrySet();
	*** firstKey();
	*** headMap(java.lang.Object);
	*** lastKey();
	*** subMap(java.lang.Object,java.lang.Object);
	*** tailMap(java.lang.Object);
}

-keep class java.util.SortedSet {
	*** comparator();
	*** first();
	*** last();
}

-keep class java.util.Stack {
	*** peek();
	*** pop();
	*** push(java.lang.Object);
}

-keep class java.util.StringTokenizer {
	java.util.StringTokenizer(java.lang.String);
	*** countTokens();
	*** hasMoreElements();
	*** hasMoreTokens();
	*** nextElement();
	*** nextToken();
}

-keep class java.util.TaskQueue {
	*** $assertionsDisabled;
	*** queue;
	*** size;
	*** add(java.util.TimerTask);
	*** clear();
	*** fixDown(int);
	*** fixUp(int);
	*** get(int);
	*** getMin();
	*** heapify();
	*** isEmpty();
	*** quickRemove(int);
	*** removeMin();
	*** rescheduleMin(long);
	*** size();
}

-keep class java.util.TimSort {
	*** $assertionsDisabled;
	*** a;
	*** c;
	*** minGallop;
	*** runBase;
	*** runLen;
	*** stackSize;
	*** tmp;
	*** binarySort(java.lang.Object[],int,int,int,java.util.Comparator);
	*** countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator);
	*** ensureCapacity(int);
	*** gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator);
	*** gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator);
	*** mergeAt(int);
	*** mergeCollapse();
	*** mergeForceCollapse();
	*** mergeHi(int,int,int,int);
	*** mergeLo(int,int,int,int);
	*** minRunLength(int);
	*** pushRun(int,int);
	*** rangeCheck(int,int,int);
	*** reverseRange(java.lang.Object[],int,int);
	*** sort(java.lang.Object[],int,int,java.util.Comparator);
}

-keep class java.util.TimeZone {
	*** $assertionsDisabled;
	*** ID;
	*** NO_TIMEZONE;
	*** defaultTimeZone;
	*** mainAppContextDefault;
	java.util.TimeZone();
	*** clone();
	*** getDSTSavings();
	*** getDefault();
	*** getDefaultInAppContext();
	*** getDefaultRef();
	*** getDisplayName(boolean,int,java.util.Locale);
	*** getDisplayNames(java.lang.String,java.util.Locale);
	*** getID();
	*** getOffset(long);
	*** getOffsets(long,int[]);
	*** getRawOffset();
	*** getSystemGMTOffsetID();
	*** getSystemTimeZoneID(java.lang.String,java.lang.String);
	*** getTimeZone(java.lang.String);
	*** getTimeZone(java.lang.String,boolean);
	*** hasPermission();
	*** hasSameRules(java.util.TimeZone);
	*** inDaylightTime(java.util.Date);
	*** parseCustomTimeZone(java.lang.String);
	*** setDefaultInAppContext(java.util.TimeZone);
	*** setDefaultZone();
	*** setID(java.lang.String);
	*** useDaylightTime();
}

-keep class java.util.TimeZone$1 {
	*** val$id;
}

-keep class java.util.TimeZone$DisplayNames {
	*** CACHE;
	*** access$000();
}

-keep class java.util.Timer {
	*** nextSerialNumber;
	*** queue;
	*** thread;
	*** threadReaper;
	java.util.Timer(java.lang.String);
	java.util.Timer(java.lang.String,boolean);
	*** access$000(java.util.Timer);
	*** access$100(java.util.Timer);
	*** cancel();
	*** sched(java.util.TimerTask,long,long);
	*** schedule(java.util.TimerTask,long);
	*** schedule(java.util.TimerTask,long,long);
	*** serialNumber();
}

-keep class java.util.Timer$1 {
	*** this$0;
}

-keep class java.util.TimerTask {
	*** lock;
	*** nextExecutionTime;
	*** period;
	*** state;
	java.util.TimerTask();
	*** cancel();
	*** run();
}

-keep class java.util.TimerThread {
	*** newTasksMayBeScheduled;
	*** queue;
	*** mainLoop();
}

-keep class java.util.TreeMap {
	*** access$000(java.util.TreeMap,java.util.TreeMap$Entry);
	*** access$100(java.util.TreeMap);
	*** clear();
	*** containsValue(java.lang.Object);
	*** descendingKeyIterator();
	*** get(java.lang.Object);
	*** getEntry(java.lang.Object);
	*** getFirstEntry();
	*** keyIterator();
	*** keySet();
	*** predecessor(java.util.TreeMap$Entry);
	*** put(java.lang.Object,java.lang.Object);
	*** size();
	*** successor(java.util.TreeMap$Entry);
	*** valEquals(java.lang.Object,java.lang.Object);
}

-keep class java.util.TreeMap$Entry {
	*** key;
	*** left;
	*** right;
	*** value;
	*** getValue();
}

-keep class java.util.TreeMap$EntryIterator {
	*** this$0;
	*** next();
}

-keep class java.util.TreeMap$EntrySet {
	*** this$0;
}

-keep class java.util.TreeMap$KeyIterator {
	*** this$0;
}

-keep class java.util.TreeMap$KeySet {
	*** m;
	*** headSet(java.lang.Object,boolean);
	*** size();
	*** subSet(java.lang.Object,boolean,java.lang.Object,boolean);
	*** tailSet(java.lang.Object,boolean);
}

-keep class java.util.TreeMap$NavigableSubMap {
	*** descendingKeyIterator();
	*** keyIterator();
}

-keep class java.util.TreeMap$PrivateEntryIterator {
	*** expectedModCount;
	*** lastReturned;
	*** next;
	*** this$0;
	java.util.TreeMap$PrivateEntryIterator(java.util.TreeMap,java.util.TreeMap$Entry);
	*** nextEntry();
}

-keep class java.util.TreeMap$ValueIterator {
	*** this$0;
}

-keep class java.util.TreeMap$Values {
	*** this$0;
}

-keep class java.util.TreeSet {
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
	*** clear();
	*** isEmpty();
	*** iterator();
	*** remove(java.lang.Object);
	*** size();
}

-keep class java.util.UUID {
	*** $assertionsDisabled;
	*** leastSigBits;
	*** mostSigBits;
	*** compareTo(java.util.UUID);
	*** digits(long,int);
	*** fromString(java.lang.String);
	*** version();
}

-keep class java.util.UUID$Holder {
	*** numberGenerator;
}

-keep class java.util.Vector {
	*** elementCount;
	java.util.Vector();
	*** add(int,java.lang.Object);
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
	*** addElement(java.lang.Object);
	*** clear();
	*** clone();
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** copyInto(java.lang.Object[]);
	*** elementAt(int);
	*** elementData(int);
	*** elements();
	*** get(int);
	*** indexOf(java.lang.Object);
	*** indexOf(java.lang.Object,int);
	*** insertElementAt(java.lang.Object,int);
	*** isEmpty();
	*** iterator();
	*** remove(int);
	*** remove(java.lang.Object);
	*** removeAllElements();
	*** removeElement(java.lang.Object);
	*** removeElementAt(int);
	*** setElementAt(java.lang.Object,int);
	*** setSize(int);
	*** size();
	*** subList(int,int);
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class java.util.Vector$1 {
	*** count;
	*** this$0;
}

-keep class java.util.Vector$Itr {
	*** cursor;
	*** expectedModCount;
	*** lastRet;
	*** this$0;
	java.util.Vector$Itr(java.util.Vector);
	*** checkForComodification();
}

-keep class java.util.WeakHashMap {
	*** modCount;
	*** table;
	*** clear();
	*** get(java.lang.Object);
	*** getEntry(java.lang.Object);
	*** isEmpty();
	*** put(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** removeMapping(java.lang.Object);
	*** size();
}

-keep class java.util.WeakHashMap$Entry {
	*** next;
	*** equals(java.lang.Object);
}

-keep class java.util.WeakHashMap$EntryIterator {
	*** this$0;
	java.util.WeakHashMap$EntryIterator(java.util.WeakHashMap);
	*** next();
}

-keep class java.util.WeakHashMap$EntrySet {
	*** this$0;
	java.util.WeakHashMap$EntrySet(java.util.WeakHashMap);
	*** deepCopy();
	*** iterator();
	*** size();
}

-keep class java.util.WeakHashMap$HashIterator {
	*** currentKey;
	*** entry;
	*** expectedModCount;
	*** index;
	*** lastReturned;
	*** nextKey;
	*** this$0;
	java.util.WeakHashMap$HashIterator(java.util.WeakHashMap);
	*** hasNext();
	*** nextEntry();
}

-keep class java.util.WeakHashMap$Holder {
	*;
}

-keep class java.util.WeakHashMap$KeySet {
	*;
}

-keep class java.util.concurrent.AbstractExecutorService {
	*** $assertionsDisabled;
	java.util.concurrent.AbstractExecutorService();
	*** doInvokeAny(java.util.Collection,boolean,long);
	*** newTaskFor(java.lang.Runnable,java.lang.Object);
	*** newTaskFor(java.util.concurrent.Callable);
	*** submit(java.lang.Runnable);
	*** submit(java.lang.Runnable,java.lang.Object);
	*** submit(java.util.concurrent.Callable);
}

-keep class java.util.concurrent.ArrayBlockingQueue {
	*** count;
	*** items;
	*** lock;
	*** notEmpty;
	*** notFull;
	*** putIndex;
	*** takeIndex;
	java.util.concurrent.ArrayBlockingQueue(int,boolean);
	*** cast(java.lang.Object);
	*** checkNotNull(java.lang.Object);
	*** extract();
	*** inc(int);
	*** insert(java.lang.Object);
	*** itemAt(int);
	*** removeAt(int);
}

-keep class java.util.concurrent.BlockingQueue {
	*** add(java.lang.Object);
	*** drainTo(java.util.Collection);
	*** offer(java.lang.Object);
	*** poll(long,java.util.concurrent.TimeUnit);
	*** put(java.lang.Object);
	*** remove(java.lang.Object);
	*** take();
}

-keep class java.util.concurrent.Callable {
	*** call();
}

-keep class java.util.concurrent.ConcurrentHashMap {
	*** segments;
	*** clear();
	*** containsKey(java.lang.Object);
	*** containsValue(java.lang.Object);
	*** elements();
	*** entryAt(java.util.concurrent.ConcurrentHashMap$HashEntry[],int);
	*** entrySet();
	*** get(java.lang.Object);
	*** isEmpty();
	*** keySet();
	*** keys();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** putIfAbsent(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** remove(java.lang.Object,java.lang.Object);
	*** segmentAt(java.util.concurrent.ConcurrentHashMap$Segment[],int);
	*** size();
	*** values();
}

-keep class java.util.concurrent.ConcurrentHashMap$EntryIterator {
	*** this$0;
	*** next();
}

-keep class java.util.concurrent.ConcurrentHashMap$EntrySet {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentHashMap$HashEntry {
	*** key;
	*** next;
	*** value;
}

-keep class java.util.concurrent.ConcurrentHashMap$HashIterator {
	*** currentTable;
	*** lastReturned;
	*** nextEntry;
	*** nextSegmentIndex;
	*** nextTableIndex;
	*** this$0;
	java.util.concurrent.ConcurrentHashMap$HashIterator(java.util.concurrent.ConcurrentHashMap);
	*** advance();
	*** nextEntry();
}

-keep class java.util.concurrent.ConcurrentHashMap$Holder {
	*;
}

-keep class java.util.concurrent.ConcurrentHashMap$KeyIterator {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentHashMap$KeySet {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentHashMap$Segment {
	*** table;
}

-keep class java.util.concurrent.ConcurrentHashMap$ValueIterator {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentHashMap$Values {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentHashMap$WriteThroughEntry {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentLinkedQueue {
	*** UNSAFE;
	*** head;
	*** headOffset;
	*** tail;
	*** tailOffset;
	*** add(java.lang.Object);
	*** casHead(java.util.concurrent.ConcurrentLinkedQueue$Node,java.util.concurrent.ConcurrentLinkedQueue$Node);
	*** casTail(java.util.concurrent.ConcurrentLinkedQueue$Node,java.util.concurrent.ConcurrentLinkedQueue$Node);
	*** checkNotNull(java.lang.Object);
	*** first();
	*** iterator();
	*** offer(java.lang.Object);
	*** poll();
	*** remove(java.lang.Object);
	*** size();
	*** succ(java.util.concurrent.ConcurrentLinkedQueue$Node);
	*** updateHead(java.util.concurrent.ConcurrentLinkedQueue$Node,java.util.concurrent.ConcurrentLinkedQueue$Node);
}

-keep class java.util.concurrent.ConcurrentLinkedQueue$Itr {
	*** lastRet;
	*** nextItem;
	*** nextNode;
	*** this$0;
	*** advance();
}

-keep class java.util.concurrent.ConcurrentLinkedQueue$Node {
	*** UNSAFE;
	*** item;
	*** itemOffset;
	*** next;
	*** nextOffset;
	*** casItem(java.lang.Object,java.lang.Object);
	*** casNext(java.util.concurrent.ConcurrentLinkedQueue$Node,java.util.concurrent.ConcurrentLinkedQueue$Node);
	*** lazySetNext(java.util.concurrent.ConcurrentLinkedQueue$Node);
}

-keep class java.util.concurrent.ConcurrentMap {
	*** putIfAbsent(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object,java.lang.Object);
	*** replace(java.lang.Object,java.lang.Object);
}

-keep class java.util.concurrent.ConcurrentNavigableMap {
	*** descendingMap();
	*** headMap(java.lang.Object,boolean);
	*** navigableKeySet();
	*** subMap(java.lang.Object,boolean,java.lang.Object,boolean);
	*** tailMap(java.lang.Object,boolean);
}

-keep class java.util.concurrent.ConcurrentSkipListMap {
	*** BASE_HEADER;
	*** UNSAFE;
	*** comparator;
	*** descendingMap;
	*** entrySet;
	*** head;
	*** headOffset;
	*** keySet;
	*** randomSeed;
	*** seedGenerator;
	*** values;
	*** access$000();
	*** addIndex(java.util.concurrent.ConcurrentSkipListMap$Index,java.util.concurrent.ConcurrentSkipListMap$HeadIndex,int);
	*** buildFromSorted(java.util.SortedMap);
	*** casHead(java.util.concurrent.ConcurrentSkipListMap$HeadIndex,java.util.concurrent.ConcurrentSkipListMap$HeadIndex);
	*** clearIndexToFirst();
	*** clone();
	*** comparable(java.lang.Object);
	*** compare(java.lang.Object,java.lang.Object);
	*** descendingMap();
	*** doGet(java.lang.Object);
	*** doPut(java.lang.Object,java.lang.Object,boolean);
	*** doRemove(java.lang.Object,java.lang.Object);
	*** doRemoveFirstEntry();
	*** doRemoveLastEntry();
	*** entryIterator();
	*** entrySet();
	*** findFirst();
	*** findLast();
	*** findNear(java.lang.Object,int);
	*** findNode(java.lang.Comparable);
	*** findPredecessor(java.lang.Comparable);
	*** findPredecessorOfLast();
	*** get(java.lang.Object);
	*** getNear(java.lang.Object,int);
	*** headMap(java.lang.Object);
	*** headMap(java.lang.Object,boolean);
	*** initialize();
	*** insertIndex(java.util.concurrent.ConcurrentSkipListMap$Node,int);
	*** keyIterator();
	*** keySet();
	*** randomLevel();
	*** remove(java.lang.Object);
	*** subMap(java.lang.Object,boolean,java.lang.Object,boolean);
	*** subMap(java.lang.Object,java.lang.Object);
	*** tailMap(java.lang.Object);
	*** tailMap(java.lang.Object,boolean);
	*** toList(java.util.Collection);
	*** tryReduceLevel();
	*** valueIterator();
}

-keep class java.util.concurrent.ConcurrentSkipListMap$EntrySet {
	*** m;
}

-keep class java.util.concurrent.ConcurrentSkipListMap$HeadIndex {
	*** level;
}

-keep class java.util.concurrent.ConcurrentSkipListMap$Index {
	*** UNSAFE;
	*** down;
	*** node;
	*** right;
	*** rightOffset;
	java.util.concurrent.ConcurrentSkipListMap$Index(java.util.concurrent.ConcurrentSkipListMap$Node,java.util.concurrent.ConcurrentSkipListMap$Index,java.util.concurrent.ConcurrentSkipListMap$Index);
	*** casRight(java.util.concurrent.ConcurrentSkipListMap$Index,java.util.concurrent.ConcurrentSkipListMap$Index);
	*** indexesDeletedNode();
	*** link(java.util.concurrent.ConcurrentSkipListMap$Index,java.util.concurrent.ConcurrentSkipListMap$Index);
	*** unlink(java.util.concurrent.ConcurrentSkipListMap$Index);
}

-keep class java.util.concurrent.ConcurrentSkipListMap$Iter {
	*** lastReturned;
	*** next;
	*** nextValue;
	*** this$0;
	java.util.concurrent.ConcurrentSkipListMap$Iter(java.util.concurrent.ConcurrentSkipListMap);
	*** advance();
}

-keep class java.util.concurrent.ConcurrentSkipListMap$KeySet {
	*** m;
	*** descendingSet();
	*** headSet(java.lang.Object);
	*** headSet(java.lang.Object,boolean);
	*** subSet(java.lang.Object,boolean,java.lang.Object,boolean);
	*** subSet(java.lang.Object,java.lang.Object);
	*** tailSet(java.lang.Object);
	*** tailSet(java.lang.Object,boolean);
}

-keep class java.util.concurrent.ConcurrentSkipListMap$Node {
	*** UNSAFE;
	*** key;
	*** next;
	*** nextOffset;
	*** value;
	*** valueOffset;
	*** appendMarker(java.util.concurrent.ConcurrentSkipListMap$Node);
	*** casNext(java.util.concurrent.ConcurrentSkipListMap$Node,java.util.concurrent.ConcurrentSkipListMap$Node);
	*** casValue(java.lang.Object,java.lang.Object);
	*** createSnapshot();
	*** getValidValue();
	*** helpDelete(java.util.concurrent.ConcurrentSkipListMap$Node,java.util.concurrent.ConcurrentSkipListMap$Node);
	*** isBaseHeader();
}

-keep class java.util.concurrent.ConcurrentSkipListMap$SubMap {
	*** entryIterator();
	*** keyIterator();
	*** valueIterator();
}

-keep class java.util.concurrent.ConcurrentSkipListMap$ValueIterator {
	*** this$0;
}

-keep class java.util.concurrent.ConcurrentSkipListMap$Values {
	*** m;
}

-keep class java.util.concurrent.CopyOnWriteArrayList {
	*** UNSAFE;
	*** array;
	*** lock;
	*** lockOffset;
	*** add(java.lang.Object);
	*** addAllAbsent(java.util.Collection);
	*** addIfAbsent(java.lang.Object);
	*** clear();
	*** contains(java.lang.Object);
	*** containsAll(java.util.Collection);
	*** eq(java.lang.Object,java.lang.Object);
	*** get(java.lang.Object[],int);
	*** getArray();
	*** indexOf(java.lang.Object,java.lang.Object[],int,int);
	*** isEmpty();
	*** iterator();
	*** lastIndexOf(java.lang.Object,java.lang.Object[],int);
	*** remove(java.lang.Object);
	*** removeAll(java.util.Collection);
	*** removeRange(int,int);
	*** resetLock();
	*** retainAll(java.util.Collection);
	*** setArray(java.lang.Object[]);
	*** size();
	*** toArray();
	*** toArray(java.lang.Object[]);
}

-keep class java.util.concurrent.CopyOnWriteArrayList$COWIterator {
	*** cursor;
	*** snapshot;
	java.util.concurrent.CopyOnWriteArrayList$COWIterator(java.lang.Object[],int);
	*** hasNext();
	*** hasPrevious();
}

-keep class java.util.concurrent.CopyOnWriteArraySet {
	*** al;
	*** eq(java.lang.Object,java.lang.Object);
}

-keep class java.util.concurrent.CountDownLatch {
	*** sync;
	*** await();
	*** await(long,java.util.concurrent.TimeUnit);
	*** countDown();
}

-keep class java.util.concurrent.CountDownLatch$Sync {
	*** getCount();
}

-keep class java.util.concurrent.Delayed {
	*** getDelay(java.util.concurrent.TimeUnit);
}

-keep class java.util.concurrent.Executor {
	*** execute(java.lang.Runnable);
}

-keep class java.util.concurrent.ExecutorCompletionService {
	*** aes;
	*** completionQueue;
	*** executor;
	*** access$000(java.util.concurrent.ExecutorCompletionService);
	*** newTaskFor(java.lang.Runnable,java.lang.Object);
	*** newTaskFor(java.util.concurrent.Callable);
	*** poll();
	*** poll(long,java.util.concurrent.TimeUnit);
	*** submit(java.util.concurrent.Callable);
	*** take();
}

-keep class java.util.concurrent.ExecutorCompletionService$QueueingFuture {
	*** task;
	*** this$0;
}

-keep class java.util.concurrent.ExecutorService {
	*** awaitTermination(long,java.util.concurrent.TimeUnit);
	*** invokeAll(java.util.Collection);
	*** invokeAll(java.util.Collection,long,java.util.concurrent.TimeUnit);
	*** invokeAny(java.util.Collection);
	*** invokeAny(java.util.Collection,long,java.util.concurrent.TimeUnit);
	*** isShutdown();
	*** isTerminated();
	*** shutdown();
	*** shutdownNow();
	*** submit(java.lang.Runnable);
	*** submit(java.lang.Runnable,java.lang.Object);
	*** submit(java.util.concurrent.Callable);
}

-keep class java.util.concurrent.Executors {
	*** callable(java.lang.Runnable,java.lang.Object);
	*** defaultThreadFactory();
	*** newCachedThreadPool(java.util.concurrent.ThreadFactory);
	*** newScheduledThreadPool(int,java.util.concurrent.ThreadFactory);
	*** newSingleThreadExecutor();
	*** newSingleThreadExecutor(java.util.concurrent.ThreadFactory);
	*** newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory);
}

-keep class java.util.concurrent.Executors$DefaultThreadFactory {
	*** group;
	*** namePrefix;
	*** poolNumber;
	*** threadNumber;
}

-keep class java.util.concurrent.Executors$DelegatedExecutorService {
	*** e;
	java.util.concurrent.Executors$DelegatedExecutorService(java.util.concurrent.ExecutorService);
	*** shutdown();
}

-keep class java.util.concurrent.Executors$DelegatedScheduledExecutorService {
	*** e;
}

-keep class java.util.concurrent.Executors$RunnableAdapter {
	*** result;
	*** task;
}

-keep class java.util.concurrent.Future {
	*** cancel(boolean);
	*** get();
	*** get(long,java.util.concurrent.TimeUnit);
	*** isCancelled();
	*** isDone();
}

-keep class java.util.concurrent.FutureTask {
	*** UNSAFE;
	*** callable;
	*** outcome;
	*** runner;
	*** runnerOffset;
	*** state;
	*** stateOffset;
	*** waiters;
	*** waitersOffset;
	java.util.concurrent.FutureTask(java.lang.Runnable,java.lang.Object);
	java.util.concurrent.FutureTask(java.util.concurrent.Callable);
	*** awaitDone(boolean,long);
	*** cancel(boolean);
	*** done();
	*** finishCompletion();
	*** get();
	*** handlePossibleCancellationInterrupt(int);
	*** removeWaiter(java.util.concurrent.FutureTask$WaitNode);
	*** report(int);
	*** run();
	*** runAndReset();
	*** set(java.lang.Object);
	*** setException(java.lang.Throwable);
}

-keep class java.util.concurrent.FutureTask$WaitNode {
	*** next;
	*** thread;
}

-keep class java.util.concurrent.LinkedBlockingQueue {
	*** capacity;
	*** count;
	*** head;
	*** last;
	*** notEmpty;
	*** notFull;
	*** putLock;
	*** takeLock;
	java.util.concurrent.LinkedBlockingQueue(int);
	*** dequeue();
	*** drainTo(java.util.Collection,int);
	*** enqueue(java.util.concurrent.LinkedBlockingQueue$Node);
	*** fullyLock();
	*** fullyUnlock();
	*** signalNotEmpty();
	*** signalNotFull();
	*** unlink(java.util.concurrent.LinkedBlockingQueue$Node,java.util.concurrent.LinkedBlockingQueue$Node);
}

-keep class java.util.concurrent.LinkedBlockingQueue$Node {
	*** item;
	*** next;
}

-keep class java.util.concurrent.LinkedTransferQueue {
	*** MP;
	*** UNSAFE;
	*** head;
	*** headOffset;
	*** sweepVotes;
	*** sweepVotesOffset;
	*** tail;
	*** tailOffset;
	java.util.concurrent.LinkedTransferQueue();
	*** awaitMatch(java.util.concurrent.LinkedTransferQueue$Node,java.util.concurrent.LinkedTransferQueue$Node,java.lang.Object,boolean,long);
	*** casHead(java.util.concurrent.LinkedTransferQueue$Node,java.util.concurrent.LinkedTransferQueue$Node);
	*** casSweepVotes(int,int);
	*** casTail(java.util.concurrent.LinkedTransferQueue$Node,java.util.concurrent.LinkedTransferQueue$Node);
	*** cast(java.lang.Object);
	*** countOfMode(boolean);
	*** findAndRemove(java.lang.Object);
	*** firstDataItem();
	*** firstOfMode(boolean);
	*** iterator();
	*** offer(java.lang.Object);
	*** poll();
	*** spinsFor(java.util.concurrent.LinkedTransferQueue$Node,boolean);
	*** succ(java.util.concurrent.LinkedTransferQueue$Node);
	*** sweep();
	*** tryAppend(java.util.concurrent.LinkedTransferQueue$Node,boolean);
	*** unsplice(java.util.concurrent.LinkedTransferQueue$Node,java.util.concurrent.LinkedTransferQueue$Node);
	*** xfer(java.lang.Object,boolean,int,long);
}

-keep class java.util.concurrent.LinkedTransferQueue$Node {
	*** isData;
	*** item;
	*** next;
	*** waiter;
	*** cannotPrecede(boolean);
	*** casItem(java.lang.Object,java.lang.Object);
	*** casNext(java.util.concurrent.LinkedTransferQueue$Node,java.util.concurrent.LinkedTransferQueue$Node);
	*** forgetContents();
	*** forgetNext();
	*** isMatched();
	*** tryMatchData();
}

-keep class java.util.concurrent.RejectedExecutionHandler {
	*** rejectedExecution(java.lang.Runnable,java.util.concurrent.ThreadPoolExecutor);
}

-keep class java.util.concurrent.RunnableScheduledFuture {
	*** isPeriodic();
}

-keep class java.util.concurrent.ScheduledExecutorService {
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
	*** scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit);
}

-keep class java.util.concurrent.ScheduledThreadPoolExecutor {
	*** continueExistingPeriodicTasksAfterShutdown;
	*** executeExistingDelayedTasksAfterShutdown;
	*** removeOnCancel;
	*** sequencer;
	*** access$000();
	*** access$100(java.util.concurrent.ScheduledThreadPoolExecutor);
	*** canRunInCurrentRunState(boolean);
	*** decorateTask(java.lang.Runnable,java.util.concurrent.RunnableScheduledFuture);
	*** decorateTask(java.util.concurrent.Callable,java.util.concurrent.RunnableScheduledFuture);
	*** delayedExecute(java.util.concurrent.RunnableScheduledFuture);
	*** getContinueExistingPeriodicTasksAfterShutdownPolicy();
	*** getExecuteExistingDelayedTasksAfterShutdownPolicy();
	*** now();
	*** onShutdown();
	*** overflowFree(long);
	*** reExecutePeriodic(java.util.concurrent.RunnableScheduledFuture);
	*** schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit);
	*** triggerTime(long);
	*** triggerTime(long,java.util.concurrent.TimeUnit);
}

-keep class java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue {
	*** available;
	*** leader;
	*** lock;
	*** queue;
	*** size;
	*** add(java.lang.Runnable);
	*** finishPoll(java.util.concurrent.RunnableScheduledFuture);
	*** grow();
	*** indexOf(java.lang.Object);
	*** offer(java.lang.Runnable);
	*** offer(java.lang.Runnable,long,java.util.concurrent.TimeUnit);
	*** peek();
	*** poll();
	*** poll(long,java.util.concurrent.TimeUnit);
	*** pollExpired();
	*** put(java.lang.Runnable);
	*** setIndex(java.util.concurrent.RunnableScheduledFuture,int);
	*** siftDown(int,java.util.concurrent.RunnableScheduledFuture);
	*** siftUp(int,java.util.concurrent.RunnableScheduledFuture);
	*** size();
	*** take();
}

-keep class java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask {
	*** heapIndex;
	*** outerTask;
	*** period;
	*** sequenceNumber;
	*** this$0;
	*** time;
	*** access$201(java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask);
	*** access$301(java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask);
	*** cancel(boolean);
	*** compareTo(java.util.concurrent.Delayed);
	*** getDelay(java.util.concurrent.TimeUnit);
	*** isPeriodic();
	*** setNextRunTime();
}

-keep class java.util.concurrent.Semaphore {
	*** sync;
	*** acquire();
	*** release();
	*** tryAcquire(long,java.util.concurrent.TimeUnit);
}

-keep class java.util.concurrent.Semaphore$Sync {
	java.util.concurrent.Semaphore$Sync(int);
	*** drainPermits();
	*** getPermits();
	*** nonfairTryAcquireShared(int);
	*** reducePermits(int);
}

-keep class java.util.concurrent.SynchronousQueue {
	*** NCPUS;
	*** maxTimedSpins;
	*** maxUntimedSpins;
	*** qlock;
	*** transferer;
	*** waitingConsumers;
	*** waitingProducers;
	java.util.concurrent.SynchronousQueue(boolean);
	*** poll();
}

-keep class java.util.concurrent.SynchronousQueue$TransferStack {
	*** UNSAFE;
	*** head;
	*** headOffset;
	*** awaitFulfill(java.util.concurrent.SynchronousQueue$TransferStack$SNode,boolean,long);
	*** casHead(java.util.concurrent.SynchronousQueue$TransferStack$SNode,java.util.concurrent.SynchronousQueue$TransferStack$SNode);
	*** clean(java.util.concurrent.SynchronousQueue$TransferStack$SNode);
	*** isFulfilling(int);
	*** shouldSpin(java.util.concurrent.SynchronousQueue$TransferStack$SNode);
	*** snode(java.util.concurrent.SynchronousQueue$TransferStack$SNode,java.lang.Object,java.util.concurrent.SynchronousQueue$TransferStack$SNode,int);
}

-keep class java.util.concurrent.SynchronousQueue$TransferStack$SNode {
	*** UNSAFE;
	*** item;
	*** match;
	*** matchOffset;
	*** mode;
	*** next;
	*** nextOffset;
	*** waiter;
	*** casNext(java.util.concurrent.SynchronousQueue$TransferStack$SNode,java.util.concurrent.SynchronousQueue$TransferStack$SNode);
	*** isCancelled();
	*** tryCancel();
	*** tryMatch(java.util.concurrent.SynchronousQueue$TransferStack$SNode);
}

-keep class java.util.concurrent.SynchronousQueue$Transferer {
	java.util.concurrent.SynchronousQueue$Transferer();
	*** transfer(java.lang.Object,boolean,long);
}

-keep class java.util.concurrent.ThreadFactory {
	*** newThread(java.lang.Runnable);
}

-keep class java.util.concurrent.ThreadLocalRandom {
	*** current();
}

-keep class java.util.concurrent.ThreadLocalRandom$1 {
	*;
}

-keep class java.util.concurrent.ThreadPoolExecutor {
	*** allowCoreThreadTimeOut;
	*** completedTaskCount;
	*** corePoolSize;
	*** ctl;
	*** defaultHandler;
	*** handler;
	*** keepAliveTime;
	*** largestPoolSize;
	*** mainLock;
	*** maximumPoolSize;
	*** shutdownPerm;
	*** termination;
	*** threadFactory;
	*** workQueue;
	*** workers;
	java.util.concurrent.ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue);
	java.util.concurrent.ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.RejectedExecutionHandler);
	java.util.concurrent.ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory);
	java.util.concurrent.ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory,java.util.concurrent.RejectedExecutionHandler);
	*** addWorker(java.lang.Runnable,boolean);
	*** addWorkerFailed(java.util.concurrent.ThreadPoolExecutor$Worker);
	*** advanceRunState(int);
	*** afterExecute(java.lang.Runnable,java.lang.Throwable);
	*** allowsCoreThreadTimeOut();
	*** beforeExecute(java.lang.Thread,java.lang.Runnable);
	*** checkShutdownAccess();
	*** compareAndDecrementWorkerCount(int);
	*** compareAndIncrementWorkerCount(int);
	*** ctlOf(int,int);
	*** decrementWorkerCount();
	*** drainQueue();
	*** ensurePrestart();
	*** getQueue();
	*** getTask();
	*** getThreadFactory();
	*** interruptIdleWorkers();
	*** interruptIdleWorkers(boolean);
	*** interruptWorkers();
	*** isRunning(int);
	*** isRunningOrShutdown(boolean);
	*** isShutdown();
	*** onShutdown();
	*** processWorkerExit(java.util.concurrent.ThreadPoolExecutor$Worker,boolean);
	*** reject(java.lang.Runnable);
	*** remove(java.lang.Runnable);
	*** runStateAtLeast(int,int);
	*** runStateLessThan(int,int);
	*** runStateOf(int);
	*** runWorker(java.util.concurrent.ThreadPoolExecutor$Worker);
	*** setThreadFactory(java.util.concurrent.ThreadFactory);
	*** shutdown();
	*** shutdownNow();
	*** terminated();
	*** toString();
	*** tryTerminate();
	*** workerCountOf(int);
}

-keep class java.util.concurrent.ThreadPoolExecutor$Worker {
	*** completedTasks;
	*** firstTask;
	*** this$0;
	*** thread;
	*** interruptIfStarted();
	*** isHeldExclusively();
	*** isLocked();
	*** lock();
	*** tryAcquire(int);
	*** tryLock();
	*** unlock();
}

-keep class java.util.concurrent.TimeUnit {
	*** $VALUES;
	*** DAYS;
	*** HOURS;
	*** MICROSECONDS;
	*** MILLISECONDS;
	*** MINUTES;
	*** NANOSECONDS;
	*** SECONDS;
	java.util.concurrent.TimeUnit(java.lang.String,int);
	java.util.concurrent.TimeUnit(java.lang.String,int,java.util.concurrent.TimeUnit$1);
	*** convert(long,java.util.concurrent.TimeUnit);
	*** excessNanos(long,long);
	*** sleep(long);
	*** timedJoin(java.lang.Thread,long);
	*** toDays(long);
	*** toHours(long);
	*** toMicros(long);
	*** toMillis(long);
	*** toMinutes(long);
	*** toNanos(long);
	*** toSeconds(long);
	*** x(long,long,long);
}

-keep class java.util.concurrent.atomic.AtomicBoolean {
	*** unsafe;
	*** value;
	*** valueOffset;
	*** compareAndSet(boolean,boolean);
	*** get();
	*** getAndSet(boolean);
	*** set(boolean);
}

-keep class java.util.concurrent.atomic.AtomicInteger {
	*** addAndGet(int);
	*** compareAndSet(int,int);
	*** decrementAndGet();
	*** get();
	*** getAndAdd(int);
	*** getAndDecrement();
	*** getAndIncrement();
	*** getAndSet(int);
	*** incrementAndGet();
	*** set(int);
}

-keep class java.util.concurrent.atomic.AtomicIntegerFieldUpdater {
	java.util.concurrent.atomic.AtomicIntegerFieldUpdater();
	*** compareAndSet(java.lang.Object,int,int);
	*** get(java.lang.Object);
	*** newUpdater(java.lang.Class,java.lang.String);
}

-keep class java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl {
	*** cclass;
	*** offset;
	*** tclass;
	*** unsafe;
	*** ensureProtectedAccess(java.lang.Object);
	*** fullCheck(java.lang.Object);
}

-keep class java.util.concurrent.atomic.AtomicLong {
	*** VM_SUPPORTS_LONG_CAS;
	*** addAndGet(long);
	*** compareAndSet(long,long);
	*** get();
	*** getAndIncrement();
	*** incrementAndGet();
	*** set(long);
}

-keep class java.util.concurrent.atomic.AtomicLongFieldUpdater {
	java.util.concurrent.atomic.AtomicLongFieldUpdater();
	*** compareAndSet(java.lang.Object,long,long);
	*** get(java.lang.Object);
	*** newUpdater(java.lang.Class,java.lang.String);
}

-keep class java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater {
	*** cclass;
	*** offset;
	*** tclass;
	*** unsafe;
	*** ensureProtectedAccess(java.lang.Object);
	*** fullCheck(java.lang.Object);
}

-keep class java.util.concurrent.atomic.AtomicMarkableReference {
	*** UNSAFE;
	*** pair;
	*** pairOffset;
	*** casPair(java.util.concurrent.atomic.AtomicMarkableReference$Pair,java.util.concurrent.atomic.AtomicMarkableReference$Pair);
	*** compareAndSet(java.lang.Object,java.lang.Object,boolean,boolean);
	*** getReference();
	*** isMarked();
	*** objectFieldOffset(sun.misc.Unsafe,java.lang.String,java.lang.Class);
}

-keep class java.util.concurrent.atomic.AtomicMarkableReference$Pair {
	*** mark;
	*** reference;
	*** of(java.lang.Object,boolean);
}

-keep class java.util.concurrent.atomic.AtomicReference {
	*** unsafe;
	*** value;
	*** valueOffset;
	*** compareAndSet(java.lang.Object,java.lang.Object);
	*** get();
	*** set(java.lang.Object);
}

-keep class java.util.concurrent.atomic.AtomicReferenceArray {
	*** array;
	*** arrayFieldOffset;
	*** base;
	*** shift;
	*** unsafe;
	*** byteOffset(int);
	*** checkedByteOffset(int);
	*** compareAndSet(int,java.lang.Object,java.lang.Object);
	*** compareAndSetRaw(long,java.lang.Object,java.lang.Object);
	*** get(int);
	*** getRaw(long);
	*** length();
	*** set(int,java.lang.Object);
}

-keep class java.util.concurrent.atomic.AtomicReferenceFieldUpdater {
	*** compareAndSet(java.lang.Object,java.lang.Object,java.lang.Object);
	*** getAndSet(java.lang.Object,java.lang.Object);
	*** newUpdater(java.lang.Class,java.lang.Class,java.lang.String);
}

-keep class java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl {
	*;
}

-keep class java.util.concurrent.locks.AbstractOwnableSynchronizer {
	*** getExclusiveOwnerThread();
	*** setExclusiveOwnerThread(java.lang.Thread);
}

-keep class java.util.concurrent.locks.AbstractQueuedSynchronizer {
	java.util.concurrent.locks.AbstractQueuedSynchronizer();
	*** access$000();
	*** acquire(int);
	*** acquireInterruptibly(int);
	*** acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,int);
	*** acquireShared(int);
	*** acquireSharedInterruptibly(int);
	*** apparentlyFirstQueuedIsExclusive();
	*** compareAndSetState(int,int);
	*** fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** getExclusiveQueuedThreads();
	*** getQueueLength();
	*** getQueuedThreads();
	*** getSharedQueuedThreads();
	*** getState();
	*** getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject);
	*** getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject);
	*** hasQueuedPredecessors();
	*** hasQueuedThreads();
	*** hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject);
	*** isHeldExclusively();
	*** isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** isQueued(java.lang.Thread);
	*** release(int);
	*** releaseShared(int);
	*** setState(int);
	*** transferAfterCancelledWait(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** tryAcquireNanos(int,long);
	*** tryAcquireSharedNanos(int,long);
}

-keep class java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject {
	*** firstWaiter;
	*** lastWaiter;
	*** this$0;
	*** addConditionWaiter();
	*** checkInterruptWhileWaiting(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** doSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** doSignalAll(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
	*** reportInterruptAfterWait(int);
	*** unlinkCancelledWaiters();
}

-keep class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node {
	*** nextWaiter;
	*** thread;
	*** waitStatus;
}

-keep class java.util.concurrent.locks.Condition {
	*** await();
	*** await(long,java.util.concurrent.TimeUnit);
	*** awaitNanos(long);
	*** signal();
	*** signalAll();
}

-keep class java.util.concurrent.locks.Lock {
	*** lock();
	*** newCondition();
	*** unlock();
}

-keep class java.util.concurrent.locks.LockSupport {
	*** parkBlockerOffset;
	*** unsafe;
	*** park(java.lang.Object);
	*** parkNanos(java.lang.Object,long);
	*** parkUntil(java.lang.Object,long);
	*** setBlocker(java.lang.Thread,java.lang.Object);
	*** unpark(java.lang.Thread);
}

-keep class java.util.concurrent.locks.ReadWriteLock {
	*** readLock();
	*** writeLock();
}

-keep class java.util.concurrent.locks.ReentrantLock {
	java.util.concurrent.locks.ReentrantLock();
	*** isHeldByCurrentThread();
	*** lock();
	*** lockInterruptibly();
	*** newCondition();
	*** tryLock();
	*** tryLock(long,java.util.concurrent.TimeUnit);
	*** unlock();
}

-keep class java.util.concurrent.locks.ReentrantLock$NonfairSync {
	*;
}

-keep class java.util.concurrent.locks.ReentrantLock$Sync {
	java.util.concurrent.locks.ReentrantLock$Sync();
}

-keep class java.util.concurrent.locks.ReentrantReadWriteLock {
	*** readerLock;
	*** sync;
	*** writerLock;
	java.util.concurrent.locks.ReentrantReadWriteLock(boolean);
	*** readLock();
	*** writeLock();
}

-keep class java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock {
	*** sync;
}

-keep class java.util.concurrent.locks.ReentrantReadWriteLock$Sync {
	*** cachedHoldCounter;
	*** firstReader;
	*** firstReaderHoldCount;
	*** readHolds;
	java.util.concurrent.locks.ReentrantReadWriteLock$Sync();
	*** exclusiveCount(int);
	*** fullTryAcquireShared(java.lang.Thread);
	*** getCount();
	*** getOwner();
	*** getReadHoldCount();
	*** getReadLockCount();
	*** getWriteHoldCount();
	*** isHeldExclusively();
	*** isWriteLocked();
	*** newCondition();
	*** readerShouldBlock();
	*** sharedCount(int);
	*** tryReadLock();
	*** tryWriteLock();
	*** unmatchedUnlockException();
	*** writerShouldBlock();
}

-keep class java.util.concurrent.locks.ReentrantReadWriteLock$Sync$HoldCounter {
	*** count;
	*** tid;
}

-keep class java.util.concurrent.locks.ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter {
	*** initialValue();
}

-keep class java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock {
	*** sync;
}

-keep class java.util.jar.Attributes {
	*** map;
	java.util.jar.Attributes(int);
	*** clear();
	*** entrySet();
	*** equals(java.lang.Object);
	*** get(java.lang.Object);
	*** getValue(java.lang.String);
	*** getValue(java.util.jar.Attributes$Name);
	*** hashCode();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** putValue(java.lang.String,java.lang.String);
	*** read(java.util.jar.Manifest$FastInputStream,byte[]);
	*** size();
	*** write(java.io.DataOutputStream);
	*** writeMain(java.io.DataOutputStream);
}

-keep class java.util.jar.Attributes$Name {
	*** CLASS_PATH;
	*** CONTENT_TYPE;
	*** EXTENSION_INSTALLATION;
	*** EXTENSION_LIST;
	*** EXTENSION_NAME;
	*** IMPLEMENTATION_TITLE;
	*** IMPLEMENTATION_URL;
	*** IMPLEMENTATION_VENDOR;
	*** IMPLEMENTATION_VENDOR_ID;
	*** IMPLEMENTATION_VERSION;
	*** MAIN_CLASS;
	*** MANIFEST_VERSION;
	*** SEALED;
	*** SIGNATURE_VERSION;
	*** SPECIFICATION_TITLE;
	*** SPECIFICATION_VENDOR;
	*** SPECIFICATION_VERSION;
	*** hashCode;
	*** name;
	*** isAlpha(char);
	*** isDigit(char);
	*** isValid(char);
	*** isValid(java.lang.String);
	*** toString();
}

-keep class java.util.jar.JarEntry {
	*** attr;
	*** certs;
	*** signers;
	*** getCertificates();
}

-keep class java.util.jar.JarFile {
	*** entries();
	*** getInputStream(java.util.zip.ZipEntry);
	*** getJarEntry(java.lang.String);
	*** getManifest();
}

-keep class java.util.jar.JarFile$1 {
	*** this$0;
	*** val$enum_;
	*** nextElement();
}

-keep class java.util.jar.JarInputStream {
	*** doVerify;
	*** first;
	*** jv;
	*** man;
	*** mev;
	*** tryManifest;
	java.util.jar.JarInputStream(java.io.InputStream,boolean);
	*** checkManifest(java.util.jar.JarEntry);
	*** getBytes(java.io.InputStream);
	*** getManifest();
	*** getNextEntry();
	*** getNextJarEntry();
}

-keep class java.util.jar.JarVerifier {
	*** anyToVerify;
	*** baos;
	*** csdomain;
	*** debug;
	*** eagerValidation;
	*** emptyEnumeration;
	*** emptySigner;
	*** jarCodeSigners;
	*** lastURL;
	*** lastURLMap;
	*** manDig;
	*** manifestDigests;
	*** manifestRawBytes;
	*** parsingBlockOrSF;
	*** parsingMeta;
	*** pendingBlocks;
	*** sigFileData;
	*** sigFileSigners;
	*** signerCache;
	*** signerMap;
	*** signerToCodeSource;
	*** urlToCodeSourceMap;
	*** verifiedSigners;
	*** beginEntry(java.util.jar.JarEntry,sun.security.util.ManifestEntryVerifier);
	*** doneWithMeta();
	*** findMatchingSigners(java.security.CodeSource);
	*** getCodeSigners(java.lang.String);
	*** getCodeSigners(java.util.jar.JarFile,java.util.jar.JarEntry);
	*** getJarCodeSigners();
	*** mapSignersToCertArray(java.security.CodeSigner[]);
	*** mapSignersToCodeSource(java.net.URL,java.security.CodeSigner[]);
	*** mapSignersToCodeSources(java.net.URL,java.util.List,boolean);
	*** nothingToVerify();
	*** processEntry(sun.security.util.ManifestEntryVerifier);
	*** signerMap();
	*** unsignedEntryNames(java.util.jar.JarFile);
	*** update(int,byte[],int,int,sun.security.util.ManifestEntryVerifier);
	*** update(int,sun.security.util.ManifestEntryVerifier);
}

-keep class java.util.jar.JarVerifier$3 {
	*** this$0;
	*** nextElement();
}

-keep class java.util.jar.JarVerifier$VerifierCodeSource {
	*** access$000(java.util.jar.JarVerifier$VerifierCodeSource);
	*** isSameDomain(java.lang.Object);
}

-keep class java.util.jar.JarVerifier$VerifierStream {
	*** is;
	*** jv;
	*** mev;
	*** numLeft;
}

-keep class java.util.jar.Manifest {
	*** attr;
	*** entries;
	*** getAttributes(java.lang.String);
	*** getEntries();
	*** getMainAttributes();
	*** make72Safe(java.lang.StringBuffer);
	*** parseName(byte[],int);
	*** read(java.io.InputStream);
	*** toLower(int);
	*** write(java.io.OutputStream);
}

-keep class java.util.jar.Manifest$FastInputStream {
	*** buf;
	*** count;
	*** pos;
	java.util.jar.Manifest$FastInputStream(java.io.InputStream,int);
	*** fill();
	*** peek();
	*** readLine(byte[]);
	*** readLine(byte[],int,int);
}

-keep class java.util.logging.ConsoleHandler {
	*** configure();
}

-keep class java.util.logging.ErrorManager {
	*** reported;
	*** error(java.lang.String,java.lang.Exception,int);
}

-keep class java.util.logging.Filter {
	*** isLoggable(java.util.logging.LogRecord);
}

-keep class java.util.logging.Formatter {
	java.util.logging.Formatter();
	*** format(java.util.logging.LogRecord);
	*** formatMessage(java.util.logging.LogRecord);
	*** getHead(java.util.logging.Handler);
	*** getTail(java.util.logging.Handler);
}

-keep class java.util.logging.Handler {
	*** encoding;
	*** errorManager;
	*** filter;
	*** formatter;
	*** logLevel;
	*** manager;
	*** offValue;
	*** sealed;
	java.util.logging.Handler();
	*** checkPermission();
	*** close();
	*** getEncoding();
	*** getFilter();
	*** getFormatter();
	*** getLevel();
	*** isLoggable(java.util.logging.LogRecord);
	*** publish(java.util.logging.LogRecord);
	*** reportError(java.lang.String,java.lang.Exception,int);
	*** setEncoding(java.lang.String);
	*** setFilter(java.util.logging.Filter);
	*** setFormatter(java.util.logging.Formatter);
	*** setLevel(java.util.logging.Level);
}

-keep class java.util.logging.Level {
	*** ALL;
	*** CONFIG;
	*** FINE;
	*** FINER;
	*** FINEST;
	*** INFO;
	*** OFF;
	*** SEVERE;
	*** WARNING;
	*** defaultBundle;
	*** localizedLevelName;
	*** name;
	*** resourceBundleName;
	*** value;
	java.util.logging.Level(java.lang.String,int,java.lang.String);
	*** access$000(java.util.logging.Level);
	*** access$100(java.util.logging.Level);
	*** access$200(java.util.logging.Level);
	*** findLevel(java.lang.String);
	*** getLevelName();
	*** getLocalizedLevelName();
	*** getLocalizedName();
	*** intValue();
}

-keep class java.util.logging.Level$KnownLevel {
	*** intToLevels;
	*** levelObject;
	*** mirroredLevel;
	*** nameToLevels;
	*** add(java.util.logging.Level);
	*** findByLocalizedLevelName(java.lang.String);
	*** findByLocalizedName(java.lang.String);
	*** findByName(java.lang.String);
	*** findByValue(int);
	*** matches(java.util.logging.Level);
}

-keep class java.util.logging.LogManager {
	*** changes;
	*** controlPermission;
	*** deathImminent;
	*** defaultLevel;
	*** initializedGlobalHandlers;
	*** loggerRefQueue;
	*** loggingMXBean;
	*** manager;
	*** props;
	*** readPrimordialConfiguration;
	*** rootLogger;
	*** systemContext;
	*** userContext;
	*** access$100();
	*** access$1000(java.util.logging.Logger,java.util.logging.Level);
	*** access$102(java.util.logging.LogManager);
	*** access$1100(java.util.logging.Logger,java.util.logging.Logger);
	*** access$1200(java.util.logging.LogManager,java.lang.String);
	*** access$1300(java.util.logging.LogManager);
	*** access$1400();
	*** access$1500(java.util.logging.LogManager);
	*** access$200(java.util.logging.LogManager);
	*** access$202(java.util.logging.LogManager,java.util.logging.Logger);
	*** access$400(java.util.logging.LogManager);
	*** access$500(java.util.logging.LogManager);
	*** access$602(java.util.logging.LogManager,boolean);
	*** access$702(java.util.logging.LogManager,boolean);
	*** addLogger(java.util.logging.Logger);
	*** checkPermission();
	*** contexts();
	*** demandLogger(java.lang.String,java.lang.String,java.lang.Class);
	*** demandSystemLogger(java.lang.String,java.lang.String);
	*** doSetLevel(java.util.logging.Logger,java.util.logging.Level);
	*** doSetParent(java.util.logging.Logger,java.util.logging.Logger);
	*** drainLoggerRefQueueBounded();
	*** getBooleanProperty(java.lang.String,boolean);
	*** getFilterProperty(java.lang.String,java.util.logging.Filter);
	*** getFormatterProperty(java.lang.String,java.util.logging.Formatter);
	*** getLevelProperty(java.lang.String,java.util.logging.Level);
	*** getLogManager();
	*** getLogger(java.lang.String);
	*** getLoggingMXBean();
	*** getProperty(java.lang.String);
	*** getStringProperty(java.lang.String,java.lang.String);
	*** getUserContext();
	*** initializeGlobalHandlers();
	*** loadLoggerHandlers(java.util.logging.Logger,java.lang.String,java.lang.String);
	*** parseClassNames(java.lang.String);
	*** readConfiguration();
	*** readConfiguration(java.io.InputStream);
	*** readPrimordialConfiguration();
	*** reset();
	*** resetLogger(java.util.logging.Logger);
	*** setLevelsOnExistingLoggers();
}

-keep class java.util.logging.LogManager$2 {
	*** this$0;
	*** run();
}

-keep class java.util.logging.LogManager$4 {
	*** this$0;
	*** val$handlersPropertyName;
	*** val$logger;
}

-keep class java.util.logging.LogManager$Cleaner {
	*** this$0;
	java.util.logging.LogManager$Cleaner(java.util.logging.LogManager);
}

-keep class java.util.logging.LogManager$LogNode {
	*** children;
	*** context;
	*** loggerRef;
	*** parent;
	*** walkAndSetParent(java.util.logging.Logger);
}

-keep class java.util.logging.LogManager$LoggerContext {
	*** $assertionsDisabled;
	*** namedLoggers;
	*** requiresDefaultLoggers;
	*** root;
	java.util.logging.LogManager$LoggerContext();
	java.util.logging.LogManager$LoggerContext(boolean);
	java.util.logging.LogManager$LoggerContext(java.util.logging.LogManager$1);
	*** addLocalLogger(java.util.logging.Logger);
	*** addLocalLogger(java.util.logging.Logger,boolean);
	*** demandLogger(java.lang.String,java.lang.String);
	*** ensureAllDefaultLoggers(java.util.logging.Logger);
	*** ensureDefaultLogger(java.util.logging.Logger);
	*** ensureInitialized();
	*** findLogger(java.lang.String);
	*** getLoggerNames();
	*** getNode(java.lang.String);
	*** processParentHandlers(java.util.logging.Logger,java.lang.String);
	*** removeLogger(java.lang.String);
}

-keep class java.util.logging.LogManager$LoggerContext$1 {
	*** this$0;
	*** val$logger;
	*** val$name;
	*** run();
}

-keep class java.util.logging.LogManager$LoggerWeakRef {
	*** name;
	*** node;
	*** parentRef;
	*** this$0;
	*** dispose();
	*** setNode(java.util.logging.LogManager$LogNode);
	*** setParentRef(java.lang.ref.WeakReference);
}

-keep class java.util.logging.LogManager$RootLogger {
	*** this$0;
	java.util.logging.LogManager$RootLogger(java.util.logging.LogManager);
}

-keep class java.util.logging.LogRecord {
	*** globalSequenceNumber;
	*** level;
	*** loggerName;
	*** message;
	*** millis;
	*** needToInferCaller;
	*** nextThreadId;
	*** parameters;
	*** resourceBundle;
	*** resourceBundleName;
	*** sequenceNumber;
	*** sourceClassName;
	*** sourceMethodName;
	*** threadID;
	*** threadIds;
	*** thrown;
	*** defaultThreadID();
	*** getLevel();
	*** getLoggerName();
	*** getMessage();
	*** getMillis();
	*** getParameters();
	*** getResourceBundle();
	*** getSourceClassName();
	*** getSourceMethodName();
	*** getThrown();
	*** inferCaller();
	*** isLoggerImplFrame(java.lang.String);
	*** setLoggerName(java.lang.String);
	*** setParameters(java.lang.Object[]);
	*** setResourceBundle(java.util.ResourceBundle);
	*** setResourceBundleName(java.lang.String);
	*** setSourceClassName(java.lang.String);
	*** setSourceMethodName(java.lang.String);
	*** setThrown(java.lang.Throwable);
}

-keep class java.util.logging.Logger {
	*** anonymous;
	*** callersClassLoaderRef;
	*** catalog;
	*** catalogLocale;
	*** catalogName;
	*** emptyHandlers;
	*** filter;
	*** global;
	*** handlers;
	*** kids;
	*** levelObject;
	*** levelValue;
	*** manager;
	*** name;
	*** offValue;
	*** parent;
	*** resourceBundleName;
	*** treeLock;
	*** useParentHandlers;
	java.util.logging.Logger(java.lang.String,java.lang.String);
	java.util.logging.Logger(java.lang.String,java.lang.String,java.lang.Class);
	*** addHandler(java.util.logging.Handler);
	*** checkPermission();
	*** config(java.lang.String);
	*** demandLogger(java.lang.String,java.lang.String,java.lang.Class);
	*** doLog(java.util.logging.LogRecord);
	*** doLog(java.util.logging.LogRecord,java.lang.String);
	*** doSetParent(java.util.logging.Logger);
	*** findResourceBundle(java.lang.String,boolean);
	*** findResourceBundleFromStack(java.lang.String,java.util.Locale,java.lang.ClassLoader);
	*** findSystemResourceBundle(java.util.Locale);
	*** fine(java.lang.String);
	*** getAnonymousLogger();
	*** getAnonymousLogger(java.lang.String);
	*** getCallersClassLoader();
	*** getEffectiveResourceBundleName();
	*** getHandlers();
	*** getLevel();
	*** getLogger(java.lang.String);
	*** getName();
	*** getParent();
	*** getPlatformLogger(java.lang.String);
	*** getResourceBundleName();
	*** getUseParentHandlers();
	*** info(java.lang.String);
	*** isLoggable(java.util.logging.Level);
	*** log(java.util.logging.Level,java.lang.String);
	*** log(java.util.logging.Level,java.lang.String,java.lang.Object);
	*** log(java.util.logging.Level,java.lang.String,java.lang.Object[]);
	*** log(java.util.logging.Level,java.lang.String,java.lang.Throwable);
	*** log(java.util.logging.LogRecord);
	*** logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String);
	*** logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Object);
	*** logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[]);
	*** removeChildLogger(java.util.logging.LogManager$LoggerWeakRef);
	*** removeHandler(java.util.logging.Handler);
	*** setCallersClassLoaderRef(java.lang.Class);
	*** setLevel(java.util.logging.Level);
	*** setLogManager(java.util.logging.LogManager);
	*** setParent(java.util.logging.Logger);
	*** setUseParentHandlers(boolean);
	*** setupResourceInfo(java.lang.String,java.lang.Class);
	*** updateEffectiveLevel();
}

-keep class java.util.logging.Logger$1 {
	*** val$locale;
	*** run();
}

-keep class java.util.logging.Logger$LoggerHelper {
	*** allowStackWalkSearch;
	*** disableCallerCheck;
}

-keep class java.util.logging.LoggingMXBean {
	*** getLoggerLevel(java.lang.String);
	*** getLoggerNames();
	*** getParentLoggerName(java.lang.String);
	*** setLoggerLevel(java.lang.String,java.lang.String);
}

-keep class java.util.logging.LoggingProxyImpl {
	*** INSTANCE;
}

-keep class java.util.logging.SimpleFormatter {
	*** dat;
	*** format;
}

-keep class java.util.logging.StreamHandler {
	*** doneHeader;
	*** manager;
	*** output;
	*** writer;
	java.util.logging.StreamHandler();
	*** configure();
	*** flush();
	*** flushAndClose();
	*** isLoggable(java.util.logging.LogRecord);
	*** publish(java.util.logging.LogRecord);
	*** setEncoding(java.lang.String);
	*** setOutputStream(java.io.OutputStream);
}

-keep class java.util.regex.ASCII {
	*;
}

-keep class java.util.regex.Matcher {
	*** end();
	*** find();
	*** find(int);
	*** group(int);
	*** matches();
	*** replaceAll(java.lang.String);
	*** start();
}

-keep class java.util.regex.Pattern {
	*** compile(java.lang.String);
	*** compile(java.lang.String,int);
	*** matcher(java.lang.CharSequence);
	*** matches(java.lang.String,java.lang.CharSequence);
	*** split(java.lang.CharSequence);
}

-keep class java.util.regex.Pattern$3 {
	*;
}

-keep class java.util.regex.Pattern$5 {
	*;
}

-keep class java.util.regex.Pattern$6 {
	*;
}

-keep class java.util.regex.Pattern$7 {
	*;
}

-keep class java.util.regex.Pattern$All {
	*;
}

-keep class java.util.regex.Pattern$BitClass {
	*;
}

-keep class java.util.regex.Pattern$Branch {
	*;
}

-keep class java.util.regex.Pattern$BranchConn {
	*;
}

-keep class java.util.regex.Pattern$CharProperty$1 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$1 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$10 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$11 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$12 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$13 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$14 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$15 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$16 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$17 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$18 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$19 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$2 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$20 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$21 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$22 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$23 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$3 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$4 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$5 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$6 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$7 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$8 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$9 {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$CharPropertyFactory {
	*;
}

-keep class java.util.regex.Pattern$CharPropertyNames$CloneableProperty {
	*;
}

-keep class java.util.regex.Pattern$Ctype {
	*;
}

-keep class java.util.regex.Pattern$Curly {
	*;
}

-keep class java.util.regex.Pattern$Dollar {
	*;
}

-keep class java.util.regex.Pattern$GroupTail {
	*;
}

-keep class java.util.regex.Pattern$Loop {
	*;
}

-keep class java.util.regex.Pattern$Prolog {
	*;
}

-keep class java.util.regex.Pattern$Ques {
	*;
}

-keep class java.util.regex.Pattern$SingleI {
	*;
}

-keep class java.util.regex.Pattern$SliceI {
	*;
}

-keep class java.util.regex.Pattern$SliceS {
	*;
}

-keep class java.util.spi.LocaleServiceProvider {
	java.util.spi.LocaleServiceProvider();
	*** getAvailableLocales();
}

-keep class java.util.zip.Adler32 {
	*** getValue();
	*** update(byte[]);
}

-keep class java.util.zip.CRC32 {
	*** crc;
	*** getValue();
	*** reset();
	*** update(byte[],int,int);
	*** update(int,int);
	*** updateBytes(int,byte[],int,int);
}

-keep class java.util.zip.CheckedInputStream {
	*** cksum;
	*** read(byte[],int,int);
}

-keep class java.util.zip.Checksum {
	*** update(byte[],int,int);
	*** update(int);
}

-keep class java.util.zip.Deflater {
	*** $assertionsDisabled;
	*** buf;
	*** bytesRead;
	*** bytesWritten;
	*** finish;
	*** finished;
	*** len;
	*** level;
	*** off;
	*** setParams;
	*** strategy;
	*** zsRef;
	java.util.zip.Deflater(int,boolean);
	*** deflate(byte[],int,int);
	*** deflate(byte[],int,int,int);
	*** deflateBytes(long,byte[],int,int,int);
	*** end();
	*** end(long);
	*** ensureOpen();
	*** finish();
	*** finished();
	*** getAdler(long);
	*** getBytesRead();
	*** getBytesWritten();
	*** getTotalIn();
	*** init(int,int,boolean);
	*** initIDs();
	*** needsInput();
	*** reset(long);
	*** setDictionary(byte[],int,int);
	*** setDictionary(long,byte[],int,int);
	*** setInput(byte[],int,int);
}

-keep class java.util.zip.DeflaterOutputStream {
	*** buf;
	*** closed;
	*** def;
	*** syncFlush;
	*** usesDefaultDeflater;
	java.util.zip.DeflaterOutputStream(java.io.OutputStream,boolean);
	java.util.zip.DeflaterOutputStream(java.io.OutputStream,java.util.zip.Deflater,int,boolean);
	*** close();
	*** deflate();
	*** finish();
	*** write(byte[],int,int);
}

-keep class java.util.zip.GZIPInputStream {
	*** closed;
	*** crc;
	*** eos;
	*** tmpbuf;
	java.util.zip.GZIPInputStream(java.io.InputStream,int);
	*** close();
	*** ensureOpen();
	*** read(byte[],int,int);
	*** readHeader(java.io.InputStream);
	*** readTrailer();
	*** readUByte(java.io.InputStream);
	*** readUInt(java.io.InputStream);
	*** readUShort(java.io.InputStream);
	*** skipBytes(java.io.InputStream,int);
}

-keep class java.util.zip.GZIPOutputStream {
	*** crc;
	java.util.zip.GZIPOutputStream(java.io.OutputStream,int,boolean);
	*** write(byte[],int,int);
	*** writeHeader();
	*** writeInt(int,byte[],int);
	*** writeShort(int,byte[],int);
	*** writeTrailer(byte[],int);
}

-keep class java.util.zip.Inflater {
	*** getBytesRead();
	*** getBytesWritten();
	*** getRemaining();
	*** reset();
	*** setInput(byte[],int,int);
}

-keep class java.util.zip.InflaterInputStream {
	*** buf;
	*** inf;
	*** len;
	*** usesDefaultInflater;
	java.util.zip.InflaterInputStream(java.io.InputStream,java.util.zip.Inflater,int);
	*** close();
	*** read(byte[],int,int);
}

-keep class java.util.zip.ZStreamRef {
	*** address();
	*** clear();
}

-keep class java.util.zip.ZipCoder {
	*** get(java.nio.charset.Charset);
	*** toString(byte[],int);
	*** toStringUTF8(byte[],int);
}

-keep class java.util.zip.ZipEntry {
	*** crc;
	*** csize;
	*** method;
	*** size;
	*** time;
	*** getName();
	*** getSize();
	*** getTime();
	*** isDirectory();
	*** setExtra(byte[]);
}

-keep class java.util.zip.ZipFile {
	*** access$1000(long,long);
	*** access$200(java.util.zip.ZipFile);
	*** access$300(java.util.zip.ZipFile);
	*** access$400(java.util.zip.ZipFile);
	*** access$500(long,int);
	*** access$600(java.util.zip.ZipFile);
	*** access$700(long);
	*** access$800(java.util.zip.ZipFile);
	*** access$900(java.util.zip.ZipFile,java.lang.String,long);
	*** close();
	*** getName();
}

-keep class java.util.zip.ZipFile$1 {
	*** i;
	*** this$0;
	*** nextElement();
}

-keep class java.util.zip.ZipInputStream {
	*** b;
	*** closed;
	*** crc;
	*** entry;
	*** entryEOF;
	*** flag;
	*** remaining;
	*** tmpbuf;
	*** zc;
	java.util.zip.ZipInputStream(java.io.InputStream);
	java.util.zip.ZipInputStream(java.io.InputStream,java.nio.charset.Charset);
	*** closeEntry();
	*** createZipEntry(java.lang.String);
	*** ensureOpen();
	*** get16(byte[],int);
	*** get32(byte[],int);
	*** get64(byte[],int);
	*** getNextEntry();
	*** read(byte[],int,int);
	*** readEnd(java.util.zip.ZipEntry);
	*** readFully(byte[],int,int);
	*** readLOC();
}

-keep class javassist.ClassClassPath {
	*;
}

-keep class javassist.ClassPath {
	*;
}

-keep class javassist.ClassPathList {
	*;
}

-keep class javassist.ClassPool {
	*** appendClassPath(java.lang.String);
	*** appendClassPath(javassist.ClassPath);
	*** get(java.lang.String);
	*** getAndRename(java.lang.String,java.lang.String);
	*** getImportedPackages();
	*** lookupCflow(java.lang.String);
	*** recordInvalidClassName(java.lang.String);
}

-keep class javassist.ClassPool$1 {
	*;
}

-keep class javassist.ClassPoolTail {
	*;
}

-keep class javassist.CtBehavior {
	*** getMethodInfo();
	*** getMethodInfo2();
	*** getModifiers();
	*** getParameterTypes();
	*** setBody(java.lang.String);
	*** setExceptionTypes(javassist.CtClass[]);
	*** setModifiers(int);
}

-keep class javassist.CtClass {
	*** booleanType;
	*** byteType;
	*** charType;
	*** doubleType;
	*** floatType;
	*** intType;
	*** longType;
	*** shortType;
	*** voidType;
	*** detach();
	*** getAccessorMaker();
	*** getClassFile2();
	*** getClassPool();
	*** getComponentType();
	*** getDeclaredMethod(java.lang.String);
	*** getDeclaringClass();
	*** getField(java.lang.String);
	*** getInterfaces();
	*** getModifiers();
	*** getName();
	*** getSuperclass();
	*** isArray();
	*** isInterface();
	*** isPrimitive();
	*** setModifiers(int);
	*** subtypeOf(javassist.CtClass);
	*** toBytecode();
}

-keep class javassist.CtConstructor {
	*** isClassInitializer();
}

-keep class javassist.CtField {
	*** getConstantValue();
	*** getDeclaringClass();
	*** getFieldInfo2();
	*** getModifiers();
	*** getName();
	*** setModifiers(int);
}

-keep class javassist.CtMember {
	*** getDeclaringClass();
}

-keep class javassist.CtMethod {
	*** getReturnType();
}

-keep class javassist.CtPrimitiveType {
	*** getDataSize();
	*** getDescriptor();
	*** getGetMethodDescriptor();
	*** getGetMethodName();
	*** getReturnOp();
	*** getWrapperName();
}

-keep class javassist.Modifier {
	*** isAbstract(int);
	*** isInterface(int);
	*** isPublic(int);
	*** isStatic(int);
}

-keep class javassist.bytecode.AccessFlag {
	*** isPrivate(int);
	*** setPackage(int);
}

-keep class javassist.bytecode.ByteArray {
	*** read32bit(byte[],int);
	*** readS16bit(byte[],int);
	*** readU16bit(byte[],int);
}

-keep class javassist.bytecode.ByteVector {
	*** buffer;
	*** size;
	javassist.bytecode.ByteVector();
	*** add(int);
	*** add(int,int);
	*** add(int,int,int,int);
	*** addGap(int);
	*** clone();
	*** copy();
	*** getSize();
	*** read(int);
	*** write(int,int);
}

-keep class javassist.bytecode.Bytecode {
	*** THIS;
	*** constPool;
	*** maxLocals;
	*** maxStack;
	*** stackDepth;
	*** tryblocks;
	javassist.bytecode.Bytecode(javassist.bytecode.ConstPool,int,int);
	*** add(int);
	*** add32bit(int);
	*** addAload(int);
	*** addAnewarray(java.lang.String);
	*** addAstore(int);
	*** addCheckcast(java.lang.String);
	*** addCheckcast(javassist.CtClass);
	*** addDconst(double);
	*** addDload(int);
	*** addDstore(int);
	*** addExceptionHandler(int,int,int,int);
	*** addExceptionHandler(int,int,int,java.lang.String);
	*** addExceptionHandler(int,int,int,javassist.CtClass);
	*** addFconst(float);
	*** addFload(int);
	*** addFstore(int);
	*** addGap(int);
	*** addGetstatic(java.lang.String,java.lang.String,java.lang.String);
	*** addIconst(int);
	*** addIload(int);
	*** addIndex(int);
	*** addInstanceof(java.lang.String);
	*** addInvokeinterface(int,java.lang.String,java.lang.String,int);
	*** addInvokeinterface(javassist.CtClass,java.lang.String,java.lang.String,int);
	*** addInvokespecial(int,java.lang.String,java.lang.String);
	*** addInvokespecial(java.lang.String,java.lang.String,java.lang.String);
	*** addInvokespecial(javassist.CtClass,java.lang.String,java.lang.String);
	*** addInvokestatic(int,java.lang.String,java.lang.String);
	*** addInvokestatic(java.lang.String,java.lang.String,java.lang.String);
	*** addInvokestatic(javassist.CtClass,java.lang.String,java.lang.String);
	*** addInvokevirtual(int,java.lang.String,java.lang.String);
	*** addInvokevirtual(java.lang.String,java.lang.String,java.lang.String);
	*** addInvokevirtual(javassist.CtClass,java.lang.String,java.lang.String);
	*** addIstore(int);
	*** addLconst(long);
	*** addLdc(int);
	*** addLdc(java.lang.String);
	*** addLdc2w(double);
	*** addLdc2w(long);
	*** addLload(int);
	*** addLoad(int,javassist.CtClass);
	*** addLstore(int);
	*** addMultiNewarray(java.lang.String,int);
	*** addMultiNewarray(javassist.CtClass,int);
	*** addNew(java.lang.String);
	*** addOpcode(int);
	*** addPutfield0(javassist.CtClass,java.lang.String,java.lang.String,java.lang.String);
	*** addPutstatic0(javassist.CtClass,java.lang.String,java.lang.String,java.lang.String);
	*** addStore(int,javassist.CtClass);
	*** currentPc();
	*** get();
	*** getConstPool();
	*** getMaxLocals();
	*** getStackDepth();
	*** growStack(int);
	*** incMaxLocals(int);
	*** read(int);
	*** read16bit(int);
	*** setMaxLocals(int);
	*** setStackDepth(int);
	*** toCodeAttribute();
	*** write(int,int);
	*** write16bit(int,int);
	*** write32bit(int,int);
}

-keep class javassist.bytecode.ClassFile {
	*** MAJOR_VERSION;
	*** getConstPool();
	*** getMajorVersion();
	*** getMethods();
}

-keep class javassist.bytecode.CodeAttribute {
	*** getAttribute(java.lang.String);
	*** getCode();
	*** getExceptionTable();
	*** getMaxLocals();
	*** getMaxStack();
	*** iterator();
}

-keep class javassist.bytecode.CodeIterator {
	*** begin();
	*** byteAt(int);
	*** changeLdcToLdcW(byte[],javassist.bytecode.ExceptionTable,javassist.bytecode.CodeAttribute,javassist.bytecode.CodeAttribute$LdcEntry);
	*** getCodeLength();
	*** hasNext();
	*** move(int);
	*** next();
	*** s16bitAt(int);
	*** s32bitAt(int);
}

-keep class javassist.bytecode.ConstPool {
	*** THIS;
	*** addClassInfo(java.lang.String);
	*** addClassInfo(javassist.CtClass);
	*** addDoubleInfo(double);
	*** addFieldrefInfo(int,java.lang.String,java.lang.String);
	*** addFloatInfo(float);
	*** addIntegerInfo(int);
	*** addInterfaceMethodrefInfo(int,java.lang.String,java.lang.String);
	*** addLongInfo(long);
	*** addMethodrefInfo(int,java.lang.String,java.lang.String);
	*** addStringInfo(java.lang.String);
	*** getClassInfo(int);
	*** getClassName();
	*** getFieldrefClassName(int);
	*** getFieldrefType(int);
	*** getInterfaceMethodrefClassName(int);
	*** getInterfaceMethodrefType(int);
	*** getMethodrefClassName(int);
	*** getMethodrefType(int);
	*** getTag(int);
}

-keep class javassist.bytecode.Descriptor {
	*** dataSize(java.lang.String);
	*** insertParameter(java.lang.String,java.lang.String);
	*** numOfParameters(java.lang.String);
	*** of(javassist.CtClass);
	*** ofMethod(javassist.CtClass,javassist.CtClass[]);
}

-keep class javassist.bytecode.ExceptionTable {
	*** add(int,int,int,int);
	*** catchType(int);
	*** clone();
	*** endPc(int);
	*** handlerPc(int);
	*** size();
	*** startPc(int);
}

-keep class javassist.bytecode.FieldInfo {
	*** getAccessFlags();
	*** getDescriptor();
	*** getName();
}

-keep class javassist.bytecode.LocalVariableAttribute {
	*** codeLength(int);
	*** descriptor(int);
	*** index(int);
	*** startPc(int);
	*** tableLength();
	*** variableName(int);
}

-keep class javassist.bytecode.MethodInfo {
	*** getAccessFlags();
	*** getCodeAttribute();
	*** getConstPool();
	*** getDescriptor();
	*** getName();
	*** isConstructor();
	*** rebuildStackMapIf6(javassist.ClassPool,javassist.bytecode.ClassFile);
	*** setCodeAttribute(javassist.bytecode.CodeAttribute);
}

-keep class javassist.bytecode.Opcode {
	*** STACK_GROW;
}

-keep class javassist.bytecode.StackMap$Writer {
	*** toStackMap(javassist.bytecode.ConstPool);
	*** write16bit(int);
	*** writeVerifyTypeInfo(int,int);
}

-keep class javassist.bytecode.StackMapTable$Writer {
	*** appendFrame(int,int[],int[]);
	*** chopFrame(int,int);
	*** fullFrame(int,int[],int[],int[],int[]);
	*** sameFrame(int);
	*** sameLocals(int,int,int);
	*** toStackMapTable(javassist.bytecode.ConstPool);
}

-keep class javassist.bytecode.stackmap.BasicBlock {
	*** exit;
	*** incoming;
	*** length;
	*** position;
	*** stop;
	*** toCatch;
	javassist.bytecode.stackmap.BasicBlock(int);
	*** find(javassist.bytecode.stackmap.BasicBlock[],int);
	*** toString2(java.lang.StringBuffer);
}

-keep class javassist.bytecode.stackmap.BasicBlock$Catch {
	*** body;
	*** next;
	*** typeIndex;
}

-keep class javassist.bytecode.stackmap.BasicBlock$Maker {
	javassist.bytecode.stackmap.BasicBlock$Maker();
	*** addCatchers(javassist.bytecode.stackmap.BasicBlock[],javassist.bytecode.ExceptionTable);
	*** getBBlock(javassist.bytecode.stackmap.BasicBlock$Mark);
	*** make(javassist.bytecode.CodeIterator,int,int,javassist.bytecode.ExceptionTable);
	*** make(javassist.bytecode.MethodInfo);
	*** makeArray(int);
	*** makeArray(javassist.bytecode.stackmap.BasicBlock);
	*** makeArray(javassist.bytecode.stackmap.BasicBlock,javassist.bytecode.stackmap.BasicBlock);
	*** makeBlock(int);
	*** makeBlocks(java.util.HashMap);
	*** makeGotoJsr(java.util.HashMap,int,int,boolean,int);
	*** makeMark(java.util.HashMap,int);
	*** makeMark(java.util.HashMap,int,javassist.bytecode.stackmap.BasicBlock[],int,boolean);
	*** makeMark0(java.util.HashMap,int,boolean,boolean);
	*** makeMarks(javassist.bytecode.CodeIterator,int,int,javassist.bytecode.ExceptionTable);
}

-keep class javassist.bytecode.stackmap.BasicBlock$Mark {
	*** alwaysJmp;
	*** block;
	*** catcher;
	*** jump;
	*** position;
	*** size;
	*** setJump(javassist.bytecode.stackmap.BasicBlock[],int,boolean);
}

-keep class javassist.bytecode.stackmap.Liveness {
	*** compute(javassist.bytecode.CodeIterator,javassist.bytecode.stackmap.TypedBlock[],int,javassist.bytecode.stackmap.TypeData[]);
}

-keep class javassist.bytecode.stackmap.MapMaker {
	*** diffSize(javassist.bytecode.stackmap.TypeData[],int,int);
	*** evalExpected(javassist.ClassPool,int,javassist.bytecode.stackmap.TypeData[]);
	*** evalExpected(javassist.bytecode.stackmap.TypedBlock);
	*** fillStackMap(int,int,int[],javassist.bytecode.stackmap.TypeData[]);
	*** fixParamTypes(javassist.bytecode.stackmap.TypedBlock);
	*** isTarget(javassist.bytecode.stackmap.TypedBlock,javassist.bytecode.stackmap.TypedBlock);
	*** make(byte[],javassist.bytecode.stackmap.TypedBlock);
	*** make(javassist.bytecode.stackmap.TypedBlock[],byte[]);
	*** merge(javassist.bytecode.stackmap.TypeData,javassist.bytecode.stackmap.TypeData);
	*** mergeMap(javassist.bytecode.stackmap.TypedBlock,boolean);
	*** recordStackMap(javassist.bytecode.stackmap.TypedBlock);
	*** recordStackMap(javassist.bytecode.stackmap.TypedBlock,int);
	*** recordStackMap0(javassist.bytecode.stackmap.TypedBlock,int,javassist.bytecode.stackmap.TypeData[]);
	*** stackMapDiff(int,javassist.bytecode.stackmap.TypeData[],int,javassist.bytecode.stackmap.TypeData[]);
	*** stackMapEq(javassist.bytecode.stackmap.TypeData[],javassist.bytecode.stackmap.TypeData[],int);
	*** toStackMap(javassist.bytecode.stackmap.TypedBlock[]);
	*** toStackMap2(javassist.bytecode.ConstPool,javassist.bytecode.stackmap.TypedBlock[]);
	*** toStackMapBody(javassist.bytecode.StackMapTable$Writer,javassist.bytecode.stackmap.TypedBlock,int,int,javassist.bytecode.stackmap.TypedBlock);
	*** traceException(byte[],javassist.bytecode.stackmap.BasicBlock$Catch);
	*** writeStackFrame(javassist.bytecode.StackMap$Writer,javassist.bytecode.ConstPool,int,javassist.bytecode.stackmap.TypedBlock);
	*** writeVerifyTypeInfo(javassist.bytecode.StackMap$Writer,javassist.bytecode.ConstPool,javassist.bytecode.stackmap.TypeData[],int);
}

-keep class javassist.bytecode.stackmap.Tracer {
	*** classPool;
	*** cpool;
	*** localsTypes;
	*** returnType;
	*** stackTop;
	*** stackTypes;
	javassist.bytecode.stackmap.Tracer(javassist.ClassPool,javassist.bytecode.ConstPool,int,int,java.lang.String);
	javassist.bytecode.stackmap.Tracer(javassist.bytecode.stackmap.Tracer,boolean);
	*** checkParamTypes(java.lang.String,int);
	*** copyFrom(int,javassist.bytecode.stackmap.TypeData[],javassist.bytecode.stackmap.TypeData[]);
	*** doALOAD(int);
	*** doASTORE(int);
	*** doDUP_XX(int,int);
	*** doGetField(int,byte[],boolean);
	*** doInvokeIntfMethod(int,byte[]);
	*** doInvokeMethod(int,byte[],boolean);
	*** doLDC(int);
	*** doMultiANewArray(int,byte[]);
	*** doNEWARRAY(int,byte[]);
	*** doOpcode(int,byte[]);
	*** doOpcode0_53(int,byte[],int);
	*** doOpcode148_201(int,byte[],int);
	*** doOpcode54_95(int,byte[],int);
	*** doOpcode96_147(int,byte[],int);
	*** doPutField(int,byte[],boolean);
	*** doWIDE(int,byte[]);
	*** doWIDE_STORE(int,byte[],javassist.bytecode.stackmap.TypeData);
	*** doWIDE_XLOAD(int,byte[],javassist.bytecode.stackmap.TypeData);
	*** doXLOAD(int,javassist.bytecode.stackmap.TypeData);
	*** doXLOAD(javassist.bytecode.stackmap.TypeData,byte[],int);
	*** doXSTORE(int,byte[],javassist.bytecode.stackmap.TypeData);
	*** doXSTORE(int,javassist.bytecode.stackmap.TypeData);
	*** getFieldClassName(java.lang.String,int);
	*** pushMemberType(java.lang.String);
	*** setFieldTarget(boolean,int);
	*** throwBadBytecode(int,java.lang.String);
	*** visitBranch(int,byte[],int);
	*** visitGoto(int,byte[],int);
	*** visitJSR(int,byte[]);
	*** visitLookupSwitch(int,byte[],int,int,int);
	*** visitRET(int,byte[]);
	*** visitReturn(int,byte[]);
	*** visitTableSwitch(int,byte[],int,int,int);
	*** visitThrow(int,byte[]);
}

-keep class javassist.bytecode.stackmap.TypeData {
	*** copy();
	*** equals(java.lang.Object);
	*** evalExpectedType(javassist.ClassPool);
	*** getName();
	*** getSelf();
	*** getTypeData(javassist.bytecode.ConstPool);
	*** getTypeTag();
	*** is2WordType();
	*** isObjectType();
	*** merge(javassist.bytecode.stackmap.TypeData);
	*** setType(javassist.bytecode.stackmap.TypeData,java.lang.String,javassist.ClassPool);
}

-keep class javassist.bytecode.stackmap.TypeData$ArrayElement {
	*** getElementType(java.lang.String);
}

-keep class javassist.bytecode.stackmap.TypeTag {
	*** DOUBLE;
	*** FLOAT;
	*** INTEGER;
	*** LONG;
	*** TOP;
}

-keep class javassist.bytecode.stackmap.TypedBlock {
	*** inputs;
	*** localsTypes;
	*** numLocals;
	*** stackTop;
	*** stackTypes;
	*** updating;
	*** alreadySet();
	*** descToTag(java.lang.String,int,int,javassist.bytecode.stackmap.TypeData[]);
	*** getRetType(java.lang.String);
	*** initFirstBlock(int,int,java.lang.String,java.lang.String,boolean,boolean);
	*** makeBlocks(javassist.bytecode.MethodInfo,javassist.bytecode.CodeAttribute,boolean);
	*** printTypes(java.lang.StringBuffer,int,javassist.bytecode.stackmap.TypeData[]);
	*** resetNumLocals();
	*** setStackMap(int,javassist.bytecode.stackmap.TypeData[],int,javassist.bytecode.stackmap.TypeData[]);
	*** toPrimitiveTag(char);
}

-keep class javassist.compiler.AccessorMaker {
	*** getConstructor(javassist.CtClass,java.lang.String,javassist.bytecode.MethodInfo);
	*** getFieldGetter(javassist.bytecode.FieldInfo,boolean);
	*** getFieldSetter(javassist.bytecode.FieldInfo,boolean);
	*** getMethodAccessor(java.lang.String,java.lang.String,java.lang.String,javassist.bytecode.MethodInfo);
}

-keep class javassist.compiler.CodeGen {
	*** arrayDim;
	*** binOp;
	*** breakList;
	*** bytecode;
	*** castOp;
	*** className;
	*** continueList;
	*** exprType;
	*** hasReturned;
	*** ifOp;
	*** ifOp2;
	*** inStaticMethod;
	*** returnHooks;
	*** tempVar;
	*** typeChecker;
	javassist.compiler.CodeGen(javassist.bytecode.Bytecode);
	*** arrayAccess(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** atArithBinExpr(javassist.compiler.ast.Expr,int,int,int);
	*** atArrayAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.Expr,javassist.compiler.ast.ASTree,boolean);
	*** atArrayPlusPlus(int,boolean,javassist.compiler.ast.Expr,boolean);
	*** atArrayRead(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** atArrayVariableAssign(javassist.compiler.ast.ArrayInit,int,int,java.lang.String);
	*** atAssignCore(javassist.compiler.ast.Expr,int,javassist.compiler.ast.ASTree,int,int,java.lang.String);
	*** atAssignExpr(javassist.compiler.ast.AssignExpr,boolean);
	*** atBreakStmnt(javassist.compiler.ast.Stmnt,boolean);
	*** atCastExpr(javassist.compiler.ast.CastExpr);
	*** atClassObject(javassist.compiler.ast.Expr);
	*** atClassObject2(java.lang.String);
	*** atDeclarator(javassist.compiler.ast.Declarator);
	*** atFieldAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree,boolean);
	*** atFieldPlusPlus(int,boolean,javassist.compiler.ast.ASTree,javassist.compiler.ast.Expr,boolean);
	*** atFieldRead(javassist.compiler.ast.ASTree);
	*** atForStmnt(javassist.compiler.ast.Stmnt);
	*** atIfStmnt(javassist.compiler.ast.Stmnt);
	*** atMethodBody(javassist.compiler.ast.Stmnt,boolean,boolean);
	*** atNumCastExpr(int,int);
	*** atPlusPlus(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.Expr,boolean);
	*** atPlusPlusCore(int,boolean,int,boolean,javassist.compiler.ast.Expr);
	*** atReturnStmnt(javassist.compiler.ast.Stmnt);
	*** atReturnStmnt2(javassist.compiler.ast.ASTree);
	*** atStringConcatExpr(javassist.compiler.ast.Expr,int,int,java.lang.String);
	*** atStringPlusEq(javassist.compiler.ast.Expr,int,int,java.lang.String,javassist.compiler.ast.ASTree);
	*** atSwitchStmnt(javassist.compiler.ast.Stmnt);
	*** atSyncStmnt(javassist.compiler.ast.Stmnt);
	*** atThrowStmnt(javassist.compiler.ast.Stmnt);
	*** atTryStmnt(javassist.compiler.ast.Stmnt);
	*** atVariable(javassist.compiler.ast.Variable);
	*** atVariableAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.Variable,javassist.compiler.ast.Declarator,javassist.compiler.ast.ASTree,boolean);
	*** atWhileStmnt(javassist.compiler.ast.Stmnt,boolean);
	*** badAssign(javassist.compiler.ast.Expr);
	*** badType(javassist.compiler.ast.Expr);
	*** badTypes(javassist.compiler.ast.Expr);
	*** booleanExpr(boolean,javassist.compiler.ast.ASTree);
	*** checkCastExpr(javassist.compiler.ast.CastExpr,java.lang.String);
	*** compareExpr(boolean,int,int,javassist.compiler.ast.BinExpr);
	*** compileBooleanExpr(boolean,javassist.compiler.ast.ASTree);
	*** compileExpr(javassist.compiler.ast.ASTree);
	*** compileOprands(javassist.compiler.ast.BinExpr);
	*** computeLabel(javassist.compiler.ast.ASTree);
	*** convToString(int,int);
	*** convertOprandTypes(int,int,javassist.compiler.ast.Expr);
	*** doTypeCheck(javassist.compiler.ast.ASTree);
	*** fatal();
	*** getArrayReadOp(int,int);
	*** getArrayWriteOp(int,int);
	*** getCompOperator(javassist.compiler.ast.ASTree);
	*** getListSize(java.util.ArrayList);
	*** getLocalVar(javassist.compiler.ast.Declarator);
	*** getMaxLocals();
	*** getSuperName();
	*** getThisName();
	*** incMaxLocals(int);
	*** insertDefaultSuperCall();
	*** invalidDim(int,int,java.lang.String,int,int,java.lang.String,boolean);
	*** is2word(int,int);
	*** isAlwaysBranch(javassist.compiler.ast.ASTree,boolean);
	*** isP_INT(int);
	*** isPlusPlusExpr(javassist.compiler.ast.ASTree);
	*** isRefType(int);
	*** lookupBinOp(int);
	*** needsSuperCall(javassist.compiler.ast.Stmnt);
	*** patchGoto(java.util.ArrayList,int);
	*** resolveClassName(java.lang.String);
	*** resolveClassName(javassist.compiler.ast.ASTList);
	*** rightIsStrong(int,int);
	*** setMaxLocals(int);
	*** setTypeChecker(javassist.compiler.TypeChecker);
	*** toJvmArrayName(java.lang.String,int);
	*** toJvmTypeName(int,int);
	*** typePrecedence(int);
}

-keep class javassist.compiler.CodeGen$ReturnHook {
	*** next;
	*** doit(javassist.bytecode.Bytecode,int);
	*** remove(javassist.compiler.CodeGen);
}

-keep class javassist.compiler.Javac {
	*** bytecode;
	*** gen;
	*** stable;
	javassist.compiler.Javac(javassist.bytecode.Bytecode,javassist.CtClass);
	*** compileExpr(javassist.compiler.ast.ASTree);
	*** compileField(javassist.compiler.ast.FieldDecl);
	*** compileMethod(javassist.compiler.Parser,javassist.compiler.ast.MethodDecl);
	*** makeDefaultBody(javassist.bytecode.Bytecode,javassist.CtClass);
	*** parseExpr(java.lang.String,javassist.compiler.SymbolTable);
	*** recordParams(javassist.CtClass[],boolean);
	*** recordReturnType(javassist.CtClass,boolean);
}

-keep class javassist.compiler.Javac$CtFieldWithInit {
	*** setInit(javassist.compiler.ast.ASTree);
}

-keep class javassist.compiler.JvstCodeGen {
	*** dollarType;
	*** param0Type;
	*** paramArrayName;
	*** paramListName;
	*** paramTypeList;
	*** paramVarBase;
	*** procHandler;
	*** proceedName;
	*** returnCastName;
	*** returnType;
	*** returnVarName;
	*** useParam0;
	*** addNullIfVoid();
	*** atAssignParamList(javassist.CtClass[],javassist.bytecode.Bytecode);
	*** atCastToRtype(javassist.compiler.ast.CastExpr);
	*** atCastToWrapper(javassist.compiler.ast.CastExpr);
	*** atCflow(javassist.compiler.ast.ASTList);
	*** atMethodArgs(javassist.compiler.ast.ASTList,int[],int[],java.lang.String[]);
	*** callGetType(java.lang.String);
	*** compileParameterList(javassist.bytecode.Bytecode,javassist.CtClass[],int);
	*** compileUnwrapValue(javassist.CtClass,javassist.bytecode.Bytecode);
	*** getMethodArgsLength(javassist.compiler.ast.ASTList);
	*** indexOfParam1();
	*** makeCflowName(java.lang.StringBuffer,javassist.compiler.ast.ASTree);
	*** recordParams(javassist.CtClass[],boolean,java.lang.String,java.lang.String,java.lang.String,boolean,int,java.lang.String,javassist.compiler.SymbolTable);
	*** recordParams(javassist.CtClass[],boolean,java.lang.String,java.lang.String,java.lang.String,javassist.compiler.SymbolTable);
	*** recordReturnType(javassist.CtClass,java.lang.String,java.lang.String,javassist.compiler.SymbolTable);
	*** recordType(javassist.CtClass);
	*** recordVar(javassist.CtClass,java.lang.String,int,javassist.compiler.SymbolTable);
	*** recordVariable(java.lang.String,java.lang.String,int,javassist.compiler.SymbolTable);
	*** recordVariable(javassist.CtClass,java.lang.String,javassist.compiler.SymbolTable);
	*** setProceedHandler(javassist.compiler.ProceedHandler,java.lang.String);
	*** setType(javassist.CtClass);
	*** setType(javassist.CtClass,int);
}

-keep class javassist.compiler.JvstTypeChecker {
	*** codeGen;
	*** addNullIfVoid();
	*** atCastToRtype(javassist.compiler.ast.CastExpr);
	*** atCastToWrapper(javassist.compiler.ast.CastExpr);
	*** atCflow(javassist.compiler.ast.ASTList);
	*** atMethodArgs(javassist.compiler.ast.ASTList,int[],int[],java.lang.String[]);
	*** compileUnwrapValue(javassist.CtClass);
	*** getMethodArgsLength(javassist.compiler.ast.ASTList);
	*** setType(javassist.CtClass);
	*** setType(javassist.CtClass,int);
}

-keep class javassist.compiler.KeywordTable {
	*** append(java.lang.String,int);
	*** lookup(java.lang.String);
}

-keep class javassist.compiler.Lex {
	*** currentToken;
	*** equalOps;
	*** input;
	*** ktable;
	*** lastChar;
	*** lineNumber;
	*** lookAheadTokens;
	*** maxlen;
	*** position;
	*** textBuffer;
	*** get();
	*** get(javassist.compiler.Token);
	*** getDouble();
	*** getLong();
	*** getNextNonWhiteChar();
	*** getString();
	*** getc();
	*** isBlank(int);
	*** lookAhead();
	*** lookAhead(int);
	*** readCharConst(javassist.compiler.Token);
	*** readDouble(java.lang.StringBuffer,int,javassist.compiler.Token);
	*** readEscapeChar();
	*** readIdentifier(int,javassist.compiler.Token);
	*** readLine(javassist.compiler.Token);
	*** readNumber(int,javassist.compiler.Token);
	*** readSeparator(int);
	*** readStringL(javassist.compiler.Token);
	*** ungetc(int);
}

-keep class javassist.compiler.MemberCodeGen {
	*** resolver;
	*** resultStatic;
	*** thisClass;
	*** thisMethod;
	javassist.compiler.MemberCodeGen(javassist.bytecode.Bytecode,javassist.CtClass,javassist.ClassPool);
	*** addFieldrefInfo(javassist.CtField,javassist.bytecode.FieldInfo);
	*** addFinally(java.util.ArrayList,javassist.compiler.ast.Stmnt);
	*** atArrayLength(javassist.compiler.ast.ASTree);
	*** atCallExpr(javassist.compiler.ast.CallExpr);
	*** atFieldAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree,boolean);
	*** atFieldAssignCore(javassist.CtField,boolean,int,boolean);
	*** atFieldRead(javassist.CtField,boolean);
	*** atFieldRead(javassist.compiler.ast.ASTree);
	*** atMember(javassist.compiler.ast.Member);
	*** atMethodArgs(javassist.compiler.ast.ASTList,int[],int[],java.lang.String[]);
	*** atMethodCallCore(javassist.CtClass,java.lang.String,javassist.compiler.ast.ASTList,boolean,boolean,int,javassist.compiler.MemberResolver$Method);
	*** atMethodCallCore2(javassist.CtClass,java.lang.String,boolean,boolean,int,int,javassist.compiler.MemberResolver$Method);
	*** atMultiNewArray(int,javassist.compiler.ast.ASTList,javassist.compiler.ast.ASTList);
	*** atNewArrayExpr(javassist.compiler.ast.NewExpr);
	*** atNewArrayExpr2(int,javassist.compiler.ast.ASTree,java.lang.String,javassist.compiler.ast.ArrayInit);
	*** badLvalue();
	*** badMethod();
	*** badNewExpr();
	*** fieldAccess(javassist.compiler.ast.ASTree,boolean);
	*** getAccessibleConstructor(java.lang.String,javassist.CtClass,javassist.bytecode.MethodInfo);
	*** getAccessiblePrivate(java.lang.String,java.lang.String,java.lang.String,javassist.bytecode.MethodInfo,javassist.CtClass);
	*** getMajorVersion();
	*** getMethodArgsLength(javassist.compiler.ast.ASTList);
	*** getThisClass();
	*** getThisName();
	*** isAccessibleField(javassist.CtField,javassist.bytecode.FieldInfo);
	*** isEnclosing(javassist.CtClass,javassist.CtClass);
	*** makeParamList(javassist.compiler.ast.MethodDecl);
	*** makeThrowsList(javassist.compiler.ast.MethodDecl);
	*** resolveClassName(java.lang.String);
	*** resolveClassName(javassist.compiler.ast.ASTList);
	*** setFieldType(javassist.bytecode.FieldInfo);
	*** setReturnType(java.lang.String,boolean,boolean);
	*** setThisMethod(javassist.CtMethod);
}

-keep class javassist.compiler.MemberCodeGen$JsrHook {
	*** jsrList;
}

-keep class javassist.compiler.MemberResolver {
	*** classPool;
	*** compareSignature(java.lang.String,int[],int[],java.lang.String[]);
	*** descToType(char);
	*** fatal();
	*** getClassPool();
	*** getModifiers(javassist.compiler.ast.ASTList);
	*** getSuperclass(javassist.CtClass);
	*** getTypeName(int);
	*** javaToJvmName(java.lang.String);
	*** jvmToJavaName(java.lang.String);
	*** lookupClass(int,int,java.lang.String);
	*** lookupClass(java.lang.String,boolean);
	*** lookupClass(javassist.compiler.ast.Declarator);
	*** lookupClass0(java.lang.String,boolean);
	*** lookupClassByJvmName(java.lang.String);
	*** lookupClassByName(javassist.compiler.ast.ASTList);
	*** lookupField(java.lang.String,javassist.compiler.ast.Symbol);
	*** lookupFieldByJvmName(java.lang.String,javassist.compiler.ast.Symbol);
	*** lookupFieldByJvmName2(java.lang.String,javassist.compiler.ast.Symbol,javassist.compiler.ast.ASTree);
	*** lookupMethod(javassist.CtClass,java.lang.String,int[],int[],java.lang.String[],boolean);
	*** lookupMethod(javassist.CtClass,javassist.CtClass,javassist.bytecode.MethodInfo,java.lang.String,int[],int[],java.lang.String[]);
	*** recordPackage(java.lang.String);
	*** resolveClassName(javassist.compiler.ast.ASTList);
	*** resolveJvmClassName(java.lang.String);
	*** searchImports(java.lang.String);
}

-keep class javassist.compiler.MemberResolver$Method {
	*** declaring;
	*** info;
	*** notmatch;
	*** isStatic();
}

-keep class javassist.compiler.NoFieldException {
	*** getExpr();
	*** getField();
}

-keep class javassist.compiler.Parser {
	*** binaryOpPrecedence;
	*** lex;
	*** binaryExpr2(javassist.compiler.SymbolTable,javassist.compiler.ast.ASTree,int);
	*** getOpPrecedence(int);
	*** hasMore();
	*** isAssignOp(int);
	*** isBuiltinType(int);
	*** nextIsBuiltinCast();
	*** nextIsClassCast();
	*** nextIsClassType(int);
	*** parseArgumentList(javassist.compiler.SymbolTable);
	*** parseArrayDimension();
	*** parseArrayIndex(javassist.compiler.SymbolTable);
	*** parseArrayInitializer(javassist.compiler.SymbolTable);
	*** parseArraySize(javassist.compiler.SymbolTable);
	*** parseBinaryExpr(javassist.compiler.SymbolTable);
	*** parseBlock(javassist.compiler.SymbolTable);
	*** parseBreak(javassist.compiler.SymbolTable);
	*** parseCast(javassist.compiler.SymbolTable);
	*** parseClassType(javassist.compiler.SymbolTable);
	*** parseConditionalExpr(javassist.compiler.SymbolTable);
	*** parseContinue(javassist.compiler.SymbolTable);
	*** parseDeclarationOrExpression(javassist.compiler.SymbolTable,boolean);
	*** parseDeclarator(javassist.compiler.SymbolTable,javassist.compiler.ast.Declarator);
	*** parseDeclarators(javassist.compiler.SymbolTable,javassist.compiler.ast.Declarator);
	*** parseDo(javassist.compiler.SymbolTable);
	*** parseDotClass(int,int);
	*** parseDotClass(javassist.compiler.ast.ASTree,int);
	*** parseExprList(javassist.compiler.SymbolTable);
	*** parseExpression(javassist.compiler.SymbolTable);
	*** parseField(javassist.compiler.SymbolTable,javassist.compiler.ast.ASTList,javassist.compiler.ast.Declarator);
	*** parseFor(javassist.compiler.SymbolTable);
	*** parseFormalParam(javassist.compiler.SymbolTable);
	*** parseFormalType(javassist.compiler.SymbolTable);
	*** parseIf(javassist.compiler.SymbolTable);
	*** parseInitializer(javassist.compiler.SymbolTable);
	*** parseInstanceOf(javassist.compiler.SymbolTable,javassist.compiler.ast.ASTree);
	*** parseMember1(javassist.compiler.SymbolTable);
	*** parseMemberMods();
	*** parseMethod1(javassist.compiler.SymbolTable,boolean,javassist.compiler.ast.ASTList,javassist.compiler.ast.Declarator);
	*** parseMethod2(javassist.compiler.SymbolTable,javassist.compiler.ast.MethodDecl);
	*** parseMethodCall(javassist.compiler.SymbolTable,javassist.compiler.ast.ASTree);
	*** parseNew(javassist.compiler.SymbolTable);
	*** parseParExpression(javassist.compiler.SymbolTable);
	*** parsePostfix(javassist.compiler.SymbolTable);
	*** parsePrimaryExpr(javassist.compiler.SymbolTable);
	*** parseReturn(javassist.compiler.SymbolTable);
	*** parseStatement(javassist.compiler.SymbolTable);
	*** parseStmntOrCase(javassist.compiler.SymbolTable);
	*** parseSwitch(javassist.compiler.SymbolTable);
	*** parseSwitchBlock(javassist.compiler.SymbolTable);
	*** parseSynchronized(javassist.compiler.SymbolTable);
	*** parseThrow(javassist.compiler.SymbolTable);
	*** parseTry(javassist.compiler.SymbolTable);
	*** parseUnaryExpr(javassist.compiler.SymbolTable);
	*** parseWhile(javassist.compiler.SymbolTable);
	*** toClassName(javassist.compiler.ast.ASTree);
	*** toClassName(javassist.compiler.ast.ASTree,java.lang.StringBuffer);
}

-keep class javassist.compiler.ProceedHandler {
	*** doit(javassist.compiler.JvstCodeGen,javassist.bytecode.Bytecode,javassist.compiler.ast.ASTList);
	*** setReturnType(javassist.compiler.JvstTypeChecker,javassist.compiler.ast.ASTList);
}

-keep class javassist.compiler.SymbolTable {
	*** parent;
	javassist.compiler.SymbolTable(javassist.compiler.SymbolTable);
	*** append(java.lang.String,javassist.compiler.ast.Declarator);
	*** lookup(java.lang.String);
}

-keep class javassist.compiler.Token {
	*** doubleValue;
	*** longValue;
	*** next;
	*** textValue;
	*** tokenId;
}

-keep class javassist.compiler.TokenId {
	*** assignOps;
}

-keep class javassist.compiler.TypeChecker {
	*** arrayDim;
	*** className;
	*** exprType;
	*** resolver;
	*** thisClass;
	*** thisMethod;
	javassist.compiler.TypeChecker(javassist.CtClass,javassist.ClassPool);
	*** argTypesToString(int[],int[],java.lang.String[]);
	*** atArrayAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.Expr,javassist.compiler.ast.ASTree);
	*** atArrayLength(javassist.compiler.ast.Expr);
	*** atArrayRead(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** atCallExpr(javassist.compiler.ast.CallExpr);
	*** atCastExpr(javassist.compiler.ast.CastExpr);
	*** atClassObject(javassist.compiler.ast.Expr);
	*** atFieldAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** atFieldPlusPlus(javassist.compiler.ast.ASTree);
	*** atFieldRead(javassist.CtField);
	*** atFieldRead(javassist.compiler.ast.ASTree);
	*** atMember(javassist.compiler.ast.Member);
	*** atMethodArgs(javassist.compiler.ast.ASTList,int[],int[],java.lang.String[]);
	*** atMethodCallCore(javassist.CtClass,java.lang.String,javassist.compiler.ast.ASTList);
	*** atMultiNewArray(int,javassist.compiler.ast.ASTList,javassist.compiler.ast.ASTList);
	*** atNewArrayExpr(javassist.compiler.ast.NewExpr);
	*** atPlusExpr(javassist.compiler.ast.BinExpr);
	*** atPlusPlus(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.Expr);
	*** atVariable(javassist.compiler.ast.Variable);
	*** atVariableAssign(javassist.compiler.ast.Expr,int,javassist.compiler.ast.Variable,javassist.compiler.ast.Declarator,javassist.compiler.ast.ASTree);
	*** badMethod();
	*** booleanExpr(javassist.compiler.ast.ASTree);
	*** computeBinExprType(javassist.compiler.ast.BinExpr,int,int);
	*** fatal();
	*** fieldAccess(javassist.compiler.ast.ASTree);
	*** fieldAccess2(javassist.compiler.ast.Expr,java.lang.String);
	*** getConstantFieldValue(javassist.CtField);
	*** getConstantFieldValue(javassist.compiler.ast.Member);
	*** getMethodArgsLength(javassist.compiler.ast.ASTList);
	*** getSuperName();
	*** getThisName();
	*** insertCast(javassist.compiler.ast.BinExpr,int,int);
	*** isConstant(javassist.compiler.ast.BinExpr,int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** isConstant(javassist.compiler.ast.Expr,int,javassist.compiler.ast.ASTree);
	*** isPlusExpr(javassist.compiler.ast.ASTree);
	*** makeAppendCall(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** resolveClassName(javassist.compiler.ast.ASTList);
	*** setReturnType(java.lang.String);
	*** setThisMethod(javassist.bytecode.MethodInfo);
	*** stripPlusExpr(javassist.compiler.ast.ASTree);
	*** typeToString(java.lang.StringBuffer,int,int,java.lang.String);
}

-keep class javassist.compiler.ast.ASTList {
	*** left;
	*** right;
	javassist.compiler.ast.ASTList(javassist.compiler.ast.ASTree);
	javassist.compiler.ast.ASTList(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTList);
	*** append(javassist.compiler.ast.ASTList,javassist.compiler.ast.ASTree);
	*** concat(javassist.compiler.ast.ASTList,javassist.compiler.ast.ASTList);
	*** getLeft();
	*** getRight();
	*** head();
	*** length();
	*** length(javassist.compiler.ast.ASTList);
	*** make(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** setHead(javassist.compiler.ast.ASTree);
	*** setLeft(javassist.compiler.ast.ASTree);
	*** sublist(int);
	*** tail();
}

-keep class javassist.compiler.ast.ASTree {
	javassist.compiler.ast.ASTree();
	*** accept(javassist.compiler.ast.Visitor);
	*** getLeft();
	*** getRight();
	*** getTag();
	*** setLeft(javassist.compiler.ast.ASTree);
	*** toString();
}

-keep class javassist.compiler.ast.AssignExpr {
	*** makeAssign(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
}

-keep class javassist.compiler.ast.BinExpr {
	*** makeBin(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
}

-keep class javassist.compiler.ast.CallExpr {
	*** getMethod();
	*** makeCall(javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** setMethod(javassist.compiler.MemberResolver$Method);
}

-keep class javassist.compiler.ast.CastExpr {
	*** arrayDim;
	*** castType;
	javassist.compiler.ast.CastExpr(int,int,javassist.compiler.ast.ASTree);
	javassist.compiler.ast.CastExpr(javassist.compiler.ast.ASTList,int,javassist.compiler.ast.ASTree);
	*** getArrayDim();
	*** getClassName();
	*** getOprand();
	*** getType();
}

-keep class javassist.compiler.ast.CondExpr {
	*** condExpr();
	*** elseExpr();
	*** setElse(javassist.compiler.ast.ASTree);
	*** setThen(javassist.compiler.ast.ASTree);
	*** thenExpr();
}

-keep class javassist.compiler.ast.Declarator {
	*** arrayDim;
	*** localVar;
	*** qualifiedClass;
	*** varType;
	*** addArrayDim(int);
	*** astToClassName(java.lang.StringBuffer,javassist.compiler.ast.ASTList,char);
	*** astToClassName(javassist.compiler.ast.ASTList,char);
	*** getArrayDim();
	*** getClassName();
	*** getInitializer();
	*** getLocalVar();
	*** getType();
	*** getVariable();
	*** make(javassist.compiler.ast.Symbol,int,javassist.compiler.ast.ASTree);
	*** setClassName(java.lang.String);
	*** setLocalVar(int);
	*** setVariable(javassist.compiler.ast.Symbol);
}

-keep class javassist.compiler.ast.DoubleConst {
	*** compute(int,javassist.compiler.ast.ASTree);
	*** get();
	*** getType();
	*** set(double);
}

-keep class javassist.compiler.ast.Expr {
	*** getName();
	*** getOperator();
	*** make(int,javassist.compiler.ast.ASTree);
	*** make(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** oprand1();
	*** oprand2();
	*** setOperator(int);
	*** setOprand1(javassist.compiler.ast.ASTree);
	*** setOprand2(javassist.compiler.ast.ASTree);
}

-keep class javassist.compiler.ast.FieldDecl {
	*** getDeclarator();
	*** getInit();
	*** getModifiers();
}

-keep class javassist.compiler.ast.IntConst {
	*** compute(int,javassist.compiler.ast.ASTree);
	*** get();
	*** getType();
	*** set(long);
}

-keep class javassist.compiler.ast.Keyword {
	*** get();
}

-keep class javassist.compiler.ast.Member {
	*** getField();
	*** setField(javassist.CtField);
}

-keep class javassist.compiler.ast.MethodDecl {
	*** accept(javassist.compiler.ast.Visitor);
	*** getBody();
	*** getModifiers();
	*** getParams();
	*** getReturn();
	*** getThrows();
	*** isConstructor();
}

-keep class javassist.compiler.ast.NewExpr {
	*** getArguments();
	*** getArraySize();
	*** getArrayType();
	*** getClassName();
	*** getInitializer();
	*** isArray();
	*** makeObjectArray(javassist.compiler.ast.ASTList,javassist.compiler.ast.ASTList,javassist.compiler.ast.ArrayInit);
}

-keep class javassist.compiler.ast.Pair {
	*** getLeft();
	*** getRight();
}

-keep class javassist.compiler.ast.Stmnt {
	*** operatorId;
	javassist.compiler.ast.Stmnt(int,javassist.compiler.ast.ASTree);
	*** accept(javassist.compiler.ast.Visitor);
	*** getOperator();
	*** make(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
	*** make(int,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree,javassist.compiler.ast.ASTree);
}

-keep class javassist.compiler.ast.StringL {
	*** get();
}

-keep class javassist.compiler.ast.Symbol {
	*** identifier;
	javassist.compiler.ast.Symbol(java.lang.String);
	*** get();
}

-keep class javassist.compiler.ast.Variable {
	*** declarator;
	*** getDeclarator();
}

-keep class javassist.compiler.ast.Visitor {
	javassist.compiler.ast.Visitor();
	*** atASTList(javassist.compiler.ast.ASTList);
	*** atCastExpr(javassist.compiler.ast.CastExpr);
	*** atDeclarator(javassist.compiler.ast.Declarator);
	*** atInstanceOfExpr(javassist.compiler.ast.InstanceOfExpr);
	*** atStmnt(javassist.compiler.ast.Stmnt);
	*** atSymbol(javassist.compiler.ast.Symbol);
	*** atVariable(javassist.compiler.ast.Variable);
}

-keep class javax.accessibility.Accessible {
	*** getAccessibleContext();
}

-keep class javax.accessibility.AccessibleComponent {
	*** contains(java.awt.Point);
	*** getAccessibleAt(java.awt.Point);
	*** getLocation();
	*** isShowing();
}

-keep class javax.accessibility.AccessibleContext {
	*** firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** getAccessibleChild(int);
	*** getAccessibleChildrenCount();
	*** getAccessibleComponent();
	*** getAccessibleIndexInParent();
	*** getAccessibleName();
	*** getAccessibleParent();
	*** getAccessibleSelection();
	*** getAccessibleStateSet();
}

-keep class javax.accessibility.AccessibleSelection {
	*** isAccessibleChildSelected(int);
}

-keep class javax.accessibility.AccessibleState {
	*** ENABLED;
	*** FOCUSABLE;
	*** FOCUSED;
	*** OPAQUE;
	*** SELECTABLE;
	*** SELECTED;
	*** SHOWING;
	*** VISIBLE;
}

-keep class javax.accessibility.AccessibleStateSet {
	*** add(javax.accessibility.AccessibleState);
}

-keep class javax.crypto.Cipher {
	*** cryptoPerm;
	*** debug;
	*** exmech;
	*** firstService;
	*** firstSpi;
	*** initialized;
	*** lock;
	*** opmode;
	*** provider;
	*** serviceIterator;
	*** spi;
	*** transformation;
	*** transforms;
	*** warnCount;
	javax.crypto.Cipher(javax.crypto.CipherSpi,java.lang.String);
	*** checkCipherState();
	*** checkCryptoPerm(javax.crypto.CipherSpi,java.security.Key);
	*** checkCryptoPerm(javax.crypto.CipherSpi,java.security.Key,java.security.AlgorithmParameters);
	*** checkCryptoPerm(javax.crypto.CipherSpi,java.security.Key,java.security.spec.AlgorithmParameterSpec);
	*** checkOpmode(int);
	*** chooseFirstProvider();
	*** chooseProvider(int,int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.AlgorithmParameters,java.security.SecureRandom);
	*** doFinal();
	*** doFinal(byte[]);
	*** doFinal(byte[],int,int,byte[]);
	*** doFinal(java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** getAlgorithmParameterSpec(java.security.AlgorithmParameters);
	*** getBlockSize();
	*** getConfiguredPermission(java.lang.String);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getMaxAllowedKeyLength(java.lang.String);
	*** getParameters();
	*** getProvider();
	*** getTransform(java.security.Provider$Service,java.util.List);
	*** getTransforms(java.lang.String);
	*** implInit(javax.crypto.CipherSpi,int,int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.AlgorithmParameters,java.security.SecureRandom);
	*** init(int,java.security.Key);
	*** init(int,java.security.Key,java.security.AlgorithmParameters);
	*** init(int,java.security.Key,java.security.AlgorithmParameters,java.security.SecureRandom);
	*** init(int,java.security.Key,java.security.SecureRandom);
	*** init(int,java.security.Key,java.security.spec.AlgorithmParameterSpec);
	*** init(int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
	*** init(int,java.security.cert.Certificate,java.security.SecureRandom);
	*** initCryptoPermission();
	*** passCryptoPermCheck(javax.crypto.CipherSpi,java.security.Key,java.security.spec.AlgorithmParameterSpec);
	*** tokenizeTransformation(java.lang.String);
	*** unwrap(byte[],java.lang.String,int);
	*** update(byte[],int,int);
	*** update(byte[],int,int,byte[],int);
	*** update(java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** updateAAD(byte[],int,int);
	*** wrap(java.security.Key);
}

-keep class javax.crypto.Cipher$Transform {
	*** mode;
	*** pad;
	*** patternCache;
	*** suffix;
	*** transform;
	*** matches(java.lang.String,java.lang.String);
	*** setModePadding(javax.crypto.CipherSpi);
	*** supports(java.security.Provider$Service,java.lang.String,java.lang.String);
	*** supportsMode(java.security.Provider$Service);
	*** supportsModePadding(java.security.Provider$Service);
	*** supportsPadding(java.security.Provider$Service);
}

-keep class javax.crypto.CipherInputStream {
	*** cipher;
	*** done;
	*** ibuffer;
	*** input;
	*** obuffer;
	*** ofinish;
	*** ostart;
	*** getMoreData();
	*** read(byte[],int,int);
}

-keep class javax.crypto.CipherOutputStream {
	*** cipher;
	*** ibuffer;
	*** obuffer;
	*** output;
	*** flush();
	*** write(byte[],int,int);
}

-keep class javax.crypto.CipherSpi {
	javax.crypto.CipherSpi();
	*** bufferCrypt(java.nio.ByteBuffer,java.nio.ByteBuffer,boolean);
	*** engineDoFinal(byte[],int,int);
	*** engineDoFinal(byte[],int,int,byte[],int);
	*** engineDoFinal(java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** engineGetBlockSize();
	*** engineGetIV();
	*** engineGetKeySize(java.security.Key);
	*** engineGetOutputSize(int);
	*** engineGetParameters();
	*** engineInit(int,java.security.Key,java.security.AlgorithmParameters,java.security.SecureRandom);
	*** engineInit(int,java.security.Key,java.security.SecureRandom);
	*** engineInit(int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
	*** engineSetMode(java.lang.String);
	*** engineSetPadding(java.lang.String);
	*** engineUnwrap(byte[],java.lang.String,int);
	*** engineUpdate(byte[],int,int);
	*** engineUpdate(byte[],int,int,byte[],int);
	*** engineUpdate(java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** engineUpdateAAD(byte[],int,int);
	*** engineUpdateAAD(java.nio.ByteBuffer);
	*** engineWrap(java.security.Key);
	*** getTempArraySize(int);
}

-keep class javax.crypto.CryptoAllPermission {
	*** INSTANCE;
}

-keep class javax.crypto.CryptoAllPermissionCollection {
	*** all_allowed;
}

-keep class javax.crypto.CryptoPermission {
	*** alg;
	*** algParamSpec;
	*** checkParam;
	*** exemptionMechanism;
	*** maxKeySize;
	javax.crypto.CryptoPermission(java.lang.String);
	*** equalObjects(java.lang.Object,java.lang.Object);
	*** getAlgorithm();
	*** getAlgorithmParameterSpec();
	*** getCheckParam();
	*** getExemptionMechanism();
	*** getMaxKeySize();
	*** implies(java.security.Permission);
	*** impliesExemptionMechanism(java.lang.String);
	*** impliesParameterSpec(boolean,java.security.spec.AlgorithmParameterSpec);
	*** newPermissionCollection();
}

-keep class javax.crypto.CryptoPermissions {
	*** perms;
	*** serialPersistentFields;
	*** add(java.security.Permission);
	*** getMinimum(int,java.security.PermissionCollection);
	*** getMinimum(java.security.PermissionCollection,java.security.PermissionCollection);
	*** getMinimum(javax.crypto.CryptoPermissions);
	*** getPermissionCollection(java.lang.String);
	*** getPermissionCollection(javax.crypto.CryptoPermission);
	*** implies(java.security.Permission);
	*** isEmpty();
	*** load(java.io.InputStream);
}

-keep class javax.crypto.CryptoPolicyParser {
	*** grantEntries;
	*** lookahead;
	*** st;
	*** getInstance(java.lang.String,java.lang.Integer[]);
	*** getPermissions();
	*** isConsistent(java.lang.String,java.lang.String,java.util.Hashtable);
	*** match();
	*** match(java.lang.String);
	*** parseGrantEntry(java.util.Hashtable);
	*** parsePermissionEntry(java.util.Hashtable);
	*** peek(java.lang.String);
	*** peekAndMatch(java.lang.String);
	*** read(java.io.Reader);
}

-keep class javax.crypto.CryptoPolicyParser$CryptoPermissionEntry {
	*** alg;
	*** algParamSpec;
	*** checkParam;
	*** cryptoPermission;
	*** exemptionMechanism;
	*** maxKeySize;
}

-keep class javax.crypto.CryptoPolicyParser$GrantEntry {
	*** permissionEntries;
	*** add(javax.crypto.CryptoPolicyParser$CryptoPermissionEntry);
	*** permissionElements();
}

-keep class javax.crypto.ExemptionMechanism {
	*** getInstance(java.lang.String);
	*** getName();
	*** isCryptoAllowed(java.security.Key);
}

-keep class javax.crypto.JarVerifier {
	*** appPerms;
	*** jarURL;
	*** savePerms;
	*** getPermissions();
	*** verify();
	*** verifyPolicySigned(java.security.cert.Certificate[]);
}

-keep class javax.crypto.JceSecurity {
	*** NULL_URL;
	*** PROVIDER_VERIFIED;
	*** RANDOM;
	*** codeBaseCacheRef;
	*** defaultPolicy;
	*** exemptPolicy;
	*** isRestricted;
	*** verificationResults;
	*** verifyingProviders;
	*** access$000();
	*** access$100();
	*** canUseProvider(java.security.Provider);
	*** getCodeBase(java.lang.Class);
	*** getDefaultPolicy();
	*** getExemptPolicy();
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.security.Provider);
	*** getVerificationResult(java.security.Provider);
	*** isRestricted();
	*** loadPolicies(java.io.File,javax.crypto.CryptoPermissions,javax.crypto.CryptoPermissions);
	*** setupJurisdictionPolicies();
	*** verifyExemptJar(java.net.URL);
	*** verifyProviderJar(java.net.URL);
}

-keep class javax.crypto.JceSecurity$2 {
	*** val$clazz;
}

-keep class javax.crypto.JceSecurityManager {
	*** CACHE_NULL_MARK;
	*** INSTANCE;
	*** TrustedCallersCache;
	*** allPerm;
	*** defaultPolicy;
	*** exemptCache;
	*** exemptPolicy;
	javax.crypto.JceSecurityManager();
	*** getAppPermissions(java.net.URL);
	*** getCryptoPermission(java.lang.String);
	*** getDefaultPermission(java.lang.String);
	*** isCallerTrusted();
}

-keep class javax.crypto.KeyAgreement {
	*** algorithm;
	*** debug;
	*** firstService;
	*** lock;
	*** provider;
	*** serviceIterator;
	*** spi;
	*** warnCount;
	*** chooseFirstProvider();
	*** chooseProvider(int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
	*** doPhase(java.security.Key,boolean);
	*** generateSecret(java.lang.String);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** implInit(javax.crypto.KeyAgreementSpi,int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
	*** init(java.security.Key);
	*** init(java.security.Key,java.security.SecureRandom);
	*** init(java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
}

-keep class javax.crypto.KeyAgreementSpi {
	javax.crypto.KeyAgreementSpi();
	*** engineDoPhase(java.security.Key,boolean);
	*** engineGenerateSecret();
	*** engineGenerateSecret(byte[],int);
	*** engineGenerateSecret(java.lang.String);
	*** engineInit(java.security.Key,java.security.SecureRandom);
	*** engineInit(java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
}

-keep class javax.crypto.KeyGenerator {
	*** algorithm;
	*** initKeySize;
	*** initParams;
	*** initRandom;
	*** initType;
	*** lock;
	*** provider;
	*** serviceIterator;
	*** spi;
	*** disableFailover();
	*** generateKey();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** init(int);
	*** init(int,java.security.SecureRandom);
	*** init(java.security.spec.AlgorithmParameterSpec);
	*** init(java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
	*** nextSpi(javax.crypto.KeyGeneratorSpi,boolean);
}

-keep class javax.crypto.KeyGeneratorSpi {
	javax.crypto.KeyGeneratorSpi();
	*** engineGenerateKey();
	*** engineInit(int,java.security.SecureRandom);
	*** engineInit(java.security.SecureRandom);
	*** engineInit(java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom);
}

-keep class javax.crypto.Mac {
	*** algorithm;
	*** debug;
	*** firstService;
	*** initialized;
	*** lock;
	*** provider;
	*** serviceIterator;
	*** spi;
	*** warnCount;
	*** chooseFirstProvider();
	*** chooseProvider(java.security.Key,java.security.spec.AlgorithmParameterSpec);
	*** doFinal();
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.security.Provider);
	*** getMacLength();
	*** init(java.security.Key);
	*** update(byte[]);
	*** update(byte[],int,int);
	*** update(java.nio.ByteBuffer);
}

-keep class javax.crypto.MacSpi {
	javax.crypto.MacSpi();
	*** clone();
	*** engineDoFinal();
	*** engineGetMacLength();
	*** engineInit(java.security.Key,java.security.spec.AlgorithmParameterSpec);
	*** engineReset();
	*** engineUpdate(byte);
	*** engineUpdate(byte[],int,int);
	*** engineUpdate(java.nio.ByteBuffer);
}

-keep class javax.crypto.SecretKeyFactory {
	*** generateSecret(java.security.spec.KeySpec);
	*** getInstance(java.lang.String);
}

-keep class javax.crypto.interfaces.DHKey {
	*** getParams();
}

-keep class javax.crypto.interfaces.DHPublicKey {
	*** getY();
}

-keep class javax.crypto.spec.DHParameterSpec {
	*** getG();
	*** getP();
}

-keep class javax.crypto.spec.DHPublicKeySpec {
	*** getG();
	*** getP();
	*** getY();
}

-keep class javax.crypto.spec.IvParameterSpec {
	*** iv;
	javax.crypto.spec.IvParameterSpec(byte[],int,int);
	*** getIV();
}

-keep class javax.crypto.spec.OAEPParameterSpec {
	*** getDigestAlgorithm();
	*** getMGFAlgorithm();
	*** getMGFParameters();
	*** getPSource();
}

-keep class javax.crypto.spec.PBEParameterSpec {
	*** getIterationCount();
}

-keep class javax.crypto.spec.PSource {
	*** pSrcName;
	javax.crypto.spec.PSource(java.lang.String);
	*** getAlgorithm();
}

-keep class javax.crypto.spec.PSource$PSpecified {
	*** DEFAULT;
	*** p;
	*** getValue();
}

-keep class javax.crypto.spec.RC2ParameterSpec {
	*** getEffectiveKeyBits();
	*** getIV();
}

-keep class javax.crypto.spec.RC5ParameterSpec {
	*** getRounds();
}

-keep class javax.crypto.spec.SecretKeySpec {
	*** algorithm;
	*** key;
}

-keep class javax.inject.Named {
	*** value();
}

-keep class javax.inject.Provider {
	*** get();
}

-keep class javax.management.JMX {
	*** newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class,boolean);
}

-keep class javax.management.MBeanServer {
	*** isRegistered(javax.management.ObjectName);
}

-keep class javax.management.MBeanServerConnection {
	*** isInstanceOf(javax.management.ObjectName,java.lang.String);
}

-keep class javax.management.MBeanServerFactory {
	*** createMBeanServer();
}

-keep class javax.management.Notification {
	*** setUserData(java.lang.Object);
}

-keep class javax.management.NotificationFilter {
	*** isNotificationEnabled(javax.management.Notification);
}

-keep class javax.management.NotificationListener {
	*** handleNotification(javax.management.Notification,java.lang.Object);
}

-keep class javax.net.ServerSocketFactory {
	*** theFactory;
	javax.net.ServerSocketFactory();
	*** createServerSocket();
	*** createServerSocket(int);
	*** createServerSocket(int,int);
	*** createServerSocket(int,int,java.net.InetAddress);
	*** getDefault();
}

-keep class javax.net.SocketFactory {
	*** theFactory;
	javax.net.SocketFactory();
	*** createSocket();
	*** createSocket(java.lang.String,int);
	*** createSocket(java.lang.String,int,java.net.InetAddress,int);
	*** createSocket(java.net.InetAddress,int);
	*** createSocket(java.net.InetAddress,int,java.net.InetAddress,int);
	*** getDefault();
}

-keep class javax.net.ssl.CertPathTrustManagerParameters {
	*** getParameters();
}

-keep class javax.net.ssl.ExtendedSSLSession {
	javax.net.ssl.ExtendedSSLSession();
	*** getLocalSupportedSignatureAlgorithms();
}

-keep class javax.net.ssl.HandshakeCompletedEvent {
	*** session;
	*** getLocalCertificates();
	*** getPeerCertificates();
}

-keep class javax.net.ssl.HandshakeCompletedListener {
	*** handshakeCompleted(javax.net.ssl.HandshakeCompletedEvent);
}

-keep class javax.net.ssl.HttpsURLConnection {
	*** setHostnameVerifier(javax.net.ssl.HostnameVerifier);
	*** setSSLSocketFactory(javax.net.ssl.SSLSocketFactory);
}

-keep class javax.net.ssl.KeyManagerFactory {
	*** algorithm;
	*** factorySpi;
	*** provider;
	*** getDefaultAlgorithm();
	*** getInstance(java.lang.String);
	*** getKeyManagers();
	*** init(java.security.KeyStore,char[]);
}

-keep class javax.net.ssl.KeyManagerFactory$1 {
	*** run();
}

-keep class javax.net.ssl.KeyManagerFactorySpi {
	javax.net.ssl.KeyManagerFactorySpi();
	*** engineGetKeyManagers();
	*** engineInit(java.security.KeyStore,char[]);
	*** engineInit(javax.net.ssl.ManagerFactoryParameters);
}

-keep class javax.net.ssl.SSLContext {
	*** contextSpi;
	*** defaultContext;
	*** protocol;
	*** provider;
	*** createSSLEngine();
	*** getDefault();
	*** getInstance(java.lang.String);
	*** getProvider();
	*** getServerSocketFactory();
	*** getSocketFactory();
	*** init(javax.net.ssl.KeyManager[],javax.net.ssl.TrustManager[],java.security.SecureRandom);
}

-keep class javax.net.ssl.SSLContextSpi {
	javax.net.ssl.SSLContextSpi();
	*** engineCreateSSLEngine();
	*** engineCreateSSLEngine(java.lang.String,int);
	*** engineGetClientSessionContext();
	*** engineGetDefaultSSLParameters();
	*** engineGetServerSessionContext();
	*** engineGetServerSocketFactory();
	*** engineGetSocketFactory();
	*** engineGetSupportedSSLParameters();
	*** engineInit(javax.net.ssl.KeyManager[],javax.net.ssl.TrustManager[],java.security.SecureRandom);
	*** getDefaultSocket();
}

-keep class javax.net.ssl.SSLEngine {
	*** peerHost;
	*** peerPort;
	javax.net.ssl.SSLEngine();
	javax.net.ssl.SSLEngine(java.lang.String,int);
	*** beginHandshake();
	*** closeInbound();
	*** closeOutbound();
	*** getDelegatedTask();
	*** getEnabledCipherSuites();
	*** getEnabledProtocols();
	*** getHandshakeSession();
	*** getNeedClientAuth();
	*** getPeerHost();
	*** getPeerPort();
	*** getSSLParameters();
	*** getSession();
	*** getUseClientMode();
	*** getWantClientAuth();
	*** setEnabledCipherSuites(java.lang.String[]);
	*** setEnabledProtocols(java.lang.String[]);
	*** setNeedClientAuth(boolean);
	*** setSSLParameters(javax.net.ssl.SSLParameters);
	*** setUseClientMode(boolean);
	*** setWantClientAuth(boolean);
	*** unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer[],int,int);
	*** wrap(java.nio.ByteBuffer,java.nio.ByteBuffer);
	*** wrap(java.nio.ByteBuffer[],int,int,java.nio.ByteBuffer);
}

-keep class javax.net.ssl.SSLEngineResult {
	*** bytesConsumed;
	*** bytesProduced;
	*** handshakeStatus;
	*** status;
	*** bytesConsumed();
	*** bytesProduced();
	*** getHandshakeStatus();
	*** getStatus();
}

-keep class javax.net.ssl.SSLEngineResult$HandshakeStatus {
	*** $VALUES;
	*** FINISHED;
	*** NEED_TASK;
	*** NEED_UNWRAP;
	*** NEED_WRAP;
	*** NOT_HANDSHAKING;
	*** values();
}

-keep class javax.net.ssl.SSLEngineResult$Status {
	*** $VALUES;
	*** BUFFER_OVERFLOW;
	*** BUFFER_UNDERFLOW;
	*** CLOSED;
	*** OK;
	*** values();
}

-keep class javax.net.ssl.SSLException {
	javax.net.ssl.SSLException(java.lang.String);
	javax.net.ssl.SSLException(java.lang.String,java.lang.Throwable);
	javax.net.ssl.SSLException(java.lang.Throwable);
}

-keep class javax.net.ssl.SSLParameters {
	*** algorithmConstraints;
	*** cipherSuites;
	*** identificationAlgorithm;
	*** needClientAuth;
	*** protocols;
	*** wantClientAuth;
	*** clone(java.lang.String[]);
	*** getAlgorithmConstraints();
	*** getCipherSuites();
	*** getEndpointIdentificationAlgorithm();
	*** getNeedClientAuth();
	*** getProtocols();
	*** getWantClientAuth();
	*** setAlgorithmConstraints(java.security.AlgorithmConstraints);
	*** setCipherSuites(java.lang.String[]);
	*** setEndpointIdentificationAlgorithm(java.lang.String);
	*** setNeedClientAuth(boolean);
	*** setProtocols(java.lang.String[]);
	*** setWantClientAuth(boolean);
}

-keep class javax.net.ssl.SSLServerSocket {
	javax.net.ssl.SSLServerSocket();
	javax.net.ssl.SSLServerSocket(int,int);
	javax.net.ssl.SSLServerSocket(int,int,java.net.InetAddress);
	*** getEnabledCipherSuites();
	*** getEnabledProtocols();
	*** getNeedClientAuth();
	*** getSSLParameters();
	*** getWantClientAuth();
	*** setEnabledCipherSuites(java.lang.String[]);
	*** setEnabledProtocols(java.lang.String[]);
	*** setNeedClientAuth(boolean);
	*** setSSLParameters(javax.net.ssl.SSLParameters);
	*** setWantClientAuth(boolean);
}

-keep class javax.net.ssl.SSLServerSocketFactory {
	*** propertyChecked;
	*** theFactory;
	javax.net.ssl.SSLServerSocketFactory();
	*** getDefaultCipherSuites();
	*** getSupportedCipherSuites();
	*** log(java.lang.String);
}

-keep class javax.net.ssl.SSLSession {
	*** getApplicationBufferSize();
	*** getCipherSuite();
	*** getCreationTime();
	*** getLocalCertificates();
	*** getLocalPrincipal();
	*** getPacketBufferSize();
	*** getPeerCertificateChain();
	*** getPeerCertificates();
	*** getPeerHost();
	*** getPeerPrincipal();
	*** getProtocol();
	*** invalidate();
}

-keep class javax.net.ssl.SSLSessionBindingListener {
	*** valueBound(javax.net.ssl.SSLSessionBindingEvent);
	*** valueUnbound(javax.net.ssl.SSLSessionBindingEvent);
}

-keep class javax.net.ssl.SSLSocket {
	javax.net.ssl.SSLSocket();
	*** addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener);
	*** getEnabledCipherSuites();
	*** getEnabledProtocols();
	*** getHandshakeSession();
	*** getNeedClientAuth();
	*** getSSLParameters();
	*** getSession();
	*** getSupportedCipherSuites();
	*** getSupportedProtocols();
	*** getWantClientAuth();
	*** setEnabledCipherSuites(java.lang.String[]);
	*** setEnabledProtocols(java.lang.String[]);
	*** setNeedClientAuth(boolean);
	*** setSSLParameters(javax.net.ssl.SSLParameters);
	*** setUseClientMode(boolean);
	*** setWantClientAuth(boolean);
	*** startHandshake();
}

-keep class javax.net.ssl.SSLSocketFactory {
	*** DEBUG;
	*** propertyChecked;
	*** theFactory;
	javax.net.ssl.SSLSocketFactory();
	*** createSocket(java.net.Socket,java.lang.String,int,boolean);
	*** getDefault();
	*** getDefaultCipherSuites();
	*** getSecurityProperty(java.lang.String);
	*** getSupportedCipherSuites();
	*** log(java.lang.String);
}

-keep class javax.net.ssl.SSLSocketFactory$1 {
	*** val$name;
	*** run();
}

-keep class javax.net.ssl.TrustManagerFactory {
	*** algorithm;
	*** factorySpi;
	*** provider;
	*** getDefaultAlgorithm();
	*** getInstance(java.lang.String);
	*** getTrustManagers();
	*** init(java.security.KeyStore);
}

-keep class javax.net.ssl.TrustManagerFactory$1 {
	*** run();
}

-keep class javax.net.ssl.TrustManagerFactorySpi {
	javax.net.ssl.TrustManagerFactorySpi();
	*** engineGetTrustManagers();
	*** engineInit(java.security.KeyStore);
	*** engineInit(javax.net.ssl.ManagerFactoryParameters);
}

-keep class javax.net.ssl.X509ExtendedKeyManager {
	javax.net.ssl.X509ExtendedKeyManager();
	*** chooseEngineClientAlias(java.lang.String[],java.security.Principal[],javax.net.ssl.SSLEngine);
	*** chooseEngineServerAlias(java.lang.String,java.security.Principal[],javax.net.ssl.SSLEngine);
}

-keep class javax.net.ssl.X509ExtendedTrustManager {
	javax.net.ssl.X509ExtendedTrustManager();
	*** checkClientTrusted(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket);
	*** checkClientTrusted(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine);
	*** checkServerTrusted(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket);
	*** checkServerTrusted(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine);
}

-keep class javax.net.ssl.X509KeyManager {
	*** chooseClientAlias(java.lang.String[],java.security.Principal[],java.net.Socket);
	*** chooseServerAlias(java.lang.String,java.security.Principal[],java.net.Socket);
	*** getCertificateChain(java.lang.String);
	*** getPrivateKey(java.lang.String);
}

-keep class javax.net.ssl.X509TrustManager {
	*** checkClientTrusted(java.security.cert.X509Certificate[],java.lang.String);
	*** checkServerTrusted(java.security.cert.X509Certificate[],java.lang.String);
	*** getAcceptedIssuers();
}

-keep class javax.security.auth.Subject {
	*** getPrincipals(java.lang.Class);
}

-keep class javax.security.auth.callback.CallbackHandler {
	*** handle(javax.security.auth.callback.Callback[]);
}

-keep class javax.security.auth.callback.NameCallback {
	*** setName(java.lang.String);
}

-keep class javax.security.auth.callback.PasswordCallback {
	*** echoOn;
	*** inputPassword;
	*** prompt;
	*** clearPassword();
	*** getPassword();
	*** setPassword(char[]);
}

-keep class javax.security.auth.callback.TextInputCallback {
	*** defaultText;
	*** inputText;
	*** prompt;
	*** getPrompt();
	*** setText(java.lang.String);
}

-keep class javax.security.auth.callback.UnsupportedCallbackException {
	*** callback;
}

-keep class javax.security.auth.login.LoginException {
	javax.security.auth.login.LoginException();
	javax.security.auth.login.LoginException(java.lang.String);
}

-keep class javax.security.auth.x500.X500Principal {
	*** thisX500Name;
	javax.security.auth.x500.X500Principal(java.lang.String,java.util.Map);
	*** equals(java.lang.Object);
	*** getEncoded();
	*** getName();
	*** getName(java.lang.String);
	*** toString();
}

-keep class javax.security.cert.X509Certificate {
	*** getInstance(byte[]);
}

-keep class javax.security.sasl.Sasl {
	*** createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler);
}

-keep class javax.security.sasl.SaslClient {
	*** evaluateChallenge(byte[]);
	*** hasInitialResponse();
}

-keep class javax.security.sasl.SaslException {
	*** _exception;
	*** initCause(java.lang.Throwable);
}

-keep class javax.servlet.AsyncEvent {
	*** context;
	*** request;
	*** response;
	*** throwable;
	javax.servlet.AsyncEvent(javax.servlet.AsyncContext,javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	javax.servlet.AsyncEvent(javax.servlet.AsyncContext,javax.servlet.ServletRequest,javax.servlet.ServletResponse,java.lang.Throwable);
	*** getSuppliedRequest();
	*** getSuppliedResponse();
}

-keep class javax.servlet.AsyncListener {
	*** onComplete(javax.servlet.AsyncEvent);
	*** onError(javax.servlet.AsyncEvent);
	*** onStartAsync(javax.servlet.AsyncEvent);
	*** onTimeout(javax.servlet.AsyncEvent);
}

-keep class javax.servlet.DispatcherType {
	*** $VALUES;
	*** ASYNC;
	*** ERROR;
	*** FORWARD;
	*** INCLUDE;
	*** REQUEST;
}

-keep class javax.servlet.Filter {
	*** destroy();
	*** init(javax.servlet.FilterConfig);
}

-keep class javax.servlet.FilterChain {
	*** doFilter(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
}

-keep class javax.servlet.GenericServlet {
	*** config;
	*** lStrings;
	javax.servlet.GenericServlet();
	*** destroy();
	*** getInitParameter(java.lang.String);
	*** getInitParameterNames();
	*** getServletConfig();
	*** getServletContext();
	*** getServletInfo();
	*** getServletName();
	*** init();
	*** init(javax.servlet.ServletConfig);
	*** log(java.lang.String);
	*** log(java.lang.String,java.lang.Throwable);
}

-keep class javax.servlet.RequestDispatcher {
	*** forward(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	*** include(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
}

-keep class javax.servlet.Servlet {
	*** destroy();
	*** init(javax.servlet.ServletConfig);
	*** service(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
}

-keep class javax.servlet.ServletConfig {
	*** getInitParameter(java.lang.String);
	*** getInitParameterNames();
	*** getServletContext();
	*** getServletName();
}

-keep class javax.servlet.ServletContext {
	*** getAttribute(java.lang.String);
	*** getContextPath();
	*** getInitParameter(java.lang.String);
	*** getMimeType(java.lang.String);
	*** getResource(java.lang.String);
	*** log(java.lang.String);
	*** log(java.lang.String,java.lang.Throwable);
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
}

-keep class javax.servlet.ServletContextAttributeListener {
	*** attributeAdded(javax.servlet.ServletContextAttributeEvent);
	*** attributeRemoved(javax.servlet.ServletContextAttributeEvent);
	*** attributeReplaced(javax.servlet.ServletContextAttributeEvent);
}

-keep class javax.servlet.ServletContextListener {
	*** contextDestroyed(javax.servlet.ServletContextEvent);
	*** contextInitialized(javax.servlet.ServletContextEvent);
}

-keep class javax.servlet.ServletException {
	*** rootCause;
	javax.servlet.ServletException(java.lang.String);
	*** getRootCause();
}

-keep class javax.servlet.ServletInputStream {
	javax.servlet.ServletInputStream();
}

-keep class javax.servlet.ServletOutputStream {
	*** lStrings;
	javax.servlet.ServletOutputStream();
	*** print(boolean);
	*** print(char);
	*** print(double);
	*** print(float);
	*** print(int);
	*** print(java.lang.String);
	*** print(long);
	*** println();
}

-keep class javax.servlet.ServletRequest {
	*** getAsyncContext();
	*** getAttribute(java.lang.String);
	*** getAttributeNames();
	*** getCharacterEncoding();
	*** getContentLength();
	*** getContentType();
	*** getDispatcherType();
	*** getInputStream();
	*** getLocalAddr();
	*** getLocalName();
	*** getLocalPort();
	*** getLocale();
	*** getLocales();
	*** getParameter(java.lang.String);
	*** getParameterMap();
	*** getParameterNames();
	*** getParameterValues(java.lang.String);
	*** getProtocol();
	*** getReader();
	*** getRealPath(java.lang.String);
	*** getRemoteAddr();
	*** getRemoteHost();
	*** getRemotePort();
	*** getRequestDispatcher(java.lang.String);
	*** getScheme();
	*** getServerName();
	*** getServerPort();
	*** getServletContext();
	*** isAsyncStarted();
	*** isAsyncSupported();
	*** isSecure();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
	*** setCharacterEncoding(java.lang.String);
	*** startAsync();
	*** startAsync(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
}

-keep class javax.servlet.ServletRequestAttributeListener {
	*** attributeAdded(javax.servlet.ServletRequestAttributeEvent);
	*** attributeRemoved(javax.servlet.ServletRequestAttributeEvent);
	*** attributeReplaced(javax.servlet.ServletRequestAttributeEvent);
}

-keep class javax.servlet.ServletRequestListener {
	*** requestDestroyed(javax.servlet.ServletRequestEvent);
	*** requestInitialized(javax.servlet.ServletRequestEvent);
}

-keep class javax.servlet.ServletRequestWrapper {
	*** request;
	javax.servlet.ServletRequestWrapper(javax.servlet.ServletRequest);
	*** getRequest();
	*** isWrapperFor(java.lang.Class);
	*** isWrapperFor(javax.servlet.ServletRequest);
}

-keep class javax.servlet.ServletResponse {
	*** flushBuffer();
	*** getBufferSize();
	*** getCharacterEncoding();
	*** getContentType();
	*** getLocale();
	*** getOutputStream();
	*** getWriter();
	*** isCommitted();
	*** reset();
	*** resetBuffer();
	*** setBufferSize(int);
	*** setCharacterEncoding(java.lang.String);
	*** setContentLength(int);
	*** setContentType(java.lang.String);
	*** setLocale(java.util.Locale);
}

-keep class javax.servlet.ServletResponseWrapper {
	*** response;
	javax.servlet.ServletResponseWrapper(javax.servlet.ServletResponse);
	*** getResponse();
	*** isWrapperFor(java.lang.Class);
	*** isWrapperFor(javax.servlet.ServletResponse);
}

-keep class javax.servlet.SessionCookieConfig {
	*** getMaxAge();
	*** getName();
	*** isHttpOnly();
	*** isSecure();
}

-keep class javax.servlet.SessionTrackingMode {
	*** $VALUES;
	*** COOKIE;
	*** SSL;
	*** URL;
}

-keep class javax.servlet.UnavailableException {
	*** permanent;
	*** seconds;
	*** servlet;
	javax.servlet.UnavailableException(java.lang.String,int);
	*** getUnavailableSeconds();
	*** isPermanent();
}

-keep class javax.servlet.http.Cookie {
	*** TSPECIALS;
	*** comment;
	*** domain;
	*** isHttpOnly;
	*** lStrings;
	*** maxAge;
	*** name;
	*** path;
	*** secure;
	*** value;
	*** version;
	*** getComment();
	*** getDomain();
	*** getMaxAge();
	*** getName();
	*** getPath();
	*** getSecure();
	*** getValue();
	*** getVersion();
	*** isHttpOnly();
	*** isToken(java.lang.String);
	*** setComment(java.lang.String);
	*** setDomain(java.lang.String);
	*** setMaxAge(int);
	*** setPath(java.lang.String);
	*** setVersion(int);
}

-keep class javax.servlet.http.HttpServlet {
	*** lStrings;
	javax.servlet.http.HttpServlet();
	*** doDelete(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doGet(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doHead(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doOptions(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doPost(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doPut(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doTrace(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** getAllDeclaredMethods(java.lang.Class);
	*** getLastModified(javax.servlet.http.HttpServletRequest);
	*** maybeSetLastModified(javax.servlet.http.HttpServletResponse,long);
	*** service(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	*** service(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class javax.servlet.http.HttpServletRequest {
	*** getCookies();
	*** getDateHeader(java.lang.String);
	*** getHeader(java.lang.String);
	*** getHeaderNames();
	*** getHeaders(java.lang.String);
	*** getMethod();
	*** getPathInfo();
	*** getQueryString();
	*** getRequestURI();
	*** getRequestURL();
	*** getRequestedSessionId();
	*** getServletPath();
	*** getSession(boolean);
}

-keep class javax.servlet.http.HttpServletResponse {
	*** addCookie(javax.servlet.http.Cookie);
	*** addHeader(java.lang.String,java.lang.String);
	*** containsHeader(java.lang.String);
	*** encodeRedirectURL(java.lang.String);
	*** sendError(int);
	*** sendError(int,java.lang.String);
	*** sendRedirect(java.lang.String);
	*** setDateHeader(java.lang.String,long);
	*** setHeader(java.lang.String,java.lang.String);
	*** setStatus(int);
}

-keep class javax.servlet.http.HttpSession {
	*** getAttribute(java.lang.String);
	*** getAttributeNames();
	*** getId();
	*** invalidate();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
}

-keep class javax.servlet.http.HttpSessionActivationListener {
	*** sessionDidActivate(javax.servlet.http.HttpSessionEvent);
	*** sessionWillPassivate(javax.servlet.http.HttpSessionEvent);
}

-keep class javax.servlet.http.HttpSessionAttributeListener {
	*** attributeAdded(javax.servlet.http.HttpSessionBindingEvent);
	*** attributeRemoved(javax.servlet.http.HttpSessionBindingEvent);
	*** attributeReplaced(javax.servlet.http.HttpSessionBindingEvent);
}

-keep class javax.servlet.http.HttpSessionBindingListener {
	*** valueBound(javax.servlet.http.HttpSessionBindingEvent);
	*** valueUnbound(javax.servlet.http.HttpSessionBindingEvent);
}

-keep class javax.servlet.http.HttpSessionListener {
	*** sessionCreated(javax.servlet.http.HttpSessionEvent);
	*** sessionDestroyed(javax.servlet.http.HttpSessionEvent);
}

-keep class javax.servlet.http.NoBodyResponse {
	*** setContentLength();
}

-keep class javax.swing.AbstractAction {
	*** RECONFIGURE_ON_NULL;
	*** arrayTable;
	*** changeSupport;
	*** enabled;
	javax.swing.AbstractAction(java.lang.String);
	*** firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** putValue(java.lang.String,java.lang.Object);
}

-keep class javax.swing.AbstractButton {
	*** getIcon();
	*** getMargin();
	*** getMnemonic();
	*** getModel();
	*** isFocusPainted();
}

-keep class javax.swing.Action {
	*** getValue(java.lang.String);
	*** isEnabled();
}

-keep class javax.swing.ActionMap {
	*** arrayTable;
	*** parent;
	javax.swing.ActionMap();
	*** allKeys();
	*** clear();
	*** get(java.lang.Object);
	*** getParent();
	*** keys();
	*** put(java.lang.Object,javax.swing.Action);
	*** remove(java.lang.Object);
	*** setParent(javax.swing.ActionMap);
	*** size();
}

-keep class javax.swing.AncestorNotifier {
	*** firstInvisibleAncestor;
	*** listenerList;
	*** root;
	*** addAncestorListener(javax.swing.event.AncestorListener);
	*** addListeners(java.awt.Component,boolean);
	*** fireAncestorAdded(javax.swing.JComponent,int,java.awt.Container,java.awt.Container);
	*** fireAncestorMoved(javax.swing.JComponent,int,java.awt.Container,java.awt.Container);
	*** fireAncestorRemoved(javax.swing.JComponent,int,java.awt.Container,java.awt.Container);
	*** getAncestorListeners();
	*** removeAllListeners();
	*** removeAncestorListener(javax.swing.event.AncestorListener);
	*** removeListeners(java.awt.Component);
}

-keep class javax.swing.ArrayTable {
	*** table;
	*** clear();
	*** clone();
	*** containsKey(java.lang.Object);
	*** get(java.lang.Object);
	*** getKeys(java.lang.Object[]);
	*** grow();
	*** isArray();
	*** put(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** shrink();
	*** size();
	*** writeArrayTable(java.io.ObjectOutputStream,javax.swing.ArrayTable);
}

-keep class javax.swing.Autoscroller {
	*** isRunning(javax.swing.JComponent);
	*** processMouseDragged(java.awt.event.MouseEvent);
	*** stop(javax.swing.JComponent);
}

-keep class javax.swing.BorderFactory {
	*** emptyBorder;
	*** sharedDashedBorder;
	*** sharedEtchedBorder;
	*** sharedLoweredBevel;
	*** sharedRaisedBevel;
	*** sharedRaisedEtchedBorder;
	*** sharedSoftLoweredBevel;
	*** sharedSoftRaisedBevel;
	*** createDashedBorder(java.awt.Paint,float,float,float,boolean);
	*** createEmptyBorder();
	*** createEmptyBorder(int,int,int,int);
	*** createLineBorder(java.awt.Color);
	*** createLoweredSoftBevelBorder();
	*** createRaisedBevelBorder();
	*** createRaisedSoftBevelBorder();
	*** createSharedBevel(int);
	*** createStrokeBorder(java.awt.BasicStroke,java.awt.Paint);
}

-keep class javax.swing.ButtonModel {
	*** addChangeListener(javax.swing.event.ChangeListener);
	*** isArmed();
	*** isPressed();
	*** isSelected();
	*** removeChangeListener(javax.swing.event.ChangeListener);
}

-keep class javax.swing.CellRendererPane {
	*** paintComponent(java.awt.Graphics,java.awt.Component,java.awt.Container,int,int,int,int,boolean);
}

-keep class javax.swing.ClientPropertyKey {
	*** $VALUES;
	*** JComponent_ANCESTOR_NOTIFIER;
	*** JComponent_INPUT_VERIFIER;
	*** JComponent_TRANSFER_HANDLER;
	*** PopupFactory_FORCE_HEAVYWEIGHT_POPUP;
	*** reportValueNotSerializable;
	javax.swing.ClientPropertyKey(java.lang.String,int,boolean);
	*** getReportValueNotSerializable();
}

-keep class javax.swing.ComponentInputMap {
	*** component;
	javax.swing.ComponentInputMap(javax.swing.JComponent);
	*** getComponent();
}

-keep class javax.swing.DebugGraphics {
	*** debugComponentCount();
	*** getDebugOptions(javax.swing.JComponent);
	*** setDebugOptions(javax.swing.JComponent,int);
	*** shouldComponentDebug(javax.swing.JComponent);
}

-keep class javax.swing.DefaultCellEditor {
	*** getComponent();
}

-keep class javax.swing.DelegatingDefaultFocusManager {
	*** getDelegate();
}

-keep class javax.swing.DropMode {
	*** USE_SELECTION;
}

-keep class javax.swing.FocusManager {
	*** enabled;
	*** isFocusManagerEnabled();
}

-keep class javax.swing.GrayFilter {
	*** createDisabledImage(java.awt.Image);
}

-keep class javax.swing.Icon {
	*** getIconHeight();
	*** getIconWidth();
	*** paintIcon(java.awt.Component,java.awt.Graphics,int,int);
}

-keep class javax.swing.ImageIcon {
	*** getImage();
}

-keep class javax.swing.InputMap {
	*** arrayTable;
	*** parent;
	javax.swing.InputMap();
	*** allKeys();
	*** clear();
	*** get(javax.swing.KeyStroke);
	*** getParent();
	*** keys();
	*** put(javax.swing.KeyStroke,java.lang.Object);
	*** remove(javax.swing.KeyStroke);
	*** setParent(javax.swing.InputMap);
	*** size();
}

-keep class javax.swing.InputVerifier {
	*** shouldYieldFocus(javax.swing.JComponent);
}

-keep class javax.swing.InternalFrameFocusTraversalPolicy {
	javax.swing.InternalFrameFocusTraversalPolicy();
}

-keep class javax.swing.JButton {
	*** isDefaultButton();
}

-keep class javax.swing.JComboBox {
	*** getUI();
}

-keep class javax.swing.JComponent {
	*** DEBUG_GRAPHICS_LOADED;
	*** INPUT_VERIFIER_SOURCE_KEY;
	*** aaTextInfo;
	*** accessibleContext;
	*** actionMap;
	*** alignmentX;
	*** alignmentY;
	*** ancestorInputMap;
	*** autoscrolls;
	*** border;
	*** clientProperties;
	*** componentObtainingGraphicsFrom;
	*** componentObtainingGraphicsFromLock;
	*** flags;
	*** focusController;
	*** focusInputMap;
	*** inputVerifier;
	*** isAlignmentXSet;
	*** isAlignmentYSet;
	*** listenerList;
	*** managingFocusBackwardTraversalKeys;
	*** managingFocusForwardTraversalKeys;
	*** paintingChild;
	*** popupMenu;
	*** readObjectCallbacks;
	*** tempRectangles;
	*** ui;
	*** verifyInputWhenFocusTarget;
	*** vetoableChangeSupport;
	*** windowInputMap;
	javax.swing.JComponent();
	*** _paintImmediately(int,int,int,int);
	*** access$100();
	*** addAncestorListener(javax.swing.event.AncestorListener);
	*** addNotify();
	*** adjustPaintFlags();
	*** alwaysOnTop();
	*** checkIfChildObscuredBySibling();
	*** clientPropertyChanged(java.lang.Object,java.lang.Object,java.lang.Object);
	*** componentInputMapChanged(javax.swing.ComponentInputMap);
	*** computeVisibleRect(java.awt.Component,java.awt.Rectangle);
	*** computeVisibleRect(java.awt.Rectangle);
	*** deregisterNextFocusableComponent();
	*** fetchRectangle();
	*** firePropertyChange(java.lang.String,boolean,boolean);
	*** firePropertyChange(java.lang.String,char,char);
	*** firePropertyChange(java.lang.String,int,int);
	*** getActionMap();
	*** getActionMap(boolean);
	*** getAncestorListeners();
	*** getAncestorNotifier();
	*** getBorder();
	*** getClientProperties();
	*** getClientProperty(java.lang.Object);
	*** getComponentGraphics(java.awt.Graphics);
	*** getComponentPopupMenu();
	*** getCreatedDoubleBuffer();
	*** getDefaultLocale();
	*** getFlag(int);
	*** getFontMetrics(java.awt.Font);
	*** getGraphicsInvoked(java.awt.Component);
	*** getHeight();
	*** getInheritsPopupMenu();
	*** getInputMap(int);
	*** getInputMap(int,boolean);
	*** getInputVerifier();
	*** getInsets();
	*** getManagingFocusBackwardTraversalKeys();
	*** getManagingFocusForwardTraversalKeys();
	*** getMaximumSize();
	*** getMinimumSize();
	*** getNextFocusableComponent();
	*** getObscuredState(int,int,int,int,int);
	*** getPreferredSize();
	*** getRootPane();
	*** getToolTipText();
	*** getToolTipText(java.awt.event.MouseEvent);
	*** getTopLevelAncestor();
	*** getTransferHandler();
	*** getUIClassID();
	*** getVerifyInputWhenFocusTarget();
	*** getVetoableChangeListeners();
	*** getVisibleRect();
	*** getWidth();
	*** getWriteObjCounter(javax.swing.JComponent);
	*** getX();
	*** getY();
	*** isComponentObtainingGraphicsFrom(java.awt.Component);
	*** isDoubleBuffered();
	*** isLightweightComponent(java.awt.Component);
	*** isManagingFocus();
	*** isOpaque();
	*** isOptimizedDrawingEnabled();
	*** isPaintingOrigin();
	*** isRequestFocusEnabled();
	*** paint(java.awt.Graphics);
	*** paintBorder(java.awt.Graphics);
	*** paintChildren(java.awt.Graphics);
	*** paintComponent(java.awt.Graphics);
	*** paintImmediately(int,int,int,int);
	*** paintToOffscreen(java.awt.Graphics,int,int,int,int,int,int);
	*** paramString();
	*** print(java.awt.Graphics);
	*** printBorder(java.awt.Graphics);
	*** printChildren(java.awt.Graphics);
	*** printComponent(java.awt.Graphics);
	*** processComponentKeyEvent(java.awt.event.KeyEvent);
	*** processKeyBinding(javax.swing.KeyStroke,java.awt.event.KeyEvent,int,boolean);
	*** processKeyBindings(java.awt.event.KeyEvent,boolean);
	*** processKeyBindingsForAllComponents(java.awt.event.KeyEvent,java.awt.Container,boolean);
	*** processKeyEvent(java.awt.event.KeyEvent);
	*** putClientProperty(java.lang.Object,java.lang.Object);
	*** rectangleIsObscured(int,int,int,int);
	*** recycleRectangle(java.awt.Rectangle);
	*** registerKeyboardAction(java.awt.event.ActionListener,java.lang.String,javax.swing.KeyStroke,int);
	*** registerNextFocusableComponent();
	*** registerNextFocusableComponent(java.awt.Component);
	*** registerWithKeyboardManager(boolean);
	*** registerWithKeyboardManager(javax.swing.KeyStroke);
	*** removeAncestorListener(javax.swing.event.AncestorListener);
	*** removeNotify();
	*** repaint(java.awt.Rectangle);
	*** repaint(long,int,int,int,int);
	*** requestDefaultFocus();
	*** requestFocus();
	*** revalidate();
	*** safelyGetGraphics(java.awt.Component,java.awt.Component);
	*** scrollRectToVisible(java.awt.Rectangle);
	*** setActionMap(javax.swing.ActionMap);
	*** setAlignmentX(float);
	*** setAutoscrolls(boolean);
	*** setBackground(java.awt.Color);
	*** setBorder(javax.swing.border.Border);
	*** setCreatedDoubleBuffer(boolean);
	*** setDefaultLocale(java.util.Locale);
	*** setDoubleBuffered(boolean);
	*** setEnabled(boolean);
	*** setFlag(int,boolean);
	*** setFont(java.awt.Font);
	*** setForeground(java.awt.Color);
	*** setInputMap(int,javax.swing.InputMap);
	*** setOpaque(boolean);
	*** setPaintingChild(java.awt.Component);
	*** setToolTipText(java.lang.String);
	*** setTransferHandler(javax.swing.TransferHandler);
	*** setUI(javax.swing.plaf.ComponentUI);
	*** setUIProperty(java.lang.String,java.lang.Object);
	*** setVisible(boolean);
	*** setWriteObjCounter(javax.swing.JComponent,byte);
	*** shouldDebugGraphics();
	*** uninstallUIAndProperties();
	*** unregisterWithKeyboardManager();
	*** unregisterWithKeyboardManager(javax.swing.KeyStroke);
	*** updateUI();
}

-keep class javax.swing.JComponent$ActionStandin {
	*** access$000(javax.swing.JComponent$ActionStandin);
}

-keep class javax.swing.JComponent$KeyboardState {
	*** shouldProcess(java.awt.event.KeyEvent);
}

-keep class javax.swing.JComponent$ReadObjectCallback {
	*** access$400(javax.swing.JComponent$ReadObjectCallback,javax.swing.JComponent);
}

-keep class javax.swing.JDialog {
	*** accessibleContext;
	*** defaultCloseOperation;
	*** defaultLookAndFeelDecoratedKey;
	*** rootPane;
	*** rootPaneCheckingEnabled;
	*** transferHandler;
	javax.swing.JDialog(java.awt.Dialog,boolean);
	javax.swing.JDialog(java.awt.Dialog,java.lang.String,boolean);
	javax.swing.JDialog(java.awt.Frame,boolean);
	javax.swing.JDialog(java.awt.Frame,java.lang.String,boolean);
	javax.swing.JDialog(java.awt.Window,java.awt.Dialog$ModalityType);
	javax.swing.JDialog(java.awt.Window,java.lang.String,java.awt.Dialog$ModalityType);
	*** createRootPane();
	*** dialogInit();
	*** getContentPane();
	*** getRootPane();
	*** isDefaultLookAndFeelDecorated();
	*** isRootPaneCheckingEnabled();
	*** remove(java.awt.Component);
	*** setRootPane(javax.swing.JRootPane);
	*** setRootPaneCheckingEnabled(boolean);
}

-keep class javax.swing.JEditorPane {
	*** defaultEditorKitMap;
	*** isUserSetEditorKit;
	*** kit;
	*** kitLoaderRegistryKey;
	*** kitRegistryKey;
	*** kitTypeRegistryKey;
	*** pageLoader;
	*** pageProperties;
	*** typeHandlers;
	javax.swing.JEditorPane();
	*** addHyperlinkListener(javax.swing.event.HyperlinkListener);
	*** createDefaultEditorKit();
	*** createEditorKitForContentType(java.lang.String);
	*** getAsynchronousLoadPriority(javax.swing.text.Document);
	*** getEditorKit();
	*** getEditorKitForContentType(java.lang.String);
	*** getKitLoaderRegistry();
	*** getKitRegisty();
	*** getKitTypeRegistry();
	*** getPage();
	*** getPostData();
	*** getPreferredSize();
	*** getScrollableTracksViewportHeight();
	*** getScrollableTracksViewportWidth();
	*** getStream(java.net.URL);
	*** getUIClassID();
	*** handleConnectionProperties(java.net.URLConnection);
	*** handlePostData(java.net.HttpURLConnection,java.lang.Object);
	*** initializeModel(javax.swing.text.EditorKit,java.net.URL);
	*** loadDefaultKitsIfNecessary();
	*** read(java.io.InputStream,javax.swing.text.Document);
	*** registerEditorKitForContentType(java.lang.String,java.lang.String);
	*** registerEditorKitForContentType(java.lang.String,java.lang.String,java.lang.ClassLoader);
	*** scrollToReference(java.lang.String);
	*** setCharsetFromContentTypeParameters(java.lang.String);
	*** setContentType(java.lang.String);
	*** setEditorKit(javax.swing.text.EditorKit);
	*** setEditorKitForContentType(java.lang.String,javax.swing.text.EditorKit);
	*** setPage(java.lang.String);
	*** setPage(java.net.URL);
	*** setText(java.lang.String);
}

-keep class javax.swing.JEditorPane$HeaderParser {
	*** findValue(java.lang.String);
}

-keep class javax.swing.JFrame {
	*** accessibleContext;
	*** defaultCloseOperation;
	*** defaultLookAndFeelDecoratedKey;
	*** rootPane;
	*** rootPaneCheckingEnabled;
	*** transferHandler;
	*** createRootPane();
	*** frameInit();
	*** getContentPane();
	*** getJMenuBar();
	*** getRootPane();
	*** isDefaultLookAndFeelDecorated();
	*** isRootPaneCheckingEnabled();
	*** remove(java.awt.Component);
	*** setContentPane(java.awt.Container);
	*** setRootPane(javax.swing.JRootPane);
	*** setRootPaneCheckingEnabled(boolean);
}

-keep class javax.swing.JInternalFrame {
	*** getMostRecentFocusOwner();
	*** isSelected();
}

-keep class javax.swing.JLabel {
	*** defaultIcon;
	*** disabledIcon;
	*** disabledIconSet;
	*** horizontalAlignment;
	*** horizontalTextPosition;
	*** iconTextGap;
	*** labelFor;
	*** mnemonic;
	*** mnemonicIndex;
	*** text;
	*** verticalAlignment;
	*** verticalTextPosition;
	javax.swing.JLabel(java.lang.String);
	javax.swing.JLabel(java.lang.String,javax.swing.Icon,int);
	*** checkHorizontalKey(int,java.lang.String);
	*** checkVerticalKey(int,java.lang.String);
	*** getDisplayedMnemonic();
	*** getIcon();
	*** getText();
	*** getUIClassID();
	*** setDisabledIcon(javax.swing.Icon);
	*** setDisplayedMnemonic(int);
	*** setDisplayedMnemonicIndex(int);
	*** setHorizontalAlignment(int);
	*** setIcon(javax.swing.Icon);
	*** setText(java.lang.String);
	*** setUI(javax.swing.plaf.LabelUI);
	*** setVerticalAlignment(int);
	*** updateUI();
}

-keep class javax.swing.JLayer {
	*** getView();
}

-keep class javax.swing.JLayeredPane {
	*** DEFAULT_LAYER;
	*** DRAG_LAYER;
	*** FRAME_CONTENT_LAYER;
	*** MODAL_LAYER;
	*** PALETTE_LAYER;
	*** POPUP_LAYER;
	*** componentToLayer;
	*** optimizedDrawingPossible;
	*** getComponentCountInLayer(int);
	*** getComponentToLayer();
	*** getIndexOf(java.awt.Component);
	*** getLayer(java.awt.Component);
	*** getObjectForLayer(int);
	*** getPosition(java.awt.Component);
	*** insertIndexForLayer(int,int);
	*** insertIndexForLayer(java.awt.Component,int,int);
	*** setLayer(java.awt.Component,int);
	*** setLayer(java.awt.Component,int,int);
	*** setPosition(java.awt.Component,int);
	*** validateOptimizedDrawing();
}

-keep class javax.swing.JList {
	*** getCellBounds(int,int);
	*** getCellRenderer();
	*** getModel();
	*** locationToIndex(java.awt.Point);
}

-keep class javax.swing.JMenu {
	*** getMenuComponents();
}

-keep class javax.swing.JMenuBar {
	*** getMenu(int);
	*** getMenuCount();
	*** getUI();
}

-keep class javax.swing.JOptionPane {
	*** showConfirmDialog(java.awt.Component,java.lang.Object,java.lang.String,int,int);
}

-keep class javax.swing.JPanel {
	javax.swing.JPanel(boolean);
	javax.swing.JPanel(java.awt.LayoutManager,boolean);
	*** getUIClassID();
	*** setUI(javax.swing.plaf.PanelUI);
	*** updateUI();
}

-keep class javax.swing.JPasswordField {
	*** customSetUIProperty(java.lang.String,java.lang.Object);
}

-keep class javax.swing.JRootPane {
	*** IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING;
	*** LOG_DISABLE_TRUE_DOUBLE_BUFFERING;
	*** contentPane;
	*** defaultButton;
	*** glassPane;
	*** layeredPane;
	*** menuBar;
	*** useTrueDoubleBuffering;
	*** windowDecorationStyle;
	*** createContentPane();
	*** createGlassPane();
	*** createLayeredPane();
	*** createRootLayout();
	*** disableTrueDoubleBuffering();
	*** getContentPane();
	*** getDefaultButton();
	*** getGlassPane();
	*** getLayeredPane();
	*** getMenuBar();
	*** getWindowDecorationStyle();
	*** setContentPane(java.awt.Container);
	*** setDoubleBuffered(boolean);
	*** setGlassPane(java.awt.Component);
	*** setLayeredPane(javax.swing.JLayeredPane);
	*** setMenuBar(javax.swing.JMenuBar);
	*** setUI(javax.swing.plaf.RootPaneUI);
	*** setWindowDecorationStyle(int);
	*** updateUI();
}

-keep class javax.swing.JRootPane$1 {
	*** this$0;
}

-keep class javax.swing.JRootPane$RootLayout {
	*** this$0;
}

-keep class javax.swing.JScrollPane {
	*** getViewport();
}

-keep class javax.swing.JTable {
	*** convertColumnIndexToModel(int);
	*** getCellRect(int,int,boolean);
	*** getCellRenderer(int,int);
	*** getValueAt(int,int);
}

-keep class javax.swing.JToolTip {
	*** setComponent(javax.swing.JComponent);
}

-keep class javax.swing.JViewport {
	*** getView();
}

-keep class javax.swing.JWindow {
	*** accessibleContext;
	*** rootPane;
	*** rootPaneCheckingEnabled;
	*** transferHandler;
	javax.swing.JWindow(java.awt.Frame);
	javax.swing.JWindow(java.awt.Window,java.awt.GraphicsConfiguration);
	*** createRootPane();
	*** getContentPane();
	*** getRootPane();
	*** isRootPaneCheckingEnabled();
	*** remove(java.awt.Component);
	*** setRootPane(javax.swing.JRootPane);
	*** setRootPaneCheckingEnabled(boolean);
	*** windowInit();
}

-keep class javax.swing.KeyStroke {
	*** getKeyStroke(char);
	*** getKeyStroke(int,int);
	*** getKeyStroke(int,int,boolean);
	*** getKeyStroke(java.lang.String);
}

-keep class javax.swing.KeyboardManager {
	*** fireKeyboardAction(java.awt.event.KeyEvent,boolean,java.awt.Container);
	*** getCurrentManager();
	*** registerKeyStroke(javax.swing.KeyStroke,javax.swing.JComponent);
	*** unregisterKeyStroke(javax.swing.KeyStroke,javax.swing.JComponent);
}

-keep class javax.swing.LayoutComparator {
	*** horizontal;
	*** leftToRight;
	*** compare(java.awt.Component,java.awt.Component);
	*** setComponentOrientation(java.awt.ComponentOrientation);
}

-keep class javax.swing.LayoutFocusTraversalPolicy {
	*** fitnessTestPolicy;
}

-keep class javax.swing.LegacyGlueFocusTraversalPolicy {
	*** setNextFocusableComponent(java.awt.Component,java.awt.Component);
	*** unsetNextFocusableComponent(java.awt.Component,java.awt.Component);
}

-keep class javax.swing.ListCellRenderer {
	*** getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean);
}

-keep class javax.swing.ListModel {
	*** getElementAt(int);
}

-keep class javax.swing.ListSelectionModel {
	*** addSelectionInterval(int,int);
	*** isSelectedIndex(int);
	*** removeSelectionInterval(int,int);
	*** setAnchorSelectionIndex(int);
	*** setLeadSelectionIndex(int);
}

-keep class javax.swing.LookAndFeel {
	javax.swing.LookAndFeel();
	*** getDefaults();
	*** getDescription();
	*** getDisabledIcon(javax.swing.JComponent,javax.swing.Icon);
	*** getSupportsWindowDecorations();
	*** initialize();
	*** installBorder(javax.swing.JComponent,java.lang.String);
	*** installColors(javax.swing.JComponent,java.lang.String,java.lang.String);
	*** installColorsAndFont(javax.swing.JComponent,java.lang.String,java.lang.String,java.lang.String);
	*** installProperty(javax.swing.JComponent,java.lang.String,java.lang.Object);
	*** isNativeLookAndFeel();
	*** isSupportedLookAndFeel();
	*** loadKeyBindings(javax.swing.InputMap,java.lang.Object[]);
	*** makeComponentInputMap(javax.swing.JComponent,java.lang.Object[]);
	*** makeInputMap(java.lang.Object[]);
	*** provideErrorFeedback(java.awt.Component);
	*** toString();
	*** uninitialize();
	*** uninstallBorder(javax.swing.JComponent);
}

-keep class javax.swing.MultiUIDefaults {
	*** tables;
	*** entrySet();
	*** get(java.lang.Object);
	*** keys();
	*** size();
}

-keep class javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator$Type {
	*** ELEMENTS;
	*** KEYS;
}

-keep class javax.swing.PopupFactory {
	*** SharedInstanceKey;
	*** popupType;
	javax.swing.PopupFactory();
	*** getHeadlessPopup(java.awt.Component,java.awt.Component,int,int);
	*** getHeavyWeightPopup(java.awt.Component,java.awt.Component,int,int);
	*** getLightWeightPopup(java.awt.Component,java.awt.Component,int,int);
	*** getMediumWeightPopup(java.awt.Component,java.awt.Component,int,int);
	*** getPopup(java.awt.Component,java.awt.Component,int,int);
	*** getPopup(java.awt.Component,java.awt.Component,int,int,int);
	*** getPopupType();
	*** getPopupType(java.awt.Component,java.awt.Component,int,int);
	*** getSharedInstance();
	*** invokerInHeavyWeightPopup(java.awt.Component);
	*** setSharedInstance(javax.swing.PopupFactory);
}

-keep class javax.swing.PopupFactory$HeadlessPopup {
	*** getHeadlessPopup(java.awt.Component,java.awt.Component,int,int);
}

-keep class javax.swing.PopupFactory$HeavyWeightPopup {
	*** getHeavyWeightPopup(java.awt.Component,java.awt.Component,int,int);
}

-keep class javax.swing.PopupFactory$LightWeightPopup {
	*** getLightWeightPopup(java.awt.Component,java.awt.Component,int,int);
}

-keep class javax.swing.PopupFactory$MediumWeightPopup {
	*** getMediumWeightPopup(java.awt.Component,java.awt.Component,int,int);
}

-keep class javax.swing.RepaintManager {
	*** BUFFER_STRATEGY_TYPE;
	*** HANDLE_TOP_LEVEL_PAINT;
	*** bufferStrategyType;
	*** dirtyComponents;
	*** doubleBufferMaxSize;
	*** doubleBufferingEnabled;
	*** hwDirtyComponents;
	*** invalidComponents;
	*** javaSecurityAccess;
	*** nativeDoubleBuffering;
	*** paintDepth;
	*** paintManager;
	*** paintThread;
	*** painting;
	*** processingRunnable;
	*** repaintManagerKey;
	*** repaintRoot;
	*** runnableList;
	*** standardDoubleBuffer;
	*** tmp;
	*** tmpDirtyComponents;
	*** volatileBufferType;
	*** volatileImageBufferEnabled;
	*** volatileMap;
	javax.swing.RepaintManager(short);
	*** _getOffscreenBuffer(java.awt.Component,int,int);
	*** access$1100(javax.swing.RepaintManager);
	*** access$300(javax.swing.RepaintManager);
	*** access$302(javax.swing.RepaintManager,javax.swing.JComponent);
	*** access$700();
	*** access$800(javax.swing.RepaintManager);
	*** addDirtyRegion(java.applet.Applet,int,int,int,int);
	*** addDirtyRegion(java.awt.Window,int,int,int,int);
	*** addDirtyRegion(javax.swing.JComponent,int,int,int,int);
	*** addDirtyRegion0(java.awt.Container,int,int,int,int);
	*** addInvalidComponent(javax.swing.JComponent);
	*** adjustRoots(javax.swing.JComponent,java.util.List,int);
	*** beginPaint();
	*** clearImages();
	*** clearImages(int,int);
	*** collectDirtyComponents(java.util.Map,java.awt.Component,java.util.List);
	*** currentManager(java.awt.Component);
	*** currentManager(javax.swing.JComponent);
	*** currentManager(sun.awt.AppContext);
	*** displayChanged();
	*** doubleBufferingChanged(javax.swing.JRootPane);
	*** endPaint();
	*** extendDirtyRegion(java.awt.Component,int,int,int,int);
	*** getDelegate(java.awt.Component);
	*** getDirtyRegion(javax.swing.JComponent);
	*** getDoubleBufferMaximumSize();
	*** getOffscreenBuffer(java.awt.Component,int,int);
	*** getPaintManager();
	*** getVolatileOffscreenBuffer(java.awt.Component,int,int);
	*** isCompletelyDirty(javax.swing.JComponent);
	*** isDoubleBufferingEnabled();
	*** isPainting();
	*** isPaintingThread();
	*** markCompletelyClean(javax.swing.JComponent);
	*** markCompletelyDirty(javax.swing.JComponent);
	*** nativeAddDirtyRegion(sun.awt.AppContext,java.awt.Container,int,int,int,int);
	*** nativeQueueSurfaceDataRunnable(sun.awt.AppContext,java.awt.Component,java.lang.Runnable);
	*** paint(javax.swing.JComponent,javax.swing.JComponent,java.awt.Graphics,int,int,int,int);
	*** paintDirtyRegions();
	*** paintDirtyRegions(java.util.Map);
	*** prePaintDirtyRegions();
	*** removeInvalidComponent(javax.swing.JComponent);
	*** resetDoubleBuffer();
	*** resetVolatileDoubleBuffer(java.awt.GraphicsConfiguration);
	*** scheduleHeavyWeightPaints();
	*** scheduleProcessingRunnable(sun.awt.AppContext);
	*** setPaintManager(javax.swing.RepaintManager$PaintManager);
	*** show(java.awt.Container,int,int,int,int);
	*** updateWindows(java.util.Map);
	*** useVolatileDoubleBuffer();
	*** validateInvalidComponents();
}

-keep class javax.swing.RepaintManager$DisplayChangedHandler {
	javax.swing.RepaintManager$DisplayChangedHandler();
	*** scheduleDisplayChanges();
}

-keep class javax.swing.RepaintManager$DoubleBufferInfo {
	*** image;
	*** needsReset;
	*** size;
}

-keep class javax.swing.RepaintManager$PaintManager {
	*** $assertionsDisabled;
	*** isRepaintingRoot;
	*** repaintManager;
	*** beginPaint();
	*** copyArea(javax.swing.JComponent,java.awt.Graphics,int,int,int,int,int,int,boolean);
	*** dispose();
	*** doubleBufferingChanged(javax.swing.JRootPane);
	*** endPaint();
	*** getValidImage(java.awt.Image);
	*** paint(javax.swing.JComponent,javax.swing.JComponent,java.awt.Graphics,int,int,int,int);
	*** paintDoubleBuffered(javax.swing.JComponent,java.awt.Image,java.awt.Graphics,int,int,int,int);
	*** show(java.awt.Container,int,int,int,int);
}

-keep class javax.swing.RepaintManager$ProcessingRunnable {
	*** pending;
	*** this$0;
	javax.swing.RepaintManager$ProcessingRunnable(javax.swing.RepaintManager);
	*** markPending();
}

-keep class javax.swing.RootPaneContainer {
	*** getRootPane();
}

-keep class javax.swing.SortingFocusTraversalPolicy {
	*** BACKWARD_TRAVERSAL;
	*** FORWARD_TRAVERSAL;
	*** cachedCycle;
	*** cachedRoot;
	*** comparator;
	*** fitnessTestPolicy;
	*** implicitDownCycleTraversal;
	*** log;
	javax.swing.SortingFocusTraversalPolicy(java.util.Comparator);
	*** accept(java.awt.Component);
	*** enumerateAndSortCycle(java.awt.Container,java.util.List);
	*** enumerateCycle(java.awt.Container,java.util.List);
	*** getComparator();
	*** getComponentAfter(java.awt.Container,java.awt.Component);
	*** getComponentBefore(java.awt.Container,java.awt.Component);
	*** getComponentDownCycle(java.awt.Component,int);
	*** getComponentIndex(java.util.List,java.awt.Component);
	*** getFirstComponent(java.awt.Container);
	*** getFocusTraversalCycle(java.awt.Container);
	*** getImplicitDownCycleTraversal();
	*** getLastComponent(java.awt.Container);
	*** getTopmostProvider(java.awt.Container,java.awt.Component);
	*** setComparator(java.util.Comparator);
	*** setImplicitDownCycleTraversal(boolean);
}

-keep class javax.swing.SwingContainerOrderFocusTraversalPolicy {
	*** accept(java.awt.Component);
}

-keep class javax.swing.SwingDefaultFocusTraversalPolicy {
	*** accept(java.awt.Component);
}

-keep class javax.swing.SwingPaintEventDispatcher {
	*** ERASE_BACKGROUND;
	*** SHOW_FROM_DOUBLE_BUFFER;
}

-keep class javax.swing.SwingUtilities {
	*** canAccessEventQueue;
	*** checkedSuppressDropSupport;
	*** eventQueueTested;
	*** sharedOwnerFrameKey;
	*** suppressDropSupport;
	*** appContextGet(java.lang.Object);
	*** appContextPut(java.lang.Object,java.lang.Object);
	*** appContextRemove(java.lang.Object);
	*** computeIntersection(int,int,int,int,java.awt.Rectangle);
	*** computeUnion(int,int,int,int,java.awt.Rectangle);
	*** convertPoint(java.awt.Component,java.awt.Point,java.awt.Component);
	*** convertPointFromScreen(java.awt.Point,java.awt.Component);
	*** convertPointToScreen(java.awt.Point,java.awt.Component);
	*** convertRectangle(java.awt.Component,java.awt.Rectangle,java.awt.Component);
	*** doesIconReferenceImage(javax.swing.Icon,java.awt.Image);
	*** findDisplayedMnemonicIndex(java.lang.String,int);
	*** getAccessibleChild(java.awt.Component,int);
	*** getAccessibleChildrenCount(java.awt.Component);
	*** getCellRendererPane(java.awt.Component,java.awt.Container);
	*** getDeepestComponentAt(java.awt.Component,int,int);
	*** getPaintingOrigin(javax.swing.JComponent);
	*** getRoot(java.awt.Component);
	*** getRootPane(java.awt.Component);
	*** getSharedOwnerFrame();
	*** getSharedOwnerFrameShutdownListener();
	*** getSuppressDropTarget();
	*** getUIInputMap(javax.swing.JComponent,int);
	*** getUnwrappedParent(java.awt.Component);
	*** getValidateRoot(java.awt.Container,boolean);
	*** getWindowAncestor(java.awt.Component);
	*** installSwingDropTargetAsNecessary(java.awt.Component,javax.swing.TransferHandler);
	*** invokeAndWait(java.lang.Runnable);
	*** invokeLater(java.lang.Runnable);
	*** isDescendingFrom(java.awt.Component,java.awt.Component);
	*** isEventDispatchThread();
	*** isLeftMouseButton(java.awt.event.MouseEvent);
	*** isRectangleContainingRectangle(java.awt.Rectangle,java.awt.Rectangle);
	*** isValidKeyEventForKeyBindings(java.awt.event.KeyEvent);
	*** layoutCompoundLabelImpl(javax.swing.JComponent,java.awt.FontMetrics,java.lang.String,javax.swing.Icon,int,int,int,int,java.awt.Rectangle,java.awt.Rectangle,java.awt.Rectangle,int);
	*** loadSystemClass(java.lang.String);
	*** notifyAction(javax.swing.Action,javax.swing.KeyStroke,java.awt.event.KeyEvent,java.lang.Object,int);
	*** paintComponent(java.awt.Graphics,java.awt.Component,java.awt.Container,int,int,int,int);
	*** processKeyBindings(java.awt.event.KeyEvent);
	*** replaceUIActionMap(javax.swing.JComponent,javax.swing.ActionMap);
	*** replaceUIInputMap(javax.swing.JComponent,int,javax.swing.InputMap);
	*** updateComponentTreeUI(java.awt.Component);
	*** updateComponentTreeUI0(java.awt.Component);
}

-keep class javax.swing.SwingUtilities$SharedOwnerFrame {
	*** dispose();
	*** installListeners();
}

-keep class javax.swing.SwingWorker {
	*** cancel(boolean);
	*** execute();
}

-keep class javax.swing.Timer {
	*** start();
	*** stop();
}

-keep class javax.swing.ToolTipManager {
	*** registerComponent(javax.swing.JComponent);
	*** sharedInstance();
	*** unregisterComponent(javax.swing.JComponent);
}

-keep class javax.swing.TransferHandler {
	*** getCopyAction();
	*** getCutAction();
	*** getPasteAction();
}

-keep class javax.swing.UIDefaults {
	*** PENDING;
	*** changeSupport;
	*** defaultLocale;
	*** resourceBundles;
	*** resourceCache;
	javax.swing.UIDefaults();
	javax.swing.UIDefaults(int,float);
	*** addResourceBundle(java.lang.String);
	*** firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object);
	*** get(java.lang.Object);
	*** get(java.lang.Object,java.util.Locale);
	*** getBoolean(java.lang.Object);
	*** getBoolean(java.lang.Object,java.util.Locale);
	*** getBorder(java.lang.Object);
	*** getBorder(java.lang.Object,java.util.Locale);
	*** getColor(java.lang.Object);
	*** getColor(java.lang.Object,java.util.Locale);
	*** getDimension(java.lang.Object);
	*** getDimension(java.lang.Object,java.util.Locale);
	*** getFont(java.lang.Object);
	*** getFont(java.lang.Object,java.util.Locale);
	*** getFromHashtable(java.lang.Object);
	*** getFromResourceBundle(java.lang.Object,java.util.Locale);
	*** getIcon(java.lang.Object);
	*** getIcon(java.lang.Object,java.util.Locale);
	*** getInsets(java.lang.Object);
	*** getInsets(java.lang.Object,java.util.Locale);
	*** getInt(java.lang.Object);
	*** getInt(java.lang.Object,java.util.Locale);
	*** getResourceCache(java.util.Locale);
	*** getString(java.lang.Object);
	*** getString(java.lang.Object,java.util.Locale);
	*** getUI(javax.swing.JComponent);
	*** getUIClass(java.lang.String,java.lang.ClassLoader);
	*** getUIError(java.lang.String);
	*** put(java.lang.Object,java.lang.Object);
	*** putDefaults(java.lang.Object[]);
	*** setDefaultLocale(java.util.Locale);
}

-keep class javax.swing.UIDefaults$ActiveValue {
	*** createValue(javax.swing.UIDefaults);
}

-keep class javax.swing.UIDefaults$LazyInputMap {
	*** bindings;
}

-keep class javax.swing.UIDefaults$LazyValue {
	*** createValue(javax.swing.UIDefaults);
}

-keep class javax.swing.UIDefaults$TextAndMnemonicHashMap {
	javax.swing.UIDefaults$TextAndMnemonicHashMap();
	*** composeKey(java.lang.String,int,java.lang.String);
	*** getIndexFromProperty(java.lang.String);
	*** getMnemonicFromProperty(java.lang.String);
	*** getTextFromProperty(java.lang.String);
}

-keep class javax.swing.UIManager {
	*** classLock;
	*** installedLAFs;
	*** access$100();
	*** access$200(java.util.Properties,java.lang.String);
	*** checkProperty(java.util.Properties,java.lang.String);
	*** get(java.lang.Object);
	*** get(java.lang.Object,java.util.Locale);
	*** getBoolean(java.lang.Object);
	*** getBorder(java.lang.Object);
	*** getColor(java.lang.Object);
	*** getCrossPlatformLookAndFeelClassName();
	*** getDefaults();
	*** getFont(java.lang.Object);
	*** getInsets(java.lang.Object);
	*** getInstalledLookAndFeels();
	*** getLAFState();
	*** getLookAndFeel();
	*** getLookAndFeelDefaults();
	*** getMultiLookAndFeel();
	*** getString(java.lang.Object,java.util.Locale);
	*** getSystemLookAndFeelClassName();
	*** getUI(javax.swing.JComponent);
	*** initialize();
	*** initializeAuxiliaryLAFs(java.util.Properties);
	*** initializeDefaultLAF(java.util.Properties);
	*** initializeInstalledLAFs(java.util.Properties);
	*** initializeSystemDefaults(java.util.Properties);
	*** installLookAndFeel(javax.swing.UIManager$LookAndFeelInfo);
	*** loadSwingProperties();
	*** makeInstalledLAFKey(java.lang.String,java.lang.String);
	*** makeSwingPropertiesFilename();
	*** maybeInitialize();
	*** maybeInitializeFocusPolicy(javax.swing.JComponent);
	*** put(java.lang.Object,java.lang.Object);
	*** setInstalledLookAndFeels(javax.swing.UIManager$LookAndFeelInfo[]);
	*** setLookAndFeel(java.lang.String);
	*** setLookAndFeel(javax.swing.LookAndFeel);
}

-keep class javax.swing.UIManager$1 {
	*** val$props;
}

-keep class javax.swing.UIManager$LAFState {
	*** auxLookAndFeels;
	*** changeSupport;
	*** focusPolicyInitialized;
	*** initialized;
	*** installedLAFs;
	*** lookAndFeel;
	*** multiLookAndFeel;
	*** multiUIDefaults;
	*** swingProps;
	*** tables;
	javax.swing.UIManager$LAFState();
	*** getLookAndFeelDefaults();
	*** getPropertyChangeSupport(boolean);
	*** setLookAndFeelDefaults(javax.swing.UIDefaults);
}

-keep class javax.swing.UIManager$LookAndFeelInfo {
	*** className;
	*** name;
	*** getClassName();
	*** getName();
}

-keep class javax.swing.border.AbstractBorder {
	javax.swing.border.AbstractBorder();
	*** getBaseline(java.awt.Component,int,int);
	*** getBaselineResizeBehavior(java.awt.Component);
	*** getBorderInsets(java.awt.Component,java.awt.Insets);
	*** getInteriorRectangle(java.awt.Component,javax.swing.border.Border,int,int,int,int);
}

-keep class javax.swing.border.BevelBorder {
	*** bevelType;
	*** highlightInner;
	*** highlightOuter;
	*** shadowInner;
	*** shadowOuter;
	javax.swing.border.BevelBorder(int);
	javax.swing.border.BevelBorder(int,java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color);
	*** getHighlightInnerColor();
	*** getHighlightInnerColor(java.awt.Component);
	*** getHighlightOuterColor();
	*** getHighlightOuterColor(java.awt.Component);
	*** getShadowInnerColor();
	*** getShadowInnerColor(java.awt.Component);
	*** getShadowOuterColor();
	*** getShadowOuterColor(java.awt.Component);
	*** paintLoweredBevel(java.awt.Component,java.awt.Graphics,int,int,int,int);
	*** paintRaisedBevel(java.awt.Component,java.awt.Graphics,int,int,int,int);
}

-keep class javax.swing.border.Border {
	*** getBorderInsets(java.awt.Component);
	*** isBorderOpaque();
	*** paintBorder(java.awt.Component,java.awt.Graphics,int,int,int,int);
}

-keep class javax.swing.border.EmptyBorder {
	*** bottom;
	*** left;
	*** right;
	*** top;
	javax.swing.border.EmptyBorder(int,int,int,int);
	javax.swing.border.EmptyBorder(java.awt.Insets);
}

-keep class javax.swing.border.EtchedBorder {
	*** etchType;
	*** highlight;
	*** shadow;
	javax.swing.border.EtchedBorder(int);
	javax.swing.border.EtchedBorder(int,java.awt.Color,java.awt.Color);
	*** getHighlightColor(java.awt.Component);
	*** getShadowColor(java.awt.Component);
}

-keep class javax.swing.border.LineBorder {
	*** blackLine;
	*** grayLine;
	*** lineColor;
	*** roundedCorners;
	*** thickness;
	javax.swing.border.LineBorder(java.awt.Color);
	javax.swing.border.LineBorder(java.awt.Color,int);
	javax.swing.border.LineBorder(java.awt.Color,int,boolean);
}

-keep class javax.swing.event.AncestorEvent {
	*** ancestor;
	*** ancestorParent;
	*** getComponent();
}

-keep class javax.swing.event.AncestorListener {
	*** ancestorAdded(javax.swing.event.AncestorEvent);
	*** ancestorMoved(javax.swing.event.AncestorEvent);
	*** ancestorRemoved(javax.swing.event.AncestorEvent);
}

-keep class javax.swing.event.CaretListener {
	*** caretUpdate(javax.swing.event.CaretEvent);
}

-keep class javax.swing.event.EventListenerList {
	*** NULL_ARRAY;
	*** listenerList;
	*** add(java.lang.Class,java.util.EventListener);
	*** getListenerCount(java.lang.Object[],java.lang.Class);
	*** getListenerList();
	*** getListeners(java.lang.Class);
	*** remove(java.lang.Class,java.util.EventListener);
}

-keep class javax.swing.event.HyperlinkEvent {
	*** getDescription();
	*** getEventType();
}

-keep class javax.swing.event.HyperlinkEvent$EventType {
	*** ACTIVATED;
}

-keep class javax.swing.event.HyperlinkListener {
	*** hyperlinkUpdate(javax.swing.event.HyperlinkEvent);
}

-keep class javax.swing.event.MenuDragMouseEvent {
	*** getMenuSelectionManager();
	*** getPath();
}

-keep class javax.swing.filechooser.FileSystemView {
	*** getFileSystemView();
	*** getHomeDirectory();
}

-keep class javax.swing.plaf.ActionMapUIResource {
	javax.swing.plaf.ActionMapUIResource();
}

-keep class javax.swing.plaf.BorderUIResource {
	*** blackLine;
	*** delegate;
	*** etched;
	*** loweredBevel;
	*** raisedBevel;
}

-keep class javax.swing.plaf.ComboBoxUI {
	*** isFocusTraversable(javax.swing.JComboBox);
}

-keep class javax.swing.plaf.ComponentInputMapUIResource {
	javax.swing.plaf.ComponentInputMapUIResource(javax.swing.JComponent);
}

-keep class javax.swing.plaf.ComponentUI {
	javax.swing.plaf.ComponentUI();
	*** contains(javax.swing.JComponent,int,int);
	*** getBaseline(javax.swing.JComponent,int,int);
	*** getBaselineResizeBehavior(javax.swing.JComponent);
	*** getMaximumSize(javax.swing.JComponent);
	*** getMinimumSize(javax.swing.JComponent);
	*** getPreferredSize(javax.swing.JComponent);
	*** installUI(javax.swing.JComponent);
	*** paint(java.awt.Graphics,javax.swing.JComponent);
	*** uninstallUI(javax.swing.JComponent);
	*** update(java.awt.Graphics,javax.swing.JComponent);
}

-keep class javax.swing.plaf.FontUIResource {
	javax.swing.plaf.FontUIResource(java.awt.Font);
	javax.swing.plaf.FontUIResource(java.lang.String,int,int);
}

-keep class javax.swing.plaf.IconUIResource {
	*** delegate;
}

-keep class javax.swing.plaf.MenuBarUI {
	javax.swing.plaf.MenuBarUI();
}

-keep class javax.swing.plaf.PanelUI {
	javax.swing.plaf.PanelUI();
}

-keep class javax.swing.plaf.RootPaneUI {
	javax.swing.plaf.RootPaneUI();
}

-keep class javax.swing.plaf.TextUI {
	*** getEditorKit(javax.swing.text.JTextComponent);
	*** getToolTipText(javax.swing.text.JTextComponent,java.awt.Point);
	*** modelToView(javax.swing.text.JTextComponent,int);
	*** viewToModel(javax.swing.text.JTextComponent,java.awt.Point);
	*** viewToModel(javax.swing.text.JTextComponent,java.awt.Point,javax.swing.text.Position$Bias[]);
}

-keep class javax.swing.plaf.basic.BasicLookAndFeel {
	*** audioLock;
	*** clipPlaying;
	*** disposer;
	*** invocator;
	*** needsEventHelper;
	javax.swing.plaf.basic.BasicLookAndFeel();
	*** createAudioAction(java.lang.Object);
	*** getAudioActionMap();
	*** initClassDefaults(javax.swing.UIDefaults);
	*** initComponentDefaults(javax.swing.UIDefaults);
	*** initResourceBundle(javax.swing.UIDefaults);
	*** initSystemColorDefaults(javax.swing.UIDefaults);
	*** initialize();
	*** installAWTEventListener();
	*** loadAudioData(java.lang.String);
	*** loadSystemColors(javax.swing.UIDefaults,java.lang.String[],boolean);
	*** playSound(javax.swing.Action);
	*** uninitialize();
}

-keep class javax.swing.plaf.basic.BasicLookAndFeel$2 {
	*** this$0;
}

-keep class javax.swing.plaf.basic.BasicMenuBarUI {
	*** changeListener;
	*** containerListener;
	*** handler;
	*** menuBar;
	javax.swing.plaf.basic.BasicMenuBarUI();
	*** createChangeListener();
	*** createContainerListener();
	*** getHandler();
	*** getInputMap(int);
	*** installDefaults();
	*** installKeyboardActions();
	*** installListeners();
	*** uninstallDefaults();
	*** uninstallKeyboardActions();
	*** uninstallListeners();
	*** uninstallUI(javax.swing.JComponent);
}

-keep class javax.swing.plaf.basic.BasicPanelUI {
	*** panelUI;
	javax.swing.plaf.basic.BasicPanelUI();
	*** installDefaults(javax.swing.JPanel);
	*** uninstallDefaults(javax.swing.JPanel);
}

-keep class javax.swing.plaf.basic.BasicPopupMenuUI {
	*** MENU_KEYBOARD_HELPER_KEY;
	*** MOUSE_GRABBER_KEY;
}

-keep class javax.swing.plaf.basic.BasicPopupMenuUI$MenuKeyboardHelper {
	*** uninstall();
}

-keep class javax.swing.plaf.basic.BasicPopupMenuUI$MouseGrabber {
	*** uninstall();
}

-keep class javax.swing.plaf.basic.BasicRootPaneUI {
	*** rootPaneUI;
	javax.swing.plaf.basic.BasicRootPaneUI();
	*** createInputMap(int,javax.swing.JComponent);
	*** getInputMap(int,javax.swing.JComponent);
	*** installComponents(javax.swing.JRootPane);
	*** installDefaults(javax.swing.JRootPane);
	*** installKeyboardActions(javax.swing.JRootPane);
	*** installListeners(javax.swing.JRootPane);
	*** installUI(javax.swing.JComponent);
	*** propertyChange(java.beans.PropertyChangeEvent);
	*** uninstallComponents(javax.swing.JRootPane);
	*** uninstallDefaults(javax.swing.JRootPane);
	*** uninstallKeyboardActions(javax.swing.JRootPane);
	*** uninstallListeners(javax.swing.JRootPane);
	*** uninstallUI(javax.swing.JComponent);
	*** updateDefaultButtonBindings(javax.swing.JRootPane);
}

-keep class javax.swing.plaf.basic.LazyActionMap {
	*** $assertionsDisabled;
	*** _loader;
	*** installLazyActionMap(javax.swing.JComponent,java.lang.Class,java.lang.String);
	*** loadIfNecessary();
	*** put(java.lang.Object,javax.swing.Action);
	*** put(javax.swing.Action);
}

-keep class javax.swing.table.TableCellRenderer {
	*** getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int);
}

-keep class javax.swing.table.TableColumn {
	*** getModelIndex();
}

-keep class javax.swing.table.TableColumnModel {
	*** getColumn(int);
	*** getColumnCount();
}

-keep class javax.swing.text.AbstractDocument {
	*** getAsynchronousLoadPriority();
	*** readLock();
	*** readUnlock();
	*** replace(int,int,java.lang.String,javax.swing.text.AttributeSet);
}

-keep class javax.swing.text.AttributeSet {
	*** getAttribute(java.lang.Object);
}

-keep class javax.swing.text.Caret {
	*** addChangeListener(javax.swing.event.ChangeListener);
	*** deinstall(javax.swing.text.JTextComponent);
	*** getBlinkRate();
	*** getDot();
	*** getMark();
	*** install(javax.swing.text.JTextComponent);
	*** isVisible();
	*** moveDot(int);
	*** removeChangeListener(javax.swing.event.ChangeListener);
	*** setBlinkRate(int);
	*** setDot(int);
	*** setVisible(boolean);
}

-keep class javax.swing.text.ChangedCharSetException {
	*** getCharSetSpec();
	*** keyEqualsCharSet();
}

-keep class javax.swing.text.DefaultCaret {
	*** getDot();
	*** getDotBias();
	*** getMark();
	*** getMarkBias();
	*** isActive();
	*** moveDot(int,javax.swing.text.Position$Bias);
	*** setDot(int,javax.swing.text.Position$Bias);
}

-keep class javax.swing.text.DefaultHighlighter$DefaultHighlightPainter {
	*** getColor();
}

-keep class javax.swing.text.Document {
	*** addDocumentListener(javax.swing.event.DocumentListener);
	*** createPosition(int);
	*** getLength();
	*** getProperty(java.lang.Object);
	*** getText(int,int);
	*** insertString(int,java.lang.String,javax.swing.text.AttributeSet);
	*** putProperty(java.lang.Object,java.lang.Object);
	*** remove(int,int);
	*** removeDocumentListener(javax.swing.event.DocumentListener);
}

-keep class javax.swing.text.EditorKit {
	*** clone();
	*** createDefaultDocument();
	*** deinstall(javax.swing.JEditorPane);
	*** getActions();
	*** getContentType();
	*** install(javax.swing.JEditorPane);
	*** read(java.io.Reader,javax.swing.text.Document,int);
	*** write(java.io.Writer,javax.swing.text.Document,int,int);
}

-keep class javax.swing.text.Highlighter {
	*** deinstall(javax.swing.text.JTextComponent);
	*** install(javax.swing.text.JTextComponent);
}

-keep class javax.swing.text.Highlighter$Highlight {
	*** getPainter();
}

-keep class javax.swing.text.JTextComponent {
	*** FOCUSED_COMPONENT;
	*** KEYMAP_TABLE;
	*** caret;
	*** caretColor;
	*** caretEvent;
	*** checkedInputOverride;
	*** composedTextAttribute;
	*** composedTextCaret;
	*** composedTextContent;
	*** composedTextEnd;
	*** composedTextStart;
	*** defaultTransferHandler;
	*** disabledTextColor;
	*** dragEnabled;
	*** dropLocation;
	*** dropMode;
	*** editable;
	*** focusAccelerator;
	*** highlighter;
	*** inputMethodRequestsHandler;
	*** keymap;
	*** latestCommittedTextEnd;
	*** latestCommittedTextStart;
	*** margin;
	*** model;
	*** navigationFilter;
	*** needToSendKeyTypedEvent;
	*** originalCaret;
	*** overrideMap;
	*** selectedTextColor;
	*** selectionColor;
	javax.swing.text.JTextComponent();
	*** addKeymap(java.lang.String,javax.swing.text.Keymap);
	*** composedTextExists();
	*** createComposedTextAttribute(int,java.text.AttributedCharacterIterator);
	*** exchangeCaret(javax.swing.text.Caret,javax.swing.text.Caret);
	*** getCaret();
	*** getCaretPosition();
	*** getCurrentEventModifiers();
	*** getDocument();
	*** getFocusedComponent();
	*** getKeymap();
	*** getKeymap(java.lang.String);
	*** getKeymapTable();
	*** getPrintable(java.text.MessageFormat,java.text.MessageFormat);
	*** getSelectionColor();
	*** getSelectionEnd();
	*** getSelectionStart();
	*** getUI();
	*** installDefaultTransferHandlerIfNecessary();
	*** invokeAction(java.lang.String,javax.swing.Action);
	*** isEditable();
	*** isProcessInputMethodEventOverridden();
	*** isProcessInputMethodEventOverridden(java.lang.Class);
	*** mapCommittedTextToAction(java.lang.String);
	*** modelToView(int);
	*** moveCaretPosition(int);
	*** paramString();
	*** print(java.text.MessageFormat,java.text.MessageFormat,boolean,javax.print.PrintService,javax.print.attribute.PrintRequestAttributeSet,boolean);
	*** read(java.io.Reader,java.lang.Object);
	*** replaceInputMethodText(java.awt.event.InputMethodEvent);
	*** replaceSelection(java.lang.String);
	*** restoreComposedText();
	*** saveComposedText(int);
	*** select(int,int);
	*** setCaret(javax.swing.text.Caret);
	*** setCaretPosition(int);
	*** setDocument(javax.swing.text.Document);
	*** setDragEnabled(boolean);
	*** setEditable(boolean);
	*** setInputMethodCaretPosition(java.awt.event.InputMethodEvent);
	*** setUI(javax.swing.plaf.TextUI);
	*** shouldSynthensizeKeyEvents();
	*** updateInputMap(javax.swing.text.Keymap,javax.swing.text.Keymap);
	*** updateUI();
	*** write(java.io.Writer);
}

-keep class javax.swing.text.JTextComponent$5 {
	*** $SwitchMap$javax$swing$DropMode;
}

-keep class javax.swing.text.JTextComponent$DropLocation {
	*** getBias();
	*** getIndex();
}

-keep class javax.swing.text.JTextComponent$KeyBinding {
	*** actionName;
	*** key;
}

-keep class javax.swing.text.Keymap {
	*** addActionForKeyStroke(javax.swing.KeyStroke,javax.swing.Action);
	*** getAction(javax.swing.KeyStroke);
	*** getDefaultAction();
	*** setDefaultAction(javax.swing.Action);
}

-keep class javax.swing.text.Position {
	*** getOffset();
}

-keep class javax.swing.text.Position$Bias {
	*** Forward;
}

-keep class javax.swing.text.SimpleAttributeSet {
	*** addAttribute(java.lang.Object,java.lang.Object);
}

-keep class javax.swing.text.StyleConstants {
	*** ComposedTextAttribute;
}

-keep class javax.swing.text.StyledEditorKit {
	*** getInputAttributes();
}

-keep class javax.swing.text.TextAction {
	javax.swing.text.TextAction(java.lang.String);
	*** getFocusedComponent();
	*** getTextComponent(java.awt.event.ActionEvent);
}

-keep class javax.swing.text.View {
	*** getPreferredSpan(int);
}

-keep class javax.swing.text.html.HTML$Attribute {
	*** NAME;
}

-keep class javax.swing.text.html.HTML$Tag {
	*** A;
}

-keep class javax.swing.text.html.HTMLDocument {
	*** getIterator(javax.swing.text.html.HTML$Tag);
}

-keep class javax.swing.text.html.HTMLDocument$Iterator {
	*** getAttributes();
	*** getStartOffset();
	*** isValid();
	*** next();
}

-keep class javax.xml.namespace.QName {
	*** localPart;
	*** namespaceURI;
	*** prefix;
	*** serialVersionUID;
	*** useDefaultSerialVersionUID;
	javax.xml.namespace.QName(java.lang.String,java.lang.String,java.lang.String);
	*** equals(java.lang.Object);
	*** getLocalPart();
	*** getNamespaceURI();
	*** getPrefix();
	*** toString();
}

-keep class javax.xml.parsers.DocumentBuilder {
	javax.xml.parsers.DocumentBuilder();
	*** getDOMImplementation();
	*** newDocument();
	*** parse(java.io.InputStream);
	*** parse(org.xml.sax.InputSource);
	*** setErrorHandler(org.xml.sax.ErrorHandler);
}

-keep class javax.xml.parsers.DocumentBuilderFactory {
	*** canonicalState;
	*** coalescing;
	*** expandEntityRef;
	*** ignoreComments;
	*** namespaceAware;
	*** validating;
	*** whitespace;
	javax.xml.parsers.DocumentBuilderFactory();
	*** isCoalescing();
	*** isExpandEntityReferences();
	*** isIgnoringComments();
	*** isIgnoringElementContentWhitespace();
	*** isNamespaceAware();
	*** isValidating();
	*** newDocumentBuilder();
	*** newInstance();
	*** setCoalescing(boolean);
	*** setExpandEntityReferences(boolean);
	*** setFeature(java.lang.String,boolean);
	*** setIgnoringComments(boolean);
	*** setIgnoringElementContentWhitespace(boolean);
	*** setNamespaceAware(boolean);
	*** setValidating(boolean);
}

-keep class javax.xml.parsers.FactoryConfigurationError {
	*** exception;
}

-keep class javax.xml.parsers.FactoryFinder {
	*** cacheProps;
	*** debug;
	*** firstTime;
	*** ss;
	*** dPrint(java.lang.String);
	*** find(java.lang.String,java.lang.String);
	*** findJarServiceProvider(java.lang.String);
	*** getProviderClass(java.lang.String,java.lang.ClassLoader,boolean,boolean);
	*** newInstance(java.lang.String,java.lang.ClassLoader,boolean);
	*** newInstance(java.lang.String,java.lang.ClassLoader,boolean,boolean);
}

-keep class javax.xml.parsers.FactoryFinder$ConfigurationError {
	*** getException();
}

-keep class javax.xml.parsers.SAXParser {
	*** getXMLReader();
}

-keep class javax.xml.parsers.SAXParserFactory {
	*** newInstance();
	*** newSAXParser();
	*** setNamespaceAware(boolean);
}

-keep class javax.xml.parsers.SecuritySupport {
	*** doesFileExist(java.io.File);
	*** getContextClassLoader();
	*** getFileInputStream(java.io.File);
	*** getResourceAsStream(java.lang.ClassLoader,java.lang.String);
	*** getSystemProperty(java.lang.String);
}

-keep class javax.xml.parsers.SecuritySupport$1 {
	*** this$0;
}

-keep class javax.xml.parsers.SecuritySupport$2 {
	*** this$0;
	*** val$propName;
}

-keep class javax.xml.parsers.SecuritySupport$4 {
	*** this$0;
	*** val$cl;
	*** val$name;
}

-keep class javax.xml.parsers.SecuritySupport$5 {
	*** this$0;
	*** val$f;
}

-keep class javax.xml.transform.ErrorListener {
	*** error(javax.xml.transform.TransformerException);
	*** fatalError(javax.xml.transform.TransformerException);
	*** warning(javax.xml.transform.TransformerException);
}

-keep class javax.xml.transform.Source {
	*** getSystemId();
}

-keep class javax.xml.transform.SourceLocator {
	*** getColumnNumber();
	*** getLineNumber();
	*** getPublicId();
	*** getSystemId();
}

-keep class javax.xml.transform.Transformer {
	*** setOutputProperty(java.lang.String,java.lang.String);
	*** transform(javax.xml.transform.Source,javax.xml.transform.Result);
}

-keep class javax.xml.transform.TransformerException {
	*** containedException;
	*** locator;
	javax.xml.transform.TransformerException(java.lang.String);
	javax.xml.transform.TransformerException(java.lang.String,java.lang.Throwable);
	javax.xml.transform.TransformerException(java.lang.String,javax.xml.transform.SourceLocator);
	javax.xml.transform.TransformerException(java.lang.String,javax.xml.transform.SourceLocator,java.lang.Throwable);
	javax.xml.transform.TransformerException(java.lang.Throwable);
	*** getCause();
	*** getException();
	*** getLocationAsString();
	*** getLocator();
	*** printStackTrace(java.io.PrintStream);
	*** printStackTrace(java.io.PrintWriter);
	*** setLocator(javax.xml.transform.SourceLocator);
}

-keep class javax.xml.transform.TransformerFactory {
	*** newInstance();
	*** newTransformer();
}

-keep class javax.xml.transform.TransformerFactoryConfigurationError {
	*** exception;
}

-keep class javax.xml.transform.URIResolver {
	*** resolve(java.lang.String,java.lang.String);
}

-keep class javax.xml.transform.dom.DOMSource {
	*** node;
	*** systemID;
	*** getNode();
	*** setNode(org.w3c.dom.Node);
	*** setSystemId(java.lang.String);
}

-keep class javax.xml.transform.sax.SAXSource {
	*** getXMLReader();
	*** sourceToInputSource(javax.xml.transform.Source);
}

-keep class javax.xml.validation.Schema {
	*** newValidatorHandler();
}

-keep class javax.xml.validation.ValidatorHandler {
	*** getTypeInfoProvider();
	*** setContentHandler(org.xml.sax.ContentHandler);
	*** setErrorHandler(org.xml.sax.ErrorHandler);
	*** setResourceResolver(org.w3c.dom.ls.LSResourceResolver);
}

-keep class javax.xml.xpath.SecuritySupport {
	*** doesFileExist(java.io.File);
	*** getContextClassLoader();
	*** getFileInputStream(java.io.File);
	*** getResourceAsURL(java.lang.ClassLoader,java.lang.String);
	*** getResources(java.lang.ClassLoader,java.lang.String);
	*** getSystemProperty(java.lang.String);
	*** getURLInputStream(java.net.URL);
}

-keep class javax.xml.xpath.SecuritySupport$1 {
	*** this$0;
}

-keep class javax.xml.xpath.SecuritySupport$2 {
	*** this$0;
	*** val$propName;
}

-keep class javax.xml.xpath.SecuritySupport$4 {
	*** this$0;
	*** val$url;
}

-keep class javax.xml.xpath.SecuritySupport$6 {
	*** this$0;
	*** val$cl;
	*** val$name;
}

-keep class javax.xml.xpath.SecuritySupport$8 {
	*** this$0;
	*** val$f;
}

-keep class javax.xml.xpath.XPath {
	*** evaluate(java.lang.String,java.lang.Object,javax.xml.namespace.QName);
}

-keep class javax.xml.xpath.XPathConstants {
	*** BOOLEAN;
	*** NODE;
	*** NODESET;
	*** NUMBER;
	*** STRING;
}

-keep class javax.xml.xpath.XPathException {
	*** cause;
	javax.xml.xpath.XPathException(java.lang.String);
	javax.xml.xpath.XPathException(java.lang.Throwable);
	*** getCause();
	*** printStackTrace(java.io.PrintStream);
}

-keep class javax.xml.xpath.XPathExpressionException {
	javax.xml.xpath.XPathExpressionException(java.lang.String);
	javax.xml.xpath.XPathExpressionException(java.lang.Throwable);
}

-keep class javax.xml.xpath.XPathFactory {
	*** ss;
	javax.xml.xpath.XPathFactory();
	*** isObjectModelSupported(java.lang.String);
	*** newInstance();
	*** newInstance(java.lang.String);
	*** newXPath();
}

-keep class javax.xml.xpath.XPathFactoryFinder {
	*** SERVICE_CLASS;
	*** SERVICE_ID;
	*** cacheProps;
	*** classLoader;
	*** debug;
	*** firstTime;
	*** ss;
	*** _newFactory(java.lang.String);
	*** createClass(java.lang.String);
	*** createInstance(java.lang.String);
	*** createInstance(java.lang.String,boolean);
	*** createServiceFileIterator();
	*** debugDisplayClassLoader();
	*** debugPrintln(java.lang.String);
	*** loadFromService(java.lang.String,java.lang.String,java.io.InputStream);
	*** newFactory(java.lang.String);
	*** newInstanceNoServiceLoader(java.lang.Class);
	*** which(java.lang.Class);
	*** which(java.lang.String,java.lang.ClassLoader);
}

-keep class javax.xml.xpath.XPathFactoryFinder$2 {
	*** this$0;
	*** val$e;
}

-keep class javax.xml.xpath.XPathVariableResolver {
	*** resolveVariable(javax.xml.namespace.QName);
}

-keep class junit.extensions.TestDecorator {
	*** fTest;
	*** basicRun(junit.framework.TestResult);
	*** getTest();
}

-keep class junit.framework.Assert {
	junit.framework.Assert();
	*** assertEquals(boolean,boolean);
	*** assertEquals(byte,byte);
	*** assertEquals(char,char);
	*** assertEquals(double,double,double);
	*** assertEquals(float,float,float);
	*** assertEquals(int,int);
	*** assertEquals(java.lang.Object,java.lang.Object);
	*** assertEquals(java.lang.String,boolean,boolean);
	*** assertEquals(java.lang.String,byte,byte);
	*** assertEquals(java.lang.String,char,char);
	*** assertEquals(java.lang.String,double,double,double);
	*** assertEquals(java.lang.String,float,float,float);
	*** assertEquals(java.lang.String,int,int);
	*** assertEquals(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertEquals(java.lang.String,java.lang.String);
	*** assertEquals(java.lang.String,java.lang.String,java.lang.String);
	*** assertEquals(java.lang.String,long,long);
	*** assertEquals(java.lang.String,short,short);
	*** assertEquals(long,long);
	*** assertEquals(short,short);
	*** assertFalse(boolean);
	*** assertFalse(java.lang.String,boolean);
	*** assertNotNull(java.lang.Object);
	*** assertNotNull(java.lang.String,java.lang.Object);
	*** assertNotSame(java.lang.Object,java.lang.Object);
	*** assertNotSame(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertNull(java.lang.Object);
	*** assertNull(java.lang.String,java.lang.Object);
	*** assertSame(java.lang.Object,java.lang.Object);
	*** assertSame(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertTrue(boolean);
	*** assertTrue(java.lang.String,boolean);
	*** fail();
	*** fail(java.lang.String);
	*** failNotEquals(java.lang.String,java.lang.Object,java.lang.Object);
	*** failNotSame(java.lang.String,java.lang.Object,java.lang.Object);
	*** failSame(java.lang.String);
	*** format(java.lang.String,java.lang.Object,java.lang.Object);
}

-keep class junit.framework.AssertionFailedError {
	junit.framework.AssertionFailedError(java.lang.String);
	*** defaultString(java.lang.String);
}

-keep class junit.framework.ComparisonCompactor {
	*** compact(java.lang.String);
}

-keep class junit.framework.ComparisonFailure {
	*** fActual;
	*** fExpected;
	*** getActual();
	*** getExpected();
}

-keep class junit.framework.Protectable {
	*** protect();
}

-keep class junit.framework.Test {
	*** countTestCases();
	*** run(junit.framework.TestResult);
}

-keep class junit.framework.TestCase {
	*** fName;
	junit.framework.TestCase(java.lang.String);
	*** assertNotNull(java.lang.String,java.lang.Object);
	*** createResult();
	*** fail(java.lang.String);
	*** getName();
	*** run(junit.framework.TestResult);
	*** runTest();
	*** setName(java.lang.String);
	*** setUp();
	*** tearDown();
	*** toString();
}

-keep class junit.framework.TestListener {
	*** addError(junit.framework.Test,java.lang.Throwable);
	*** addFailure(junit.framework.Test,junit.framework.AssertionFailedError);
	*** endTest(junit.framework.Test);
	*** startTest(junit.framework.Test);
}

-keep class junit.framework.TestResult {
	*** fErrors;
	*** fFailures;
	*** fListeners;
	*** fRunTests;
	*** fStop;
	*** addError(junit.framework.Test,java.lang.Throwable);
	*** addFailure(junit.framework.Test,junit.framework.AssertionFailedError);
	*** addListener(junit.framework.TestListener);
	*** cloneListeners();
	*** endTest(junit.framework.Test);
	*** errorCount();
	*** failureCount();
	*** run(junit.framework.TestCase);
	*** runProtected(junit.framework.Test,junit.framework.Protectable);
	*** shouldStop();
	*** startTest(junit.framework.Test);
	*** stop();
}

-keep class junit.framework.TestSuite {
	*** fName;
	*** fTests;
	junit.framework.TestSuite(java.lang.Class);
	junit.framework.TestSuite(java.lang.Class[]);
	*** addTest(junit.framework.Test);
	*** addTestMethod(java.lang.reflect.Method,java.util.List,java.lang.Class);
	*** addTestsFromTestCase(java.lang.Class);
	*** countTestCases();
	*** createTest(java.lang.Class,java.lang.String);
	*** exceptionToString(java.lang.Throwable);
	*** getName();
	*** getTestConstructor(java.lang.Class);
	*** isPublicTestMethod(java.lang.reflect.Method);
	*** isTestMethod(java.lang.reflect.Method);
	*** runTest(junit.framework.Test,junit.framework.TestResult);
	*** setName(java.lang.String);
	*** testAt(int);
	*** testCaseForClass(java.lang.Class);
	*** testCount();
	*** tests();
	*** warning(java.lang.String);
}

-keep class kp.FenwickTree {
	*** size;
	*** tree;
	*** addValue(int,int);
	*** bitAnd(int,int);
	*** getCumulativeFrequency(int);
	*** getFrequency(int);
	*** indexOfCumulativeFrequency(int);
	*** validateIdx(int);
}

-keep class net.sourceforge.jdpapi.DataProtector {
	*** protect(java.lang.String);
	*** unprotect(byte[]);
}

-keep class org.apache.commons.beanutils.BeanAccessLanguageException {
	org.apache.commons.beanutils.BeanAccessLanguageException();
	org.apache.commons.beanutils.BeanAccessLanguageException(java.lang.String);
}

-keep class org.apache.commons.beanutils.BeanUtils {
	*** debug;
	*** initCause(java.lang.Throwable,java.lang.Throwable);
}

-keep class org.apache.commons.beanutils.BeanUtilsBean {
	*** BEANS_BY_CLASSLOADER;
	*** INIT_CAUSE_METHOD;
	*** class$java$lang$Object;
	*** class$java$lang$Throwable;
	*** class$org$apache$commons$beanutils$BeanUtils;
	*** convertUtilsBean;
	*** log;
	*** propertyUtilsBean;
	org.apache.commons.beanutils.BeanUtilsBean(org.apache.commons.beanutils.ConvertUtilsBean,org.apache.commons.beanutils.PropertyUtilsBean);
	*** class$(java.lang.String);
	*** cloneBean(java.lang.Object);
	*** convert(java.lang.Object,java.lang.Class);
	*** copyProperties(java.lang.Object,java.lang.Object);
	*** copyProperty(java.lang.Object,java.lang.String,java.lang.Object);
	*** describe(java.lang.Object);
	*** getArrayProperty(java.lang.Object,java.lang.String);
	*** getConvertUtils();
	*** getIndexedProperty(java.lang.Object,java.lang.String);
	*** getIndexedProperty(java.lang.Object,java.lang.String,int);
	*** getInitCauseMethod();
	*** getInstance();
	*** getMappedProperty(java.lang.Object,java.lang.String);
	*** getMappedProperty(java.lang.Object,java.lang.String,java.lang.String);
	*** getNestedProperty(java.lang.Object,java.lang.String);
	*** getProperty(java.lang.Object,java.lang.String);
	*** getPropertyUtils();
	*** getSimpleProperty(java.lang.Object,java.lang.String);
	*** initCause(java.lang.Throwable,java.lang.Throwable);
	*** populate(java.lang.Object,java.util.Map);
	*** setProperty(java.lang.Object,java.lang.String,java.lang.Object);
}

-keep class org.apache.commons.beanutils.ContextClassLoaderLocal {
	*** globalValue;
	*** globalValueInitialized;
	*** valueByClassLoader;
	org.apache.commons.beanutils.ContextClassLoaderLocal();
	*** get();
	*** initialValue();
	*** set(java.lang.Object);
	*** unset(java.lang.ClassLoader);
}

-keep class org.apache.commons.beanutils.ConversionException {
	*** cause;
}

-keep class org.apache.commons.beanutils.ConvertUtilsBean {
	*** SPACE;
	*** ZERO;
	*** array$Ljava$lang$String;
	*** class$java$io$File;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Class;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** class$java$math$BigDecimal;
	*** class$java$math$BigInteger;
	*** class$java$net$URL;
	*** class$java$sql$Date;
	*** class$java$sql$Time;
	*** class$java$sql$Timestamp;
	*** class$java$util$Calendar;
	*** class$java$util$Collection;
	*** class$java$util$Date;
	*** class$org$apache$commons$beanutils$ConvertUtils;
	*** converters;
	*** defaultBoolean;
	*** defaultByte;
	*** defaultCharacter;
	*** defaultDouble;
	*** defaultFloat;
	*** defaultInteger;
	*** defaultLong;
	*** defaultShort;
	*** log;
	*** class$(java.lang.String);
	*** convert(java.lang.Object);
	*** convert(java.lang.Object,java.lang.Class);
	*** convert(java.lang.String,java.lang.Class);
	*** convert(java.lang.String[],java.lang.Class);
	*** deregister();
	*** deregister(java.lang.Class);
	*** getDefaultBoolean();
	*** getDefaultByte();
	*** getDefaultCharacter();
	*** getDefaultDouble();
	*** getDefaultFloat();
	*** getDefaultInteger();
	*** getDefaultLong();
	*** getDefaultShort();
	*** getInstance();
	*** lookup(java.lang.Class);
	*** lookup(java.lang.Class,java.lang.Class);
	*** register(java.lang.Class,org.apache.commons.beanutils.Converter);
	*** register(org.apache.commons.beanutils.Converter,java.lang.Class);
	*** registerArrayConverter(java.lang.Class,org.apache.commons.beanutils.Converter,boolean,int);
	*** registerArrays(boolean,int);
	*** registerOther(boolean);
	*** registerPrimitives(boolean);
	*** registerStandard(boolean,boolean);
	*** setDefaultBoolean(boolean);
	*** setDefaultByte(byte);
	*** setDefaultCharacter(char);
	*** setDefaultDouble(double);
	*** setDefaultFloat(float);
	*** setDefaultInteger(int);
	*** setDefaultLong(long);
	*** setDefaultShort(short);
}

-keep class org.apache.commons.beanutils.Converter {
	*** convert(java.lang.Class,java.lang.Object);
}

-keep class org.apache.commons.beanutils.DynaBean {
	*** get(java.lang.String);
	*** get(java.lang.String,int);
	*** get(java.lang.String,java.lang.String);
	*** getDynaClass();
	*** set(java.lang.String,int,java.lang.Object);
	*** set(java.lang.String,java.lang.Object);
	*** set(java.lang.String,java.lang.String,java.lang.Object);
}

-keep class org.apache.commons.beanutils.DynaClass {
	*** getDynaProperties();
	*** getDynaProperty(java.lang.String);
	*** newInstance();
}

-keep class org.apache.commons.beanutils.DynaProperty {
	*** class$java$lang$Object;
	*** class$java$util$List;
	*** class$java$util$Map;
	*** contentType;
	*** name;
	*** type;
	org.apache.commons.beanutils.DynaProperty(java.lang.String,java.lang.Class);
	*** class$(java.lang.String);
	*** getName();
	*** getType();
	*** isIndexed();
	*** isMapped();
	*** readAnyClass(java.io.ObjectInputStream);
	*** writeAnyClass(java.lang.Class,java.io.ObjectOutputStream);
}

-keep class org.apache.commons.beanutils.MappedPropertyDescriptor {
	*** STRING_CLASS_PARAMETER;
	*** class$java$lang$String;
	*** mappedPropertyTypeRef;
	*** mappedReadMethodRef;
	*** mappedWriteMethodRef;
	*** capitalizePropertyName(java.lang.String);
	*** class$(java.lang.String);
	*** findMappedPropertyType();
	*** getMappedPropertyType();
	*** getMappedReadMethod();
	*** getMappedWriteMethod();
	*** getMethod(java.lang.Class,java.lang.String,int);
	*** getMethod(java.lang.Class,java.lang.String,java.lang.Class[]);
	*** internalGetMethod(java.lang.Class,java.lang.String,int);
}

-keep class org.apache.commons.beanutils.MappedPropertyDescriptor$MappedMethodReference {
	*** access$000(org.apache.commons.beanutils.MappedPropertyDescriptor$MappedMethodReference);
}

-keep class org.apache.commons.beanutils.MethodUtils {
	*** CACHE_METHODS;
	*** EMPTY_CLASS_PARAMETERS;
	*** EMPTY_OBJECT_ARRAY;
	*** cache;
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$org$apache$commons$beanutils$MethodUtils;
	*** loggedAccessibleWarning;
	*** cacheMethod(org.apache.commons.beanutils.MethodUtils$MethodDescriptor,java.lang.reflect.Method);
	*** class$(java.lang.String);
	*** clearCache();
	*** getAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[]);
	*** getAccessibleMethod(java.lang.Class,java.lang.reflect.Method);
	*** getAccessibleMethod(java.lang.reflect.Method);
	*** getAccessibleMethodFromInterfaceNest(java.lang.Class,java.lang.String,java.lang.Class[]);
	*** getAccessibleMethodFromSuperclass(java.lang.Class,java.lang.String,java.lang.Class[]);
	*** getCachedMethod(org.apache.commons.beanutils.MethodUtils$MethodDescriptor);
	*** getMatchingAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[]);
	*** getObjectTransformationCost(java.lang.Class,java.lang.Class);
	*** getPrimitiveWrapper(java.lang.Class);
	*** getTotalTransformationCost(java.lang.Class[],java.lang.Class[]);
	*** invokeExactMethod(java.lang.Object,java.lang.String,java.lang.Object[]);
	*** invokeExactMethod(java.lang.Object,java.lang.String,java.lang.Object[],java.lang.Class[]);
	*** invokeExactStaticMethod(java.lang.Class,java.lang.String,java.lang.Object[]);
	*** invokeExactStaticMethod(java.lang.Class,java.lang.String,java.lang.Object[],java.lang.Class[]);
	*** invokeMethod(java.lang.Object,java.lang.String,java.lang.Object[]);
	*** invokeMethod(java.lang.Object,java.lang.String,java.lang.Object[],java.lang.Class[]);
	*** invokeStaticMethod(java.lang.Class,java.lang.String,java.lang.Object[]);
	*** invokeStaticMethod(java.lang.Class,java.lang.String,java.lang.Object[],java.lang.Class[]);
	*** isAssignmentCompatible(java.lang.Class,java.lang.Class);
	*** setMethodAccessible(java.lang.reflect.Method);
}

-keep class org.apache.commons.beanutils.PropertyUtils {
	*** debug;
	*** getProperty(java.lang.Object,java.lang.String);
	*** getPropertyDescriptors(java.lang.Class);
	*** getSimpleProperty(java.lang.Object,java.lang.String);
	*** setProperty(java.lang.Object,java.lang.String,java.lang.Object);
	*** setSimpleProperty(java.lang.Object,java.lang.String,java.lang.Object);
}

-keep class org.apache.commons.beanutils.PropertyUtilsBean {
	*** EMPTY_CLASS_PARAMETERS;
	*** EMPTY_OBJECT_ARRAY;
	*** LIST_CLASS_PARAMETER;
	*** class$java$util$List;
	*** class$org$apache$commons$beanutils$PropertyUtils;
	*** descriptorsCache;
	*** log;
	*** mappedDescriptorsCache;
	*** resolver;
	*** class$(java.lang.String);
	*** clearDescriptors();
	*** copyProperties(java.lang.Object,java.lang.Object);
	*** describe(java.lang.Object);
	*** getIndexedProperty(java.lang.Object,java.lang.String);
	*** getIndexedProperty(java.lang.Object,java.lang.String,int);
	*** getInstance();
	*** getMappedProperty(java.lang.Object,java.lang.String);
	*** getMappedProperty(java.lang.Object,java.lang.String,java.lang.String);
	*** getMappedPropertyDescriptors(java.lang.Class);
	*** getMappedPropertyDescriptors(java.lang.Object);
	*** getNestedProperty(java.lang.Object,java.lang.String);
	*** getProperty(java.lang.Object,java.lang.String);
	*** getPropertyDescriptor(java.lang.Object,java.lang.String);
	*** getPropertyDescriptors(java.lang.Class);
	*** getPropertyDescriptors(java.lang.Object);
	*** getPropertyEditorClass(java.lang.Object,java.lang.String);
	*** getPropertyOfMapBean(java.util.Map,java.lang.String);
	*** getPropertyType(java.lang.Object,java.lang.String);
	*** getReadMethod(java.beans.PropertyDescriptor);
	*** getReadMethod(java.lang.Class,java.beans.PropertyDescriptor);
	*** getResolver();
	*** getSimpleProperty(java.lang.Object,java.lang.String);
	*** getWriteMethod(java.beans.PropertyDescriptor);
	*** getWriteMethod(java.lang.Class,java.beans.PropertyDescriptor);
	*** invokeMethod(java.lang.reflect.Method,java.lang.Object,java.lang.Object[]);
	*** isReadable(java.lang.Object,java.lang.String);
	*** isWriteable(java.lang.Object,java.lang.String);
	*** setIndexedProperty(java.lang.Object,java.lang.String,int,java.lang.Object);
	*** setIndexedProperty(java.lang.Object,java.lang.String,java.lang.Object);
	*** setMappedProperty(java.lang.Object,java.lang.String,java.lang.Object);
	*** setMappedProperty(java.lang.Object,java.lang.String,java.lang.String,java.lang.Object);
	*** setNestedProperty(java.lang.Object,java.lang.String,java.lang.Object);
	*** setProperty(java.lang.Object,java.lang.String,java.lang.Object);
	*** setPropertyOfMapBean(java.util.Map,java.lang.String,java.lang.Object);
	*** setSimpleProperty(java.lang.Object,java.lang.String,java.lang.Object);
}

-keep class org.apache.commons.beanutils.WeakFastHashMap {
	*** fast;
	*** map;
	*** clear();
	*** cloneMap(java.util.Map);
	*** createMap();
	*** createMap(int);
	*** createMap(int,float);
	*** createMap(java.util.Map);
	*** get(java.lang.Object);
	*** getFast();
	*** put(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** setFast(boolean);
}

-keep class org.apache.commons.beanutils.WrapDynaBean {
	*** getInstance();
}

-keep class org.apache.commons.beanutils.converters.AbstractConverter {
	*** class$java$lang$Boolean;
	*** class$java$lang$Byte;
	*** class$java$lang$Character;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$lang$String;
	*** defaultValue;
	*** log;
	*** useDefault;
	org.apache.commons.beanutils.converters.AbstractConverter();
	org.apache.commons.beanutils.converters.AbstractConverter(java.lang.Object);
	*** class$(java.lang.String);
	*** convert(java.lang.Class,java.lang.Object);
	*** convertArray(java.lang.Object);
	*** convertToString(java.lang.Object);
	*** convertToType(java.lang.Class,java.lang.Object);
	*** getDefault(java.lang.Class);
	*** getDefaultType();
	*** handleError(java.lang.Class,java.lang.Object,java.lang.Throwable);
	*** handleMissing(java.lang.Class);
	*** isUseDefault();
	*** log();
	*** primitive(java.lang.Class);
	*** setDefaultValue(java.lang.Object);
	*** toString(java.lang.Class);
}

-keep class org.apache.commons.beanutils.converters.ArrayConverter {
	*** allowedChars;
	*** class$java$lang$String;
	*** defaultSize;
	*** defaultTypeInstance;
	*** delimiter;
	*** elementConverter;
	*** onlyFirstToString;
	org.apache.commons.beanutils.converters.ArrayConverter(java.lang.Class,org.apache.commons.beanutils.Converter);
	*** class$(java.lang.String);
	*** convertToCollection(java.lang.Class,java.lang.Object);
	*** getDefault(java.lang.Class);
	*** parseElements(java.lang.Class,java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.BigDecimalConverter {
	*** class$java$math$BigDecimal;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.BigIntegerConverter {
	*** class$java$math$BigInteger;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.BooleanConverter {
	*** NO_DEFAULT;
	*** class$java$lang$Boolean;
	*** falseStrings;
	*** trueStrings;
	*** class$(java.lang.String);
	*** copyStrings(java.lang.String[]);
}

-keep class org.apache.commons.beanutils.converters.ByteConverter {
	*** class$java$lang$Byte;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.CalendarConverter {
	*** class$java$util$Calendar;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.CharacterConverter {
	*** class$java$lang$Character;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.ClassConverter {
	*** class$java$lang$Class;
	*** class$org$apache$commons$beanutils$converters$ClassConverter;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.ConverterFacade {
	*** converter;
}

-keep class org.apache.commons.beanutils.converters.DateConverter {
	*** class$java$util$Date;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.DateTimeConverter {
	*** class$java$sql$Date;
	*** class$java$sql$Time;
	*** class$java$sql$Timestamp;
	*** class$java$util$Calendar;
	*** class$java$util$Date;
	*** displayPatterns;
	*** locale;
	*** patterns;
	*** timeZone;
	*** useLocaleFormat;
	org.apache.commons.beanutils.converters.DateTimeConverter();
	org.apache.commons.beanutils.converters.DateTimeConverter(java.lang.Object);
	*** class$(java.lang.String);
	*** getFormat(java.lang.String);
	*** getFormat(java.util.Locale,java.util.TimeZone);
	*** logFormat(java.lang.String,java.text.DateFormat);
	*** parse(java.lang.Class,java.lang.Class,java.lang.String);
	*** parse(java.lang.Class,java.lang.Class,java.lang.String,java.text.DateFormat);
	*** setPatterns(java.lang.String[]);
	*** setUseLocaleFormat(boolean);
	*** toDate(java.lang.Class,java.lang.String);
	*** toDate(java.lang.Class,long);
}

-keep class org.apache.commons.beanutils.converters.DoubleConverter {
	*** class$java$lang$Double;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.FileConverter {
	*** class$java$io$File;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.FloatConverter {
	*** class$java$lang$Float;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.IntegerConverter {
	*** class$java$lang$Integer;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.LongConverter {
	*** class$java$lang$Long;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.NumberConverter {
	*** ONE;
	*** ZERO;
	*** allowDecimals;
	*** class$java$lang$Byte;
	*** class$java$lang$Double;
	*** class$java$lang$Float;
	*** class$java$lang$Integer;
	*** class$java$lang$Long;
	*** class$java$lang$Short;
	*** class$java$math$BigDecimal;
	*** class$java$math$BigInteger;
	*** locale;
	*** pattern;
	*** useLocaleFormat;
	org.apache.commons.beanutils.converters.NumberConverter(boolean);
	org.apache.commons.beanutils.converters.NumberConverter(boolean,java.lang.Object);
	*** class$(java.lang.String);
	*** getFormat();
	*** parse(java.lang.Class,java.lang.Class,java.lang.String,java.text.NumberFormat);
	*** setUseLocaleFormat(boolean);
	*** toNumber(java.lang.Class,java.lang.Class,java.lang.Number);
	*** toNumber(java.lang.Class,java.lang.Class,java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.ShortConverter {
	*** class$java$lang$Short;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.SqlDateConverter {
	*** class$java$sql$Date;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.SqlTimeConverter {
	*** class$java$sql$Time;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.SqlTimestampConverter {
	*** class$java$sql$Timestamp;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.StringConverter {
	*** class$java$lang$String;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.converters.URLConverter {
	*** class$java$net$URL;
	*** class$(java.lang.String);
}

-keep class org.apache.commons.beanutils.expression.DefaultResolver {
	*** next(java.lang.String);
	*** remove(java.lang.String);
}

-keep class org.apache.commons.beanutils.expression.Resolver {
	*** getIndex(java.lang.String);
	*** getKey(java.lang.String);
	*** getProperty(java.lang.String);
	*** hasNested(java.lang.String);
	*** isIndexed(java.lang.String);
	*** isMapped(java.lang.String);
	*** next(java.lang.String);
	*** remove(java.lang.String);
}

-keep class org.apache.commons.cli.CommandLine {
	*** args;
	*** options;
	*** addArg(java.lang.String);
	*** addOption(org.apache.commons.cli.Option);
	*** getArgs();
	*** getOptionObject(java.lang.String);
	*** getOptionValue(java.lang.String);
	*** getOptionValue(java.lang.String,java.lang.String);
	*** getOptionValues(java.lang.String);
	*** getParsedOptionValue(java.lang.String);
	*** hasOption(java.lang.String);
	*** resolveOption(java.lang.String);
}

-keep class org.apache.commons.cli.CommandLineParser {
	*** parse(org.apache.commons.cli.Options,java.lang.String[]);
}

-keep class org.apache.commons.cli.HelpFormatter {
	*** printHelp(java.lang.String,org.apache.commons.cli.Options);
}

-keep class org.apache.commons.cli.MissingArgumentException {
	*** option;
	org.apache.commons.cli.MissingArgumentException(java.lang.String);
}

-keep class org.apache.commons.cli.MissingOptionException {
	*** missingOptions;
	org.apache.commons.cli.MissingOptionException(java.lang.String);
	*** createMessage(java.util.List);
}

-keep class org.apache.commons.cli.Option {
	*** argName;
	*** description;
	*** longOpt;
	*** numberOfArgs;
	*** opt;
	*** optionalArg;
	*** required;
	*** type;
	*** values;
	*** valuesep;
	org.apache.commons.cli.Option(java.lang.String,java.lang.String,boolean,java.lang.String);
	*** add(java.lang.String);
	*** addValueForProcessing(java.lang.String);
	*** clearValues();
	*** clone();
	*** getKey();
	*** getLongOpt();
	*** getOpt();
	*** getType();
	*** getValue();
	*** getValueSeparator();
	*** getValues();
	*** getValuesList();
	*** hasArg();
	*** hasArgs();
	*** hasLongOpt();
	*** hasNoValues();
	*** hasOptionalArg();
	*** hasValueSeparator();
	*** isRequired();
	*** processValue(java.lang.String);
	*** setRequired(boolean);
}

-keep class org.apache.commons.cli.OptionGroup {
	*** getOptions();
	*** isRequired();
	*** setSelected(org.apache.commons.cli.Option);
}

-keep class org.apache.commons.cli.OptionValidator {
	*** isValidChar(char);
	*** isValidOpt(char);
	*** validateOption(java.lang.String);
}

-keep class org.apache.commons.cli.Options {
	*** longOpts;
	*** optionGroups;
	*** requiredOpts;
	*** shortOpts;
	*** addOption(java.lang.String,java.lang.String,boolean,java.lang.String);
	*** addOption(org.apache.commons.cli.Option);
	*** getOption(java.lang.String);
	*** getOptionGroup(org.apache.commons.cli.Option);
	*** getRequiredOptions();
	*** hasOption(java.lang.String);
	*** helpOptions();
}

-keep class org.apache.commons.cli.ParseException {
	org.apache.commons.cli.ParseException(java.lang.String);
}

-keep class org.apache.commons.cli.Parser {
	*** cmd;
	*** options;
	*** requiredOptions;
	org.apache.commons.cli.Parser();
	*** checkRequiredOptions();
	*** flatten(org.apache.commons.cli.Options,java.lang.String[],boolean);
	*** getOptions();
	*** getRequiredOptions();
	*** parse(org.apache.commons.cli.Options,java.lang.String[],java.util.Properties,boolean);
	*** processArgs(org.apache.commons.cli.Option,java.util.ListIterator);
	*** processOption(java.lang.String,java.util.ListIterator);
	*** processProperties(java.util.Properties);
	*** setOptions(org.apache.commons.cli.Options);
}

-keep class org.apache.commons.cli.PosixParser {
	*** currentOption;
	*** eatTheRest;
	*** options;
	*** tokens;
	*** burstToken(java.lang.String,boolean);
	*** gobble(java.util.Iterator);
	*** init();
	*** processNonOptionToken(java.lang.String,boolean);
	*** processOptionToken(java.lang.String,boolean);
}

-keep class org.apache.commons.cli.TypeHandler {
	*** createValue(java.lang.String,java.lang.Object);
}

-keep class org.apache.commons.cli.UnrecognizedOptionException {
	*** option;
	org.apache.commons.cli.UnrecognizedOptionException(java.lang.String);
}

-keep class org.apache.commons.cli.Util {
	*** stripLeadingAndTrailingQuotes(java.lang.String);
	*** stripLeadingHyphens(java.lang.String);
}

-keep class org.apache.commons.codec.Charsets {
	*** ISO_8859_1;
	*** US_ASCII;
	*** UTF_16;
	*** UTF_16BE;
	*** UTF_16LE;
	*** UTF_8;
}

-keep class org.apache.commons.codec.binary.Base64 {
	*** CHUNK_SEPARATOR;
	*** DECODE_TABLE;
	*** STANDARD_ENCODE_TABLE;
	*** URL_SAFE_ENCODE_TABLE;
	*** decodeSize;
	*** decodeTable;
	*** encodeSize;
	*** encodeTable;
	*** lineSeparator;
	org.apache.commons.codec.binary.Base64(int);
	org.apache.commons.codec.binary.Base64(int,byte[]);
	org.apache.commons.codec.binary.Base64(int,byte[],boolean);
	*** decodeBase64(byte[]);
	*** decodeBase64(java.lang.String);
	*** encodeBase64(byte[],boolean);
	*** encodeBase64(byte[],boolean,boolean);
	*** encodeBase64(byte[],boolean,boolean,int);
	*** encodeBase64String(byte[]);
	*** encodeBase64URLSafeString(byte[]);
	*** isBase64(byte);
	*** isBase64(byte[]);
	*** toIntegerBytes(java.math.BigInteger);
}

-keep class org.apache.commons.codec.binary.BaseNCodec {
	*** PAD;
	*** chunkSeparatorLength;
	*** encodedBlockSize;
	*** lineLength;
	*** unencodedBlockSize;
	org.apache.commons.codec.binary.BaseNCodec(int,int,int,int);
	*** available(org.apache.commons.codec.binary.BaseNCodec$Context);
	*** containsAlphabetOrPad(byte[]);
	*** decode(byte[]);
	*** decode(byte[],int,int,org.apache.commons.codec.binary.BaseNCodec$Context);
	*** decode(java.lang.String);
	*** encode(byte[]);
	*** encode(byte[],int,int,org.apache.commons.codec.binary.BaseNCodec$Context);
	*** ensureBufferSize(int,org.apache.commons.codec.binary.BaseNCodec$Context);
	*** getDefaultBufferSize();
	*** getEncodedLength(byte[]);
	*** isInAlphabet(byte);
	*** isInAlphabet(byte[],boolean);
	*** isWhiteSpace(byte);
	*** readResults(byte[],int,int,org.apache.commons.codec.binary.BaseNCodec$Context);
	*** resizeBuffer(org.apache.commons.codec.binary.BaseNCodec$Context);
}

-keep class org.apache.commons.codec.binary.BaseNCodec$Context {
	*** buffer;
	*** currentLinePos;
	*** eof;
	*** ibitWorkArea;
	*** lbitWorkArea;
	*** modulus;
	*** pos;
	*** readPos;
}

-keep class org.apache.commons.codec.binary.Hex {
	*** DEFAULT_CHARSET;
	*** DIGITS_LOWER;
	*** DIGITS_UPPER;
	*** charset;
	org.apache.commons.codec.binary.Hex(java.nio.charset.Charset);
	*** decodeHex(char[]);
	*** encodeHex(byte[]);
	*** encodeHex(byte[],boolean);
	*** encodeHex(byte[],char[]);
	*** encodeHexString(byte[]);
	*** getCharset();
	*** toDigit(char,int);
}

-keep class org.apache.commons.codec.binary.StringUtils {
	*** getBytes(java.lang.String,java.nio.charset.Charset);
	*** getBytesUsAscii(java.lang.String);
	*** getBytesUtf8(java.lang.String);
	*** newIllegalStateException(java.lang.String,java.io.UnsupportedEncodingException);
	*** newString(byte[],java.nio.charset.Charset);
	*** newStringUsAscii(byte[]);
	*** newStringUtf8(byte[]);
}

-keep class org.apache.commons.codec.net.URLCodec {
	*** WWW_FORM_URL;
	*** charset;
	org.apache.commons.codec.net.URLCodec(java.lang.String);
	*** decode(byte[]);
	*** decode(java.lang.String);
	*** decode(java.lang.String,java.lang.String);
	*** decodeUrl(byte[]);
	*** encode(byte[]);
	*** encode(java.lang.String);
	*** encode(java.lang.String,java.lang.String);
	*** encodeUrl(java.util.BitSet,byte[]);
	*** getDefaultCharset();
}

-keep class org.apache.commons.codec.net.Utils {
	*** digit16(byte);
}

-keep class org.apache.commons.collections.FastHashMap {
	*** get(java.lang.Object);
	*** put(java.lang.Object,java.lang.Object);
	*** setFast(boolean);
}

-keep class org.apache.commons.httpclient.HttpClient {
	*** executeMethod(org.apache.commons.httpclient.HttpMethod);
}

-keep class org.apache.commons.httpclient.HttpException {
	*** cause;
	*** class$java$lang$Throwable;
	*** reason;
	*** reasonCode;
	org.apache.commons.httpclient.HttpException();
	org.apache.commons.httpclient.HttpException(java.lang.String);
	*** class$(java.lang.String);
	*** printStackTrace(java.io.PrintStream);
}

-keep class org.apache.commons.httpclient.HttpMethod {
	*** getResponseBody();
	*** getStatusLine();
	*** releaseConnection();
}

-keep class org.apache.commons.httpclient.HttpMethodBase {
	*** getResponseBody();
	*** getResponseBodyAsStream();
	*** releaseConnection();
	*** setFollowRedirects(boolean);
	*** setRequestHeader(java.lang.String,java.lang.String);
}

-keep class org.apache.commons.httpclient.NameValuePair {
	*** getName();
	*** getValue();
}

-keep class org.apache.commons.httpclient.URI {
	*** IPv4address;
	*** IPv6address;
	*** IPv6reference;
	*** URI_reference;
	*** _authority;
	*** _fragment;
	*** _host;
	*** _is_IPv4address;
	*** _is_IPv6reference;
	*** _is_abs_path;
	*** _is_hier_part;
	*** _is_hostname;
	*** _is_net_path;
	*** _is_opaque_part;
	*** _is_reg_name;
	*** _is_rel_path;
	*** _is_server;
	*** _opaque;
	*** _path;
	*** _port;
	*** _query;
	*** _scheme;
	*** _uri;
	*** _userinfo;
	*** abs_path;
	*** absoluteURI;
	*** allowed_IPv6reference;
	*** allowed_abs_path;
	*** allowed_authority;
	*** allowed_fragment;
	*** allowed_host;
	*** allowed_opaque_part;
	*** allowed_query;
	*** allowed_reg_name;
	*** allowed_rel_path;
	*** allowed_userinfo;
	*** allowed_within_authority;
	*** allowed_within_path;
	*** allowed_within_query;
	*** allowed_within_userinfo;
	*** alpha;
	*** alphanum;
	*** authority;
	*** control;
	*** defaultDocumentCharset;
	*** defaultDocumentCharsetByLocale;
	*** defaultDocumentCharsetByPlatform;
	*** defaultProtocolCharset;
	*** delims;
	*** digit;
	*** disallowed_opaque_part;
	*** disallowed_rel_path;
	*** domainlabel;
	*** escaped;
	*** fragment;
	*** hash;
	*** hex;
	*** hier_part;
	*** host;
	*** hostname;
	*** hostport;
	*** mark;
	*** net_path;
	*** opaque_part;
	*** param;
	*** path;
	*** path_segments;
	*** pchar;
	*** percent;
	*** port;
	*** protocolCharset;
	*** query;
	*** reg_name;
	*** rel_path;
	*** rel_segment;
	*** relativeURI;
	*** reserved;
	*** rootPath;
	*** scheme;
	*** segment;
	*** server;
	*** space;
	*** toplabel;
	*** unreserved;
	*** unwise;
	*** uric;
	*** uric_no_slash;
	*** userinfo;
	*** within_userinfo;
	org.apache.commons.httpclient.URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String);
	org.apache.commons.httpclient.URI(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	org.apache.commons.httpclient.URI(org.apache.commons.httpclient.URI,org.apache.commons.httpclient.URI);
	*** decode(char[],java.lang.String);
	*** decode(java.lang.String,java.lang.String);
	*** encode(java.lang.String,java.util.BitSet,java.lang.String);
	*** equals(char[],char[]);
	*** getEscapedURI();
	*** getHost();
	*** getProtocolCharset();
	*** getRawAboveHierPath();
	*** getRawAuthority();
	*** getRawCurrentHierPath();
	*** getRawCurrentHierPath(char[]);
	*** getRawName();
	*** getRawPath();
	*** getRawPathQuery();
	*** getRawURIReference();
	*** indexFirstOf(char[],char);
	*** indexFirstOf(char[],char,int);
	*** indexFirstOf(java.lang.String,java.lang.String,int);
	*** isAbsPath();
	*** normalize(char[]);
	*** parseAuthority(java.lang.String,boolean);
	*** parseUriReference(java.lang.String,boolean);
	*** prevalidate(java.lang.String,java.util.BitSet);
	*** removeFragmentIdentifier(char[]);
	*** resolvePath(char[],char[]);
	*** setPath(java.lang.String);
	*** setRawFragment(char[]);
	*** setRawPath(char[]);
	*** setRawQuery(char[]);
	*** setURI();
	*** toString();
	*** validate(char[],int,int,java.util.BitSet);
	*** validate(char[],java.util.BitSet);
}

-keep class org.apache.commons.httpclient.URI$DefaultCharsetChanged {
	*** reason;
	*** reasonCode;
}

-keep class org.apache.commons.httpclient.URI$LocaleToCharsetMap {
	*** LOCALE_TO_CHARSET_MAP;
	*** getCharset(java.util.Locale);
}

-keep class org.apache.commons.httpclient.URIException {
	*** reason;
	*** reasonCode;
}

-keep class org.apache.commons.httpclient.util.EncodingUtil {
	*** LOG;
	*** class$org$apache$commons$httpclient$util$EncodingUtil;
	*** class$(java.lang.String);
	*** doFormUrlEncode(org.apache.commons.httpclient.NameValuePair[],java.lang.String);
	*** getAsciiBytes(java.lang.String);
	*** getAsciiString(byte[]);
	*** getAsciiString(byte[],int,int);
	*** getBytes(java.lang.String,java.lang.String);
	*** getString(byte[],int,int,java.lang.String);
	*** getString(byte[],java.lang.String);
}

-keep class org.apache.commons.id.DigestUtils {
	*** md5(byte[]);
	*** sha(byte[]);
}

-keep class org.apache.commons.id.Hex {
	*** DIGITS;
	*** decodeHex(char[]);
	*** encodeHex(byte[]);
	*** toDigit(char,int);
}

-keep class org.apache.commons.id.uuid.Bytes {
	*** append(byte[],byte[]);
	*** areEqual(byte[],byte[]);
	*** compareTo(byte[],byte[]);
	*** toBytes(long);
	*** toBytes(long,byte[]);
	*** toLong(byte[]);
	*** toShort(byte[]);
}

-keep class org.apache.commons.id.uuid.Constants {
	*** TOKEN_LENGTHS;
}

-keep class org.apache.commons.id.uuid.UUID {
	*** clockSq;
	*** node;
	*** rawBytes;
	*** stringValue;
	*** timestamp;
	*** variant;
	*** version;
	org.apache.commons.id.uuid.UUID(org.apache.commons.id.uuid.UUID);
	*** equals(java.lang.Object);
	*** fromString(java.lang.String);
	*** getRawBytes();
	*** nameUUIDFromString(java.lang.String,org.apache.commons.id.uuid.UUID,java.lang.String);
	*** randomUUID();
	*** toString();
	*** variant();
	*** version();
}

-keep class org.apache.commons.id.uuid.VersionFourGenerator {
	*** generator;
	*** regularRandom;
	*** secureRandom;
	*** usePRNG;
	*** usePRNGPackage;
	*** getInstance();
	*** nextUUID();
	*** nextUUID(boolean);
}

-keep class org.apache.commons.id.uuid.VersionOneGenerator {
	*** getInstance();
	*** nextUUID();
}

-keep class org.apache.commons.io.Charsets {
	*** ISO_8859_1;
	*** US_ASCII;
	*** UTF_16;
	*** UTF_16BE;
	*** UTF_16LE;
	*** UTF_8;
	*** toCharset(java.lang.String);
	*** toCharset(java.nio.charset.Charset);
}

-keep class org.apache.commons.io.FileSystemUtils {
	*** DF;
	*** INSTANCE;
	*** OS;
	*** freeSpaceKb();
	*** freeSpaceKb(java.lang.String);
	*** freeSpaceKb(java.lang.String,long);
	*** freeSpaceKb(long);
	*** freeSpaceOS(java.lang.String,int,boolean,long);
	*** freeSpaceUnix(java.lang.String,boolean,boolean,long);
	*** freeSpaceWindows(java.lang.String,long);
	*** openProcess(java.lang.String[]);
	*** parseBytes(java.lang.String,java.lang.String);
	*** parseDir(java.lang.String,java.lang.String);
	*** performCommand(java.lang.String[],int,long);
}

-keep class org.apache.commons.io.FileUtils {
	*** EMPTY_FILE_ARRAY;
	*** ONE_EB_BI;
	*** ONE_GB_BI;
	*** ONE_KB_BI;
	*** ONE_MB_BI;
	*** ONE_PB_BI;
	*** ONE_TB_BI;
	*** ONE_YB;
	*** ONE_ZB;
	*** UTF8;
	*** byteCountToDisplaySize(java.math.BigInteger);
	*** checkDirectory(java.io.File);
	*** checksum(java.io.File,java.util.zip.Checksum);
	*** cleanDirectory(java.io.File);
	*** cleanDirectoryOnExit(java.io.File);
	*** copyDirectory(java.io.File,java.io.File);
	*** copyDirectory(java.io.File,java.io.File,boolean);
	*** copyDirectory(java.io.File,java.io.File,java.io.FileFilter,boolean);
	*** copyDirectoryToDirectory(java.io.File,java.io.File);
	*** copyFile(java.io.File,java.io.File);
	*** copyFile(java.io.File,java.io.File,boolean);
	*** copyFileToDirectory(java.io.File,java.io.File);
	*** copyFileToDirectory(java.io.File,java.io.File,boolean);
	*** copyInputStreamToFile(java.io.InputStream,java.io.File);
	*** decodeUrl(java.lang.String);
	*** deleteDirectory(java.io.File);
	*** deleteDirectoryOnExit(java.io.File);
	*** deleteQuietly(java.io.File);
	*** doCopyDirectory(java.io.File,java.io.File,java.io.FileFilter,boolean,java.util.List);
	*** doCopyFile(java.io.File,java.io.File,boolean);
	*** forceDelete(java.io.File);
	*** forceDeleteOnExit(java.io.File);
	*** getTempDirectoryPath();
	*** getUserDirectoryPath();
	*** innerListFiles(java.util.Collection,java.io.File,org.apache.commons.io.filefilter.IOFileFilter,boolean);
	*** isFileNewer(java.io.File,java.io.File);
	*** isFileNewer(java.io.File,long);
	*** isFileOlder(java.io.File,long);
	*** isSymlink(java.io.File);
	*** lineIterator(java.io.File,java.lang.String);
	*** listFiles(java.io.File,java.lang.String[],boolean);
	*** listFiles(java.io.File,org.apache.commons.io.filefilter.IOFileFilter,org.apache.commons.io.filefilter.IOFileFilter);
	*** listFilesAndDirs(java.io.File,org.apache.commons.io.filefilter.IOFileFilter,org.apache.commons.io.filefilter.IOFileFilter);
	*** moveDirectory(java.io.File,java.io.File);
	*** moveDirectoryToDirectory(java.io.File,java.io.File,boolean);
	*** moveFile(java.io.File,java.io.File);
	*** moveFileToDirectory(java.io.File,java.io.File,boolean);
	*** openInputStream(java.io.File);
	*** openOutputStream(java.io.File);
	*** openOutputStream(java.io.File,boolean);
	*** readFileToByteArray(java.io.File);
	*** readFileToString(java.io.File);
	*** readFileToString(java.io.File,java.lang.String);
	*** readFileToString(java.io.File,java.nio.charset.Charset);
	*** readLines(java.io.File,java.lang.String);
	*** readLines(java.io.File,java.nio.charset.Charset);
	*** setUpEffectiveDirFilter(org.apache.commons.io.filefilter.IOFileFilter);
	*** setUpEffectiveFileFilter(org.apache.commons.io.filefilter.IOFileFilter);
	*** sizeOf(java.io.File);
	*** sizeOfDirectory(java.io.File);
	*** sizeOfDirectoryAsBigInteger(java.io.File);
	*** toFile(java.net.URL);
	*** toSuffixes(java.lang.String[]);
	*** validateListFilesParameters(java.io.File,org.apache.commons.io.filefilter.IOFileFilter);
	*** write(java.io.File,java.lang.CharSequence,java.lang.String);
	*** write(java.io.File,java.lang.CharSequence,java.lang.String,boolean);
	*** write(java.io.File,java.lang.CharSequence,java.nio.charset.Charset,boolean);
	*** writeByteArrayToFile(java.io.File,byte[]);
	*** writeByteArrayToFile(java.io.File,byte[],boolean);
	*** writeLines(java.io.File,java.lang.String,java.util.Collection,boolean);
	*** writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean);
	*** writeStringToFile(java.io.File,java.lang.String);
	*** writeStringToFile(java.io.File,java.lang.String,java.lang.String);
	*** writeStringToFile(java.io.File,java.lang.String,java.lang.String,boolean);
	*** writeStringToFile(java.io.File,java.lang.String,java.nio.charset.Charset,boolean);
}

-keep class org.apache.commons.io.FilenameUtils {
	*** EXTENSION_SEPARATOR_STR;
	*** OTHER_SEPARATOR;
	*** SYSTEM_SEPARATOR;
	*** directoryContains(java.lang.String,java.lang.String);
	*** doGetFullPath(java.lang.String,boolean);
	*** doGetPath(java.lang.String,int);
	*** doNormalize(java.lang.String,char,boolean);
	*** equals(java.lang.String,java.lang.String,boolean,org.apache.commons.io.IOCase);
	*** getExtension(java.lang.String);
	*** getName(java.lang.String);
	*** getPrefix(java.lang.String);
	*** getPrefixLength(java.lang.String);
	*** indexOfExtension(java.lang.String);
	*** indexOfLastSeparator(java.lang.String);
	*** isSeparator(char);
	*** isSystemWindows();
	*** normalize(java.lang.String);
	*** normalize(java.lang.String,boolean);
	*** removeExtension(java.lang.String);
	*** separatorsToUnix(java.lang.String);
	*** separatorsToWindows(java.lang.String);
	*** splitOnTokens(java.lang.String);
	*** wildcardMatch(java.lang.String,java.lang.String,org.apache.commons.io.IOCase);
}

-keep class org.apache.commons.io.IOCase {
	*** SENSITIVE;
	*** SYSTEM;
	*** checkEquals(java.lang.String,java.lang.String);
	*** checkIndexOf(java.lang.String,int,java.lang.String);
	*** checkRegionMatches(java.lang.String,int,java.lang.String);
	*** checkStartsWith(java.lang.String,java.lang.String);
}

-keep class org.apache.commons.io.IOUtils {
	*** DIR_SEPARATOR;
	*** LINE_SEPARATOR;
	*** SKIP_BYTE_BUFFER;
	*** SKIP_CHAR_BUFFER;
	*** close(java.net.URLConnection);
	*** closeQuietly(java.io.Closeable);
	*** closeQuietly(java.io.InputStream);
	*** closeQuietly(java.io.OutputStream);
	*** closeQuietly(java.io.Reader);
	*** closeQuietly(java.io.Writer);
	*** closeQuietly(java.net.Socket);
	*** contentEquals(java.io.InputStream,java.io.InputStream);
	*** contentEqualsIgnoreEOL(java.io.Reader,java.io.Reader);
	*** copy(java.io.InputStream,java.io.OutputStream);
	*** copy(java.io.InputStream,java.io.Writer,java.nio.charset.Charset);
	*** copy(java.io.Reader,java.io.OutputStream,java.nio.charset.Charset);
	*** copy(java.io.Reader,java.io.Writer);
	*** copyLarge(java.io.InputStream,java.io.OutputStream);
	*** copyLarge(java.io.InputStream,java.io.OutputStream,byte[]);
	*** copyLarge(java.io.InputStream,java.io.OutputStream,long,long,byte[]);
	*** copyLarge(java.io.Reader,java.io.Writer);
	*** copyLarge(java.io.Reader,java.io.Writer,char[]);
	*** copyLarge(java.io.Reader,java.io.Writer,long,long,char[]);
	*** lineIterator(java.io.InputStream,java.lang.String);
	*** lineIterator(java.io.InputStream,java.nio.charset.Charset);
	*** read(java.io.InputStream,byte[],int,int);
	*** read(java.io.Reader,char[],int,int);
	*** readFully(java.io.InputStream,byte[],int,int);
	*** readFully(java.io.Reader,char[],int,int);
	*** readLines(java.io.InputStream,java.nio.charset.Charset);
	*** readLines(java.io.Reader);
	*** skip(java.io.InputStream,long);
	*** skip(java.io.Reader,long);
	*** skipFully(java.io.InputStream,long);
	*** skipFully(java.io.Reader,long);
	*** toBufferedReader(java.io.Reader);
	*** toByteArray(java.io.InputStream);
	*** toByteArray(java.io.InputStream,int);
	*** toByteArray(java.io.InputStream,long);
	*** toByteArray(java.io.Reader,java.nio.charset.Charset);
	*** toByteArray(java.net.URL);
	*** toByteArray(java.net.URLConnection);
	*** toCharArray(java.io.InputStream,java.nio.charset.Charset);
	*** toInputStream(java.lang.CharSequence,java.nio.charset.Charset);
	*** toInputStream(java.lang.String,java.nio.charset.Charset);
	*** toString(java.io.InputStream);
	*** toString(java.io.InputStream,java.lang.String);
	*** toString(java.io.InputStream,java.nio.charset.Charset);
	*** toString(java.io.Reader);
	*** toString(java.net.URI,java.nio.charset.Charset);
	*** toString(java.net.URL,java.nio.charset.Charset);
	*** write(byte[],java.io.Writer,java.nio.charset.Charset);
	*** write(char[],java.io.OutputStream,java.nio.charset.Charset);
	*** write(java.lang.CharSequence,java.io.OutputStream,java.nio.charset.Charset);
	*** write(java.lang.String,java.io.OutputStream,java.nio.charset.Charset);
	*** write(java.lang.String,java.io.Writer);
	*** write(java.lang.StringBuffer,java.io.OutputStream,java.lang.String);
	*** writeLines(java.util.Collection,java.lang.String,java.io.OutputStream,java.lang.String);
	*** writeLines(java.util.Collection,java.lang.String,java.io.OutputStream,java.nio.charset.Charset);
}

-keep class org.apache.commons.io.ThreadMonitor {
	*** thread;
	*** timeout;
	*** start(java.lang.Thread,long);
	*** start(long);
	*** stop(java.lang.Thread);
}

-keep class org.apache.commons.io.filefilter.DirectoryFileFilter {
	*** INSTANCE;
}

-keep class org.apache.commons.io.filefilter.FalseFileFilter {
	*** INSTANCE;
}

-keep class org.apache.commons.io.filefilter.FileFilterUtils {
	*** and(org.apache.commons.io.filefilter.IOFileFilter[]);
	*** notFileFilter(org.apache.commons.io.filefilter.IOFileFilter);
	*** or(org.apache.commons.io.filefilter.IOFileFilter[]);
}

-keep class org.apache.commons.io.filefilter.TrueFileFilter {
	*** INSTANCE;
}

-keep class org.apache.commons.io.input.ClosedInputStream {
	*** CLOSED_INPUT_STREAM;
}

-keep class org.apache.commons.io.input.ProxyInputStream {
	org.apache.commons.io.input.ProxyInputStream(java.io.InputStream);
	*** afterRead(int);
	*** beforeRead(int);
	*** handleIOException(java.io.IOException);
}

-keep class org.apache.commons.io.output.ByteArrayOutputStream {
	*** EMPTY_BYTE_ARRAY;
	*** buffers;
	*** count;
	*** currentBuffer;
	*** currentBufferIndex;
	*** filledBufferSum;
	org.apache.commons.io.output.ByteArrayOutputStream(int);
	*** needNewBuffer(int);
	*** toBufferedInputStream();
	*** toBufferedInputStream(java.io.InputStream);
	*** toByteArray();
	*** write(java.io.InputStream);
}

-keep class org.apache.commons.io.output.ClosedOutputStream {
	*** CLOSED_OUTPUT_STREAM;
}

-keep class org.apache.commons.io.output.CountingOutputStream {
	*** count;
	*** getByteCount();
	*** resetByteCount();
}

-keep class org.apache.commons.io.output.NullOutputStream {
	*** NULL_OUTPUT_STREAM;
}

-keep class org.apache.commons.io.output.ProxyOutputStream {
	org.apache.commons.io.output.ProxyOutputStream(java.io.OutputStream);
	*** afterWrite(int);
	*** beforeWrite(int);
	*** close();
	*** handleIOException(java.io.IOException);
	*** write(byte[]);
}

-keep class org.apache.commons.io.output.StringBuilderWriter {
	*** builder;
	*** append(char);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
	*** toString();
}

-keep class org.apache.commons.lang.ArrayUtils {
	*** EMPTY_BYTE_ARRAY;
	*** EMPTY_CHAR_ARRAY;
	*** EMPTY_INT_ARRAY;
	*** EMPTY_STRING_ARRAY;
	*** isEmpty(char[]);
	*** isEmpty(java.lang.Object[]);
	*** reverse(java.lang.Object[]);
}

-keep class org.apache.commons.lang.CharSetUtils {
	*** delete(java.lang.String,java.lang.String);
}

-keep class org.apache.commons.lang.CharUtils {
	*** isAsciiPrintable(char);
	*** isHighSurrogate(char);
}

-keep class org.apache.commons.lang.ClassUtils {
	*** getShortClassName(java.lang.Class);
}

-keep class org.apache.commons.lang.ObjectUtils {
	*** toString(java.lang.Object);
}

-keep class org.apache.commons.lang.StringEscapeUtils {
	*** escapeJava(java.lang.String);
}

-keep class org.apache.commons.lang.StringUtils {
	*** abbreviate(java.lang.String,int);
	*** abbreviate(java.lang.String,int,int);
	*** capitalize(java.lang.String);
	*** center(java.lang.String,int,char);
	*** chompLast(java.lang.String,java.lang.String);
	*** containsAny(java.lang.String,char[]);
	*** containsNone(java.lang.String,char[]);
	*** containsOnly(java.lang.String,char[]);
	*** endsWith(java.lang.String,java.lang.String);
	*** endsWith(java.lang.String,java.lang.String,boolean);
	*** endsWithIgnoreCase(java.lang.String,java.lang.String);
	*** indexOfAny(java.lang.String,char[]);
	*** indexOfAnyBut(java.lang.String,char[]);
	*** indexOfDifference(java.lang.String,java.lang.String);
	*** indexOfDifference(java.lang.String[]);
	*** indexOfIgnoreCase(java.lang.String,java.lang.String,int);
	*** isBlank(java.lang.String);
	*** isEmpty(java.lang.String);
	*** isNotBlank(java.lang.String);
	*** isNotEmpty(java.lang.String);
	*** join(java.lang.Object[],char);
	*** join(java.lang.Object[],char,int,int);
	*** join(java.lang.Object[],java.lang.String);
	*** join(java.lang.Object[],java.lang.String,int,int);
	*** join(java.util.Collection,java.lang.String);
	*** join(java.util.Iterator,char);
	*** join(java.util.Iterator,java.lang.String);
	*** lastIndexOfIgnoreCase(java.lang.String,java.lang.String,int);
	*** leftPad(java.lang.String,int,char);
	*** leftPad(java.lang.String,int,java.lang.String);
	*** ordinalIndexOf(java.lang.String,java.lang.String,int,boolean);
	*** padding(int,char);
	*** removeEnd(java.lang.String,java.lang.String);
	*** repeat(java.lang.String,int);
	*** replace(java.lang.String,java.lang.String,java.lang.String,int);
	*** replaceEach(java.lang.String,java.lang.String[],java.lang.String[],boolean,int);
	*** rightPad(java.lang.String,int,char);
	*** rightPad(java.lang.String,int,java.lang.String);
	*** split(java.lang.String);
	*** split(java.lang.String,char);
	*** split(java.lang.String,java.lang.String);
	*** split(java.lang.String,java.lang.String,int);
	*** splitByCharacterType(java.lang.String,boolean);
	*** splitByWholeSeparatorWorker(java.lang.String,java.lang.String,int,boolean);
	*** splitWorker(java.lang.String,char,boolean);
	*** splitWorker(java.lang.String,java.lang.String,int,boolean);
	*** startsWith(java.lang.String,java.lang.String);
	*** startsWith(java.lang.String,java.lang.String,boolean);
	*** startsWithIgnoreCase(java.lang.String,java.lang.String);
	*** strip(java.lang.String);
	*** strip(java.lang.String,java.lang.String);
	*** stripAll(java.lang.String[],java.lang.String);
	*** stripEnd(java.lang.String,java.lang.String);
	*** stripStart(java.lang.String,java.lang.String);
	*** substringAfter(java.lang.String,java.lang.String);
	*** substringAfterLast(java.lang.String,java.lang.String);
	*** substringBefore(java.lang.String,java.lang.String);
	*** substringBeforeLast(java.lang.String,java.lang.String);
	*** substringBetween(java.lang.String,java.lang.String,java.lang.String);
	*** trim(java.lang.String);
	*** uncapitalize(java.lang.String);
}

-keep class org.apache.commons.lang.SystemUtils {
	*** AWT_TOOLKIT;
	*** FILE_ENCODING;
	*** FILE_SEPARATOR;
	*** IS_JAVA_1_1;
	*** IS_JAVA_1_2;
	*** IS_JAVA_1_3;
	*** IS_JAVA_1_4;
	*** IS_JAVA_1_5;
	*** IS_JAVA_1_6;
	*** IS_JAVA_1_7;
	*** IS_OS_AIX;
	*** IS_OS_HP_UX;
	*** IS_OS_IRIX;
	*** IS_OS_LINUX;
	*** IS_OS_MAC;
	*** IS_OS_MAC_OSX;
	*** IS_OS_OS2;
	*** IS_OS_SOLARIS;
	*** IS_OS_SUN_OS;
	*** IS_OS_UNIX;
	*** IS_OS_WINDOWS;
	*** IS_OS_WINDOWS_2000;
	*** IS_OS_WINDOWS_7;
	*** IS_OS_WINDOWS_95;
	*** IS_OS_WINDOWS_98;
	*** IS_OS_WINDOWS_ME;
	*** IS_OS_WINDOWS_NT;
	*** IS_OS_WINDOWS_VISTA;
	*** IS_OS_WINDOWS_XP;
	*** JAVA_AWT_FONTS;
	*** JAVA_AWT_GRAPHICSENV;
	*** JAVA_AWT_HEADLESS;
	*** JAVA_AWT_PRINTERJOB;
	*** JAVA_CLASS_PATH;
	*** JAVA_CLASS_VERSION;
	*** JAVA_COMPILER;
	*** JAVA_ENDORSED_DIRS;
	*** JAVA_EXT_DIRS;
	*** JAVA_HOME;
	*** JAVA_IO_TMPDIR;
	*** JAVA_LIBRARY_PATH;
	*** JAVA_RUNTIME_NAME;
	*** JAVA_RUNTIME_VERSION;
	*** JAVA_SPECIFICATION_NAME;
	*** JAVA_SPECIFICATION_VENDOR;
	*** JAVA_SPECIFICATION_VERSION;
	*** JAVA_UTIL_PREFS_PREFERENCES_FACTORY;
	*** JAVA_VENDOR;
	*** JAVA_VENDOR_URL;
	*** JAVA_VERSION;
	*** JAVA_VERSION_FLOAT;
	*** JAVA_VERSION_INT;
	*** JAVA_VERSION_TRIMMED;
	*** JAVA_VM_INFO;
	*** JAVA_VM_NAME;
	*** JAVA_VM_SPECIFICATION_NAME;
	*** JAVA_VM_SPECIFICATION_VENDOR;
	*** JAVA_VM_SPECIFICATION_VERSION;
	*** JAVA_VM_VENDOR;
	*** JAVA_VM_VERSION;
	*** LINE_SEPARATOR;
	*** OS_ARCH;
	*** OS_NAME;
	*** OS_VERSION;
	*** PATH_SEPARATOR;
	*** USER_COUNTRY;
	*** USER_DIR;
	*** USER_HOME;
	*** USER_LANGUAGE;
	*** USER_NAME;
	*** USER_TIMEZONE;
	*** getJavaIoTmpDir();
	*** getJavaVersionAsFloat();
	*** getJavaVersionAsInt();
	*** getJavaVersionMatches(java.lang.String);
	*** getJavaVersionTrimmed();
	*** getOSMatches(java.lang.String,java.lang.String);
	*** getOSMatchesName(java.lang.String);
	*** getSystemProperty(java.lang.String);
	*** isJavaVersionMatch(java.lang.String,java.lang.String);
	*** isOSMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** isOSNameMatch(java.lang.String,java.lang.String);
	*** toJavaVersionIntArray(java.lang.String,int);
	*** toVersionFloat(int[]);
	*** toVersionInt(int[]);
}

-keep class org.apache.commons.lang.WordUtils {
	*** capitalize(java.lang.String);
}

-keep class org.apache.commons.lang.math.JVMRandom {
	*** SHARED_RANDOM;
	*** constructed;
	*** bitsRequired(long);
	*** next63bits();
	*** nextInt(int);
	*** nextLong(long);
}

-keep class org.apache.commons.lang.math.NumberUtils {
	*** BYTE_MINUS_ONE;
	*** BYTE_ONE;
	*** BYTE_ZERO;
	*** DOUBLE_MINUS_ONE;
	*** DOUBLE_ONE;
	*** DOUBLE_ZERO;
	*** FLOAT_MINUS_ONE;
	*** FLOAT_ONE;
	*** FLOAT_ZERO;
	*** INTEGER_MINUS_ONE;
	*** INTEGER_ONE;
	*** INTEGER_ZERO;
	*** LONG_MINUS_ONE;
	*** LONG_ONE;
	*** LONG_ZERO;
	*** SHORT_MINUS_ONE;
	*** SHORT_ONE;
	*** SHORT_ZERO;
	*** createBigDecimal(java.lang.String);
	*** createBigInteger(java.lang.String);
	*** createDouble(java.lang.String);
	*** createFloat(java.lang.String);
	*** createInteger(java.lang.String);
	*** createLong(java.lang.String);
	*** isAllZeros(java.lang.String);
	*** isDigits(java.lang.String);
	*** isNumber(java.lang.String);
	*** toByte(java.lang.String,byte);
	*** toDouble(java.lang.String,double);
	*** toFloat(java.lang.String,float);
	*** toInt(java.lang.String);
	*** toInt(java.lang.String,int);
	*** toLong(java.lang.String,long);
	*** toShort(java.lang.String,short);
}

-keep class org.apache.commons.lang.math.RandomUtils {
	*** JVM_RANDOM;
	*** nextBoolean(java.util.Random);
	*** nextDouble(java.util.Random);
	*** nextFloat(java.util.Random);
	*** nextInt();
	*** nextInt(java.util.Random);
	*** nextInt(java.util.Random,int);
	*** nextLong();
	*** nextLong(java.util.Random);
}

-keep class org.apache.commons.lang.text.StrBuilder {
	*** buffer;
	*** newLine;
	*** nullText;
	*** size;
	org.apache.commons.lang.text.StrBuilder(int);
	*** append(boolean);
	*** append(char);
	*** append(char[]);
	*** append(char[],int,int);
	*** append(double);
	*** append(float);
	*** append(int);
	*** append(java.lang.Object);
	*** append(java.lang.String);
	*** append(java.lang.String,int,int);
	*** append(java.lang.StringBuffer);
	*** append(java.lang.StringBuffer,int,int);
	*** append(long);
	*** append(org.apache.commons.lang.text.StrBuilder);
	*** append(org.apache.commons.lang.text.StrBuilder,int,int);
	*** appendFixedWidthPadLeft(java.lang.Object,int,char);
	*** appendFixedWidthPadRight(java.lang.Object,int,char);
	*** appendNewLine();
	*** appendNull();
	*** appendSeparator(java.lang.String,java.lang.String);
	*** charAt(int);
	*** clear();
	*** delete(int,int);
	*** deleteImpl(int,int,int);
	*** ensureCapacity(int);
	*** equals(org.apache.commons.lang.text.StrBuilder);
	*** getChars(int,int,char[],int);
	*** getNullText();
	*** indexOf(char,int);
	*** indexOf(java.lang.String,int);
	*** indexOf(org.apache.commons.lang.text.StrMatcher,int);
	*** insert(int,java.lang.String);
	*** isEmpty();
	*** lastIndexOf(char,int);
	*** lastIndexOf(java.lang.String,int);
	*** lastIndexOf(org.apache.commons.lang.text.StrMatcher,int);
	*** length();
	*** replace(org.apache.commons.lang.text.StrMatcher,java.lang.String,int,int,int);
	*** replaceImpl(int,int,int,java.lang.String,int);
	*** replaceImpl(org.apache.commons.lang.text.StrMatcher,java.lang.String,int,int,int);
	*** reverse();
	*** size();
	*** substring(int,int);
	*** toString();
	*** validateIndex(int);
	*** validateRange(int,int);
}

-keep class org.apache.commons.lang.text.StrBuilder$StrBuilderReader {
	*** mark;
	*** pos;
	*** this$0;
	*** ready();
}

-keep class org.apache.commons.lang.text.StrBuilder$StrBuilderTokenizer {
	*** this$0;
}

-keep class org.apache.commons.lang.text.StrBuilder$StrBuilderWriter {
	*** this$0;
}

-keep class org.apache.commons.lang.text.StrMatcher {
	*** charMatcher(char);
	*** commaMatcher();
	*** doubleQuoteMatcher();
	*** isMatch(char[],int,int,int);
	*** noneMatcher();
	*** splitMatcher();
	*** stringMatcher(java.lang.String);
	*** tabMatcher();
	*** trimMatcher();
}

-keep class org.apache.commons.lang.text.StrTokenizer {
	*** CSV_TOKENIZER_PROTOTYPE;
	*** TSV_TOKENIZER_PROTOTYPE;
	*** chars;
	*** delimMatcher;
	*** emptyAsNull;
	*** ignoreEmptyTokens;
	*** ignoredMatcher;
	*** quoteMatcher;
	*** tokenPos;
	*** tokens;
	*** trimmerMatcher;
	org.apache.commons.lang.text.StrTokenizer();
	org.apache.commons.lang.text.StrTokenizer(char[]);
	org.apache.commons.lang.text.StrTokenizer(char[],char);
	org.apache.commons.lang.text.StrTokenizer(char[],org.apache.commons.lang.text.StrMatcher);
	org.apache.commons.lang.text.StrTokenizer(java.lang.String);
	org.apache.commons.lang.text.StrTokenizer(java.lang.String,char);
	org.apache.commons.lang.text.StrTokenizer(java.lang.String,org.apache.commons.lang.text.StrMatcher);
	*** addToken(java.util.List,java.lang.String);
	*** checkTokenized();
	*** clone();
	*** cloneReset();
	*** getCSVClone();
	*** getContent();
	*** getDelimiterMatcher();
	*** getIgnoredMatcher();
	*** getQuoteMatcher();
	*** getTSVClone();
	*** getTokenList();
	*** getTrimmerMatcher();
	*** hasNext();
	*** hasPrevious();
	*** isEmptyTokenAsNull();
	*** isIgnoreEmptyTokens();
	*** isQuote(char[],int,int,int,int);
	*** readNextToken(char[],int,int,org.apache.commons.lang.text.StrBuilder,java.util.List);
	*** readWithQuotes(char[],int,int,org.apache.commons.lang.text.StrBuilder,java.util.List,int,int);
	*** reset();
	*** reset(char[]);
	*** reset(java.lang.String);
	*** setDelimiterChar(char);
	*** setDelimiterMatcher(org.apache.commons.lang.text.StrMatcher);
	*** setDelimiterString(java.lang.String);
	*** setEmptyTokenAsNull(boolean);
	*** setIgnoreEmptyTokens(boolean);
	*** setIgnoredMatcher(org.apache.commons.lang.text.StrMatcher);
	*** setQuoteChar(char);
	*** setQuoteMatcher(org.apache.commons.lang.text.StrMatcher);
	*** setTrimmerMatcher(org.apache.commons.lang.text.StrMatcher);
	*** tokenize(char[],int,int);
}

-keep class org.apache.commons.lang3.ArrayUtils {
	*** EMPTY_STRING_ARRAY;
	*** add(java.lang.Object[],java.lang.Object);
	*** addAll(java.lang.Object[],java.lang.Object[]);
	*** isEmpty(char[]);
	*** isEmpty(java.lang.Object[]);
	*** isNotEmpty(java.lang.Object[]);
	*** reverse(java.lang.Object[]);
}

-keep class org.apache.commons.lang3.CharSequenceUtils {
	*** indexOf(java.lang.CharSequence,int,int);
	*** indexOf(java.lang.CharSequence,java.lang.CharSequence,int);
	*** lastIndexOf(java.lang.CharSequence,int,int);
	*** lastIndexOf(java.lang.CharSequence,java.lang.CharSequence,int);
	*** regionMatches(java.lang.CharSequence,boolean,int,java.lang.CharSequence,int,int);
	*** toCharArray(java.lang.CharSequence);
}

-keep class org.apache.commons.lang3.CharUtils {
	*** isAsciiPrintable(char);
}

-keep class org.apache.commons.lang3.JavaVersion {
	*** $VALUES;
	*** JAVA_0_9;
	*** JAVA_1_1;
	*** JAVA_1_2;
	*** JAVA_1_3;
	*** JAVA_1_4;
	*** JAVA_1_5;
	*** JAVA_1_6;
	*** JAVA_1_7;
	*** JAVA_1_8;
	*** name;
	*** value;
	*** atLeast(org.apache.commons.lang3.JavaVersion);
	*** get(java.lang.String);
}

-keep class org.apache.commons.lang3.ObjectUtils {
	*** NULL;
	*** clone(java.lang.Object);
	*** compare(java.lang.Comparable,java.lang.Comparable,boolean);
	*** equals(java.lang.Object,java.lang.Object);
	*** hashCode(java.lang.Object);
	*** identityToString(java.lang.StringBuffer,java.lang.Object);
	*** toString(java.lang.Object);
}

-keep class org.apache.commons.lang3.StringUtils {
	*** WHITESPACE_BLOCK;
	*** abbreviate(java.lang.String,int);
	*** abbreviate(java.lang.String,int,int);
	*** center(java.lang.String,int,char);
	*** containsAny(java.lang.CharSequence,char[]);
	*** containsNone(java.lang.CharSequence,char[]);
	*** containsOnly(java.lang.CharSequence,char[]);
	*** endsWith(java.lang.CharSequence,java.lang.CharSequence);
	*** endsWith(java.lang.CharSequence,java.lang.CharSequence,boolean);
	*** endsWithIgnoreCase(java.lang.CharSequence,java.lang.CharSequence);
	*** equals(java.lang.CharSequence,java.lang.CharSequence);
	*** indexOfAny(java.lang.CharSequence,char[]);
	*** indexOfAnyBut(java.lang.CharSequence,char[]);
	*** indexOfDifference(java.lang.CharSequence,java.lang.CharSequence);
	*** indexOfDifference(java.lang.CharSequence[]);
	*** indexOfIgnoreCase(java.lang.CharSequence,java.lang.CharSequence,int);
	*** isBlank(java.lang.CharSequence);
	*** isEmpty(java.lang.CharSequence);
	*** isNotBlank(java.lang.CharSequence);
	*** join(java.lang.Object[],char);
	*** join(java.lang.Object[],char,int,int);
	*** join(java.lang.Object[],java.lang.String);
	*** join(java.lang.Object[],java.lang.String,int,int);
	*** join(java.util.Iterator,char);
	*** join(java.util.Iterator,java.lang.String);
	*** lastIndexOfIgnoreCase(java.lang.CharSequence,java.lang.CharSequence,int);
	*** leftPad(java.lang.String,int,char);
	*** leftPad(java.lang.String,int,java.lang.String);
	*** ordinalIndexOf(java.lang.CharSequence,java.lang.CharSequence,int,boolean);
	*** removeAccentsJava6(java.lang.CharSequence);
	*** removeAccentsSUN(java.lang.CharSequence);
	*** removeEnd(java.lang.String,java.lang.String);
	*** repeat(char,int);
	*** repeat(java.lang.String,int);
	*** replace(java.lang.String,java.lang.String,java.lang.String,int);
	*** replaceEach(java.lang.String,java.lang.String[],java.lang.String[],boolean,int);
	*** rightPad(java.lang.String,int,char);
	*** rightPad(java.lang.String,int,java.lang.String);
	*** split(java.lang.String,char);
	*** split(java.lang.String,java.lang.String,int);
	*** splitByCharacterType(java.lang.String,boolean);
	*** splitByWholeSeparatorWorker(java.lang.String,java.lang.String,int,boolean);
	*** splitWorker(java.lang.String,char,boolean);
	*** splitWorker(java.lang.String,java.lang.String,int,boolean);
	*** startsWith(java.lang.CharSequence,java.lang.CharSequence);
	*** startsWith(java.lang.CharSequence,java.lang.CharSequence,boolean);
	*** startsWithIgnoreCase(java.lang.CharSequence,java.lang.CharSequence);
	*** strip(java.lang.String,java.lang.String);
	*** stripAll(java.lang.String[],java.lang.String);
	*** stripEnd(java.lang.String,java.lang.String);
	*** stripStart(java.lang.String,java.lang.String);
	*** substringAfter(java.lang.String,java.lang.String);
	*** substringAfterLast(java.lang.String,java.lang.String);
	*** substringBefore(java.lang.String,java.lang.String);
	*** substringBetween(java.lang.String,java.lang.String,java.lang.String);
	*** trim(java.lang.String);
}

-keep class org.apache.commons.lang3.StringUtils$InitStripAccents {
	*** access$000();
	*** access$100();
	*** access$200();
	*** access$300();
	*** access$400();
	*** access$500();
	*** access$600();
}

-keep class org.apache.commons.lang3.SystemUtils {
	*** AWT_TOOLKIT;
	*** FILE_ENCODING;
	*** FILE_SEPARATOR;
	*** IS_JAVA_1_1;
	*** IS_JAVA_1_2;
	*** IS_JAVA_1_3;
	*** IS_JAVA_1_4;
	*** IS_JAVA_1_5;
	*** IS_JAVA_1_6;
	*** IS_JAVA_1_7;
	*** IS_OS_AIX;
	*** IS_OS_FREE_BSD;
	*** IS_OS_HP_UX;
	*** IS_OS_IRIX;
	*** IS_OS_LINUX;
	*** IS_OS_MAC;
	*** IS_OS_MAC_OSX;
	*** IS_OS_NET_BSD;
	*** IS_OS_OPEN_BSD;
	*** IS_OS_OS2;
	*** IS_OS_SOLARIS;
	*** IS_OS_SUN_OS;
	*** IS_OS_UNIX;
	*** IS_OS_WINDOWS;
	*** IS_OS_WINDOWS_2000;
	*** IS_OS_WINDOWS_2003;
	*** IS_OS_WINDOWS_2008;
	*** IS_OS_WINDOWS_7;
	*** IS_OS_WINDOWS_95;
	*** IS_OS_WINDOWS_98;
	*** IS_OS_WINDOWS_ME;
	*** IS_OS_WINDOWS_NT;
	*** IS_OS_WINDOWS_VISTA;
	*** IS_OS_WINDOWS_XP;
	*** JAVA_AWT_FONTS;
	*** JAVA_AWT_GRAPHICSENV;
	*** JAVA_AWT_HEADLESS;
	*** JAVA_AWT_PRINTERJOB;
	*** JAVA_CLASS_PATH;
	*** JAVA_CLASS_VERSION;
	*** JAVA_COMPILER;
	*** JAVA_ENDORSED_DIRS;
	*** JAVA_EXT_DIRS;
	*** JAVA_HOME;
	*** JAVA_IO_TMPDIR;
	*** JAVA_LIBRARY_PATH;
	*** JAVA_RUNTIME_NAME;
	*** JAVA_RUNTIME_VERSION;
	*** JAVA_SPECIFICATION_NAME;
	*** JAVA_SPECIFICATION_VENDOR;
	*** JAVA_SPECIFICATION_VERSION;
	*** JAVA_SPECIFICATION_VERSION_AS_ENUM;
	*** JAVA_UTIL_PREFS_PREFERENCES_FACTORY;
	*** JAVA_VENDOR;
	*** JAVA_VENDOR_URL;
	*** JAVA_VERSION;
	*** JAVA_VM_INFO;
	*** JAVA_VM_NAME;
	*** JAVA_VM_SPECIFICATION_NAME;
	*** JAVA_VM_SPECIFICATION_VENDOR;
	*** JAVA_VM_SPECIFICATION_VERSION;
	*** JAVA_VM_VENDOR;
	*** JAVA_VM_VERSION;
	*** LINE_SEPARATOR;
	*** OS_ARCH;
	*** OS_NAME;
	*** OS_VERSION;
	*** PATH_SEPARATOR;
	*** USER_COUNTRY;
	*** USER_DIR;
	*** USER_HOME;
	*** USER_LANGUAGE;
	*** USER_NAME;
	*** USER_TIMEZONE;
	*** getJavaVersionMatches(java.lang.String);
	*** getOSMatches(java.lang.String,java.lang.String);
	*** getOSMatchesName(java.lang.String);
	*** getSystemProperty(java.lang.String);
	*** getUserHome();
	*** isJavaVersionMatch(java.lang.String,java.lang.String);
	*** isOSMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** isOSNameMatch(java.lang.String,java.lang.String);
}

-keep class org.apache.commons.lang3.Validate {
	*** isTrue(boolean,java.lang.String,long);
	*** noNullElements(java.lang.Iterable,java.lang.String,java.lang.Object[]);
	*** noNullElements(java.lang.Object[]);
	*** noNullElements(java.lang.Object[],java.lang.String,java.lang.Object[]);
	*** notBlank(java.lang.CharSequence,java.lang.String,java.lang.Object[]);
	*** notEmpty(java.lang.CharSequence,java.lang.String,java.lang.Object[]);
	*** notEmpty(java.lang.Object[]);
	*** notEmpty(java.lang.Object[],java.lang.String,java.lang.Object[]);
	*** notEmpty(java.util.Collection,java.lang.String,java.lang.Object[]);
	*** notEmpty(java.util.Map,java.lang.String,java.lang.Object[]);
	*** notNull(java.lang.Object);
	*** notNull(java.lang.Object,java.lang.String,java.lang.Object[]);
	*** validIndex(java.lang.CharSequence,int,java.lang.String,java.lang.Object[]);
	*** validIndex(java.lang.Object[],int,java.lang.String,java.lang.Object[]);
	*** validIndex(java.util.Collection,int,java.lang.String,java.lang.Object[]);
}

-keep class org.apache.commons.lang3.builder.CompareToBuilder {
	*** append(java.lang.Object,java.lang.Object);
	*** toComparison();
}

-keep class org.apache.commons.lang3.math.NumberUtils {
	*** isNumber(java.lang.String);
}

-keep class org.apache.commons.lang3.mutable.MutableInt {
	*** increment();
	*** intValue();
}

-keep class org.apache.commons.lang3.time.DateFormatUtils {
	*** ISO_DATETIME_FORMAT;
	*** ISO_DATETIME_TIME_ZONE_FORMAT;
	*** ISO_DATE_FORMAT;
	*** ISO_DATE_TIME_ZONE_FORMAT;
	*** ISO_TIME_FORMAT;
	*** ISO_TIME_NO_T_FORMAT;
	*** ISO_TIME_NO_T_TIME_ZONE_FORMAT;
	*** ISO_TIME_TIME_ZONE_FORMAT;
	*** SMTP_DATETIME_FORMAT;
	*** UTC_TIME_ZONE;
	*** format(java.util.Calendar,java.lang.String,java.util.TimeZone,java.util.Locale);
	*** format(java.util.Date,java.lang.String);
	*** format(java.util.Date,java.lang.String,java.util.TimeZone,java.util.Locale);
}

-keep class org.apache.commons.lang3.time.FastDateFormat {
	*** cTimeZoneDisplayCache;
	*** cache;
	*** mLocale;
	*** mMaxLengthEstimate;
	*** mPattern;
	*** mRules;
	*** mTimeZone;
	*** applyRules(java.util.Calendar,java.lang.StringBuffer);
	*** format(java.util.Calendar);
	*** format(java.util.Calendar,java.lang.StringBuffer);
	*** format(java.util.Date);
	*** format(java.util.Date,java.lang.StringBuffer);
	*** format(long);
	*** format(long,java.lang.StringBuffer);
	*** getDateTimeInstance(int,int,java.util.TimeZone,java.util.Locale);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.util.Locale);
	*** getInstance(java.lang.String,java.util.TimeZone,java.util.Locale);
	*** init();
	*** parsePattern();
	*** parseToken(java.lang.String,int[]);
	*** selectNumberRule(int,int);
}

-keep class org.apache.commons.lang3.time.FastDateFormat$1 {
	*** createInstance(java.lang.String,java.util.TimeZone,java.util.Locale);
}

-keep class org.apache.commons.lang3.time.FastDateFormat$CharacterLiteral {
	*** mValue;
}

-keep class org.apache.commons.lang3.time.FastDateFormat$PaddedNumberField {
	*** mField;
	*** mSize;
	*** appendTo(java.lang.StringBuffer,int);
}

-keep class org.apache.commons.lang3.time.FastDateFormat$Rule {
	*** appendTo(java.lang.StringBuffer,java.util.Calendar);
	*** estimateLength();
}

-keep class org.apache.commons.lang3.time.FastDateFormat$StringLiteral {
	*** mValue;
}

-keep class org.apache.commons.lang3.time.FastDateFormat$TextField {
	*** mField;
	*** mValues;
}

-keep class org.apache.commons.lang3.time.FastDateFormat$TimeZoneNumberRule {
	*** INSTANCE_COLON;
	*** INSTANCE_NO_COLON;
	*** mColon;
}

-keep class org.apache.commons.lang3.time.FastDateFormat$TwoDigitMonthField {
	*** INSTANCE;
	*** appendTo(java.lang.StringBuffer,int);
}

-keep class org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField {
	*** mField;
	*** appendTo(java.lang.StringBuffer,int);
}

-keep class org.apache.commons.lang3.time.FastDateFormat$TwoDigitYearField {
	*** INSTANCE;
	*** appendTo(java.lang.StringBuffer,int);
}

-keep class org.apache.commons.lang3.time.FastDateFormat$UnpaddedMonthField {
	*** INSTANCE;
}

-keep class org.apache.commons.lang3.time.FormatCache {
	*** cDateTimeInstanceCache;
	*** cInstanceCache;
	org.apache.commons.lang3.time.FormatCache();
	*** createInstance(java.lang.String,java.util.TimeZone,java.util.Locale);
	*** getDateTimeInstance(java.lang.Integer,java.lang.Integer,java.util.TimeZone,java.util.Locale);
	*** getInstance(java.lang.String,java.util.TimeZone,java.util.Locale);
}

-keep class org.apache.commons.lang3.time.FormatCache$MultipartKey {
	*** hashCode;
	*** keys;
}

-keep class org.apache.commons.lang3.tuple.ImmutablePair {
	*** left;
	*** right;
}

-keep class org.apache.commons.lang3.tuple.Pair {
	org.apache.commons.lang3.tuple.Pair();
	*** compareTo(org.apache.commons.lang3.tuple.Pair);
	*** getKey();
	*** getLeft();
	*** getRight();
	*** getValue();
	*** of(java.lang.Object,java.lang.Object);
}

-keep class org.apache.commons.logging.Log {
	*** debug(java.lang.Object);
	*** debug(java.lang.Object,java.lang.Throwable);
	*** error(java.lang.Object);
	*** error(java.lang.Object,java.lang.Throwable);
	*** info(java.lang.Object);
	*** isDebugEnabled();
	*** isErrorEnabled();
	*** isInfoEnabled();
	*** isTraceEnabled();
	*** isWarnEnabled();
	*** trace(java.lang.Object);
	*** warn(java.lang.Object);
	*** warn(java.lang.Object,java.lang.Throwable);
}

-keep class org.apache.commons.logging.LogConfigurationException {
	*** cause;
	org.apache.commons.logging.LogConfigurationException(java.lang.String,java.lang.Throwable);
}

-keep class org.apache.commons.logging.LogFactory {
	*** class$java$lang$Thread;
	*** class$org$apache$commons$logging$LogFactory;
	*** diagnosticPrefix;
	*** diagnosticsStream;
	*** factories;
	*** nullClassLoaderFactory;
	*** thisClassLoader;
	org.apache.commons.logging.LogFactory();
	*** access$000(java.lang.String);
	*** cacheFactory(java.lang.ClassLoader,org.apache.commons.logging.LogFactory);
	*** class$(java.lang.String);
	*** createFactory(java.lang.String,java.lang.ClassLoader);
	*** createFactoryStore();
	*** directGetContextClassLoader();
	*** getCachedFactory(java.lang.ClassLoader);
	*** getClassLoader(java.lang.Class);
	*** getConfigurationFile(java.lang.ClassLoader,java.lang.String);
	*** getContextClassLoader();
	*** getContextClassLoaderInternal();
	*** getFactory();
	*** getInstance(java.lang.Class);
	*** getInstance(java.lang.String);
	*** getLog(java.lang.Class);
	*** getLog(java.lang.String);
	*** getProperties(java.net.URL);
	*** getResourceAsStream(java.lang.ClassLoader,java.lang.String);
	*** getResources(java.lang.ClassLoader,java.lang.String);
	*** getSystemProperty(java.lang.String,java.lang.String);
	*** implementsLogFactory(java.lang.Class);
	*** initDiagnostics();
	*** isDiagnosticsEnabled();
	*** logClassLoaderEnvironment(java.lang.Class);
	*** logDiagnostic(java.lang.String);
	*** logHierarchy(java.lang.String,java.lang.ClassLoader);
	*** logRawDiagnostic(java.lang.String);
	*** newFactory(java.lang.String,java.lang.ClassLoader,java.lang.ClassLoader);
	*** objectId(java.lang.Object);
	*** release();
	*** setAttribute(java.lang.String,java.lang.Object);
	*** trim(java.lang.String);
}

-keep class org.apache.commons.logging.LogFactory$2 {
	*** val$classLoader;
	*** val$factoryClass;
}

-keep class org.apache.commons.logging.LogFactory$3 {
	*** val$loader;
	*** val$name;
}

-keep class org.apache.commons.logging.LogFactory$4 {
	*** val$loader;
	*** val$name;
}

-keep class org.apache.commons.logging.LogFactory$6 {
	*** val$def;
	*** val$key;
}

-keep class org.apache.commons.logging.impl.Log4JLogger {
	*** FQCN;
	*** class$org$apache$commons$logging$impl$Log4JLogger;
	*** class$org$apache$log4j$Level;
	*** class$org$apache$log4j$Priority;
	*** logger;
	*** name;
	*** traceLevel;
	*** class$(java.lang.String);
	*** getLogger();
}

-keep class org.apache.commons.logging.impl.LogFactoryImpl {
	*** PKG_LEN;
	*** allowFlawedContext;
	*** allowFlawedDiscovery;
	*** allowFlawedHierarchy;
	*** attributes;
	*** class$java$lang$String;
	*** class$org$apache$commons$logging$Log;
	*** class$org$apache$commons$logging$LogFactory;
	*** class$org$apache$commons$logging$impl$LogFactoryImpl;
	*** classesToDiscover;
	*** diagnosticPrefix;
	*** instances;
	*** logClassName;
	*** logConstructor;
	*** logConstructorSignature;
	*** logMethod;
	*** logMethodSignature;
	*** useTCCL;
	*** access$000();
	*** class$(java.lang.String);
	*** createLogFromClass(java.lang.String,java.lang.String,boolean);
	*** discoverLogImplementation(java.lang.String);
	*** findUserSpecifiedLogClassName();
	*** getAttribute(java.lang.String);
	*** getBaseClassLoader();
	*** getBooleanConfiguration(java.lang.String,boolean);
	*** getClassLoader(java.lang.Class);
	*** getConfigurationValue(java.lang.String);
	*** getContextClassLoaderInternal();
	*** getInstance(java.lang.String);
	*** getLowestClassLoader(java.lang.ClassLoader,java.lang.ClassLoader);
	*** getParentClassLoader(java.lang.ClassLoader);
	*** getSystemProperty(java.lang.String,java.lang.String);
	*** handleFlawedDiscovery(java.lang.String,java.lang.ClassLoader,java.lang.Throwable);
	*** handleFlawedHierarchy(java.lang.ClassLoader,java.lang.Class);
	*** informUponSimilarName(java.lang.StringBuffer,java.lang.String,java.lang.String);
	*** initConfiguration();
	*** initDiagnostics();
	*** isDiagnosticsEnabled();
	*** isLogLibraryAvailable(java.lang.String,java.lang.String);
	*** logDiagnostic(java.lang.String);
	*** newInstance(java.lang.String);
}

-keep class org.apache.commons.logging.impl.LogFactoryImpl$2 {
	*** val$def;
	*** val$key;
}

-keep class org.apache.commons.logging.impl.WeakHashtable {
	*** changeCount;
	*** queue;
	*** purge();
	*** purgeOne();
	*** put(java.lang.Object,java.lang.Object);
}

-keep class org.apache.commons.logging.impl.WeakHashtable$Referenced {
	*** hashCode;
	*** reference;
	org.apache.commons.logging.impl.WeakHashtable$Referenced(java.lang.Object);
	org.apache.commons.logging.impl.WeakHashtable$Referenced(java.lang.Object,java.lang.ref.ReferenceQueue);
	*** access$100(org.apache.commons.logging.impl.WeakHashtable$Referenced);
	*** getValue();
	*** hashCode();
}

-keep class org.apache.commons.logging.impl.WeakHashtable$WeakKey {
	*** referenced;
	org.apache.commons.logging.impl.WeakHashtable$WeakKey(java.lang.Object,java.lang.ref.ReferenceQueue,org.apache.commons.logging.impl.WeakHashtable$Referenced);
	*** access$400(org.apache.commons.logging.impl.WeakHashtable$WeakKey);
	*** getReferenced();
}

-keep class org.apache.http.ConnectionReuseStrategy {
	*** keepAlive(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.Consts {
	*** ASCII;
	*** ISO_8859_1;
	*** UTF_8;
}

-keep class org.apache.http.FormattedHeader {
	*** getBuffer();
	*** getValuePos();
}

-keep class org.apache.http.Header {
	*** getElements();
	*** getName();
	*** getValue();
}

-keep class org.apache.http.HeaderElement {
	*** getName();
	*** getParameterByName(java.lang.String);
	*** getParameters();
	*** getValue();
}

-keep class org.apache.http.HeaderElementIterator {
	*** hasNext();
	*** nextElement();
}

-keep class org.apache.http.HeaderIterator {
	*** hasNext();
	*** nextHeader();
}

-keep class org.apache.http.HttpClientConnection {
	*** flush();
	*** isResponseAvailable(int);
	*** receiveResponseEntity(org.apache.http.HttpResponse);
	*** receiveResponseHeader();
	*** sendRequestEntity(org.apache.http.HttpEntityEnclosingRequest);
	*** sendRequestHeader(org.apache.http.HttpRequest);
}

-keep class org.apache.http.HttpConnection {
	*** close();
	*** getMetrics();
	*** getSocketTimeout();
	*** isOpen();
	*** isStale();
	*** setSocketTimeout(int);
	*** shutdown();
}

-keep class org.apache.http.HttpEntity {
	*** consumeContent();
	*** getContent();
	*** getContentEncoding();
	*** getContentLength();
	*** getContentType();
	*** isChunked();
	*** isRepeatable();
	*** isStreaming();
	*** writeTo(java.io.OutputStream);
}

-keep class org.apache.http.HttpEntityEnclosingRequest {
	*** expectContinue();
	*** getEntity();
	*** setEntity(org.apache.http.HttpEntity);
}

-keep class org.apache.http.HttpException {
	org.apache.http.HttpException();
	org.apache.http.HttpException(java.lang.String);
	org.apache.http.HttpException(java.lang.String,java.lang.Throwable);
}

-keep class org.apache.http.HttpHost {
	*** hostname;
	*** lcHostname;
	*** port;
	*** schemeName;
	org.apache.http.HttpHost(java.lang.String,int,java.lang.String);
	*** equals(java.lang.Object);
	*** getHostName();
	*** getPort();
	*** getSchemeName();
	*** toHostString();
	*** toURI();
}

-keep class org.apache.http.HttpInetConnection {
	*** getLocalAddress();
	*** getLocalPort();
	*** getRemoteAddress();
	*** getRemotePort();
}

-keep class org.apache.http.HttpMessage {
	*** addHeader(java.lang.String,java.lang.String);
	*** addHeader(org.apache.http.Header);
	*** containsHeader(java.lang.String);
	*** getAllHeaders();
	*** getFirstHeader(java.lang.String);
	*** getHeaders(java.lang.String);
	*** getLastHeader(java.lang.String);
	*** getParams();
	*** getProtocolVersion();
	*** headerIterator();
	*** headerIterator(java.lang.String);
	*** removeHeaders(java.lang.String);
	*** setHeader(java.lang.String,java.lang.String);
	*** setHeaders(org.apache.http.Header[]);
	*** setParams(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.HttpRequest {
	*** getRequestLine();
}

-keep class org.apache.http.HttpRequestInterceptor {
	*** process(org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.HttpResponse {
	*** getEntity();
	*** getStatusLine();
	*** setEntity(org.apache.http.HttpEntity);
}

-keep class org.apache.http.HttpResponseFactory {
	*** newHttpResponse(org.apache.http.StatusLine,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.HttpResponseInterceptor {
	*** process(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.HttpVersion {
	*** HTTP_0_9;
	*** HTTP_1_0;
	*** HTTP_1_1;
}

-keep class org.apache.http.MalformedChunkCodingException {
	org.apache.http.MalformedChunkCodingException(java.lang.String);
}

-keep class org.apache.http.NameValuePair {
	*** getName();
	*** getValue();
}

-keep class org.apache.http.ProtocolException {
	org.apache.http.ProtocolException();
	org.apache.http.ProtocolException(java.lang.String);
	org.apache.http.ProtocolException(java.lang.String,java.lang.Throwable);
}

-keep class org.apache.http.ProtocolVersion {
	*** major;
	*** minor;
	*** protocol;
	org.apache.http.ProtocolVersion(java.lang.String,int,int);
	*** compareToVersion(org.apache.http.ProtocolVersion);
	*** forVersion(int,int);
	*** getMajor();
	*** getMinor();
	*** getProtocol();
	*** isComparable(org.apache.http.ProtocolVersion);
	*** lessEquals(org.apache.http.ProtocolVersion);
}

-keep class org.apache.http.ReasonPhraseCatalog {
	*** getReason(int,java.util.Locale);
}

-keep class org.apache.http.RequestLine {
	*** getMethod();
	*** getProtocolVersion();
	*** getUri();
}

-keep class org.apache.http.StatusLine {
	*** getProtocolVersion();
	*** getReasonPhrase();
	*** getStatusCode();
}

-keep class org.apache.http.TokenIterator {
	*** hasNext();
	*** nextToken();
}

-keep class org.apache.http.auth.AuthOption {
	*** getAuthScheme();
	*** getCredentials();
}

-keep class org.apache.http.auth.AuthProtocolState {
	*** $VALUES;
	*** CHALLENGED;
	*** FAILURE;
	*** HANDSHAKE;
	*** SUCCESS;
	*** UNCHALLENGED;
	*** values();
}

-keep class org.apache.http.auth.AuthScheme {
	*** authenticate(org.apache.http.auth.Credentials,org.apache.http.HttpRequest);
	*** getRealm();
	*** getSchemeName();
	*** isComplete();
	*** isConnectionBased();
	*** processChallenge(org.apache.http.Header);
}

-keep class org.apache.http.auth.AuthSchemeFactory {
	*** newInstance(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.auth.AuthSchemeRegistry {
	*** registeredSchemes;
	*** getAuthScheme(java.lang.String,org.apache.http.params.HttpParams);
	*** register(java.lang.String,org.apache.http.auth.AuthSchemeFactory);
}

-keep class org.apache.http.auth.AuthScope {
	*** ANY_REALM;
	*** match(org.apache.http.auth.AuthScope);
}

-keep class org.apache.http.auth.AuthState {
	*** authOptions;
	*** authScheme;
	*** authScope;
	*** credentials;
	*** state;
	*** getAuthOptions();
	*** getAuthScheme();
	*** getCredentials();
	*** getState();
	*** reset();
	*** setState(org.apache.http.auth.AuthProtocolState);
	*** update(java.util.Queue);
	*** update(org.apache.http.auth.AuthScheme,org.apache.http.auth.Credentials);
}

-keep class org.apache.http.auth.ContextAwareAuthScheme {
	*** authenticate(org.apache.http.auth.Credentials,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.auth.Credentials {
	*** getUserPrincipal();
}

-keep class org.apache.http.client.AuthCache {
	*** get(org.apache.http.HttpHost);
	*** put(org.apache.http.HttpHost,org.apache.http.auth.AuthScheme);
	*** remove(org.apache.http.HttpHost);
}

-keep class org.apache.http.client.AuthenticationHandler {
	*** getChallenges(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isAuthenticationRequested(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** selectScheme(java.util.Map,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.AuthenticationStrategy {
	*** authFailed(org.apache.http.HttpHost,org.apache.http.auth.AuthScheme,org.apache.http.protocol.HttpContext);
	*** authSucceeded(org.apache.http.HttpHost,org.apache.http.auth.AuthScheme,org.apache.http.protocol.HttpContext);
	*** getChallenges(org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isAuthenticationRequested(org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** select(java.util.Map,org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.BackoffManager {
	*** backOff(org.apache.http.conn.routing.HttpRoute);
	*** probe(org.apache.http.conn.routing.HttpRoute);
}

-keep class org.apache.http.client.ConnectionBackoffStrategy {
	*** shouldBackoff(java.lang.Throwable);
	*** shouldBackoff(org.apache.http.HttpResponse);
}

-keep class org.apache.http.client.CookieStore {
	*** addCookie(org.apache.http.cookie.Cookie);
	*** getCookies();
}

-keep class org.apache.http.client.CredentialsProvider {
	*** getCredentials(org.apache.http.auth.AuthScope);
}

-keep class org.apache.http.client.HttpClient {
	*** execute(org.apache.http.client.methods.HttpUriRequest);
	*** getConnectionManager();
	*** getParams();
}

-keep class org.apache.http.client.HttpRequestRetryHandler {
	*** retryRequest(java.io.IOException,int,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.RedirectException {
	org.apache.http.client.RedirectException();
	org.apache.http.client.RedirectException(java.lang.String);
	org.apache.http.client.RedirectException(java.lang.String,java.lang.Throwable);
}

-keep class org.apache.http.client.RedirectHandler {
	*** getLocationURI(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isRedirectRequested(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.RedirectStrategy {
	*** getRedirect(org.apache.http.HttpRequest,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isRedirected(org.apache.http.HttpRequest,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.RequestDirector {
	*** execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.ResponseHandler {
	*** handleResponse(org.apache.http.HttpResponse);
}

-keep class org.apache.http.client.UserTokenHandler {
	*** getUserToken(org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.entity.UrlEncodedFormEntity {
	org.apache.http.client.entity.UrlEncodedFormEntity(java.lang.Iterable,java.nio.charset.Charset);
}

-keep class org.apache.http.client.methods.AbortableHttpRequest {
	*** setConnectionRequest(org.apache.http.conn.ClientConnectionRequest);
	*** setReleaseTrigger(org.apache.http.conn.ConnectionReleaseTrigger);
}

-keep class org.apache.http.client.methods.HttpEntityEnclosingRequestBase {
	*** entity;
	org.apache.http.client.methods.HttpEntityEnclosingRequestBase();
	*** clone();
	*** expectContinue();
	*** getEntity();
	*** setEntity(org.apache.http.HttpEntity);
}

-keep class org.apache.http.client.methods.HttpPost {
	org.apache.http.client.methods.HttpPost();
	org.apache.http.client.methods.HttpPost(java.lang.String);
	org.apache.http.client.methods.HttpPost(java.net.URI);
	*** getMethod();
}

-keep class org.apache.http.client.methods.HttpPost$$EnhancerByMockitoWithCGLIB$$f2a749df {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$abort$12$Method;
	*** CGLIB$abort$12$Proxy;
	*** CGLIB$addHeader$19$Method;
	*** CGLIB$addHeader$19$Proxy;
	*** CGLIB$addHeader$20$Method;
	*** CGLIB$addHeader$20$Proxy;
	*** CGLIB$clone$1$Method;
	*** CGLIB$clone$1$Proxy;
	*** CGLIB$containsHeader$16$Method;
	*** CGLIB$containsHeader$16$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$33$Method;
	*** CGLIB$equals$33$Proxy;
	*** CGLIB$expectContinue$2$Method;
	*** CGLIB$expectContinue$2$Proxy;
	*** CGLIB$finalize$32$Method;
	*** CGLIB$finalize$32$Proxy;
	*** CGLIB$getAllHeaders$30$Method;
	*** CGLIB$getAllHeaders$30$Proxy;
	*** CGLIB$getEntity$3$Method;
	*** CGLIB$getEntity$3$Proxy;
	*** CGLIB$getFirstHeader$17$Method;
	*** CGLIB$getFirstHeader$17$Proxy;
	*** CGLIB$getHeaders$31$Method;
	*** CGLIB$getHeaders$31$Proxy;
	*** CGLIB$getLastHeader$18$Method;
	*** CGLIB$getLastHeader$18$Proxy;
	*** CGLIB$getMethod$0$Method;
	*** CGLIB$getMethod$0$Proxy;
	*** CGLIB$getParams$29$Method;
	*** CGLIB$getParams$29$Proxy;
	*** CGLIB$getProtocolVersion$11$Method;
	*** CGLIB$getProtocolVersion$11$Proxy;
	*** CGLIB$getRequestLine$9$Method;
	*** CGLIB$getRequestLine$9$Proxy;
	*** CGLIB$getURI$8$Method;
	*** CGLIB$getURI$8$Proxy;
	*** CGLIB$hashCode$34$Method;
	*** CGLIB$hashCode$34$Proxy;
	*** CGLIB$headerIterator$24$Method;
	*** CGLIB$headerIterator$24$Proxy;
	*** CGLIB$headerIterator$25$Method;
	*** CGLIB$headerIterator$25$Proxy;
	*** CGLIB$isAborted$10$Method;
	*** CGLIB$isAborted$10$Proxy;
	*** CGLIB$releaseConnection$13$Method;
	*** CGLIB$releaseConnection$13$Proxy;
	*** CGLIB$removeHeader$22$Method;
	*** CGLIB$removeHeader$22$Proxy;
	*** CGLIB$removeHeaders$23$Method;
	*** CGLIB$removeHeaders$23$Proxy;
	*** CGLIB$reset$6$Method;
	*** CGLIB$reset$6$Proxy;
	*** CGLIB$setConnectionRequest$14$Method;
	*** CGLIB$setConnectionRequest$14$Proxy;
	*** CGLIB$setEntity$4$Method;
	*** CGLIB$setEntity$4$Proxy;
	*** CGLIB$setHeader$27$Method;
	*** CGLIB$setHeader$27$Proxy;
	*** CGLIB$setHeader$28$Method;
	*** CGLIB$setHeader$28$Proxy;
	*** CGLIB$setHeaders$21$Method;
	*** CGLIB$setHeaders$21$Proxy;
	*** CGLIB$setParams$26$Method;
	*** CGLIB$setParams$26$Proxy;
	*** CGLIB$setReleaseTrigger$15$Method;
	*** CGLIB$setReleaseTrigger$15$Proxy;
	*** CGLIB$setURI$7$Method;
	*** CGLIB$setURI$7$Proxy;
	*** CGLIB$toString$5$Method;
	*** CGLIB$toString$5$Proxy;
	org.apache.http.client.methods.HttpPost$$EnhancerByMockitoWithCGLIB$$f2a749df();
	org.apache.http.client.methods.HttpPost$$EnhancerByMockitoWithCGLIB$$f2a749df(java.lang.String);
	org.apache.http.client.methods.HttpPost$$EnhancerByMockitoWithCGLIB$$f2a749df(java.net.URI);
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_STATIC_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK9();
	*** CGLIB$abort$12();
	*** CGLIB$addHeader$19(org.apache.http.Header);
	*** CGLIB$addHeader$20(java.lang.String,java.lang.String);
	*** CGLIB$clone$1();
	*** CGLIB$containsHeader$16(java.lang.String);
	*** CGLIB$equals$33(java.lang.Object);
	*** CGLIB$expectContinue$2();
	*** CGLIB$finalize$32();
	*** CGLIB$findMethodProxy(org.mockito.cglib.core.Signature);
	*** CGLIB$getAllHeaders$30();
	*** CGLIB$getEntity$3();
	*** CGLIB$getFirstHeader$17(java.lang.String);
	*** CGLIB$getHeaders$31(java.lang.String);
	*** CGLIB$getLastHeader$18(java.lang.String);
	*** CGLIB$getMethod$0();
	*** CGLIB$getParams$29();
	*** CGLIB$getProtocolVersion$11();
	*** CGLIB$getRequestLine$9();
	*** CGLIB$getURI$8();
	*** CGLIB$hashCode$34();
	*** CGLIB$headerIterator$24(java.lang.String);
	*** CGLIB$headerIterator$25();
	*** CGLIB$isAborted$10();
	*** CGLIB$releaseConnection$13();
	*** CGLIB$removeHeader$22(org.apache.http.Header);
	*** CGLIB$removeHeaders$23(java.lang.String);
	*** CGLIB$reset$6();
	*** CGLIB$setConnectionRequest$14(org.apache.http.conn.ClientConnectionRequest);
	*** CGLIB$setEntity$4(org.apache.http.HttpEntity);
	*** CGLIB$setHeader$27(org.apache.http.Header);
	*** CGLIB$setHeader$28(java.lang.String,java.lang.String);
	*** CGLIB$setHeaders$21(org.apache.http.Header[]);
	*** CGLIB$setParams$26(org.apache.http.params.HttpParams);
	*** CGLIB$setReleaseTrigger$15(org.apache.http.conn.ConnectionReleaseTrigger);
	*** CGLIB$setURI$7(java.net.URI);
	*** CGLIB$toString$5();
	*** abort();
	*** addHeader(java.lang.String,java.lang.String);
	*** addHeader(org.apache.http.Header);
	*** clone();
	*** containsHeader(java.lang.String);
	*** equals(java.lang.Object);
	*** expectContinue();
	*** getAllHeaders();
	*** getCallback(int);
	*** getCallbacks();
	*** getEntity();
	*** getFirstHeader(java.lang.String);
	*** getHeaders(java.lang.String);
	*** getLastHeader(java.lang.String);
	*** getMethod();
	*** getParams();
	*** getProtocolVersion();
	*** getRequestLine();
	*** getURI();
	*** hashCode();
	*** headerIterator();
	*** headerIterator(java.lang.String);
	*** isAborted();
	*** newInstance(java.lang.Class[],java.lang.Object[],org.mockito.cglib.proxy.Callback[]);
	*** newInstance(org.mockito.cglib.proxy.Callback);
	*** newInstance(org.mockito.cglib.proxy.Callback[]);
	*** releaseConnection();
	*** removeHeader(org.apache.http.Header);
	*** removeHeaders(java.lang.String);
	*** reset();
	*** setCallback(int,org.mockito.cglib.proxy.Callback);
	*** setCallbacks(org.mockito.cglib.proxy.Callback[]);
	*** setConnectionRequest(org.apache.http.conn.ClientConnectionRequest);
	*** setEntity(org.apache.http.HttpEntity);
	*** setHeader(java.lang.String,java.lang.String);
	*** setHeader(org.apache.http.Header);
	*** setHeaders(org.apache.http.Header[]);
	*** setParams(org.apache.http.params.HttpParams);
	*** setReleaseTrigger(org.apache.http.conn.ConnectionReleaseTrigger);
	*** setURI(java.net.URI);
	*** toString();
}

-keep class org.apache.http.client.methods.HttpRequestBase {
	*** abortLock;
	*** aborted;
	*** connRequest;
	*** releaseTrigger;
	*** uri;
	org.apache.http.client.methods.HttpRequestBase();
	*** abort();
	*** cleanup();
	*** clone();
	*** getMethod();
	*** getProtocolVersion();
	*** getRequestLine();
	*** getURI();
	*** isAborted();
	*** releaseConnection();
	*** reset();
	*** setConnectionRequest(org.apache.http.conn.ClientConnectionRequest);
	*** setReleaseTrigger(org.apache.http.conn.ConnectionReleaseTrigger);
	*** setURI(java.net.URI);
	*** toString();
}

-keep class org.apache.http.client.methods.HttpUriRequest {
	*** getMethod();
	*** getURI();
	*** isAborted();
}

-keep class org.apache.http.client.params.HttpClientParams {
	*** getConnectionManagerTimeout(org.apache.http.params.HttpParams);
	*** getCookiePolicy(org.apache.http.params.HttpParams);
	*** isAuthenticating(org.apache.http.params.HttpParams);
	*** isRedirecting(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.client.protocol.RequestAddCookies {
	*** log;
}

-keep class org.apache.http.client.protocol.RequestAuthCache {
	*** log;
	*** doPreemptiveAuth(org.apache.http.HttpHost,org.apache.http.auth.AuthScheme,org.apache.http.auth.AuthState,org.apache.http.client.CredentialsProvider);
}

-keep class org.apache.http.client.protocol.RequestAuthenticationBase {
	*** log;
	org.apache.http.client.protocol.RequestAuthenticationBase();
	*** authenticate(org.apache.http.auth.AuthScheme,org.apache.http.auth.Credentials,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
	*** ensureAuthScheme(org.apache.http.auth.AuthScheme);
	*** process(org.apache.http.auth.AuthState,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.client.protocol.RequestAuthenticationBase$1 {
	*** $SwitchMap$org$apache$http$auth$AuthProtocolState;
}

-keep class org.apache.http.client.protocol.RequestClientConnControl {
	*** log;
}

-keep class org.apache.http.client.protocol.ResponseProcessCookies {
	*** log;
	*** processCookies(org.apache.http.HeaderIterator,org.apache.http.cookie.CookieSpec,org.apache.http.cookie.CookieOrigin,org.apache.http.client.CookieStore);
}

-keep class org.apache.http.client.utils.CloneUtils {
	*** clone(java.lang.Object);
}

-keep class org.apache.http.client.utils.URIBuilder {
	*** encodedAuthority;
	*** encodedFragment;
	*** encodedPath;
	*** encodedQuery;
	*** encodedSchemeSpecificPart;
	*** encodedUserInfo;
	*** fragment;
	*** host;
	*** path;
	*** port;
	*** queryParams;
	*** scheme;
	*** userInfo;
	*** build();
	*** buildString();
	*** digestURI(java.net.URI);
	*** encodeFragment(java.lang.String);
	*** encodePath(java.lang.String);
	*** encodeQuery(java.util.List);
	*** encodeUserInfo(java.lang.String);
	*** getPath();
	*** normalizePath(java.lang.String);
	*** parseQuery(java.lang.String,java.nio.charset.Charset);
	*** setFragment(java.lang.String);
	*** setHost(java.lang.String);
	*** setPath(java.lang.String);
	*** setPort(int);
	*** setScheme(java.lang.String);
	*** setUserInfo(java.lang.String);
}

-keep class org.apache.http.client.utils.URIUtils {
	*** extractHost(java.net.URI);
	*** normalizeSyntax(java.net.URI);
	*** resolve(java.net.URI,java.net.URI);
	*** resolveReferenceStartingWithQueryString(java.net.URI,java.net.URI);
	*** rewriteURI(java.net.URI);
	*** rewriteURI(java.net.URI,org.apache.http.HttpHost,boolean);
}

-keep class org.apache.http.client.utils.URLEncodedUtils {
	*** DELIM;
	*** FRAGMENT;
	*** PATHSAFE;
	*** PUNCT;
	*** RESERVED;
	*** UNRESERVED;
	*** URLENCODER;
	*** USERINFO;
	*** decodeFormFields(java.lang.String,java.lang.String);
	*** decodeFormFields(java.lang.String,java.nio.charset.Charset);
	*** encFragment(java.lang.String,java.nio.charset.Charset);
	*** encPath(java.lang.String,java.nio.charset.Charset);
	*** encUserInfo(java.lang.String,java.nio.charset.Charset);
	*** encodeFormFields(java.lang.String,java.lang.String);
	*** encodeFormFields(java.lang.String,java.nio.charset.Charset);
	*** format(java.lang.Iterable,java.nio.charset.Charset);
	*** format(java.util.List,java.lang.String);
	*** parse(java.lang.String,java.nio.charset.Charset);
	*** parse(java.util.List,java.util.Scanner,java.lang.String);
	*** urldecode(java.lang.String,java.nio.charset.Charset,boolean);
	*** urlencode(java.lang.String,java.nio.charset.Charset,java.util.BitSet,boolean);
}

-keep class org.apache.http.conn.BasicManagedEntity {
	*** attemptReuse;
	*** managedConn;
	*** ensureConsumed();
	*** releaseManagedConnection();
}

-keep class org.apache.http.conn.ClientConnectionManager {
	*** getSchemeRegistry();
	*** releaseConnection(org.apache.http.conn.ManagedClientConnection,long,java.util.concurrent.TimeUnit);
	*** requestConnection(org.apache.http.conn.routing.HttpRoute,java.lang.Object);
	*** shutdown();
}

-keep class org.apache.http.conn.ClientConnectionManagerFactory {
	*** newInstance(org.apache.http.params.HttpParams,org.apache.http.conn.scheme.SchemeRegistry);
}

-keep class org.apache.http.conn.ClientConnectionOperator {
	*** createConnection();
	*** openConnection(org.apache.http.conn.OperatedClientConnection,org.apache.http.HttpHost,java.net.InetAddress,org.apache.http.protocol.HttpContext,org.apache.http.params.HttpParams);
	*** updateSecureConnection(org.apache.http.conn.OperatedClientConnection,org.apache.http.HttpHost,org.apache.http.protocol.HttpContext,org.apache.http.params.HttpParams);
}

-keep class org.apache.http.conn.ClientConnectionRequest {
	*** abortRequest();
	*** getConnection(long,java.util.concurrent.TimeUnit);
}

-keep class org.apache.http.conn.ConnectionKeepAliveStrategy {
	*** getKeepAliveDuration(org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.conn.ConnectionReleaseTrigger {
	*** abortConnection();
	*** releaseConnection();
}

-keep class org.apache.http.conn.DnsResolver {
	*** resolve(java.lang.String);
}

-keep class org.apache.http.conn.EofSensorInputStream {
	*** eofWatcher;
	*** selfClosed;
	*** wrappedStream;
	*** checkAbort();
	*** checkClose();
	*** checkEOF(int);
	*** close();
	*** isReadAllowed();
}

-keep class org.apache.http.conn.EofSensorWatcher {
	*** eofDetected(java.io.InputStream);
	*** streamAbort(java.io.InputStream);
	*** streamClosed(java.io.InputStream);
}

-keep class org.apache.http.conn.HttpHostConnectException {
	*** host;
}

-keep class org.apache.http.conn.HttpInetSocketAddress {
	*** httphost;
	*** getHttpHost();
}

-keep class org.apache.http.conn.HttpRoutedConnection {
	*** getRoute();
	*** getSSLSession();
	*** isSecure();
}

-keep class org.apache.http.conn.ManagedClientConnection {
	*** getRoute();
	*** layerProtocol(org.apache.http.protocol.HttpContext,org.apache.http.params.HttpParams);
	*** markReusable();
	*** open(org.apache.http.conn.routing.HttpRoute,org.apache.http.protocol.HttpContext,org.apache.http.params.HttpParams);
	*** setIdleDuration(long,java.util.concurrent.TimeUnit);
	*** setState(java.lang.Object);
	*** tunnelProxy(org.apache.http.HttpHost,boolean,org.apache.http.params.HttpParams);
	*** tunnelTarget(boolean,org.apache.http.params.HttpParams);
	*** unmarkReusable();
}

-keep class org.apache.http.conn.OperatedClientConnection {
	*** getSocket();
	*** isSecure();
	*** openCompleted(boolean,org.apache.http.params.HttpParams);
	*** opening(java.net.Socket,org.apache.http.HttpHost);
	*** update(java.net.Socket,org.apache.http.HttpHost,boolean,org.apache.http.params.HttpParams);
}

-keep class org.apache.http.conn.params.ConnManagerParams {
	*** DEFAULT_CONN_PER_ROUTE;
	*** setMaxConnectionsPerRoute(org.apache.http.params.HttpParams,org.apache.http.conn.params.ConnPerRoute);
	*** setMaxTotalConnections(org.apache.http.params.HttpParams,int);
	*** setTimeout(org.apache.http.params.HttpParams,long);
}

-keep class org.apache.http.conn.params.ConnRouteParams {
	*** NO_HOST;
	*** NO_ROUTE;
	*** getDefaultProxy(org.apache.http.params.HttpParams);
	*** getForcedRoute(org.apache.http.params.HttpParams);
	*** getLocalAddress(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.conn.routing.BasicRouteDirector {
	*** directStep(org.apache.http.conn.routing.RouteInfo,org.apache.http.conn.routing.RouteInfo);
	*** firstStep(org.apache.http.conn.routing.RouteInfo);
	*** proxiedStep(org.apache.http.conn.routing.RouteInfo,org.apache.http.conn.routing.RouteInfo);
}

-keep class org.apache.http.conn.routing.HttpRoute {
	*** EMPTY_HTTP_HOST_ARRAY;
	*** layered;
	*** localAddress;
	*** proxyChain;
	*** secure;
	*** targetHost;
	*** tunnelled;
	org.apache.http.conn.routing.HttpRoute(java.net.InetAddress,org.apache.http.HttpHost,org.apache.http.HttpHost[],boolean,org.apache.http.conn.routing.RouteInfo$TunnelType,org.apache.http.conn.routing.RouteInfo$LayerType);
	*** equals(java.lang.Object);
	*** getHopCount();
	*** getHopTarget(int);
	*** getLocalAddress();
	*** getProxyHost();
	*** getTargetHost();
	*** isTunnelled();
	*** toChain(org.apache.http.HttpHost);
	*** toChain(org.apache.http.HttpHost[]);
}

-keep class org.apache.http.conn.routing.HttpRouteDirector {
	*** nextStep(org.apache.http.conn.routing.RouteInfo,org.apache.http.conn.routing.RouteInfo);
}

-keep class org.apache.http.conn.routing.HttpRoutePlanner {
	*** determineRoute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.conn.routing.RouteInfo {
	*** getHopCount();
	*** getHopTarget(int);
	*** getLocalAddress();
	*** getTargetHost();
	*** isLayered();
	*** isSecure();
	*** isTunnelled();
}

-keep class org.apache.http.conn.routing.RouteInfo$LayerType {
	*** $VALUES;
	*** LAYERED;
	*** PLAIN;
}

-keep class org.apache.http.conn.routing.RouteInfo$TunnelType {
	*** $VALUES;
	*** PLAIN;
	*** TUNNELLED;
}

-keep class org.apache.http.conn.routing.RouteTracker {
	*** connected;
	*** layered;
	*** localAddress;
	*** proxyChain;
	*** secure;
	*** targetHost;
	*** tunnelled;
	org.apache.http.conn.routing.RouteTracker(org.apache.http.HttpHost,java.net.InetAddress);
	*** connectProxy(org.apache.http.HttpHost,boolean);
	*** connectTarget(boolean);
	*** getHopCount();
	*** getTargetHost();
	*** isConnected();
	*** isLayered();
	*** isTunnelled();
	*** layerProtocol(boolean);
	*** reset();
	*** toRoute();
	*** tunnelProxy(org.apache.http.HttpHost,boolean);
	*** tunnelTarget(boolean);
}

-keep class org.apache.http.conn.scheme.HostNameResolver {
	*** resolve(java.lang.String);
}

-keep class org.apache.http.conn.scheme.PlainSocketFactory {
	*** nameResolver;
	*** connectSocket(java.net.Socket,java.net.InetSocketAddress,java.net.InetSocketAddress,org.apache.http.params.HttpParams);
	*** createSocket();
	*** getSocketFactory();
}

-keep class org.apache.http.conn.scheme.Scheme {
	*** defaultPort;
	*** layered;
	*** name;
	*** socketFactory;
	*** stringRep;
	*** getDefaultPort();
	*** getName();
	*** getSchemeSocketFactory();
	*** isLayered();
	*** resolvePort(int);
}

-keep class org.apache.http.conn.scheme.SchemeLayeredSocketFactory {
	*** createLayeredSocket(java.net.Socket,java.lang.String,int,org.apache.http.params.HttpParams);
}

-keep class org.apache.http.conn.scheme.SchemeRegistry {
	*** registeredSchemes;
	*** get(java.lang.String);
	*** getScheme(java.lang.String);
	*** getScheme(org.apache.http.HttpHost);
	*** register(org.apache.http.conn.scheme.Scheme);
}

-keep class org.apache.http.conn.scheme.SchemeSocketFactory {
	*** connectSocket(java.net.Socket,java.net.InetSocketAddress,java.net.InetSocketAddress,org.apache.http.params.HttpParams);
	*** createSocket(org.apache.http.params.HttpParams);
	*** isSecure(java.net.Socket);
}

-keep class org.apache.http.conn.scheme.SchemeSocketFactoryAdaptor {
	*** getFactory();
}

-keep class org.apache.http.conn.ssl.AbstractVerifier {
	*** BAD_COUNTRY_2LDS;
	org.apache.http.conn.ssl.AbstractVerifier();
	*** acceptableCountryWildcard(java.lang.String);
	*** countDots(java.lang.String);
	*** getCNs(java.security.cert.X509Certificate);
	*** getSubjectAlts(java.security.cert.X509Certificate,java.lang.String);
	*** isIPAddress(java.lang.String);
	*** verify(java.lang.String,java.lang.String[],java.lang.String[],boolean);
	*** verify(java.lang.String,java.security.cert.X509Certificate);
}

-keep class org.apache.http.conn.ssl.SSLSocketFactory {
	*** ALLOW_ALL_HOSTNAME_VERIFIER;
	*** BROWSER_COMPATIBLE_HOSTNAME_VERIFIER;
	*** STRICT_HOSTNAME_VERIFIER;
	*** hostnameVerifier;
	*** nameResolver;
	*** socketfactory;
	org.apache.http.conn.ssl.SSLSocketFactory(java.lang.String,java.security.KeyStore,java.lang.String,java.security.KeyStore,java.security.SecureRandom,org.apache.http.conn.ssl.TrustStrategy,org.apache.http.conn.ssl.X509HostnameVerifier);
	org.apache.http.conn.ssl.SSLSocketFactory(javax.net.ssl.SSLContext,org.apache.http.conn.scheme.HostNameResolver);
	org.apache.http.conn.ssl.SSLSocketFactory(javax.net.ssl.SSLContext,org.apache.http.conn.ssl.X509HostnameVerifier);
	org.apache.http.conn.ssl.SSLSocketFactory(javax.net.ssl.SSLSocketFactory,org.apache.http.conn.ssl.X509HostnameVerifier);
	*** connectSocket(java.net.Socket,java.net.InetSocketAddress,java.net.InetSocketAddress,org.apache.http.params.HttpParams);
	*** createLayeredSocket(java.net.Socket,java.lang.String,int,boolean);
	*** createSSLContext(java.lang.String,java.security.KeyStore,java.lang.String,java.security.KeyStore,java.security.SecureRandom,org.apache.http.conn.ssl.TrustStrategy);
	*** getSocketFactory();
	*** getSystemSocketFactory();
	*** prepareSocket(javax.net.ssl.SSLSocket);
}

-keep class org.apache.http.conn.ssl.X509HostnameVerifier {
	*** verify(java.lang.String,java.lang.String[],java.lang.String[]);
	*** verify(java.lang.String,javax.net.ssl.SSLSocket);
}

-keep class org.apache.http.conn.util.InetAddressUtils {
	*** IPV4_PATTERN;
	*** IPV6_HEX_COMPRESSED_PATTERN;
	*** IPV6_STD_PATTERN;
	*** isIPv4Address(java.lang.String);
	*** isIPv6Address(java.lang.String);
	*** isIPv6HexCompressedAddress(java.lang.String);
	*** isIPv6StdAddress(java.lang.String);
}

-keep class org.apache.http.cookie.ClientCookie {
	*** containsAttribute(java.lang.String);
	*** getAttribute(java.lang.String);
}

-keep class org.apache.http.cookie.Cookie {
	*** getDomain();
	*** getName();
	*** getPath();
	*** getPorts();
	*** getValue();
	*** getVersion();
	*** isExpired(java.util.Date);
	*** isSecure();
}

-keep class org.apache.http.cookie.CookieAttributeHandler {
	*** match(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
	*** parse(org.apache.http.cookie.SetCookie,java.lang.String);
	*** validate(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
}

-keep class org.apache.http.cookie.CookieIdentityComparator {
	*** compare(org.apache.http.cookie.Cookie,org.apache.http.cookie.Cookie);
}

-keep class org.apache.http.cookie.CookieOrigin {
	*** host;
	*** path;
	*** port;
	*** secure;
	*** getHost();
	*** getPath();
	*** getPort();
	*** isSecure();
}

-keep class org.apache.http.cookie.CookiePathComparator {
	*** compare(org.apache.http.cookie.Cookie,org.apache.http.cookie.Cookie);
	*** normalizePath(org.apache.http.cookie.Cookie);
}

-keep class org.apache.http.cookie.CookieSpec {
	*** formatCookies(java.util.List);
	*** getVersion();
	*** getVersionHeader();
	*** match(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
	*** parse(org.apache.http.Header,org.apache.http.cookie.CookieOrigin);
	*** validate(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
}

-keep class org.apache.http.cookie.CookieSpecFactory {
	*** newInstance(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.cookie.CookieSpecRegistry {
	*** registeredSpecs;
	*** getCookieSpec(java.lang.String,org.apache.http.params.HttpParams);
	*** register(java.lang.String,org.apache.http.cookie.CookieSpecFactory);
}

-keep class org.apache.http.cookie.MalformedCookieException {
	org.apache.http.cookie.MalformedCookieException();
	org.apache.http.cookie.MalformedCookieException(java.lang.String);
}

-keep class org.apache.http.cookie.SetCookie {
	*** setComment(java.lang.String);
	*** setDomain(java.lang.String);
	*** setExpiryDate(java.util.Date);
	*** setPath(java.lang.String);
	*** setSecure(boolean);
	*** setVersion(int);
}

-keep class org.apache.http.cookie.SetCookie2 {
	*** setCommentURL(java.lang.String);
	*** setDiscard(boolean);
	*** setPorts(int[]);
}

-keep class org.apache.http.entity.AbstractHttpEntity {
	*** chunked;
	*** contentEncoding;
	*** contentType;
	org.apache.http.entity.AbstractHttpEntity();
	*** setChunked(boolean);
	*** setContentEncoding(java.lang.String);
	*** setContentEncoding(org.apache.http.Header);
	*** setContentType(java.lang.String);
	*** setContentType(org.apache.http.Header);
}

-keep class org.apache.http.entity.BasicHttpEntity {
	*** content;
	*** length;
	*** getContent();
	*** setContent(java.io.InputStream);
	*** setContentLength(long);
}

-keep class org.apache.http.entity.ByteArrayEntity {
	*** b;
	*** content;
	*** len;
	*** off;
	org.apache.http.entity.ByteArrayEntity(byte[],int,int,org.apache.http.entity.ContentType);
	org.apache.http.entity.ByteArrayEntity(byte[],org.apache.http.entity.ContentType);
}

-keep class org.apache.http.entity.ContentLengthStrategy {
	*** determineLength(org.apache.http.HttpMessage);
}

-keep class org.apache.http.entity.ContentType {
	*** APPLICATION_ATOM_XML;
	*** APPLICATION_FORM_URLENCODED;
	*** APPLICATION_JSON;
	*** APPLICATION_OCTET_STREAM;
	*** APPLICATION_SVG_XML;
	*** APPLICATION_XHTML_XML;
	*** APPLICATION_XML;
	*** DEFAULT_BINARY;
	*** DEFAULT_TEXT;
	*** MULTIPART_FORM_DATA;
	*** TEXT_HTML;
	*** TEXT_PLAIN;
	*** TEXT_XML;
	*** WILDCARD;
	*** charset;
	*** mimeType;
	*** create(java.lang.String,java.lang.String);
	*** create(java.lang.String,java.nio.charset.Charset);
	*** create(org.apache.http.HeaderElement);
	*** get(org.apache.http.HttpEntity);
	*** getCharset();
	*** getMimeType();
	*** toString();
	*** valid(java.lang.String);
}

-keep class org.apache.http.entity.HttpEntityWrapper {
	*** wrappedEntity;
	org.apache.http.entity.HttpEntityWrapper(org.apache.http.HttpEntity);
	*** consumeContent();
	*** getContent();
	*** writeTo(java.io.OutputStream);
}

-keep class org.apache.http.entity.StringEntity {
	*** content;
	org.apache.http.entity.StringEntity(java.lang.String,org.apache.http.entity.ContentType);
}

-keep class org.apache.http.impl.AbstractHttpClientConnection {
	*** entitydeserializer;
	*** entityserializer;
	*** eofSensor;
	*** inbuffer;
	*** metrics;
	*** outbuffer;
	*** requestWriter;
	*** responseParser;
	org.apache.http.impl.AbstractHttpClientConnection();
	*** assertOpen();
	*** createConnectionMetrics(org.apache.http.io.HttpTransportMetrics,org.apache.http.io.HttpTransportMetrics);
	*** createEntityDeserializer();
	*** createEntitySerializer();
	*** createHttpResponseFactory();
	*** createRequestWriter(org.apache.http.io.SessionOutputBuffer,org.apache.http.params.HttpParams);
	*** createResponseParser(org.apache.http.io.SessionInputBuffer,org.apache.http.HttpResponseFactory,org.apache.http.params.HttpParams);
	*** doFlush();
	*** init(org.apache.http.io.SessionInputBuffer,org.apache.http.io.SessionOutputBuffer,org.apache.http.params.HttpParams);
	*** isEof();
	*** receiveResponseHeader();
	*** sendRequestHeader(org.apache.http.HttpRequest);
}

-keep class org.apache.http.impl.DefaultConnectionReuseStrategy {
	*** canResponseHaveBody(org.apache.http.HttpResponse);
	*** createTokenIterator(org.apache.http.HeaderIterator);
}

-keep class org.apache.http.impl.DefaultHttpResponseFactory {
	*** reasonCatalog;
	org.apache.http.impl.DefaultHttpResponseFactory(org.apache.http.ReasonPhraseCatalog);
	*** determineLocale(org.apache.http.protocol.HttpContext);
	*** newHttpResponse(org.apache.http.ProtocolVersion,int,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.impl.EnglishReasonPhraseCatalog {
	*** INSTANCE;
	*** REASON_PHRASES;
	*** setReason(int,java.lang.String);
}

-keep class org.apache.http.impl.HttpConnectionMetricsImpl {
	*** inTransportMetric;
	*** metricsCache;
	*** outTransportMetric;
	*** requestCount;
	*** responseCount;
	*** incrementRequestCount();
	*** incrementResponseCount();
}

-keep class org.apache.http.impl.SocketHttpClientConnection {
	*** open;
	*** socket;
	org.apache.http.impl.SocketHttpClientConnection();
	*** assertNotOpen();
	*** assertOpen();
	*** bind(java.net.Socket,org.apache.http.params.HttpParams);
	*** close();
	*** createSessionInputBuffer(java.net.Socket,int,org.apache.http.params.HttpParams);
	*** createSessionOutputBuffer(java.net.Socket,int,org.apache.http.params.HttpParams);
	*** formatAddress(java.lang.StringBuilder,java.net.SocketAddress);
	*** shutdown();
}

-keep class org.apache.http.impl.auth.KerberosSchemeFactory {
	*** stripPort;
	org.apache.http.impl.auth.KerberosSchemeFactory(boolean);
}

-keep class org.apache.http.impl.auth.SPNegoSchemeFactory {
	*** stripPort;
	org.apache.http.impl.auth.SPNegoSchemeFactory(boolean);
}

-keep class org.apache.http.impl.client.AbstractHttpClient {
	*** backoffManager;
	*** connManager;
	*** connectionBackoffStrategy;
	*** cookieStore;
	*** credsProvider;
	*** defaultParams;
	*** keepAliveStrategy;
	*** log;
	*** mutableProcessor;
	*** protocolProcessor;
	*** proxyAuthStrategy;
	*** redirectStrategy;
	*** requestExec;
	*** retryHandler;
	*** reuseStrategy;
	*** routePlanner;
	*** supportedAuthSchemes;
	*** supportedCookieSpecs;
	*** targetAuthStrategy;
	*** userTokenHandler;
	org.apache.http.impl.client.AbstractHttpClient(org.apache.http.conn.ClientConnectionManager,org.apache.http.params.HttpParams);
	*** createAuthSchemeRegistry();
	*** createClientConnectionManager();
	*** createClientRequestDirector(org.apache.http.protocol.HttpRequestExecutor,org.apache.http.conn.ClientConnectionManager,org.apache.http.ConnectionReuseStrategy,org.apache.http.conn.ConnectionKeepAliveStrategy,org.apache.http.conn.routing.HttpRoutePlanner,org.apache.http.protocol.HttpProcessor,org.apache.http.client.HttpRequestRetryHandler,org.apache.http.client.RedirectStrategy,org.apache.http.client.AuthenticationStrategy,org.apache.http.client.AuthenticationStrategy,org.apache.http.client.UserTokenHandler,org.apache.http.params.HttpParams);
	*** createConnectionKeepAliveStrategy();
	*** createConnectionReuseStrategy();
	*** createCookieSpecRegistry();
	*** createCookieStore();
	*** createCredentialsProvider();
	*** createHttpContext();
	*** createHttpParams();
	*** createHttpProcessor();
	*** createHttpRequestRetryHandler();
	*** createHttpRoutePlanner();
	*** createProxyAuthenticationHandler();
	*** createProxyAuthenticationStrategy();
	*** createRedirectHandler();
	*** createRequestExecutor();
	*** createTargetAuthenticationHandler();
	*** createTargetAuthenticationStrategy();
	*** createUserTokenHandler();
	*** determineParams(org.apache.http.HttpRequest);
	*** determineTarget(org.apache.http.client.methods.HttpUriRequest);
	*** execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext);
	*** execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
	*** execute(org.apache.http.client.methods.HttpUriRequest);
	*** execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext);
	*** execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.protocol.HttpContext);
	*** getAuthSchemes();
	*** getBackoffManager();
	*** getConnectionBackoffStrategy();
	*** getConnectionKeepAliveStrategy();
	*** getConnectionManager();
	*** getConnectionReuseStrategy();
	*** getCookieSpecs();
	*** getCookieStore();
	*** getCredentialsProvider();
	*** getHttpProcessor();
	*** getHttpRequestRetryHandler();
	*** getParams();
	*** getProtocolProcessor();
	*** getProxyAuthenticationStrategy();
	*** getRedirectStrategy();
	*** getRequestExecutor();
	*** getRoutePlanner();
	*** getTargetAuthenticationStrategy();
	*** getUserTokenHandler();
	*** setHttpRequestRetryHandler(org.apache.http.client.HttpRequestRetryHandler);
	*** setRoutePlanner(org.apache.http.conn.routing.HttpRoutePlanner);
}

-keep class org.apache.http.impl.client.AuthenticationStrategyAdaptor {
	*** handler;
	*** log;
	*** getHandler();
	*** isCachable(org.apache.http.auth.AuthScheme);
}

-keep class org.apache.http.impl.client.AuthenticationStrategyImpl {
	*** DEFAULT_SCHEME_PRIORITY;
	*** challengeCode;
	*** headerName;
	*** log;
	*** prefParamName;
	org.apache.http.impl.client.AuthenticationStrategyImpl(int,java.lang.String,java.lang.String);
	*** authFailed(org.apache.http.HttpHost,org.apache.http.auth.AuthScheme,org.apache.http.protocol.HttpContext);
	*** authSucceeded(org.apache.http.HttpHost,org.apache.http.auth.AuthScheme,org.apache.http.protocol.HttpContext);
	*** getChallenges(org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isAuthenticationRequested(org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isCachable(org.apache.http.auth.AuthScheme);
	*** select(java.util.Map,org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.impl.client.BasicCookieStore {
	*** cookies;
	*** addCookie(org.apache.http.cookie.Cookie);
}

-keep class org.apache.http.impl.client.BasicCredentialsProvider {
	*** credMap;
	*** matchCredentials(java.util.Map,org.apache.http.auth.AuthScope);
}

-keep class org.apache.http.impl.client.ClientParamsStack {
	*** applicationParams;
	*** clientParams;
	*** overrideParams;
	*** requestParams;
	org.apache.http.impl.client.ClientParamsStack(org.apache.http.params.HttpParams,org.apache.http.params.HttpParams,org.apache.http.params.HttpParams,org.apache.http.params.HttpParams);
	*** getApplicationParams();
	*** getClientParams();
	*** getOverrideParams();
	*** getRequestParams();
}

-keep class org.apache.http.impl.client.DefaultHttpClient {
	*** setDefaultHttpParams(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.impl.client.DefaultHttpRequestRetryHandler {
	*** requestSentRetryEnabled;
	*** retryCount;
	org.apache.http.impl.client.DefaultHttpRequestRetryHandler(int,boolean);
	*** handleAsIdempotent(org.apache.http.HttpRequest);
	*** requestIsAborted(org.apache.http.HttpRequest);
}

-keep class org.apache.http.impl.client.DefaultRedirectStrategy {
	*** REDIRECT_METHODS;
	*** log;
	*** copyEntity(org.apache.http.client.methods.HttpEntityEnclosingRequestBase,org.apache.http.HttpRequest);
	*** createLocationURI(java.lang.String);
	*** getLocationURI(org.apache.http.HttpRequest,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** isRedirectable(java.lang.String);
}

-keep class org.apache.http.impl.client.DefaultRedirectStrategyAdaptor {
	*** handler;
	*** getHandler();
}

-keep class org.apache.http.impl.client.DefaultRequestDirector {
	*** authenticator;
	*** connManager;
	*** execCount;
	*** httpProcessor;
	*** keepAliveStrategy;
	*** log;
	*** managedConn;
	*** maxRedirects;
	*** params;
	*** proxyAuthHandler;
	*** proxyAuthState;
	*** proxyAuthStrategy;
	*** redirectCount;
	*** redirectHandler;
	*** redirectStrategy;
	*** requestExec;
	*** retryHandler;
	*** reuseStrategy;
	*** routePlanner;
	*** targetAuthHandler;
	*** targetAuthState;
	*** targetAuthStrategy;
	*** userTokenHandler;
	*** virtualHost;
	org.apache.http.impl.client.DefaultRequestDirector(org.apache.commons.logging.Log,org.apache.http.protocol.HttpRequestExecutor,org.apache.http.conn.ClientConnectionManager,org.apache.http.ConnectionReuseStrategy,org.apache.http.conn.ConnectionKeepAliveStrategy,org.apache.http.conn.routing.HttpRoutePlanner,org.apache.http.protocol.HttpProcessor,org.apache.http.client.HttpRequestRetryHandler,org.apache.http.client.RedirectStrategy,org.apache.http.client.AuthenticationStrategy,org.apache.http.client.AuthenticationStrategy,org.apache.http.client.UserTokenHandler,org.apache.http.params.HttpParams);
	*** abortConnection();
	*** createConnectRequest(org.apache.http.conn.routing.HttpRoute,org.apache.http.protocol.HttpContext);
	*** createTunnelToProxy(org.apache.http.conn.routing.HttpRoute,int,org.apache.http.protocol.HttpContext);
	*** createTunnelToTarget(org.apache.http.conn.routing.HttpRoute,org.apache.http.protocol.HttpContext);
	*** determineRoute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext);
	*** establishRoute(org.apache.http.conn.routing.HttpRoute,org.apache.http.protocol.HttpContext);
	*** handleResponse(org.apache.http.impl.client.RoutedRequest,org.apache.http.HttpResponse,org.apache.http.protocol.HttpContext);
	*** releaseConnection();
	*** rewriteRequestURI(org.apache.http.impl.client.RequestWrapper,org.apache.http.conn.routing.HttpRoute);
	*** tryConnect(org.apache.http.impl.client.RoutedRequest,org.apache.http.protocol.HttpContext);
	*** tryExecute(org.apache.http.impl.client.RoutedRequest,org.apache.http.protocol.HttpContext);
	*** wrapRequest(org.apache.http.HttpRequest);
}

-keep class org.apache.http.impl.client.DefaultUserTokenHandler {
	*** getAuthPrincipal(org.apache.http.auth.AuthState);
}

-keep class org.apache.http.impl.client.EntityEnclosingRequestWrapper {
	*** consumed;
	*** entity;
	*** access$002(org.apache.http.impl.client.EntityEnclosingRequestWrapper,boolean);
	*** setEntity(org.apache.http.HttpEntity);
}

-keep class org.apache.http.impl.client.EntityEnclosingRequestWrapper$EntityWrapper {
	*** this$0;
}

-keep class org.apache.http.impl.client.HttpAuthenticator {
	*** log;
	org.apache.http.impl.client.HttpAuthenticator(org.apache.commons.logging.Log);
	*** authenticate(org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.client.AuthenticationStrategy,org.apache.http.auth.AuthState,org.apache.http.protocol.HttpContext);
	*** isAuthenticationRequested(org.apache.http.HttpHost,org.apache.http.HttpResponse,org.apache.http.client.AuthenticationStrategy,org.apache.http.auth.AuthState,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.impl.client.HttpAuthenticator$1 {
	*** $SwitchMap$org$apache$http$auth$AuthProtocolState;
}

-keep class org.apache.http.impl.client.RedirectLocations {
	*** all;
	*** unique;
	*** add(java.net.URI);
	*** contains(java.net.URI);
}

-keep class org.apache.http.impl.client.RequestWrapper {
	*** execCount;
	*** method;
	*** original;
	*** uri;
	*** version;
	org.apache.http.impl.client.RequestWrapper(org.apache.http.HttpRequest);
	*** getExecCount();
	*** getMethod();
	*** getOriginal();
	*** getProtocolVersion();
	*** getRequestLine();
	*** getURI();
	*** incrementExecCount();
	*** isRepeatable();
	*** resetHeaders();
	*** setURI(java.net.URI);
}

-keep class org.apache.http.impl.client.RoutedRequest {
	*** request;
	*** route;
	*** getRequest();
	*** getRoute();
}

-keep class org.apache.http.impl.client.TunnelRefusedException {
	*** response;
	*** getResponse();
}

-keep class org.apache.http.impl.conn.BasicClientConnectionManager {
	*** COUNTER;
	*** conn;
	*** connOperator;
	*** log;
	*** poolEntry;
	*** schemeRegistry;
	*** shutdown;
	org.apache.http.impl.conn.BasicClientConnectionManager(org.apache.http.conn.scheme.SchemeRegistry);
	*** assertNotShutdown();
	*** createConnectionOperator(org.apache.http.conn.scheme.SchemeRegistry);
	*** getConnection(org.apache.http.conn.routing.HttpRoute,java.lang.Object);
	*** shutdown();
	*** shutdownConnection(org.apache.http.HttpClientConnection);
}

-keep class org.apache.http.impl.conn.BasicClientConnectionManager$1 {
	*** this$0;
	*** val$route;
	*** val$state;
}

-keep class org.apache.http.impl.conn.DefaultClientConnection {
	*** attributes;
	*** connSecure;
	*** headerLog;
	*** log;
	*** shutdown;
	*** socket;
	*** targetHost;
	*** wireLog;
}

-keep class org.apache.http.impl.conn.DefaultClientConnectionOperator {
	*** dnsResolver;
	*** log;
	*** schemeRegistry;
	*** prepareSocket(java.net.Socket,org.apache.http.protocol.HttpContext,org.apache.http.params.HttpParams);
	*** resolveHostname(java.lang.String);
}

-keep class org.apache.http.impl.conn.DefaultHttpResponseParser {
	*** lineBuf;
	*** log;
	*** responseFactory;
	*** parseHead(org.apache.http.io.SessionInputBuffer);
	*** reject(org.apache.http.util.CharArrayBuffer,int);
}

-keep class org.apache.http.impl.conn.DefaultHttpRoutePlanner {
	*** schemeRegistry;
}

-keep class org.apache.http.impl.conn.HttpPoolEntry {
	*** log;
	*** tracker;
	*** close();
	*** getEffectiveRoute();
	*** getPlannedRoute();
	*** getTracker();
	*** isClosed();
	*** isExpired(long);
}

-keep class org.apache.http.impl.conn.ManagedClientConnectionImpl {
	*** duration;
	*** manager;
	*** operator;
	*** poolEntry;
	*** reusable;
	*** detach();
	*** ensureConnection();
	*** ensurePoolEntry();
	*** getConnection();
	*** getManager();
	*** getPoolEntry();
	*** isMarkedReusable();
	*** isOpen();
}

-keep class org.apache.http.impl.conn.SchemeRegistryFactory {
	*** createDefault();
}

-keep class org.apache.http.impl.cookie.AbstractCookieAttributeHandler {
	org.apache.http.impl.cookie.AbstractCookieAttributeHandler();
}

-keep class org.apache.http.impl.cookie.AbstractCookieSpec {
	*** attribHandlerMap;
	org.apache.http.impl.cookie.AbstractCookieSpec();
	*** findAttribHandler(java.lang.String);
	*** getAttribHandlers();
	*** registerAttribHandler(java.lang.String,org.apache.http.cookie.CookieAttributeHandler);
}

-keep class org.apache.http.impl.cookie.BasicClientCookie {
	*** attribs;
	*** cookieComment;
	*** cookieDomain;
	*** cookieExpiryDate;
	*** cookiePath;
	*** cookieVersion;
	*** isSecure;
	*** name;
	*** value;
	*** setAttribute(java.lang.String,java.lang.String);
	*** setDomain(java.lang.String);
	*** setPath(java.lang.String);
}

-keep class org.apache.http.impl.cookie.BasicClientCookie2 {
	*** setPorts(int[]);
}

-keep class org.apache.http.impl.cookie.BasicExpiresHandler {
	*** datepatterns;
}

-keep class org.apache.http.impl.cookie.BasicPathHandler {
	*** match(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
}

-keep class org.apache.http.impl.cookie.BestMatchSpec {
	*** compat;
	*** datepatterns;
	*** obsoleteStrict;
	*** oneHeader;
	*** strict;
	org.apache.http.impl.cookie.BestMatchSpec(java.lang.String[],boolean);
	*** getCompat();
	*** getObsoleteStrict();
	*** getStrict();
}

-keep class org.apache.http.impl.cookie.BrowserCompatSpec {
	*** DEFAULT_DATE_PATTERNS;
	*** datepatterns;
	org.apache.http.impl.cookie.BrowserCompatSpec(java.lang.String[]);
	*** formatCookies(java.util.List);
}

-keep class org.apache.http.impl.cookie.CookieSpecBase {
	org.apache.http.impl.cookie.CookieSpecBase();
	*** getDefaultDomain(org.apache.http.cookie.CookieOrigin);
	*** getDefaultPath(org.apache.http.cookie.CookieOrigin);
	*** match(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
	*** parse(org.apache.http.HeaderElement[],org.apache.http.cookie.CookieOrigin);
	*** validate(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
}

-keep class org.apache.http.impl.cookie.DateUtils {
	*** DEFAULT_PATTERNS;
	*** DEFAULT_TWO_DIGIT_YEAR_START;
	*** GMT;
	*** formatDate(java.util.Date,java.lang.String);
	*** parseDate(java.lang.String,java.lang.String[]);
	*** parseDate(java.lang.String,java.lang.String[],java.util.Date);
}

-keep class org.apache.http.impl.cookie.DateUtils$DateFormatHolder {
	*** THREADLOCAL_FORMATS;
	*** clearThreadLocal();
	*** formatFor(java.lang.String);
}

-keep class org.apache.http.impl.cookie.DateUtils$DateFormatHolder$1 {
	*** initialValue();
}

-keep class org.apache.http.impl.cookie.NetscapeDraftHeaderParser {
	*** DEFAULT;
	*** parseHeader(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseNameValuePair(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
}

-keep class org.apache.http.impl.cookie.RFC2109Spec {
	*** DATE_PATTERNS;
	*** PATH_COMPARATOR;
	*** datepatterns;
	*** oneHeader;
	org.apache.http.impl.cookie.RFC2109Spec(java.lang.String[],boolean);
	*** doFormatManyHeaders(java.util.List);
	*** doFormatOneHeader(java.util.List);
	*** formatCookieAsVer(org.apache.http.util.CharArrayBuffer,org.apache.http.cookie.Cookie,int);
	*** formatCookies(java.util.List);
	*** formatParamAsVer(org.apache.http.util.CharArrayBuffer,java.lang.String,java.lang.String,int);
	*** validate(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
}

-keep class org.apache.http.impl.cookie.RFC2965DomainAttributeHandler {
	*** domainMatch(java.lang.String,java.lang.String);
}

-keep class org.apache.http.impl.cookie.RFC2965PortAttributeHandler {
	*** parsePortAttribute(java.lang.String);
	*** portMatch(int,int[]);
}

-keep class org.apache.http.impl.cookie.RFC2965Spec {
	org.apache.http.impl.cookie.RFC2965Spec(java.lang.String[],boolean);
	*** adjustEffectiveHost(org.apache.http.cookie.CookieOrigin);
	*** createCookies(org.apache.http.HeaderElement[],org.apache.http.cookie.CookieOrigin);
	*** getVersion();
	*** getVersionHeader();
	*** match(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
	*** parse(org.apache.http.HeaderElement[],org.apache.http.cookie.CookieOrigin);
	*** validate(org.apache.http.cookie.Cookie,org.apache.http.cookie.CookieOrigin);
}

-keep class org.apache.http.impl.entity.EntityDeserializer {
	*** lenStrategy;
	*** deserialize(org.apache.http.io.SessionInputBuffer,org.apache.http.HttpMessage);
	*** doDeserialize(org.apache.http.io.SessionInputBuffer,org.apache.http.HttpMessage);
}

-keep class org.apache.http.impl.entity.EntitySerializer {
	*** lenStrategy;
	*** doSerialize(org.apache.http.io.SessionOutputBuffer,org.apache.http.HttpMessage);
	*** serialize(org.apache.http.io.SessionOutputBuffer,org.apache.http.HttpMessage,org.apache.http.HttpEntity);
}

-keep class org.apache.http.impl.entity.LaxContentLengthStrategy {
	*** implicitLen;
	org.apache.http.impl.entity.LaxContentLengthStrategy(int);
}

-keep class org.apache.http.impl.entity.StrictContentLengthStrategy {
	*** implicitLen;
	org.apache.http.impl.entity.StrictContentLengthStrategy(int);
}

-keep class org.apache.http.impl.io.AbstractMessageParser {
	*** headerLines;
	*** lineParser;
	*** maxHeaderCount;
	*** maxLineLen;
	*** message;
	*** sessionBuffer;
	*** state;
	org.apache.http.impl.io.AbstractMessageParser(org.apache.http.io.SessionInputBuffer,org.apache.http.message.LineParser,org.apache.http.params.HttpParams);
	*** parseHead(org.apache.http.io.SessionInputBuffer);
	*** parseHeaders(org.apache.http.io.SessionInputBuffer,int,int,org.apache.http.message.LineParser);
	*** parseHeaders(org.apache.http.io.SessionInputBuffer,int,int,org.apache.http.message.LineParser,java.util.List);
}

-keep class org.apache.http.impl.io.AbstractMessageWriter {
	*** lineBuf;
	*** lineFormatter;
	*** sessionBuffer;
	org.apache.http.impl.io.AbstractMessageWriter(org.apache.http.io.SessionOutputBuffer,org.apache.http.message.LineFormatter,org.apache.http.params.HttpParams);
	*** writeHeadLine(org.apache.http.HttpMessage);
}

-keep class org.apache.http.impl.io.AbstractSessionInputBuffer {
	*** ASCII;
	*** ascii;
	*** buffer;
	*** bufferlen;
	*** bufferpos;
	*** cbuf;
	*** charset;
	*** decoder;
	*** instream;
	*** linebuffer;
	*** maxLineLen;
	*** metrics;
	*** minChunkLimit;
	*** onMalformedInputAction;
	*** onUnMappableInputAction;
	org.apache.http.impl.io.AbstractSessionInputBuffer();
	*** appendDecoded(org.apache.http.util.CharArrayBuffer,java.nio.ByteBuffer);
	*** capacity();
	*** createTransportMetrics();
	*** fillBuffer();
	*** handleDecodingResult(java.nio.charset.CoderResult,org.apache.http.util.CharArrayBuffer,java.nio.ByteBuffer);
	*** hasBufferedData();
	*** init(java.io.InputStream,int,org.apache.http.params.HttpParams);
	*** length();
	*** lineFromLineBuffer(org.apache.http.util.CharArrayBuffer);
	*** lineFromReadBuffer(org.apache.http.util.CharArrayBuffer,int);
	*** locateLF();
	*** read(byte[],int,int);
	*** readLine(org.apache.http.util.CharArrayBuffer);
}

-keep class org.apache.http.impl.io.AbstractSessionOutputBuffer {
	*** ASCII;
	*** CRLF;
	*** ascii;
	*** bbuf;
	*** buffer;
	*** charset;
	*** encoder;
	*** metrics;
	*** minChunkLimit;
	*** onMalformedInputAction;
	*** onUnMappableInputAction;
	*** outstream;
	org.apache.http.impl.io.AbstractSessionOutputBuffer();
	*** capacity();
	*** createTransportMetrics();
	*** flushBuffer();
	*** handleEncodingResult(java.nio.charset.CoderResult);
	*** init(java.io.OutputStream,int,org.apache.http.params.HttpParams);
	*** length();
	*** write(byte[]);
	*** write(byte[],int,int);
	*** write(int);
	*** writeEncoded(java.nio.CharBuffer);
}

-keep class org.apache.http.impl.io.ChunkedInputStream {
	*** buffer;
	*** chunkSize;
	*** closed;
	*** eof;
	*** footers;
	*** in;
	*** pos;
	*** state;
	*** getChunkSize();
	*** nextChunk();
	*** parseTrailerHeaders();
	*** read(byte[]);
	*** read(byte[],int,int);
}

-keep class org.apache.http.impl.io.ChunkedOutputStream {
	*** cache;
	*** cachePosition;
	*** closed;
	*** out;
	*** wroteLastChunk;
	org.apache.http.impl.io.ChunkedOutputStream(org.apache.http.io.SessionOutputBuffer,int);
	*** finish();
	*** flushCache();
	*** flushCacheWithAppend(byte[],int,int);
	*** write(byte[],int,int);
	*** writeClosingChunk();
}

-keep class org.apache.http.impl.io.ContentLengthInputStream {
	*** closed;
	*** contentLength;
	*** in;
	*** pos;
	*** read(byte[]);
	*** read(byte[],int,int);
}

-keep class org.apache.http.impl.io.ContentLengthOutputStream {
	*** closed;
	*** contentLength;
	*** out;
	*** total;
	*** write(byte[],int,int);
}

-keep class org.apache.http.impl.io.HttpRequestWriter {
	*** writeHeadLine(org.apache.http.HttpRequest);
}

-keep class org.apache.http.impl.io.HttpTransportMetricsImpl {
	*** bytesTransferred;
	*** incrementBytesTransferred(long);
}

-keep class org.apache.http.impl.io.IdentityInputStream {
	*** closed;
	*** in;
}

-keep class org.apache.http.impl.io.IdentityOutputStream {
	*** closed;
	*** out;
	*** write(byte[],int,int);
}

-keep class org.apache.http.impl.io.SocketInputBuffer {
	*** eof;
	*** socket;
	*** fillBuffer();
}

-keep class org.apache.http.io.BufferInfo {
	*** length();
}

-keep class org.apache.http.io.EofSensor {
	*** isEof();
}

-keep class org.apache.http.io.HttpMessageParser {
	*** parse();
}

-keep class org.apache.http.io.HttpMessageWriter {
	*** write(org.apache.http.HttpMessage);
}

-keep class org.apache.http.io.HttpTransportMetrics {
	*** getBytesTransferred();
	*** reset();
}

-keep class org.apache.http.io.SessionInputBuffer {
	*** getMetrics();
	*** isDataAvailable(int);
	*** read();
	*** read(byte[],int,int);
	*** readLine(org.apache.http.util.CharArrayBuffer);
}

-keep class org.apache.http.io.SessionOutputBuffer {
	*** flush();
	*** getMetrics();
	*** write(byte[],int,int);
	*** write(int);
	*** writeLine(java.lang.String);
	*** writeLine(org.apache.http.util.CharArrayBuffer);
}

-keep class org.apache.http.message.AbstractHttpMessage {
	*** headergroup;
	*** params;
	org.apache.http.message.AbstractHttpMessage();
	org.apache.http.message.AbstractHttpMessage(org.apache.http.params.HttpParams);
	*** addHeader(java.lang.String,java.lang.String);
	*** addHeader(org.apache.http.Header);
	*** containsHeader(java.lang.String);
	*** getAllHeaders();
	*** getFirstHeader(java.lang.String);
	*** getHeaders(java.lang.String);
	*** getLastHeader(java.lang.String);
	*** getParams();
	*** headerIterator();
	*** headerIterator(java.lang.String);
	*** removeHeader(org.apache.http.Header);
	*** removeHeaders(java.lang.String);
	*** setHeader(java.lang.String,java.lang.String);
	*** setHeader(org.apache.http.Header);
	*** setHeaders(org.apache.http.Header[]);
	*** setParams(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.message.BasicHeader {
	*** name;
	*** value;
}

-keep class org.apache.http.message.BasicHeaderElement {
	*** name;
	*** parameters;
	*** value;
	org.apache.http.message.BasicHeaderElement(java.lang.String,java.lang.String,org.apache.http.NameValuePair[]);
}

-keep class org.apache.http.message.BasicHeaderElementIterator {
	*** buffer;
	*** currentElement;
	*** cursor;
	*** headerIt;
	*** parser;
	org.apache.http.message.BasicHeaderElementIterator(org.apache.http.HeaderIterator,org.apache.http.message.HeaderValueParser);
	*** bufferHeaderValue();
	*** nextElement();
	*** parseNextElement();
}

-keep class org.apache.http.message.BasicHeaderValueFormatter {
	*** DEFAULT;
	*** formatHeaderElement(org.apache.http.util.CharArrayBuffer,org.apache.http.HeaderElement,boolean);
}

-keep class org.apache.http.message.BasicHeaderValueParser {
	*** ALL_DELIMITERS;
	*** DEFAULT;
	*** createHeaderElement(java.lang.String,java.lang.String,org.apache.http.NameValuePair[]);
	*** createNameValuePair(java.lang.String,java.lang.String);
	*** isOneOf(char,char[]);
	*** parseElements(java.lang.String,org.apache.http.message.HeaderValueParser);
	*** parseElements(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseHeaderElement(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseNameValuePair(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseNameValuePair(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor,char[]);
	*** parseParameters(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
}

-keep class org.apache.http.message.BasicHttpRequest {
	*** method;
	*** requestline;
	*** uri;
	org.apache.http.message.BasicHttpRequest(org.apache.http.RequestLine);
	*** getRequestLine();
}

-keep class org.apache.http.message.BasicHttpResponse {
	*** entity;
	*** locale;
	*** reasonCatalog;
	*** statusline;
	org.apache.http.message.BasicHttpResponse(org.apache.http.StatusLine,org.apache.http.ReasonPhraseCatalog,java.util.Locale);
	*** getReason(int);
}

-keep class org.apache.http.message.BasicLineFormatter {
	*** DEFAULT;
	*** appendProtocolVersion(org.apache.http.util.CharArrayBuffer,org.apache.http.ProtocolVersion);
	*** doFormatHeader(org.apache.http.util.CharArrayBuffer,org.apache.http.Header);
	*** doFormatRequestLine(org.apache.http.util.CharArrayBuffer,org.apache.http.RequestLine);
	*** doFormatStatusLine(org.apache.http.util.CharArrayBuffer,org.apache.http.StatusLine);
	*** estimateProtocolVersionLen(org.apache.http.ProtocolVersion);
	*** formatHeader(org.apache.http.util.CharArrayBuffer,org.apache.http.Header);
	*** formatRequestLine(org.apache.http.util.CharArrayBuffer,org.apache.http.RequestLine);
	*** formatStatusLine(org.apache.http.util.CharArrayBuffer,org.apache.http.StatusLine);
	*** initBuffer(org.apache.http.util.CharArrayBuffer);
}

-keep class org.apache.http.message.BasicLineParser {
	*** DEFAULT;
	*** protocol;
	org.apache.http.message.BasicLineParser(org.apache.http.ProtocolVersion);
	*** createProtocolVersion(int,int);
	*** createRequestLine(java.lang.String,java.lang.String,org.apache.http.ProtocolVersion);
	*** createStatusLine(org.apache.http.ProtocolVersion,int,java.lang.String);
	*** parseProtocolVersion(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** skipWhitespace(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
}

-keep class org.apache.http.message.BasicListHeaderIterator {
	*** allHeaders;
	*** currentIndex;
	*** headerName;
	*** lastIndex;
	*** filterHeader(int);
	*** findNext(int);
	*** nextHeader();
}

-keep class org.apache.http.message.BasicNameValuePair {
	*** name;
	*** value;
}

-keep class org.apache.http.message.BasicRequestLine {
	*** method;
	*** protoversion;
	*** uri;
}

-keep class org.apache.http.message.BasicStatusLine {
	*** protoVersion;
	*** reasonPhrase;
	*** statusCode;
}

-keep class org.apache.http.message.BasicTokenIterator {
	*** currentHeader;
	*** currentToken;
	*** headerIt;
	*** searchPos;
	*** createToken(java.lang.String,int,int);
	*** findNext(int);
	*** findTokenEnd(int);
	*** findTokenSeparator(int);
	*** findTokenStart(int);
	*** isHttpSeparator(char);
	*** isTokenChar(char);
	*** isTokenSeparator(char);
	*** isWhitespace(char);
	*** nextToken();
}

-keep class org.apache.http.message.BufferedHeader {
	*** buffer;
	*** name;
	*** valuePos;
}

-keep class org.apache.http.message.HeaderGroup {
	*** headers;
	*** addHeader(org.apache.http.Header);
	*** clear();
	*** containsHeader(java.lang.String);
	*** getAllHeaders();
	*** getFirstHeader(java.lang.String);
	*** getHeaders(java.lang.String);
	*** getLastHeader(java.lang.String);
	*** iterator();
	*** iterator(java.lang.String);
	*** removeHeader(org.apache.http.Header);
	*** setHeaders(org.apache.http.Header[]);
	*** updateHeader(org.apache.http.Header);
}

-keep class org.apache.http.message.HeaderValueParser {
	*** parseElements(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseHeaderElement(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseNameValuePair(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseParameters(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
}

-keep class org.apache.http.message.LineFormatter {
	*** appendProtocolVersion(org.apache.http.util.CharArrayBuffer,org.apache.http.ProtocolVersion);
	*** formatHeader(org.apache.http.util.CharArrayBuffer,org.apache.http.Header);
	*** formatRequestLine(org.apache.http.util.CharArrayBuffer,org.apache.http.RequestLine);
	*** formatStatusLine(org.apache.http.util.CharArrayBuffer,org.apache.http.StatusLine);
}

-keep class org.apache.http.message.LineParser {
	*** hasProtocolVersion(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseHeader(org.apache.http.util.CharArrayBuffer);
	*** parseProtocolVersion(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseRequestLine(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
	*** parseStatusLine(org.apache.http.util.CharArrayBuffer,org.apache.http.message.ParserCursor);
}

-keep class org.apache.http.message.ParserCursor {
	*** lowerBound;
	*** pos;
	*** upperBound;
	*** atEnd();
	*** getPos();
	*** getUpperBound();
	*** updatePos(int);
}

-keep class org.apache.http.params.AbstractHttpParams {
	org.apache.http.params.AbstractHttpParams();
	*** getBooleanParameter(java.lang.String,boolean);
}

-keep class org.apache.http.params.BasicHttpParams {
	*** parameters;
	org.apache.http.params.BasicHttpParams();
	*** clear();
	*** clone();
	*** copyParams(org.apache.http.params.HttpParams);
	*** getParameter(java.lang.String);
	*** isParameterSet(java.lang.String);
	*** isParameterSetLocally(java.lang.String);
	*** removeParameter(java.lang.String);
	*** setParameter(java.lang.String,java.lang.Object);
	*** setParameters(java.lang.String[],java.lang.Object);
}

-keep class org.apache.http.params.HttpConnectionParams {
	*** getConnectionTimeout(org.apache.http.params.HttpParams);
	*** getLinger(org.apache.http.params.HttpParams);
	*** getSoReuseaddr(org.apache.http.params.HttpParams);
	*** getSoTimeout(org.apache.http.params.HttpParams);
	*** getSocketBufferSize(org.apache.http.params.HttpParams);
	*** getTcpNoDelay(org.apache.http.params.HttpParams);
	*** isStaleCheckingEnabled(org.apache.http.params.HttpParams);
	*** setConnectionTimeout(org.apache.http.params.HttpParams,int);
	*** setSoTimeout(org.apache.http.params.HttpParams,int);
	*** setSocketBufferSize(org.apache.http.params.HttpParams,int);
	*** setStaleCheckingEnabled(org.apache.http.params.HttpParams,boolean);
	*** setTcpNoDelay(org.apache.http.params.HttpParams,boolean);
}

-keep class org.apache.http.params.HttpParams {
	*** getBooleanParameter(java.lang.String,boolean);
	*** getIntParameter(java.lang.String,int);
	*** getLongParameter(java.lang.String,long);
	*** getParameter(java.lang.String);
	*** isParameterFalse(java.lang.String);
	*** isParameterTrue(java.lang.String);
	*** setBooleanParameter(java.lang.String,boolean);
	*** setIntParameter(java.lang.String,int);
	*** setLongParameter(java.lang.String,long);
	*** setParameter(java.lang.String,java.lang.Object);
}

-keep class org.apache.http.params.HttpProtocolParams {
	*** getHttpElementCharset(org.apache.http.params.HttpParams);
	*** getMalformedInputAction(org.apache.http.params.HttpParams);
	*** getUnmappableInputAction(org.apache.http.params.HttpParams);
	*** getUserAgent(org.apache.http.params.HttpParams);
	*** getVersion(org.apache.http.params.HttpParams);
	*** setContentCharset(org.apache.http.params.HttpParams,java.lang.String);
	*** setUserAgent(org.apache.http.params.HttpParams,java.lang.String);
	*** setVersion(org.apache.http.params.HttpParams,org.apache.http.ProtocolVersion);
	*** useExpectContinue(org.apache.http.params.HttpParams);
}

-keep class org.apache.http.pool.PoolEntry {
	*** conn;
	*** created;
	*** expiry;
	*** id;
	*** route;
	*** state;
	*** updated;
	*** validUnit;
	org.apache.http.pool.PoolEntry(java.lang.String,java.lang.Object,java.lang.Object,long,java.util.concurrent.TimeUnit);
	*** getConnection();
	*** getExpiry();
	*** getRoute();
	*** getState();
	*** getUpdated();
	*** isExpired(long);
	*** setState(java.lang.Object);
	*** updateExpiry(long,java.util.concurrent.TimeUnit);
}

-keep class org.apache.http.protocol.BasicHttpContext {
	*** map;
	*** parentContext;
	org.apache.http.protocol.BasicHttpContext(org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.protocol.BasicHttpProcessor {
	*** requestInterceptors;
	*** responseInterceptors;
	*** addInterceptor(org.apache.http.HttpRequestInterceptor);
	*** addInterceptor(org.apache.http.HttpRequestInterceptor,int);
	*** addInterceptor(org.apache.http.HttpResponseInterceptor);
	*** addInterceptor(org.apache.http.HttpResponseInterceptor,int);
	*** addRequestInterceptor(org.apache.http.HttpRequestInterceptor);
	*** addRequestInterceptor(org.apache.http.HttpRequestInterceptor,int);
	*** addResponseInterceptor(org.apache.http.HttpResponseInterceptor);
	*** addResponseInterceptor(org.apache.http.HttpResponseInterceptor,int);
	*** clearRequestInterceptors();
	*** clearResponseInterceptors();
	*** copyInterceptors(org.apache.http.protocol.BasicHttpProcessor);
	*** getRequestInterceptor(int);
	*** getRequestInterceptorCount();
	*** getResponseInterceptor(int);
	*** getResponseInterceptorCount();
	*** removeRequestInterceptorByClass(java.lang.Class);
	*** removeResponseInterceptorByClass(java.lang.Class);
}

-keep class org.apache.http.protocol.HTTP {
	*** DEF_CONTENT_CHARSET;
	*** DEF_PROTOCOL_CHARSET;
	*** isWhitespace(char);
}

-keep class org.apache.http.protocol.HttpContext {
	*** getAttribute(java.lang.String);
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
}

-keep class org.apache.http.protocol.HttpRequestExecutor {
	*** canResponseHaveBody(org.apache.http.HttpRequest,org.apache.http.HttpResponse);
	*** closeConnection(org.apache.http.HttpClientConnection);
	*** doReceiveResponse(org.apache.http.HttpRequest,org.apache.http.HttpClientConnection,org.apache.http.protocol.HttpContext);
	*** doSendRequest(org.apache.http.HttpRequest,org.apache.http.HttpClientConnection,org.apache.http.protocol.HttpContext);
	*** execute(org.apache.http.HttpRequest,org.apache.http.HttpClientConnection,org.apache.http.protocol.HttpContext);
	*** postProcess(org.apache.http.HttpResponse,org.apache.http.protocol.HttpProcessor,org.apache.http.protocol.HttpContext);
	*** preProcess(org.apache.http.HttpRequest,org.apache.http.protocol.HttpProcessor,org.apache.http.protocol.HttpContext);
}

-keep class org.apache.http.protocol.HttpRequestInterceptorList {
	*** getRequestInterceptor(int);
	*** getRequestInterceptorCount();
}

-keep class org.apache.http.protocol.HttpResponseInterceptorList {
	*** getResponseInterceptor(int);
	*** getResponseInterceptorCount();
}

-keep class org.apache.http.protocol.ImmutableHttpProcessor {
	*** requestInterceptors;
	*** responseInterceptors;
	org.apache.http.protocol.ImmutableHttpProcessor(org.apache.http.HttpRequestInterceptor[],org.apache.http.HttpResponseInterceptor[]);
}

-keep class org.apache.http.protocol.RequestContent {
	*** overwrite;
	org.apache.http.protocol.RequestContent(boolean);
}

-keep class org.apache.http.util.ByteArrayBuffer {
	*** buffer;
	*** len;
	*** append(byte[],int,int);
	*** append(char[],int,int);
	*** append(int);
	*** append(org.apache.http.util.CharArrayBuffer,int,int);
	*** buffer();
	*** byteAt(int);
	*** capacity();
	*** clear();
	*** expand(int);
	*** indexOf(byte,int,int);
	*** isEmpty();
	*** isFull();
	*** length();
	*** toByteArray();
}

-keep class org.apache.http.util.CharArrayBuffer {
	*** buffer;
	*** len;
	*** append(byte[],int,int);
	*** append(char);
	*** append(char[],int,int);
	*** append(java.lang.String);
	*** append(org.apache.http.util.ByteArrayBuffer,int,int);
	*** append(org.apache.http.util.CharArrayBuffer,int,int);
	*** buffer();
	*** charAt(int);
	*** clear();
	*** ensureCapacity(int);
	*** expand(int);
	*** indexOf(int);
	*** indexOf(int,int,int);
	*** isEmpty();
	*** length();
	*** substring(int,int);
	*** substringTrimmed(int,int);
	*** toString();
}

-keep class org.apache.http.util.EntityUtils {
	*** consume(org.apache.http.HttpEntity);
	*** toString(org.apache.http.HttpEntity,java.nio.charset.Charset);
}

-keep class org.apache.http.util.LangUtils {
	*** equals(java.lang.Object,java.lang.Object);
	*** equals(java.lang.Object[],java.lang.Object[]);
	*** hashCode(int,boolean);
	*** hashCode(int,int);
	*** hashCode(int,java.lang.Object);
}

-keep class org.apache.http.util.VersionInfo {
	*** infoClassloader;
	*** infoModule;
	*** infoPackage;
	*** infoRelease;
	*** infoTimestamp;
	*** fromMap(java.lang.String,java.util.Map,java.lang.ClassLoader);
	*** getRelease();
	*** loadVersionInfo(java.lang.String,java.lang.ClassLoader);
}

-keep class org.apache.log4j.Appender {
	*** addFilter(org.apache.log4j.spi.Filter);
	*** close();
	*** doAppend(org.apache.log4j.spi.LoggingEvent);
	*** getName();
	*** requiresLayout();
	*** setErrorHandler(org.apache.log4j.spi.ErrorHandler);
	*** setLayout(org.apache.log4j.Layout);
	*** setName(java.lang.String);
}

-keep class org.apache.log4j.AppenderSkeleton {
	*** closed;
	*** errorHandler;
	*** headFilter;
	*** layout;
	*** name;
	*** tailFilter;
	*** threshold;
	org.apache.log4j.AppenderSkeleton();
	*** append(org.apache.log4j.spi.LoggingEvent);
	*** isAsSevereAsThreshold(org.apache.log4j.Priority);
	*** setLayout(org.apache.log4j.Layout);
}

-keep class org.apache.log4j.BasicConfigurator {
	*** configure(org.apache.log4j.Appender);
}

-keep class org.apache.log4j.Category {
	*** FQCN;
	*** aai;
	*** additive;
	*** class$org$apache$log4j$Category;
	*** level;
	*** name;
	*** parent;
	*** repository;
	*** resourceBundle;
	org.apache.log4j.Category(java.lang.String);
	*** addAppender(org.apache.log4j.Appender);
	*** callAppenders(org.apache.log4j.spi.LoggingEvent);
	*** class$(java.lang.String);
	*** closeNestedAppenders();
	*** error(java.lang.Object);
	*** fireRemoveAppenderEvent(org.apache.log4j.Appender);
	*** forcedLog(java.lang.String,org.apache.log4j.Priority,java.lang.Object,java.lang.Throwable);
	*** getAllAppenders();
	*** getEffectiveLevel();
	*** getLevel();
	*** getLoggerRepository();
	*** getName();
	*** getResourceBundle();
	*** getResourceBundleString(java.lang.String);
	*** isDebugEnabled();
	*** isEnabledFor(org.apache.log4j.Priority);
	*** isInfoEnabled();
	*** log(java.lang.String,org.apache.log4j.Priority,java.lang.Object,java.lang.Throwable);
	*** removeAllAppenders();
	*** removeAppender(org.apache.log4j.Appender);
	*** setAdditivity(boolean);
	*** setHierarchy(org.apache.log4j.spi.LoggerRepository);
	*** setLevel(org.apache.log4j.Level);
	*** setResourceBundle(java.util.ResourceBundle);
}

-keep class org.apache.log4j.CategoryKey {
	*** class$org$apache$log4j$CategoryKey;
	*** hashCache;
	*** name;
	*** class$(java.lang.String);
}

-keep class org.apache.log4j.ConsoleAppender {
	*** follow;
	*** target;
	org.apache.log4j.ConsoleAppender(org.apache.log4j.Layout,java.lang.String);
	*** activateOptions();
	*** setTarget(java.lang.String);
	*** targetWarn(java.lang.String);
}

-keep class org.apache.log4j.DefaultThrowableRenderer {
	*** render(java.lang.Throwable);
}

-keep class org.apache.log4j.FileAppender {
	*** bufferSize;
	*** bufferedIO;
	*** fileAppend;
	*** fileName;
	org.apache.log4j.FileAppender();
	org.apache.log4j.FileAppender(org.apache.log4j.Layout,java.lang.String);
	org.apache.log4j.FileAppender(org.apache.log4j.Layout,java.lang.String,boolean);
	*** closeFile();
	*** reset();
	*** setFile(java.lang.String,boolean,boolean,int);
	*** setQWForFiles(java.io.Writer);
}

-keep class org.apache.log4j.Hierarchy {
	*** defaultFactory;
	*** emittedNoAppenderWarning;
	*** emittedNoResourceBundleWarning;
	*** ht;
	*** listeners;
	*** rendererMap;
	*** root;
	*** threshold;
	*** thresholdInt;
	*** throwableRenderer;
	*** fireRemoveAppenderEvent(org.apache.log4j.Category,org.apache.log4j.Appender);
	*** getCurrentLoggers();
	*** getLogger(java.lang.String,org.apache.log4j.spi.LoggerFactory);
	*** getRootLogger();
	*** setThreshold(org.apache.log4j.Level);
	*** shutdown();
	*** updateChildren(org.apache.log4j.ProvisionNode,org.apache.log4j.Logger);
	*** updateParents(org.apache.log4j.Logger);
}

-keep class org.apache.log4j.Layout {
	*** LINE_SEP;
	*** LINE_SEP_LEN;
	org.apache.log4j.Layout();
	*** format(org.apache.log4j.spi.LoggingEvent);
	*** getFooter();
	*** getHeader();
	*** ignoresThrowable();
}

-keep class org.apache.log4j.Level {
	*** ALL;
	*** DEBUG;
	*** ERROR;
	*** FATAL;
	*** INFO;
	*** OFF;
	*** TRACE;
	*** WARN;
	*** class$org$apache$log4j$Level;
	*** class$(java.lang.String);
	*** toLevel(int);
	*** toLevel(int,org.apache.log4j.Level);
	*** toLevel(java.lang.String);
	*** toLevel(java.lang.String,org.apache.log4j.Level);
}

-keep class org.apache.log4j.LogManager {
	*** guard;
	*** repositorySelector;
	*** exists(java.lang.String);
	*** getCurrentLoggers();
	*** getLogger(java.lang.Class);
	*** getLogger(java.lang.String);
	*** getLogger(java.lang.String,org.apache.log4j.spi.LoggerFactory);
	*** getLoggerRepository();
	*** getRootLogger();
	*** isLikelySafeScenario(java.lang.Exception);
	*** shutdown();
}

-keep class org.apache.log4j.Logger {
	*** FQCN;
	*** class$org$apache$log4j$Logger;
	org.apache.log4j.Logger(java.lang.String);
	*** class$(java.lang.String);
	*** getLogger(java.lang.String);
	*** getRootLogger();
	*** isTraceEnabled();
}

-keep class org.apache.log4j.MDC {
	*** get(java.lang.String);
	*** getContext();
}

-keep class org.apache.log4j.NDC {
	*** get();
}

-keep class org.apache.log4j.NameValue {
	*** key;
	*** value;
}

-keep class org.apache.log4j.PatternLayout {
	*** BUF_SIZE;
	*** MAX_CAPACITY;
	*** head;
	*** pattern;
	*** sbuf;
	org.apache.log4j.PatternLayout(java.lang.String);
	*** createPatternParser(java.lang.String);
}

-keep class org.apache.log4j.Priority {
	*** DEBUG;
	*** ERROR;
	*** FATAL;
	*** INFO;
	*** WARN;
	*** level;
	*** levelStr;
	*** syslogEquivalent;
	org.apache.log4j.Priority(int,java.lang.String,int);
	*** isGreaterOrEqual(org.apache.log4j.Priority);
	*** toInt();
	*** toPriority(int,org.apache.log4j.Priority);
	*** toString();
}

-keep class org.apache.log4j.PropertyConfigurator {
	*** class$org$apache$log4j$Appender;
	*** class$org$apache$log4j$Layout;
	*** class$org$apache$log4j$spi$ErrorHandler;
	*** class$org$apache$log4j$spi$Filter;
	*** class$org$apache$log4j$spi$LoggerFactory;
	*** class$org$apache$log4j$spi$ThrowableRenderer;
	*** loggerFactory;
	*** registry;
	*** repository;
	*** class$(java.lang.String);
	*** configure(java.lang.String);
	*** configure(java.util.Properties);
	*** configureAndWatch(java.lang.String,long);
	*** configureLoggerFactory(java.util.Properties);
	*** configureRootCategory(java.util.Properties,org.apache.log4j.spi.LoggerRepository);
	*** doConfigure(java.io.InputStream,org.apache.log4j.spi.LoggerRepository);
	*** doConfigure(java.lang.String,org.apache.log4j.spi.LoggerRepository);
	*** doConfigure(java.net.URL,org.apache.log4j.spi.LoggerRepository);
	*** doConfigure(java.util.Properties,org.apache.log4j.spi.LoggerRepository);
	*** parseAdditivityForLogger(java.util.Properties,org.apache.log4j.Logger,java.lang.String);
	*** parseAppender(java.util.Properties,java.lang.String);
	*** parseAppenderFilters(java.util.Properties,java.lang.String,org.apache.log4j.Appender);
	*** parseCategory(java.util.Properties,org.apache.log4j.Logger,java.lang.String,java.lang.String,java.lang.String);
	*** parseCatsAndRenderers(java.util.Properties,org.apache.log4j.spi.LoggerRepository);
	*** parseErrorHandler(org.apache.log4j.spi.ErrorHandler,java.lang.String,java.util.Properties,org.apache.log4j.spi.LoggerRepository);
	*** registryGet(java.lang.String);
	*** registryPut(org.apache.log4j.Appender);
}

-keep class org.apache.log4j.RollingFileAppender {
	*** maxBackupIndex;
	*** maxFileSize;
	*** nextRollover;
	*** rollOver();
	*** setFile(java.lang.String,boolean,boolean,int);
}

-keep class org.apache.log4j.SortedKeyEnumeration {
	*** e;
}

-keep class org.apache.log4j.WriterAppender {
	*** encoding;
	*** immediateFlush;
	*** qw;
	org.apache.log4j.WriterAppender();
	org.apache.log4j.WriterAppender(org.apache.log4j.Layout,java.io.Writer);
	*** activateOptions();
	*** checkEntryConditions();
	*** closeWriter();
	*** createWriter(java.io.OutputStream);
	*** getEncoding();
	*** reset();
	*** setImmediateFlush(boolean);
	*** setWriter(java.io.Writer);
	*** shouldFlush(org.apache.log4j.spi.LoggingEvent);
	*** subAppend(org.apache.log4j.spi.LoggingEvent);
	*** writeFooter();
	*** writeHeader();
}

-keep class org.apache.log4j.config.PropertySetter {
	*** class$java$lang$String;
	*** class$org$apache$log4j$Priority;
	*** class$org$apache$log4j$spi$ErrorHandler;
	*** class$org$apache$log4j$spi$OptionHandler;
	*** obj;
	*** props;
	*** activate();
	*** class$(java.lang.String);
	*** convertArg(java.lang.String,java.lang.Class);
	*** getPropertyDescriptor(java.lang.String);
	*** introspect();
	*** setProperties(java.lang.Object,java.util.Properties,java.lang.String);
	*** setProperties(java.util.Properties,java.lang.String);
	*** setProperty(java.beans.PropertyDescriptor,java.lang.String,java.lang.String);
	*** setProperty(java.lang.String,java.lang.String);
}

-keep class org.apache.log4j.config.PropertySetterException {
	*** rootCause;
}

-keep class org.apache.log4j.helpers.AbsoluteTimeDateFormat {
	*** previousTime;
	*** previousTimeWithoutMillis;
	org.apache.log4j.helpers.AbsoluteTimeDateFormat();
	org.apache.log4j.helpers.AbsoluteTimeDateFormat(java.util.TimeZone);
	*** format(java.util.Date,java.lang.StringBuffer,java.text.FieldPosition);
}

-keep class org.apache.log4j.helpers.AppenderAttachableImpl {
	*** appenderList;
	*** addAppender(org.apache.log4j.Appender);
	*** appendLoopOnAppenders(org.apache.log4j.spi.LoggingEvent);
	*** getAllAppenders();
	*** getAppender(java.lang.String);
	*** isAttached(org.apache.log4j.Appender);
	*** removeAllAppenders();
	*** removeAppender(java.lang.String);
	*** removeAppender(org.apache.log4j.Appender);
}

-keep class org.apache.log4j.helpers.CountingQuietWriter {
	*** count;
	*** getCount();
	*** setCount(long);
}

-keep class org.apache.log4j.helpers.DateTimeDateFormat {
	*** shortMonths;
	org.apache.log4j.helpers.DateTimeDateFormat();
}

-keep class org.apache.log4j.helpers.FileWatchdog {
	*** setDelay(long);
}

-keep class org.apache.log4j.helpers.FormattingInfo {
	*** leftAlign;
	*** max;
	*** min;
	*** reset();
}

-keep class org.apache.log4j.helpers.ISO8601DateFormat {
	*** lastTime;
	*** lastTimeString;
}

-keep class org.apache.log4j.helpers.Loader {
	*** class$java$lang$Thread;
	*** class$org$apache$log4j$helpers$Loader;
	*** ignoreTCL;
	*** java1;
	*** class$(java.lang.String);
	*** getResource(java.lang.String);
	*** getTCL();
	*** loadClass(java.lang.String);
}

-keep class org.apache.log4j.helpers.LogLog {
	*** debugEnabled;
	*** quietMode;
	*** debug(java.lang.String);
	*** debug(java.lang.String,java.lang.Throwable);
	*** error(java.lang.String);
	*** error(java.lang.String,java.lang.Throwable);
	*** setInternalDebugging(boolean);
	*** warn(java.lang.String);
	*** warn(java.lang.String,java.lang.Throwable);
}

-keep class org.apache.log4j.helpers.NullEnumeration {
	*** getInstance();
}

-keep class org.apache.log4j.helpers.OnlyOnceErrorHandler {
	*** ERROR_PREFIX;
	*** WARN_PREFIX;
	*** firstTime;
	*** error(java.lang.String,java.lang.Exception,int,org.apache.log4j.spi.LoggingEvent);
}

-keep class org.apache.log4j.helpers.OptionConverter {
	*** DELIM_START;
	*** DELIM_START_LEN;
	*** DELIM_STOP;
	*** DELIM_STOP_LEN;
	*** class$java$lang$String;
	*** class$org$apache$log4j$Level;
	*** class$org$apache$log4j$spi$Configurator;
	*** class$(java.lang.String);
	*** findAndSubst(java.lang.String,java.util.Properties);
	*** getSystemProperty(java.lang.String,java.lang.String);
	*** instantiateByClassName(java.lang.String,java.lang.Class,java.lang.Object);
	*** instantiateByKey(java.util.Properties,java.lang.String,java.lang.Class,java.lang.Object);
	*** selectAndConfigure(java.net.URL,java.lang.String,org.apache.log4j.spi.LoggerRepository);
	*** substVars(java.lang.String,java.util.Properties);
	*** toBoolean(java.lang.String,boolean);
	*** toFileSize(java.lang.String,long);
	*** toLevel(java.lang.String,org.apache.log4j.Level);
}

-keep class org.apache.log4j.helpers.PatternConverter {
	*** SPACES;
	*** leftAlign;
	*** max;
	*** min;
	*** next;
	org.apache.log4j.helpers.PatternConverter();
	org.apache.log4j.helpers.PatternConverter(org.apache.log4j.helpers.FormattingInfo);
	*** convert(org.apache.log4j.spi.LoggingEvent);
	*** format(java.lang.StringBuffer,org.apache.log4j.spi.LoggingEvent);
	*** spacePad(java.lang.StringBuffer,int);
}

-keep class org.apache.log4j.helpers.PatternParser {
	*** class$java$text$DateFormat;
	*** currentLiteral;
	*** formattingInfo;
	*** head;
	*** i;
	*** pattern;
	*** patternLength;
	*** state;
	*** tail;
	*** addConverter(org.apache.log4j.helpers.PatternConverter);
	*** addToList(org.apache.log4j.helpers.PatternConverter);
	*** class$(java.lang.String);
	*** extractOption();
	*** extractPrecisionOption();
	*** finalizeConverter(char);
	*** parse();
}

-keep class org.apache.log4j.helpers.PatternParser$BasicPatternConverter {
	*** type;
}

-keep class org.apache.log4j.helpers.PatternParser$CategoryPatternConverter {
	*** this$0;
}

-keep class org.apache.log4j.helpers.PatternParser$ClassNamePatternConverter {
	*** this$0;
}

-keep class org.apache.log4j.helpers.PatternParser$DatePatternConverter {
	*** date;
	*** df;
}

-keep class org.apache.log4j.helpers.PatternParser$LiteralPatternConverter {
	*** literal;
}

-keep class org.apache.log4j.helpers.PatternParser$LocationPatternConverter {
	*** this$0;
	*** type;
}

-keep class org.apache.log4j.helpers.PatternParser$MDCPatternConverter {
	*** key;
}

-keep class org.apache.log4j.helpers.PatternParser$NamedPatternConverter {
	*** precision;
	org.apache.log4j.helpers.PatternParser$NamedPatternConverter(org.apache.log4j.helpers.FormattingInfo,int);
	*** getFullyQualifiedName(org.apache.log4j.spi.LoggingEvent);
}

-keep class org.apache.log4j.helpers.QuietWriter {
	*** errorHandler;
	org.apache.log4j.helpers.QuietWriter(java.io.Writer,org.apache.log4j.spi.ErrorHandler);
	*** flush();
	*** setErrorHandler(org.apache.log4j.spi.ErrorHandler);
	*** write(java.lang.String);
}

-keep class org.apache.log4j.or.ObjectRenderer {
	*** doRender(java.lang.Object);
}

-keep class org.apache.log4j.or.RendererMap {
	*** class$org$apache$log4j$or$ObjectRenderer;
	*** defaultRenderer;
	*** map;
	*** addRenderer(org.apache.log4j.spi.RendererSupport,java.lang.String,java.lang.String);
	*** class$(java.lang.String);
	*** clear();
	*** findAndRender(java.lang.Object);
	*** get(java.lang.Class);
	*** put(java.lang.Class,org.apache.log4j.or.ObjectRenderer);
	*** searchInterfaces(java.lang.Class);
}

-keep class org.apache.log4j.spi.Configurator {
	*** doConfigure(java.io.InputStream,org.apache.log4j.spi.LoggerRepository);
	*** doConfigure(java.net.URL,org.apache.log4j.spi.LoggerRepository);
}

-keep class org.apache.log4j.spi.DefaultRepositorySelector {
	*** repository;
}

-keep class org.apache.log4j.spi.ErrorHandler {
	*** error(java.lang.String);
	*** error(java.lang.String,java.lang.Exception,int);
	*** setBackupAppender(org.apache.log4j.Appender);
	*** setLogger(org.apache.log4j.Logger);
}

-keep class org.apache.log4j.spi.Filter {
	*** next;
	*** decide(org.apache.log4j.spi.LoggingEvent);
	*** getNext();
	*** setNext(org.apache.log4j.spi.Filter);
}

-keep class org.apache.log4j.spi.HierarchyEventListener {
	*** addAppenderEvent(org.apache.log4j.Category,org.apache.log4j.Appender);
	*** removeAppenderEvent(org.apache.log4j.Category,org.apache.log4j.Appender);
}

-keep class org.apache.log4j.spi.LocationInfo {
	*** NA_LOCATION_INFO;
	*** class$java$lang$Throwable;
	*** className;
	*** fileName;
	*** fullInfo;
	*** getClassNameMethod;
	*** getFileNameMethod;
	*** getLineNumberMethod;
	*** getMethodNameMethod;
	*** getStackTraceMethod;
	*** inVisualAge;
	*** lineNumber;
	*** methodName;
	*** pw;
	*** sw;
	*** appendFragment(java.lang.StringBuffer,java.lang.String);
	*** class$(java.lang.String);
	*** getClassName();
	*** getFileName();
	*** getLineNumber();
	*** getMethodName();
}

-keep class org.apache.log4j.spi.LoggerFactory {
	*** makeNewLoggerInstance(java.lang.String);
}

-keep class org.apache.log4j.spi.LoggerRepository {
	*** emitNoAppenderWarning(org.apache.log4j.Category);
	*** exists(java.lang.String);
	*** fireAddAppenderEvent(org.apache.log4j.Category,org.apache.log4j.Appender);
	*** getCurrentLoggers();
	*** getLogger(java.lang.String);
	*** getLogger(java.lang.String,org.apache.log4j.spi.LoggerFactory);
	*** getRootLogger();
	*** getThreshold();
	*** isDisabled(int);
	*** resetConfiguration();
	*** setThreshold(org.apache.log4j.Level);
	*** shutdown();
}

-keep class org.apache.log4j.spi.LoggingEvent {
	*** PARAM_ARRAY;
	*** TO_LEVEL_PARAMS;
	*** categoryName;
	*** class$org$apache$log4j$Level;
	*** fqnOfCategoryClass;
	*** level;
	*** locationInfo;
	*** logger;
	*** mdcCopy;
	*** mdcCopyLookupRequired;
	*** message;
	*** methodCache;
	*** ndc;
	*** ndcLookupRequired;
	*** renderedMessage;
	*** startTime;
	*** threadName;
	*** throwableInfo;
	*** timeStamp;
	*** class$(java.lang.String);
	*** getLevel();
	*** getLocationInformation();
	*** getLoggerName();
	*** getMDC(java.lang.String);
	*** getMDCCopy();
	*** getNDC();
	*** getProperties();
	*** getRenderedMessage();
	*** getStartTime();
	*** getThreadName();
	*** getThrowableStrRep();
	*** readLevel(java.io.ObjectInputStream);
	*** writeLevel(java.io.ObjectOutputStream);
}

-keep class org.apache.log4j.spi.OptionHandler {
	*** activateOptions();
}

-keep class org.apache.log4j.spi.RendererSupport {
	*** getRendererMap();
	*** setRenderer(java.lang.Class,org.apache.log4j.or.ObjectRenderer);
}

-keep class org.apache.log4j.spi.RepositorySelector {
	*** getLoggerRepository();
}

-keep class org.apache.log4j.spi.RootLogger {
	*** setLevel(org.apache.log4j.Level);
}

-keep class org.apache.log4j.spi.ThrowableInformation {
	*** category;
	*** rep;
	*** throwable;
	*** getThrowableStrRep();
}

-keep class org.apache.log4j.spi.ThrowableRenderer {
	*** doRender(java.lang.Throwable);
}

-keep class org.apache.log4j.spi.ThrowableRendererSupport {
	*** getThrowableRenderer();
	*** setThrowableRenderer(org.apache.log4j.spi.ThrowableRenderer);
}

-keep class org.apache.xalan.res.XSLMessages {
	*** createMessage(java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xalan.templates.ElemTemplateElement {
	*** getParentElem();
	*** getParentNode();
	*** getPreviousSiblingElem();
	*** getStylesheetRoot();
}

-keep class org.apache.xalan.templates.ElemVariable {
	*** getIndex();
	*** getName();
	*** getSelect();
}

-keep class org.apache.xalan.templates.FuncKey {
	*** ISTRUE;
}

-keep class org.apache.xalan.templates.StylesheetRoot {
	*** getAvailableElements();
	*** getVariableOrParamComposed(org.apache.xml.utils.QName);
}

-keep class org.apache.xalan.transformer.KeyManager {
	*** getNodeSetDTMByKey(org.apache.xpath.XPathContext,int,org.apache.xml.utils.QName,org.apache.xml.utils.XMLString,org.apache.xml.utils.PrefixResolver);
}

-keep class org.apache.xalan.transformer.TransformerImpl {
	*** getKeyManager();
	*** getStylesheet();
}

-keep class org.apache.xerces.dom.AttrImpl {
	*** name;
	*** type;
	*** value;
	org.apache.xerces.dom.AttrImpl();
	org.apache.xerces.dom.AttrImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** checkNormalizationAfterInsert(org.apache.xerces.dom.ChildNode);
	*** checkNormalizationAfterRemove(org.apache.xerces.dom.ChildNode);
	*** cloneNode(boolean);
	*** getFirstChild();
	*** getName();
	*** getNodeName();
	*** getNodeValue();
	*** getOwnerElement();
	*** getSpecified();
	*** getValue();
	*** insertBefore(org.w3c.dom.Node,org.w3c.dom.Node);
	*** internalInsertBefore(org.w3c.dom.Node,org.w3c.dom.Node,boolean);
	*** internalRemoveChild(org.w3c.dom.Node,boolean);
	*** lastChild();
	*** lastChild(org.apache.xerces.dom.ChildNode);
	*** makeChildNode();
	*** removeChild(org.w3c.dom.Node);
	*** rename(java.lang.String);
	*** setIdAttribute(boolean);
	*** setOwnerDocument(org.apache.xerces.dom.CoreDocumentImpl);
	*** setSpecified(boolean);
	*** setType(java.lang.Object);
	*** setValue(java.lang.String);
	*** synchronizeChildren();
}

-keep class org.apache.xerces.dom.AttrNSImpl {
	*** localName;
	*** namespaceURI;
	org.apache.xerces.dom.AttrNSImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** rename(java.lang.String,java.lang.String);
	*** setName(java.lang.String,java.lang.String);
}

-keep class org.apache.xerces.dom.AttributeMap {
	*** addItem(org.w3c.dom.Node);
	*** cloneContent(org.apache.xerces.dom.NamedNodeMapImpl);
	*** cloneMap(org.apache.xerces.dom.NodeImpl);
	*** internalRemoveNamedItem(java.lang.String,boolean);
	*** internalRemoveNamedItemNS(java.lang.String,java.lang.String,boolean);
	*** moveSpecifiedAttributes(org.apache.xerces.dom.AttributeMap);
	*** reconcileDefaults(org.apache.xerces.dom.NamedNodeMapImpl);
	*** remove(org.apache.xerces.dom.AttrImpl,int,boolean);
	*** removeItem(org.w3c.dom.Node,boolean);
	*** safeRemoveNamedItem(java.lang.String);
	*** safeRemoveNamedItemNS(java.lang.String,java.lang.String);
	*** setNamedItem(org.w3c.dom.Node);
	*** setNamedItemNS(org.w3c.dom.Node);
}

-keep class org.apache.xerces.dom.CDATASectionImpl {
	org.apache.xerces.dom.CDATASectionImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
}

-keep class org.apache.xerces.dom.CharacterDataImpl {
	*** data;
	*** singletonNodeList;
	org.apache.xerces.dom.CharacterDataImpl();
	org.apache.xerces.dom.CharacterDataImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** getNodeValue();
	*** internalDeleteData(int,int,boolean);
	*** internalInsertData(int,java.lang.String,boolean);
	*** setData(java.lang.String);
	*** setNodeValue(java.lang.String);
	*** setNodeValueInternal(java.lang.String);
	*** setNodeValueInternal(java.lang.String,boolean);
}

-keep class org.apache.xerces.dom.ChildNode {
	*** nextSibling;
	*** previousSibling;
	org.apache.xerces.dom.ChildNode();
	org.apache.xerces.dom.ChildNode(org.apache.xerces.dom.CoreDocumentImpl);
	*** cloneNode(boolean);
	*** getNextSibling();
	*** getParentNode();
	*** getPreviousSibling();
	*** parentNode();
	*** previousSibling();
}

-keep class org.apache.xerces.dom.CommentImpl {
	org.apache.xerces.dom.CommentImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
}

-keep class org.apache.xerces.dom.CoreDOMImplementationImpl {
	*** assignDocTypeNumber();
	*** assignDocumentNumber();
	*** getDOMImplementation();
}

-keep class org.apache.xerces.dom.CoreDocumentImpl {
	*** actualEncoding;
	*** allowGrammarAccess;
	*** changes;
	*** class$org$w3c$dom$Document;
	*** docElement;
	*** docType;
	*** documentNumber;
	*** domNormalizer;
	*** encoding;
	*** errorChecking;
	*** fConfiguration;
	*** fDocumentURI;
	*** fFreeNLCache;
	*** fXPathEvaluator;
	*** identifiers;
	*** kidOK;
	*** nodeCounter;
	*** nodeTable;
	*** standalone;
	*** userData;
	*** version;
	*** xml11Version;
	*** xmlVersionChanged;
	org.apache.xerces.dom.CoreDocumentImpl();
	org.apache.xerces.dom.CoreDocumentImpl(boolean);
	org.apache.xerces.dom.CoreDocumentImpl(org.w3c.dom.DocumentType);
	org.apache.xerces.dom.CoreDocumentImpl(org.w3c.dom.DocumentType,boolean);
	*** addEventListener(org.apache.xerces.dom.NodeImpl,java.lang.String,org.w3c.dom.events.EventListener,boolean);
	*** callUserDataHandlers(org.w3c.dom.Node,org.w3c.dom.Node,short);
	*** callUserDataHandlers(org.w3c.dom.Node,org.w3c.dom.Node,short,java.util.Hashtable);
	*** canRenameElements(java.lang.String,java.lang.String,org.apache.xerces.dom.ElementImpl);
	*** changed();
	*** changes();
	*** checkDOMNSErr(java.lang.String,java.lang.String);
	*** checkNamespaceWF(java.lang.String,int,int);
	*** checkQName(java.lang.String,java.lang.String);
	*** class$(java.lang.String);
	*** cloneNode(org.apache.xerces.dom.CoreDocumentImpl,boolean);
	*** copyEventListeners(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl);
	*** createAttribute(java.lang.String);
	*** createAttributeNS(java.lang.String,java.lang.String);
	*** createAttributeNS(java.lang.String,java.lang.String,java.lang.String);
	*** createCDATASection(java.lang.String);
	*** createComment(java.lang.String);
	*** createDocumentFragment();
	*** createDocumentType(java.lang.String,java.lang.String,java.lang.String);
	*** createElement(java.lang.String);
	*** createElementDefinition(java.lang.String);
	*** createElementNS(java.lang.String,java.lang.String);
	*** createElementNS(java.lang.String,java.lang.String,java.lang.String);
	*** createEntity(java.lang.String);
	*** createEntityReference(java.lang.String);
	*** createNotation(java.lang.String);
	*** createProcessingInstruction(java.lang.String,java.lang.String);
	*** createTextNode(java.lang.String);
	*** deletedText(org.apache.xerces.dom.CharacterDataImpl,int,int);
	*** dispatchEvent(org.apache.xerces.dom.NodeImpl,org.w3c.dom.events.Event);
	*** freeNodeListCache(org.apache.xerces.dom.NodeListCache);
	*** getBaseURI();
	*** getDoctype();
	*** getDocumentURI();
	*** getIdentifier(java.lang.String);
	*** getImplementation();
	*** getMutationEvents();
	*** getNodeListCache(org.apache.xerces.dom.ParentNode);
	*** getNodeNumber();
	*** getNodeNumber(org.w3c.dom.Node);
	*** getUserData(org.apache.xerces.dom.NodeImpl);
	*** getUserData(org.w3c.dom.Node,java.lang.String);
	*** getUserDataRecord(org.w3c.dom.Node);
	*** getXmlEncoding();
	*** getXmlStandalone();
	*** getXmlVersion();
	*** importNode(org.w3c.dom.Node,boolean,boolean,java.util.HashMap);
	*** insertedNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean);
	*** insertedText(org.apache.xerces.dom.CharacterDataImpl,int,int);
	*** insertingNode(org.apache.xerces.dom.NodeImpl,boolean);
	*** isKidOK(org.w3c.dom.Node,org.w3c.dom.Node);
	*** isNormalizeDocRequired();
	*** isXML11Version();
	*** isXMLName(java.lang.String,boolean);
	*** modifiedAttrValue(org.apache.xerces.dom.AttrImpl,java.lang.String);
	*** modifiedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String,boolean);
	*** modifyingCharacterData(org.apache.xerces.dom.NodeImpl,boolean);
	*** putIdentifier(java.lang.String,org.w3c.dom.Element);
	*** removeEventListener(org.apache.xerces.dom.NodeImpl,java.lang.String,org.w3c.dom.events.EventListener,boolean);
	*** removeIdentifier(java.lang.String);
	*** removeUserDataTable(org.w3c.dom.Node);
	*** removedAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.NodeImpl,java.lang.String);
	*** removedNode(org.apache.xerces.dom.NodeImpl,boolean);
	*** removingNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean);
	*** renamedAttrNode(org.w3c.dom.Attr,org.w3c.dom.Attr);
	*** renamedElement(org.w3c.dom.Element,org.w3c.dom.Element);
	*** replaceRenameElement(org.apache.xerces.dom.ElementImpl,java.lang.String,java.lang.String);
	*** replacedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String);
	*** replacedNode(org.apache.xerces.dom.NodeImpl);
	*** replacedText(org.apache.xerces.dom.CharacterDataImpl);
	*** replacingData(org.apache.xerces.dom.NodeImpl);
	*** replacingNode(org.apache.xerces.dom.NodeImpl);
	*** setAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.AttrImpl);
	*** setDocumentURI(java.lang.String);
	*** setInputEncoding(java.lang.String);
	*** setMutationEvents(boolean);
	*** setStrictErrorChecking(boolean);
	*** setUserData(org.apache.xerces.dom.NodeImpl,java.lang.Object);
	*** setUserData(org.w3c.dom.Node,java.lang.String,java.lang.Object,org.w3c.dom.UserDataHandler);
	*** setUserDataTable(org.w3c.dom.Node,java.util.Hashtable);
	*** setXmlEncoding(java.lang.String);
	*** setXmlStandalone(boolean);
	*** setXmlVersion(java.lang.String);
	*** undeferChildren(org.w3c.dom.Node);
}

-keep class org.apache.xerces.dom.DOMConfigurationImpl {
	*** reset();
}

-keep class org.apache.xerces.dom.DOMErrorImpl {
	*** fRelatedData;
	*** fSeverity;
	*** fType;
}

-keep class org.apache.xerces.dom.DOMImplementationImpl {
	*** getDOMImplementation();
}

-keep class org.apache.xerces.dom.DOMMessageFormatter {
	*** formatMessage(java.lang.String,java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xerces.dom.DOMNormalizer {
	*** normalizeDocument(org.apache.xerces.dom.CoreDocumentImpl,org.apache.xerces.dom.DOMConfigurationImpl);
}

-keep class org.apache.xerces.dom.DeepNodeListImpl {
	*** changes;
	*** enableNS;
	*** nodes;
	*** nsName;
	*** rootNode;
	*** tagName;
	org.apache.xerces.dom.DeepNodeListImpl(org.apache.xerces.dom.NodeImpl,java.lang.String);
	*** item(int);
	*** nextMatchingElementAfter(org.w3c.dom.Node);
}

-keep class org.apache.xerces.dom.DeferredAttrImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredAttrNSImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredCDATASectionImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredCommentImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredDOMImplementationImpl {
	*** getDOMImplementation();
}

-keep class org.apache.xerces.dom.DeferredDocumentImpl {
	*** INIT_ARRAY;
	*** fBufferStr;
	*** fIdCount;
	*** fIdElement;
	*** fIdName;
	*** fNamespacesEnabled;
	*** fNodeCount;
	*** fNodeExtra;
	*** fNodeLastChild;
	*** fNodeName;
	*** fNodeParent;
	*** fNodePrevSib;
	*** fNodeType;
	*** fNodeURI;
	*** fNodeValue;
	*** fStrChunks;
	org.apache.xerces.dom.DeferredDocumentImpl(boolean);
	org.apache.xerces.dom.DeferredDocumentImpl(boolean,boolean);
	*** appendChild(int,int);
	*** binarySearch(int[],int,int,int);
	*** clearChunkIndex(int[][],int,int);
	*** clearChunkValue(java.lang.Object[][],int,int);
	*** cloneNode(int,boolean);
	*** createChunk(int[][],int);
	*** createChunk(java.lang.Object[][],int);
	*** createDeferredAttribute(java.lang.String,java.lang.String,java.lang.String,boolean);
	*** createDeferredCDATASection(java.lang.String);
	*** createDeferredComment(java.lang.String);
	*** createDeferredDocument();
	*** createDeferredDocumentType(java.lang.String,java.lang.String,java.lang.String);
	*** createDeferredElement(java.lang.String,java.lang.String);
	*** createDeferredElementDefinition(java.lang.String);
	*** createDeferredEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** createDeferredEntityReference(java.lang.String,java.lang.String);
	*** createDeferredNotation(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** createDeferredProcessingInstruction(java.lang.String,java.lang.String);
	*** createDeferredTextNode(java.lang.String,boolean);
	*** createNode(short);
	*** ensureCapacity(int);
	*** getChunkIndex(int[][],int,int);
	*** getChunkValue(java.lang.Object[][],int,int);
	*** getDeferredEntityBaseURI(int);
	*** getLastChild(int);
	*** getLastChild(int,boolean);
	*** getNodeExtra(int);
	*** getNodeExtra(int,boolean);
	*** getNodeName(int);
	*** getNodeName(int,boolean);
	*** getNodeObject(int);
	*** getNodeType(int);
	*** getNodeType(int,boolean);
	*** getNodeURI(int);
	*** getNodeURI(int,boolean);
	*** getNodeValue(int);
	*** getNodeValue(int,boolean);
	*** getNodeValueString(int);
	*** getNodeValueString(int,boolean);
	*** getParentNode(int,boolean);
	*** getPrevSibling(int);
	*** getPrevSibling(int,boolean);
	*** getRealPrevSibling(int);
	*** getRealPrevSibling(int,boolean);
	*** getTypeInfo(int);
	*** insertBefore(int,int,int);
	*** lookupElementDefinition(java.lang.String);
	*** putIdentifier(java.lang.String,int);
	*** putIdentifier0(java.lang.String,org.w3c.dom.Element);
	*** setAsLastChild(int,int);
	*** setChunkIndex(int[][],int,int,int);
	*** setChunkValue(java.lang.Object[][],java.lang.Object,int,int);
	*** setDeferredAttribute(int,java.lang.String,java.lang.String,java.lang.String,boolean);
	*** setDeferredAttribute(int,java.lang.String,java.lang.String,java.lang.String,boolean,boolean,java.lang.Object);
	*** setEntityInfo(int,java.lang.String,java.lang.String);
	*** setIdAttribute(int);
	*** setInputEncoding(int,java.lang.String);
	*** setInternalSubset(int,java.lang.String);
	*** setTypeInfo(int,java.lang.Object);
	*** synchronizeChildren(org.apache.xerces.dom.AttrImpl,int);
	*** synchronizeChildren(org.apache.xerces.dom.ParentNode,int);
	*** synchronizeData();
}

-keep class org.apache.xerces.dom.DeferredDocumentImpl$IntVector {
	*** addElement(int);
	*** elementAt(int);
	*** removeAllElements();
	*** size();
}

-keep class org.apache.xerces.dom.DeferredDocumentImpl$RefCount {
	*** fCount;
}

-keep class org.apache.xerces.dom.DeferredDocumentTypeImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredElementDefinitionImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredElementImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredElementNSImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredEntityImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredEntityReferenceImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredNode {
	*** getNodeIndex();
}

-keep class org.apache.xerces.dom.DeferredNotationImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredProcessingInstructionImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DeferredTextImpl {
	*** fNodeIndex;
}

-keep class org.apache.xerces.dom.DocumentImpl {
	*** eventListeners;
	*** iteratorReferenceQueue;
	*** iterators;
	*** mutationEvents;
	*** rangeReferenceQueue;
	*** ranges;
	*** savedEnclosingAttr;
	org.apache.xerces.dom.DocumentImpl(boolean);
	*** createNodeIterator(org.w3c.dom.Node,int,org.w3c.dom.traversal.NodeFilter,boolean);
	*** createTreeWalker(org.w3c.dom.Node,int,org.w3c.dom.traversal.NodeFilter,boolean);
	*** dispatchAggregateEvents(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.AttrImpl,java.lang.String,short);
	*** dispatchAggregateEvents(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.DocumentImpl$EnclosingAttr);
	*** dispatchEvent(org.apache.xerces.dom.NodeImpl,org.w3c.dom.events.Event);
	*** dispatchEventToSubtree(org.w3c.dom.Node,org.w3c.dom.events.Event);
	*** dispatchingEventToSubtree(org.w3c.dom.Node,org.w3c.dom.events.Event);
	*** getEventListeners(org.apache.xerces.dom.NodeImpl);
	*** getMutationEvents();
	*** modifiedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String,boolean);
	*** mutationEventsInsertedNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean);
	*** mutationEventsModifiedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String,boolean);
	*** mutationEventsRemovedAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.NodeImpl,java.lang.String);
	*** mutationEventsRemovingNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean);
	*** notifyIteratorsRemovingNode(org.apache.xerces.dom.NodeImpl);
	*** notifyRangesDeletedText(org.apache.xerces.dom.CharacterDataImpl,int,int);
	*** notifyRangesInsertedNode(org.apache.xerces.dom.NodeImpl);
	*** notifyRangesInsertedText(org.apache.xerces.dom.CharacterDataImpl,int,int);
	*** notifyRangesRemovingNode(org.apache.xerces.dom.NodeImpl);
	*** notifyRangesReplacedText(org.apache.xerces.dom.CharacterDataImpl);
	*** notifyRangesSplitData(org.w3c.dom.Node,org.w3c.dom.Node,int);
	*** removeEventListener(org.apache.xerces.dom.NodeImpl,java.lang.String,org.w3c.dom.events.EventListener,boolean);
	*** removeStaleIteratorReferences();
	*** removeStaleRangeReferences();
	*** removeStaleReferences(java.lang.ref.ReferenceQueue,java.util.List);
	*** saveEnclosingAttr(org.apache.xerces.dom.NodeImpl);
	*** setEventListeners(org.apache.xerces.dom.NodeImpl,java.util.Vector);
	*** setMutationEvents(boolean);
}

-keep class org.apache.xerces.dom.DocumentImpl$EnclosingAttr {
	*** node;
	*** oldvalue;
}

-keep class org.apache.xerces.dom.DocumentImpl$LEntry {
	*** listener;
	*** type;
	*** useCapture;
}

-keep class org.apache.xerces.dom.DocumentTypeImpl {
	*** doctypeNumber;
	*** elements;
	*** entities;
	*** internalSubset;
	*** name;
	*** notations;
	*** publicID;
	*** systemID;
	*** userData;
	org.apache.xerces.dom.DocumentTypeImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** getElements();
	*** getEntities();
	*** getInternalSubset();
	*** getNotations();
	*** getPublicId();
	*** getSystemId();
	*** setInternalSubset(java.lang.String);
	*** setReadOnly(boolean,boolean);
}

-keep class org.apache.xerces.dom.ElementDefinitionImpl {
	*** attributes;
	*** name;
	org.apache.xerces.dom.ElementDefinitionImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** getAttributes();
}

-keep class org.apache.xerces.dom.ElementImpl {
	*** attributes;
	*** name;
	org.apache.xerces.dom.ElementImpl();
	org.apache.xerces.dom.ElementImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** getAttributeNode(java.lang.String);
	*** getAttributeNodeNS(java.lang.String,java.lang.String);
	*** getAttributes();
	*** getDefaultAttributes();
	*** getFirstElementChild();
	*** getFirstElementChild(org.w3c.dom.Node);
	*** getLastElementChild(org.w3c.dom.Node);
	*** getNextElementSibling();
	*** getNextLogicalSibling(org.w3c.dom.Node);
	*** getNodeName();
	*** getPreviousLogicalSibling(org.w3c.dom.Node);
	*** getTagName();
	*** getXMLBaseAttribute();
	*** hasAttributes();
	*** moveSpecifiedAttributes(org.apache.xerces.dom.ElementImpl);
	*** reconcileDefaultAttributes();
	*** rename(java.lang.String);
	*** setIdAttributeNode(org.w3c.dom.Attr,boolean);
	*** setupDefaultAttributes();
	*** synchronizeData();
}

-keep class org.apache.xerces.dom.ElementNSImpl {
	*** localName;
	*** namespaceURI;
	*** type;
	org.apache.xerces.dom.ElementNSImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** rename(java.lang.String,java.lang.String);
	*** setName(java.lang.String,java.lang.String);
	*** setType(org.apache.xerces.xs.XSTypeDefinition);
}

-keep class org.apache.xerces.dom.EntityImpl {
	*** baseURI;
	*** encoding;
	*** inputEncoding;
	*** name;
	*** notationName;
	*** publicId;
	*** systemId;
	*** version;
	org.apache.xerces.dom.EntityImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** getBaseURI();
	*** setBaseURI(java.lang.String);
	*** setInputEncoding(java.lang.String);
	*** setNotationName(java.lang.String);
	*** setPublicId(java.lang.String);
	*** setSystemId(java.lang.String);
	*** setXmlEncoding(java.lang.String);
	*** setXmlVersion(java.lang.String);
}

-keep class org.apache.xerces.dom.EntityReferenceImpl {
	*** baseURI;
	*** name;
	org.apache.xerces.dom.EntityReferenceImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** getBaseURI();
	*** getEntityRefValue();
	*** getNodeName();
	*** setBaseURI(java.lang.String);
	*** setReadOnly(boolean,boolean);
	*** synchronizeChildren();
}

-keep class org.apache.xerces.dom.LCount {
	*** bubbles;
	*** captures;
	*** defaults;
	*** total;
	*** lookup(java.lang.String);
}

-keep class org.apache.xerces.dom.NamedNodeMapImpl {
	*** flags;
	*** nodes;
	*** ownerNode;
	org.apache.xerces.dom.NamedNodeMapImpl(org.apache.xerces.dom.NodeImpl);
	*** cloneContent(org.apache.xerces.dom.NamedNodeMapImpl);
	*** cloneMap(org.apache.xerces.dom.NodeImpl);
	*** findNamePoint(java.lang.String,int);
	*** findNamePoint(java.lang.String,java.lang.String);
	*** getLength();
	*** getNamedItem(java.lang.String);
	*** getNamedItemIndex(java.lang.String,java.lang.String);
	*** getNamedItemNS(java.lang.String,java.lang.String);
	*** hasDefaults();
	*** hasDefaults(boolean);
	*** isReadOnly();
	*** isReadOnly(boolean);
	*** item(int);
	*** precedes(org.w3c.dom.Node,org.w3c.dom.Node);
	*** setNamedItem(org.w3c.dom.Node);
	*** setOwnerDocument(org.apache.xerces.dom.CoreDocumentImpl);
	*** setReadOnly(boolean,boolean);
}

-keep class org.apache.xerces.dom.NodeImpl {
	*** flags;
	*** ownerNode;
	org.apache.xerces.dom.NodeImpl();
	org.apache.xerces.dom.NodeImpl(org.apache.xerces.dom.CoreDocumentImpl);
	*** appendChild(org.w3c.dom.Node);
	*** changed();
	*** changes();
	*** cloneNode(boolean);
	*** dispatchEvent(org.w3c.dom.events.Event);
	*** getAttributes();
	*** getBaseURI();
	*** getElementAncestor(org.w3c.dom.Node);
	*** getFeature(java.lang.String,java.lang.String);
	*** getFirstChild();
	*** getLocalName();
	*** getNamespaceURI();
	*** getNodeName();
	*** getNodeNumber();
	*** getNodeType();
	*** getNodeValue();
	*** getOwnerDocument();
	*** getParentNode();
	*** getPrefix();
	*** getTextContent();
	*** getTextContent(java.lang.StringBuffer);
	*** getUserDataRecord();
	*** hasAttributes();
	*** hasStringValue();
	*** hasStringValue(boolean);
	*** insertBefore(org.w3c.dom.Node,org.w3c.dom.Node);
	*** internalIsIgnorableWhitespace();
	*** isDefaultNamespace(java.lang.String);
	*** isEqualNode(org.w3c.dom.Node);
	*** isFirstChild();
	*** isFirstChild(boolean);
	*** isIdAttribute();
	*** isIdAttribute(boolean);
	*** isIgnorableWhitespace(boolean);
	*** isNormalized();
	*** isNormalized(boolean);
	*** isOwned();
	*** isOwned(boolean);
	*** isReadOnly();
	*** isReadOnly(boolean);
	*** isSpecified();
	*** isSpecified(boolean);
	*** isSupported(java.lang.String,java.lang.String);
	*** lookupNamespacePrefix(java.lang.String,org.apache.xerces.dom.ElementImpl);
	*** lookupNamespaceURI(java.lang.String);
	*** lookupPrefix(java.lang.String);
	*** needsSyncChildren();
	*** needsSyncChildren(boolean);
	*** needsSyncData();
	*** needsSyncData(boolean);
	*** normalize();
	*** ownerDocument();
	*** parentNode();
	*** removeChild(org.w3c.dom.Node);
	*** setNodeValue(java.lang.String);
	*** setOwnerDocument(org.apache.xerces.dom.CoreDocumentImpl);
	*** setReadOnly(boolean,boolean);
	*** synchronizeData();
}

-keep class org.apache.xerces.dom.NodeIteratorImpl {
	*** removeNode(org.w3c.dom.Node);
}

-keep class org.apache.xerces.dom.NodeListCache {
	*** fChild;
	*** fChildIndex;
	*** fLength;
	*** fOwner;
	*** next;
}

-keep class org.apache.xerces.dom.NotationImpl {
	*** baseURI;
	*** name;
	*** publicId;
	*** systemId;
	org.apache.xerces.dom.NotationImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** setBaseURI(java.lang.String);
	*** setPublicId(java.lang.String);
	*** setSystemId(java.lang.String);
}

-keep class org.apache.xerces.dom.ObjectFactory {
	*** findClassLoader();
	*** findProviderClass(java.lang.String,java.lang.ClassLoader,boolean);
}

-keep class org.apache.xerces.dom.PSVIAttrNSImpl {
	*** setPSVI(org.apache.xerces.xs.AttributePSVI);
}

-keep class org.apache.xerces.dom.PSVIElementNSImpl {
	*** setPSVI(org.apache.xerces.xs.ElementPSVI);
}

-keep class org.apache.xerces.dom.ParentNode {
	*** fNodeListCache;
	*** firstChild;
	*** ownerDocument;
	org.apache.xerces.dom.ParentNode();
	org.apache.xerces.dom.ParentNode(org.apache.xerces.dom.CoreDocumentImpl);
	*** checkNormalizationAfterInsert(org.apache.xerces.dom.ChildNode);
	*** checkNormalizationAfterRemove(org.apache.xerces.dom.ChildNode);
	*** cloneNode(boolean);
	*** getFirstChild();
	*** getLastChild();
	*** getOwnerDocument();
	*** getTextContent(java.lang.StringBuffer);
	*** hasTextContent(org.w3c.dom.Node);
	*** insertBefore(org.w3c.dom.Node,org.w3c.dom.Node);
	*** internalInsertBefore(org.w3c.dom.Node,org.w3c.dom.Node,boolean);
	*** internalRemoveChild(org.w3c.dom.Node,boolean);
	*** isEqualNode(org.w3c.dom.Node);
	*** lastChild();
	*** lastChild(org.apache.xerces.dom.ChildNode);
	*** nodeListGetLength();
	*** nodeListItem(int);
	*** ownerDocument();
	*** removeChild(org.w3c.dom.Node);
	*** replaceChild(org.w3c.dom.Node,org.w3c.dom.Node);
	*** setOwnerDocument(org.apache.xerces.dom.CoreDocumentImpl);
	*** setReadOnly(boolean,boolean);
	*** synchronizeChildren();
}

-keep class org.apache.xerces.dom.ParentNode$UserDataRecord {
	*** fData;
	*** fHandler;
}

-keep class org.apache.xerces.dom.ProcessingInstructionImpl {
	*** target;
	org.apache.xerces.dom.ProcessingInstructionImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String,java.lang.String);
}

-keep class org.apache.xerces.dom.RangeImpl {
	*** insertedNodeFromDOM(org.w3c.dom.Node);
	*** receiveDeletedText(org.apache.xerces.dom.CharacterDataImpl,int,int);
	*** receiveInsertedText(org.apache.xerces.dom.CharacterDataImpl,int,int);
	*** receiveReplacedText(org.apache.xerces.dom.CharacterDataImpl);
	*** receiveSplitData(org.w3c.dom.Node,org.w3c.dom.Node,int);
	*** removeNode(org.w3c.dom.Node);
}

-keep class org.apache.xerces.dom.TextImpl {
	org.apache.xerces.dom.TextImpl(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String);
	*** canModifyNext(org.w3c.dom.Node);
	*** canModifyPrev(org.w3c.dom.Node);
	*** getWholeTextBackward(org.w3c.dom.Node,java.lang.StringBuffer,org.w3c.dom.Node);
	*** getWholeTextForward(org.w3c.dom.Node,java.lang.StringBuffer,org.w3c.dom.Node);
	*** hasTextOnlyChildren(org.w3c.dom.Node);
	*** insertTextContent(java.lang.StringBuffer);
	*** isIgnorableWhitespace();
	*** removeData();
	*** replaceData(java.lang.String);
	*** setIgnorableWhitespace(boolean);
}

-keep class org.apache.xerces.dom.events.EventImpl {
	*** bubbles;
	*** cancelable;
	*** currentTarget;
	*** eventPhase;
	*** initialized;
	*** preventDefault;
	*** stopPropagation;
	*** target;
	*** type;
	*** getType();
}

-keep class org.apache.xerces.dom.events.MutationEventImpl {
	*** initMutationEvent(java.lang.String,boolean,boolean,org.w3c.dom.Node,java.lang.String,java.lang.String,java.lang.String,short);
}

-keep class org.apache.xerces.impl.Constants {
	*** NS_DTD;
	*** NS_XMLSCHEMA;
	*** fgEmptyEnumeration;
	*** fgSAXFeatures;
	*** fgSAXProperties;
	*** fgXercesFeatures;
	*** fgXercesProperties;
	*** print(java.lang.String,java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xerces.impl.Constants$ArrayEnumeration {
	*** array;
	*** index;
}

-keep class org.apache.xerces.impl.ExternalSubsetResolver {
	*** getExternalSubset(org.apache.xerces.xni.grammars.XMLDTDDescription);
}

-keep class org.apache.xerces.impl.XML11NSDocumentScannerImpl {
	*** setDTDValidator(org.apache.xerces.impl.dtd.XMLDTDValidatorFilter);
}

-keep class org.apache.xerces.impl.XMLDTDScannerImpl {
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** fContentDepth;
	*** fContentStack;
	*** fDTDContentModelHandler;
	*** fDTDHandler;
	*** fEnumeration;
	*** fEnumerationCount;
	*** fExtEntityDepth;
	*** fIgnoreConditionalBuffer;
	*** fIncludeSectDepth;
	*** fLiteral;
	*** fLiteral2;
	*** fMarkUpDepth;
	*** fPEDepth;
	*** fPEReport;
	*** fPEStack;
	*** fScannerState;
	*** fSeenExternalDTD;
	*** fSeenPEReferences;
	*** fStandalone;
	*** fStartDTDCalled;
	*** fString;
	*** fStringBuffer;
	*** fStringBuffer2;
	*** fStrings;
	*** ensureEnumerationSize(int);
	*** init();
	*** peekReportEntity();
	*** popContentStack();
	*** popPEStack();
	*** pushContentStack(int);
	*** pushPEStack(int,boolean);
	*** scanAttDefaultDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString);
	*** scanAttType(java.lang.String,java.lang.String);
	*** scanAttlistDecl();
	*** scanChildren(java.lang.String);
	*** scanComment();
	*** scanConditionalSect(int);
	*** scanDecls(boolean);
	*** scanElementDecl();
	*** scanEntityDecl();
	*** scanEntityValue(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString);
	*** scanMixed(java.lang.String);
	*** scanNotationDecl();
	*** scanPIData(java.lang.String,org.apache.xerces.xni.XMLString);
	*** scanTextDecl();
	*** scanningInternalSubset();
	*** setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler);
	*** setDTDHandler(org.apache.xerces.xni.XMLDTDHandler);
	*** setScannerState(int);
	*** skipInvalidEnumerationValue();
	*** skipSeparator(boolean,boolean);
	*** startPE(java.lang.String,boolean);
}

-keep class org.apache.xerces.impl.XMLDocumentFragmentScannerImpl {
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** fAttributeQName;
	*** fAttributes;
	*** fContentDispatcher;
	*** fCurrentElement;
	*** fDispatcher;
	*** fDocumentHandler;
	*** fElementQName;
	*** fElementStack;
	*** fEntityStack;
	*** fExternalSubsetResolver;
	*** fHasExternalDTD;
	*** fInScanContent;
	*** fIsEntityDeclaredVC;
	*** fMarkupDepth;
	*** fNotifyBuiltInRefs;
	*** fQName;
	*** fSawSpace;
	*** fScannerState;
	*** fSingleChar;
	*** fStandalone;
	*** fStringBuffer;
	*** fStringBuffer2;
	*** fStrings;
	*** fTempAugmentations;
	*** fTempString;
	*** fTempString2;
	org.apache.xerces.impl.XMLDocumentFragmentScannerImpl();
	*** access$000(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl);
	*** createContentDispatcher();
	*** endEntity(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** getFeatureDefault(java.lang.String);
	*** getPropertyDefault(java.lang.String);
	*** getRecognizedFeatures();
	*** getRecognizedProperties();
	*** getScannerStateName(int);
	*** handleCharacter(char,java.lang.String);
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** scanAttribute(org.apache.xerces.xni.XMLAttributes);
	*** scanCDATASection(boolean);
	*** scanCharReference();
	*** scanComment();
	*** scanContent();
	*** scanEndElement();
	*** scanEntityReference();
	*** scanPIData(java.lang.String,org.apache.xerces.xni.XMLString);
	*** scanStartElement();
	*** scanStartElementAfterName();
	*** scanStartElementName();
	*** scanXMLDeclOrTextDecl(boolean);
	*** setDispatcher(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher);
	*** setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler);
	*** setFeature(java.lang.String,boolean);
	*** setProperty(java.lang.String,java.lang.Object);
	*** setScannerState(int);
	*** startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher {
	*** dispatch(boolean);
}

-keep class org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack {
	*** fElements;
	*** fSize;
	*** clear();
	*** popElement(org.apache.xerces.xni.QName);
	*** pushElement(org.apache.xerces.xni.QName);
}

-keep class org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher {
	*** this$0;
	org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl);
	*** elementDepthIsZeroHook();
	*** endOfFileHook(java.io.EOFException);
	*** scanForDoctypeHook();
	*** scanRootElementHook();
}

-keep class org.apache.xerces.impl.XMLDocumentScannerImpl {
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** fDTDDescription;
	*** fDTDDispatcher;
	*** fDTDScanner;
	*** fDisallowDoctype;
	*** fDoctypeName;
	*** fDoctypePublicId;
	*** fDoctypeSystemId;
	*** fExternalSubsetSource;
	*** fLoadExternalDTD;
	*** fNamespaceContext;
	*** fPrologDispatcher;
	*** fScanningDTD;
	*** fSeenDoctypeDecl;
	*** fString;
	*** fStringBuffer;
	*** fStrings;
	*** fTrailingMiscDispatcher;
	*** fValidationManager;
	*** fXMLDeclDispatcher;
	org.apache.xerces.impl.XMLDocumentScannerImpl();
	*** access$000(org.apache.xerces.impl.XMLDocumentScannerImpl);
	*** access$100(org.apache.xerces.impl.XMLDocumentScannerImpl);
	*** access$200(org.apache.xerces.impl.XMLDocumentScannerImpl);
	*** access$202(org.apache.xerces.impl.XMLDocumentScannerImpl,org.apache.xerces.xni.parser.XMLInputSource);
	*** access$300(org.apache.xerces.impl.XMLDocumentScannerImpl);
	*** getScannerStateName(int);
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** scanDoctypeDecl();
}

-keep class org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher {
	*** this$0;
	org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher(org.apache.xerces.impl.XMLDocumentScannerImpl);
	*** resolveExternalSubsetAndRead();
}

-keep class org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher {
	*** this$0;
}

-keep class org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher {
	*** this$0;
}

-keep class org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher {
	*** this$0;
}

-keep class org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher {
	*** this$0;
}

-keep class org.apache.xerces.impl.XMLEntityHandler {
	*** endEntity(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.impl.XMLEntityManager {
	*** DTDEntity;
	*** FEATURE_DEFAULTS;
	*** GET_USER_DIR_SYSTEM_PROPERTY;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** XMLEntity;
	*** fAllowJavaEncodings;
	*** fBufferSize;
	*** fCharacterBufferPool;
	*** fCurrentEntity;
	*** fDeclaredEntities;
	*** fEntities;
	*** fEntityAugs;
	*** fEntityExpansionCount;
	*** fEntityExpansionLimit;
	*** fEntityHandler;
	*** fEntityResolver;
	*** fEntityScanner;
	*** fEntityStack;
	*** fErrorReporter;
	*** fExternalGeneralEntities;
	*** fExternalParameterEntities;
	*** fHasPEReferences;
	*** fInExternalSubset;
	*** fLargeByteBufferPool;
	*** fReaderStack;
	*** fResourceIdentifier;
	*** fSecurityManager;
	*** fSmallByteBufferPool;
	*** fStandalone;
	*** fStrictURI;
	*** fSymbolTable;
	*** fTempByteBuffer;
	*** fValidation;
	*** fValidationManager;
	*** fWarnDuplicateEntityDef;
	*** fXML10EntityScanner;
	*** fXML11EntityScanner;
	*** gAfterEscaping1;
	*** gAfterEscaping2;
	*** gHexChs;
	*** gNeedEscaping;
	*** gUserDir;
	*** gUserDirURI;
	org.apache.xerces.impl.XMLEntityManager(org.apache.xerces.impl.XMLEntityManager);
	*** access$200(org.apache.xerces.impl.XMLEntityManager);
	*** access$400(org.apache.xerces.impl.XMLEntityManager);
	*** access$402(org.apache.xerces.impl.XMLEntityManager,byte[]);
	*** addExternalEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** addInternalEntity(java.lang.String,java.lang.String);
	*** addUnparsedEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** closeReaders();
	*** createASCIIReader(java.io.InputStream);
	*** createLatin1Reader(java.io.InputStream);
	*** createReader(java.io.InputStream,java.lang.String,java.lang.Boolean);
	*** createUTF16Reader(java.io.InputStream,boolean);
	*** createUTF8Reader(java.io.InputStream);
	*** endEntity();
	*** endExternalSubset();
	*** expandSystemId(java.lang.String,java.lang.String,boolean);
	*** expandSystemIdStrictOff(java.lang.String,java.lang.String);
	*** expandSystemIdStrictOn(java.lang.String,java.lang.String);
	*** fixURI(java.lang.String);
	*** getCurrentEntity();
	*** getCurrentResourceIdentifier();
	*** getDeclaredEntities();
	*** getEncodingInfo(byte[],int);
	*** getEntityScanner();
	*** getPathWithoutEscapes(java.lang.String);
	*** getUserDir();
	*** hasPEReferences();
	*** isDeclaredEntity(java.lang.String);
	*** isEntityDeclInExternalSubset(java.lang.String);
	*** isExternalEntity(java.lang.String);
	*** isUnparsedEntity(java.lang.String);
	*** notifyHasPEReferences();
	*** print(org.apache.xerces.impl.XMLEntityManager$ScannedEntity);
	*** reset();
	*** resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier);
	*** setEntityHandler(org.apache.xerces.impl.XMLEntityHandler);
	*** setProperty(java.lang.String,java.lang.Object);
	*** setScannerVersion(short);
	*** setStandalone(boolean);
	*** setupCurrentEntity(java.lang.String,org.apache.xerces.xni.parser.XMLInputSource,boolean,boolean);
	*** startDTDEntity(org.apache.xerces.xni.parser.XMLInputSource);
	*** startDocumentEntity(org.apache.xerces.xni.parser.XMLInputSource);
	*** startEntity(java.lang.String,boolean);
	*** startEntity(java.lang.String,org.apache.xerces.xni.parser.XMLInputSource,boolean,boolean);
	*** startExternalSubset();
}

-keep class org.apache.xerces.impl.XMLEntityManager$ByteBufferPool {
	*** fBufferSize;
	*** fByteBufferPool;
	*** fDepth;
	*** fPoolSize;
	org.apache.xerces.impl.XMLEntityManager$ByteBufferPool(int,int);
	*** getBuffer();
	*** returnBuffer(byte[]);
	*** setBufferSize(int);
}

-keep class org.apache.xerces.impl.XMLEntityManager$CharacterBuffer {
	*** ch;
	*** isExternal;
	*** access$300(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer);
	*** access$500(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer);
}

-keep class org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool {
	*** fExternalBufferPool;
	*** fExternalBufferSize;
	*** fExternalTop;
	*** fInternalBufferPool;
	*** fInternalBufferSize;
	*** fInternalTop;
	*** fPoolSize;
	org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool(int,int,int);
	*** getBuffer(boolean);
	*** init();
	*** returnBuffer(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer);
	*** setExternalBufferSize(int);
}

-keep class org.apache.xerces.impl.XMLEntityManager$EncodingInfo {
	*** EBCDIC;
	*** UCS_4_BIG_ENDIAN;
	*** UCS_4_LITTLE_ENDIAN;
	*** UCS_4_UNUSUAL_BYTE_ORDER;
	*** UTF_16_BIG_ENDIAN;
	*** UTF_16_BIG_ENDIAN_WITH_BOM;
	*** UTF_16_LITTLE_ENDIAN;
	*** UTF_16_LITTLE_ENDIAN_WITH_BOM;
	*** UTF_8;
	*** UTF_8_WITH_BOM;
	*** encoding;
	*** hasBOM;
	*** isBigEndian;
}

-keep class org.apache.xerces.impl.XMLEntityManager$Entity {
	*** inExternalSubset;
	*** name;
	org.apache.xerces.impl.XMLEntityManager$Entity();
	org.apache.xerces.impl.XMLEntityManager$Entity(java.lang.String,boolean);
	*** clear();
	*** isEntityDeclInExternalSubset();
	*** isExternal();
	*** isUnparsed();
	*** setValues(org.apache.xerces.impl.XMLEntityManager$Entity);
}

-keep class org.apache.xerces.impl.XMLEntityManager$ExternalEntity {
	*** entityLocation;
	*** notation;
	*** clear();
}

-keep class org.apache.xerces.impl.XMLEntityManager$InternalEntity {
	*** text;
	*** clear();
}

-keep class org.apache.xerces.impl.XMLEntityManager$RewindableInputStream {
	*** fData;
	*** fEndOffset;
	*** fInputStream;
	*** fLength;
	*** fMark;
	*** fOffset;
	*** fStartOffset;
	*** this$0;
	*** readAndBuffer();
}

-keep class org.apache.xerces.impl.XMLEntityManager$ScannedEntity {
	*** baseCharOffset;
	*** ch;
	*** columnNumber;
	*** count;
	*** encoding;
	*** entityLocation;
	*** externallySpecifiedEncoding;
	*** fByteBuffer;
	*** fCharacterBuffer;
	*** isExternal;
	*** lineNumber;
	*** literal;
	*** mayReadChunks;
	*** position;
	*** reader;
	*** startPosition;
	*** stream;
	*** this$0;
	*** xmlVersion;
	*** access$000(org.apache.xerces.impl.XMLEntityManager$ScannedEntity);
	*** access$100(org.apache.xerces.impl.XMLEntityManager$ScannedEntity);
	*** getCharacterOffset();
	*** getColumnNumber();
	*** getEncoding();
	*** getExpandedSystemId();
	*** getLineNumber();
	*** getLiteralSystemId();
	*** getXMLVersion();
	*** isEncodingExternallySpecified();
	*** isExternal();
	*** setEncodingExternallySpecified(boolean);
	*** setReader(java.io.InputStream,java.lang.String,java.lang.Boolean);
}

-keep class org.apache.xerces.impl.XMLEntityScanner {
	*** END_OF_DOCUMENT_ENTITY;
	*** fBufferSize;
	*** fCurrentEntity;
	*** fEntityManager;
	*** fErrorReporter;
	*** fSymbolTable;
	org.apache.xerces.impl.XMLEntityScanner();
	*** getBaseSystemId();
	*** isExternal();
	*** load(int,boolean);
	*** peekChar();
	*** reset(org.apache.xerces.util.SymbolTable,org.apache.xerces.impl.XMLEntityManager,org.apache.xerces.impl.XMLErrorReporter);
	*** scanChar();
	*** scanContent(org.apache.xerces.xni.XMLString);
	*** scanData(java.lang.String,org.apache.xerces.util.XMLStringBuffer);
	*** scanLiteral(int,org.apache.xerces.xni.XMLString);
	*** scanNCName();
	*** scanName();
	*** scanNmtoken();
	*** scanQName(org.apache.xerces.xni.QName);
	*** setBufferSize(int);
	*** setCurrentEntity(org.apache.xerces.impl.XMLEntityManager$ScannedEntity);
	*** setEncoding(java.lang.String);
	*** setXMLVersion(java.lang.String);
	*** skipChar(int);
	*** skipDeclSpaces();
	*** skipSpaces();
	*** skipString(java.lang.String);
}

-keep class org.apache.xerces.impl.XMLErrorReporter {
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** fContinueAfterFatalError;
	*** fDefaultErrorHandler;
	*** fErrorHandler;
	*** fLocale;
	*** fLocator;
	*** fMessageFormatters;
	*** fSaxProxy;
	*** getLocale();
	*** getMessageFormatter(java.lang.String);
	*** putMessageFormatter(java.lang.String,org.apache.xerces.util.MessageFormatter);
	*** reportError(java.lang.String,java.lang.String,java.lang.Object[],short);
	*** reportError(java.lang.String,java.lang.String,java.lang.Object[],short,java.lang.Exception);
	*** reportError(org.apache.xerces.xni.XMLLocator,java.lang.String,java.lang.String,java.lang.Object[],short);
	*** reportError(org.apache.xerces.xni.XMLLocator,java.lang.String,java.lang.String,java.lang.Object[],short,java.lang.Exception);
	*** setDocumentLocator(org.apache.xerces.xni.XMLLocator);
	*** setLocale(java.util.Locale);
}

-keep class org.apache.xerces.impl.XMLNSDocumentScannerImpl {
	*** fBindNamespaces;
	*** fDTDValidator;
	*** fPerformValidation;
	*** fSawSpace;
	*** access$000(org.apache.xerces.impl.XMLNSDocumentScannerImpl);
	*** scanAttribute(org.apache.xerces.util.XMLAttributesImpl);
	*** scanStartElement();
	*** scanStartElementAfterName();
	*** scanStartElementName();
	*** setDTDValidator(org.apache.xerces.impl.dtd.XMLDTDValidatorFilter);
}

-keep class org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher {
	*** this$0;
	*** reconfigurePipeline();
}

-keep class org.apache.xerces.impl.XMLScanner {
	*** fAmpSymbol;
	*** fAposSymbol;
	*** fCharRefLiteral;
	*** fEncodingSymbol;
	*** fEntityDepth;
	*** fEntityManager;
	*** fEntityScanner;
	*** fErrorReporter;
	*** fGtSymbol;
	*** fLtSymbol;
	*** fNamespaces;
	*** fNotifyCharRefs;
	*** fParserSettings;
	*** fQuotSymbol;
	*** fReportEntity;
	*** fResourceIdentifier;
	*** fScanningAttribute;
	*** fStandaloneSymbol;
	*** fString;
	*** fStringBuffer;
	*** fStringBuffer2;
	*** fStringBuffer3;
	*** fSymbolTable;
	*** fValidation;
	*** fVersionSymbol;
	org.apache.xerces.impl.XMLScanner();
	*** endEntity(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** getVersionNotSupportedKey();
	*** init();
	*** isInvalid(int);
	*** isInvalidLiteral(int);
	*** isUnchangedByNormalization(org.apache.xerces.xni.XMLString);
	*** isValidNCName(int);
	*** isValidNameChar(int);
	*** isValidNameStartChar(int);
	*** isValidNameStartHighSurrogate(int);
	*** normalizeWhitespace(org.apache.xerces.xni.XMLString);
	*** normalizeWhitespace(org.apache.xerces.xni.XMLString,int);
	*** reportFatalError(java.lang.String,java.lang.Object[]);
	*** reset();
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** scanAttributeValue(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,java.lang.String,boolean,java.lang.String);
	*** scanCharReferenceValue(org.apache.xerces.util.XMLStringBuffer,org.apache.xerces.util.XMLStringBuffer);
	*** scanComment(org.apache.xerces.util.XMLStringBuffer);
	*** scanExternalID(java.lang.String[],boolean);
	*** scanPI();
	*** scanPIData(java.lang.String,org.apache.xerces.xni.XMLString);
	*** scanPseudoAttribute(boolean,org.apache.xerces.xni.XMLString);
	*** scanPubidLiteral(org.apache.xerces.xni.XMLString);
	*** scanSurrogates(org.apache.xerces.util.XMLStringBuffer);
	*** scanXMLDeclOrTextDecl(boolean,java.lang.String[]);
	*** setFeature(java.lang.String,boolean);
	*** setProperty(java.lang.String,java.lang.Object);
	*** startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** versionSupported(java.lang.String);
}

-keep class org.apache.xerces.impl.XMLVersionDetector {
	*** XML11_VERSION;
	*** fEncoding;
	*** fEntityManager;
	*** fErrorReporter;
	*** fExpectedVersionString;
	*** fSymbolTable;
	*** fVersionSymbol;
	*** fXMLSymbol;
	*** determineDocVersion(org.apache.xerces.xni.parser.XMLInputSource);
	*** fixupCurrentEntity(org.apache.xerces.impl.XMLEntityManager,char[],int);
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** startDocumentParsing(org.apache.xerces.impl.XMLEntityHandler,short);
}

-keep class org.apache.xerces.impl.dtd.BalancedDTDGrammar {
	*** fDepth;
	*** fGroupIndexStack;
	*** fGroupIndexStackSizes;
	*** fMixed;
	*** fOpStack;
	*** addContentSpecNodes(int,int);
	*** addToCurrentGroup(int);
	*** initializeContentModelStacks();
}

-keep class org.apache.xerces.impl.dtd.DTDGrammar {
	*** fAttributeDecl;
	*** fAttributeDeclCount;
	*** fAttributeDeclDatatypeValidator;
	*** fAttributeDeclDefaultType;
	*** fAttributeDeclDefaultValue;
	*** fAttributeDeclEnumeration;
	*** fAttributeDeclIsExternal;
	*** fAttributeDeclName;
	*** fAttributeDeclNextAttributeDeclIndex;
	*** fAttributeDeclNonNormalizedDefaultValue;
	*** fAttributeDeclType;
	*** fContentSpec;
	*** fContentSpecCount;
	*** fContentSpecOtherValue;
	*** fContentSpecType;
	*** fContentSpecValue;
	*** fCurrentAttributeIndex;
	*** fCurrentElementIndex;
	*** fDTDContentModelSource;
	*** fDTDSource;
	*** fDepth;
	*** fElementDecl;
	*** fElementDeclContentModelValidator;
	*** fElementDeclContentSpecIndex;
	*** fElementDeclCount;
	*** fElementDeclFirstAttributeDeclIndex;
	*** fElementDeclIsExternal;
	*** fElementDeclLastAttributeDeclIndex;
	*** fElementDeclName;
	*** fElementDeclTab;
	*** fElementDeclType;
	*** fElementIndexMap;
	*** fEntityBaseSystemId;
	*** fEntityCount;
	*** fEntityDecl;
	*** fEntityInExternal;
	*** fEntityIndexMap;
	*** fEntityIsPE;
	*** fEntityName;
	*** fEntityNotation;
	*** fEntityPublicId;
	*** fEntitySystemId;
	*** fEntityValue;
	*** fEpsilonIndex;
	*** fGrammarDescription;
	*** fIsImmutable;
	*** fLeafCount;
	*** fMixed;
	*** fNodeIndexStack;
	*** fNotationBaseSystemId;
	*** fNotationCount;
	*** fNotationIndexMap;
	*** fNotationName;
	*** fNotationPublicId;
	*** fNotationSystemId;
	*** fOpStack;
	*** fPEDepth;
	*** fPEntityStack;
	*** fPrevNodeIndexStack;
	*** fQName;
	*** fQName2;
	*** fReadingExternalDTD;
	*** fSimpleType;
	*** fSymbolTable;
	*** nodeIndex;
	*** prevNodeIndex;
	*** valueIndex;
	org.apache.xerces.impl.dtd.DTDGrammar(org.apache.xerces.util.SymbolTable,org.apache.xerces.impl.dtd.XMLDTDDescription);
	*** addContentSpecNode(short,int,int);
	*** addContentSpecNode(short,java.lang.String);
	*** addContentSpecToElement(org.apache.xerces.impl.dtd.XMLElementDecl);
	*** addUniqueLeafNode(java.lang.String);
	*** any(org.apache.xerces.xni.Augmentations);
	*** appendContentSpec(org.apache.xerces.impl.dtd.XMLContentSpec,java.lang.StringBuffer,boolean,int);
	*** attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String[],java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** buildSyntaxTree(int,org.apache.xerces.impl.dtd.XMLContentSpec);
	*** comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** contentSpecTree(int,org.apache.xerces.impl.dtd.XMLContentSpec,org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList);
	*** createAttributeDecl();
	*** createChildModel(int);
	*** createContentSpec();
	*** createElementDecl();
	*** createEntityDecl();
	*** createNotationDecl();
	*** element(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** elementDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** empty(org.apache.xerces.xni.Augmentations);
	*** endAttlist(org.apache.xerces.xni.Augmentations);
	*** endConditional(org.apache.xerces.xni.Augmentations);
	*** endContentModel(org.apache.xerces.xni.Augmentations);
	*** endDTD(org.apache.xerces.xni.Augmentations);
	*** endExternalSubset(org.apache.xerces.xni.Augmentations);
	*** endGroup(org.apache.xerces.xni.Augmentations);
	*** endParameterEntity(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** ensureAttributeDeclCapacity(int);
	*** ensureContentSpecCapacity(int);
	*** ensureElementDeclCapacity(int);
	*** ensureEntityDeclCapacity(int);
	*** ensureNotationDeclCapacity(int);
	*** externalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations);
	*** getAttributeDecl(int,org.apache.xerces.impl.dtd.XMLAttributeDecl);
	*** getAttributeDeclIndex(int,java.lang.String);
	*** getAttributeDeclIsExternal(int);
	*** getContentSpec(int,org.apache.xerces.impl.dtd.XMLContentSpec);
	*** getContentSpecAsString(int);
	*** getContentSpecIndex(int);
	*** getContentSpecType(int);
	*** getElementContentModelValidator(int);
	*** getElementDecl(int,org.apache.xerces.impl.dtd.XMLElementDecl);
	*** getElementDeclIndex(java.lang.String);
	*** getElementDeclIndex(org.apache.xerces.xni.QName);
	*** getElementDeclIsExternal(int);
	*** getElementDeclName(int);
	*** getEntityDecl(int,org.apache.xerces.impl.dtd.XMLEntityDecl);
	*** getEntityDeclIndex(java.lang.String);
	*** getFirstAttributeDeclIndex(int);
	*** getFirstElementDeclIndex();
	*** getGrammarDescription();
	*** getNextAttributeDeclIndex(int);
	*** getNextElementDeclIndex(int);
	*** getNotationDeclIndex(java.lang.String);
	*** ignoredCharacters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** initializeContentModelStack();
	*** internalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** isImmutable();
	*** notationDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations);
	*** occurrence(short,org.apache.xerces.xni.Augmentations);
	*** pcdata(org.apache.xerces.xni.Augmentations);
	*** printAttribute(int);
	*** processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** resize(byte[][],int);
	*** resize(int[][],int);
	*** resize(java.lang.Object[][],int);
	*** resize(java.lang.String[][],int);
	*** resize(java.lang.String[][][],int);
	*** resize(org.apache.xerces.impl.dtd.models.ContentModelValidator[][],int);
	*** resize(org.apache.xerces.impl.dv.DatatypeValidator[][],int);
	*** resize(org.apache.xerces.xni.QName[][],int);
	*** resize(short[][],int);
	*** separator(short,org.apache.xerces.xni.Augmentations);
	*** setAttributeDecl(int,int,org.apache.xerces.impl.dtd.XMLAttributeDecl);
	*** setContentSpec(int,org.apache.xerces.impl.dtd.XMLContentSpec);
	*** setContentSpecIndex(int,int);
	*** setElementDecl(int,org.apache.xerces.impl.dtd.XMLElementDecl);
	*** setEntityDecl(int,org.apache.xerces.impl.dtd.XMLEntityDecl);
	*** setNotationDecl(int,org.apache.xerces.impl.dtd.XMLNotationDecl);
	*** startAttlist(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** startConditional(short,org.apache.xerces.xni.Augmentations);
	*** startContentModel(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** startDTD(org.apache.xerces.xni.XMLLocator,org.apache.xerces.xni.Augmentations);
	*** startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations);
	*** startGroup(org.apache.xerces.xni.Augmentations);
	*** startParameterEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** unparsedEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList {
	*** length;
	*** qname;
	*** type;
}

-keep class org.apache.xerces.impl.dtd.DTDGrammar$QNameHashtable {
	*** get(java.lang.String);
	*** put(java.lang.String,int);
}

-keep class org.apache.xerces.impl.dtd.DTDGrammarBucket {
	*** fActiveGrammar;
	*** fGrammars;
	*** fIsStandalone;
	*** clear();
	*** getActiveGrammar();
	*** getGrammar(org.apache.xerces.xni.grammars.XMLGrammarDescription);
	*** getStandalone();
	*** putGrammar(org.apache.xerces.impl.dtd.DTDGrammar);
	*** setActiveGrammar(org.apache.xerces.impl.dtd.DTDGrammar);
	*** setStandalone(boolean);
}

-keep class org.apache.xerces.impl.dtd.XMLAttributeDecl {
	*** name;
	*** optional;
	*** simpleType;
	*** setValues(org.apache.xerces.xni.QName,org.apache.xerces.impl.dtd.XMLSimpleType,boolean);
}

-keep class org.apache.xerces.impl.dtd.XMLContentSpec {
	*** otherValue;
	*** type;
	*** value;
	*** setValues(short,java.lang.Object,java.lang.Object);
}

-keep class org.apache.xerces.impl.dtd.XMLDTDDescription {
	*** fPossibleRoots;
	*** fRootName;
	*** getGrammarType();
	*** getRootName();
	*** setPossibleRoots(java.util.ArrayList);
	*** setRootName(java.lang.String);
}

-keep class org.apache.xerces.impl.dtd.XMLDTDProcessor {
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** fDTDContentModelHandler;
	*** fDTDContentModelSource;
	*** fDTDElementDeclName;
	*** fDTDElementDecls;
	*** fDTDGrammar;
	*** fDTDHandler;
	*** fDTDSource;
	*** fDTDValidation;
	*** fEntityDecl;
	*** fErrorReporter;
	*** fGrammarBucket;
	*** fGrammarPool;
	*** fInDTDIgnore;
	*** fMixed;
	*** fMixedElementTypes;
	*** fNDataDeclNotations;
	*** fNotationEnumVals;
	*** fPerformValidation;
	*** fSymbolTable;
	*** fTableOfIDAttributeNames;
	*** fTableOfNOTATIONAttributeNames;
	*** fValidation;
	*** fValidator;
	*** fWarnDuplicateAttdef;
	*** fWarnOnUndeclaredElemdef;
	*** checkDeclaredElements(org.apache.xerces.impl.dtd.DTDGrammar);
	*** checkDeclaredElements(org.apache.xerces.impl.dtd.DTDGrammar,int,int,org.apache.xerces.impl.dtd.XMLContentSpec);
	*** checkStandaloneEntityRef(java.lang.String,org.apache.xerces.impl.dtd.DTDGrammar,org.apache.xerces.impl.dtd.XMLEntityDecl,org.apache.xerces.impl.XMLErrorReporter);
	*** isValidName(java.lang.String);
	*** isValidNmtoken(java.lang.String);
	*** normalizeDefaultAttrValue(org.apache.xerces.xni.XMLString);
	*** reset();
	*** setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler);
	*** setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource);
	*** setDTDHandler(org.apache.xerces.xni.XMLDTDHandler);
	*** setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource);
}

-keep class org.apache.xerces.impl.dtd.XMLDTDValidator {
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** fBalanceSyntaxTrees;
	*** fBuffer;
	*** fContentSpecTypeStack;
	*** fCurrentContentSpecType;
	*** fCurrentElement;
	*** fCurrentElementIndex;
	*** fDTDGrammar;
	*** fDTDValidation;
	*** fDatatypeValidatorFactory;
	*** fDocLocation;
	*** fDocumentHandler;
	*** fDocumentSource;
	*** fDynamicValidation;
	*** fElementChildren;
	*** fElementChildrenLength;
	*** fElementChildrenOffsetStack;
	*** fElementDepth;
	*** fElementIndexStack;
	*** fElementQNamePartsStack;
	*** fEntityDecl;
	*** fErrorReporter;
	*** fGrammarBucket;
	*** fGrammarPool;
	*** fInCDATASection;
	*** fInElementContent;
	*** fNamespaceContext;
	*** fNamespaces;
	*** fPerformValidation;
	*** fRootElement;
	*** fSchemaType;
	*** fSeenDoctypeDecl;
	*** fSeenRootElement;
	*** fSymbolTable;
	*** fTempAttDecl;
	*** fTempElementDecl;
	*** fTempQName;
	*** fValENTITIES;
	*** fValENTITY;
	*** fValID;
	*** fValIDRef;
	*** fValIDRefs;
	*** fValNMTOKEN;
	*** fValNMTOKENS;
	*** fValNOTATION;
	*** fValidation;
	*** fValidationManager;
	*** fValidationState;
	*** fWarnDuplicateAttdef;
	org.apache.xerces.impl.dtd.XMLDTDValidator();
	*** addDTDDefaultAttrsAndValidate(org.apache.xerces.xni.QName,int,org.apache.xerces.xni.XMLAttributes);
	*** charDataInContent();
	*** characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** checkContent(int,org.apache.xerces.xni.QName[],int,int);
	*** endNamespaceScope(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations,boolean);
	*** ensureStackCapacity(int);
	*** getAttributeTypeName(org.apache.xerces.impl.dtd.XMLAttributeDecl);
	*** getExternalEntityRefInAttrValue(java.lang.String);
	*** getGrammarBucket();
	*** handleEndElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations,boolean);
	*** handleStartElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
	*** init();
	*** isSpace(int);
	*** normalizeAttrValue(org.apache.xerces.xni.XMLAttributes,int);
	*** rootElementSpecified(org.apache.xerces.xni.QName);
	*** setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler);
	*** setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource);
	*** startNamespaceScope(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
	*** validate();
	*** validateDTDattribute(org.apache.xerces.xni.QName,java.lang.String,org.apache.xerces.impl.dtd.XMLAttributeDecl);
}

-keep class org.apache.xerces.impl.dtd.XMLDTDValidatorFilter {
	*** hasGrammar();
	*** validate();
}

-keep class org.apache.xerces.impl.dtd.XMLElementDecl {
	*** contentModelValidator;
	*** name;
	*** scope;
	*** simpleType;
	*** type;
}

-keep class org.apache.xerces.impl.dtd.XMLEntityDecl {
	*** baseSystemId;
	*** inExternal;
	*** isPE;
	*** name;
	*** notation;
	*** publicId;
	*** systemId;
	*** value;
	*** setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,boolean);
}

-keep class org.apache.xerces.impl.dtd.XMLNSDTDValidator {
	*** fAttributeQName;
}

-keep class org.apache.xerces.impl.dtd.XMLNotationDecl {
	*** baseSystemId;
	*** name;
	*** publicId;
	*** systemId;
	*** setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.apache.xerces.impl.dtd.XMLSimpleType {
	*** datatypeValidator;
	*** defaultType;
	*** defaultValue;
	*** enumeration;
	*** list;
	*** name;
	*** nonNormalizedDefaultValue;
	*** type;
	*** clear();
	*** setValues(org.apache.xerces.impl.dtd.XMLSimpleType);
	*** setValues(short,java.lang.String,java.lang.String[],boolean,short,java.lang.String,java.lang.String,org.apache.xerces.impl.dv.DatatypeValidator);
}

-keep class org.apache.xerces.impl.dtd.models.ContentModelValidator {
	*** validate(org.apache.xerces.xni.QName[],int,int);
}

-keep class org.apache.xerces.impl.dv.DTDDVFactory {
	org.apache.xerces.impl.dv.DTDDVFactory();
	*** getBuiltInDV(java.lang.String);
	*** getInstance();
	*** getInstance(java.lang.String);
}

-keep class org.apache.xerces.impl.dv.DatatypeException {
	*** args;
	*** key;
	org.apache.xerces.impl.dv.DatatypeException(java.lang.String,java.lang.Object[]);
	*** getArgs();
	*** getKey();
}

-keep class org.apache.xerces.impl.dv.DatatypeValidator {
	*** validate(java.lang.String,org.apache.xerces.impl.dv.ValidationContext);
}

-keep class org.apache.xerces.impl.dv.ObjectFactory {
	*** DEBUG;
	*** class$org$apache$xerces$impl$dv$ObjectFactory;
	*** fLastModified;
	*** fXercesProperties;
	*** class$(java.lang.String);
	*** createObject(java.lang.String,java.lang.String,java.lang.String);
	*** debugPrintln(java.lang.String);
	*** findClassLoader();
	*** findJarServiceProvider(java.lang.String);
	*** findProviderClass(java.lang.String,java.lang.ClassLoader,boolean);
	*** isDebugEnabled();
	*** newInstance(java.lang.String,java.lang.ClassLoader,boolean);
}

-keep class org.apache.xerces.impl.dv.ObjectFactory$ConfigurationError {
	*** exception;
}

-keep class org.apache.xerces.impl.dv.SecuritySupport {
	*** getContextClassLoader();
	*** getFileExists(java.io.File);
	*** getFileInputStream(java.io.File);
	*** getLastModified(java.io.File);
	*** getParentClassLoader(java.lang.ClassLoader);
	*** getResourceAsStream(java.lang.ClassLoader,java.lang.String);
	*** getSystemClassLoader();
	*** getSystemProperty(java.lang.String);
}

-keep class org.apache.xerces.impl.dv.SecuritySupport$4 {
	*** val$propName;
}

-keep class org.apache.xerces.impl.dv.ValidatedInfo {
	*** actualValue;
	*** actualValueType;
	*** itemValueTypes;
	*** memberType;
	*** normalizedValue;
	*** isComparable(org.apache.xerces.impl.dv.ValidatedInfo,org.apache.xerces.impl.dv.ValidatedInfo);
	*** reset();
	*** stringValue();
}

-keep class org.apache.xerces.impl.dv.ValidationContext {
	*** addId(java.lang.String);
	*** addIdRef(java.lang.String);
	*** isEntityUnparsed(java.lang.String);
	*** isIdDeclared(java.lang.String);
	*** useNamespaces();
}

-keep class org.apache.xerces.impl.dv.XSSimpleType {
	*** getPrimitiveKind();
	*** getWhitespace();
	*** isIDType();
	*** validate(java.lang.Object,org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo);
	*** validate(java.lang.String,org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo);
}

-keep class org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl {
	*** fBuiltInTypes;
	*** createBuiltInTypes();
}

-keep class org.apache.xerces.impl.dv.dtd.ListDatatypeValidator {
	*** fItemValidator;
}

-keep class org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl {
	*** getName();
	*** getNamespace();
	*** getTypeName();
	*** isDOMDerivedFrom(java.lang.String,java.lang.String,int);
}

-keep class org.apache.xerces.impl.io.ASCIIReader {
	*** fBuffer;
	*** fFormatter;
	*** fInputStream;
	*** fLocale;
	org.apache.xerces.impl.io.ASCIIReader(java.io.InputStream,byte[],org.apache.xerces.util.MessageFormatter,java.util.Locale);
	org.apache.xerces.impl.io.ASCIIReader(java.io.InputStream,int,org.apache.xerces.util.MessageFormatter,java.util.Locale);
}

-keep class org.apache.xerces.impl.io.Latin1Reader {
	*** fBuffer;
	*** fInputStream;
	org.apache.xerces.impl.io.Latin1Reader(java.io.InputStream,byte[]);
	org.apache.xerces.impl.io.Latin1Reader(java.io.InputStream,int);
}

-keep class org.apache.xerces.impl.io.MalformedByteSequenceException {
	*** fArguments;
	*** fDomain;
	*** fFormatter;
	*** fKey;
	*** fLocale;
	*** fMessage;
	*** getArguments();
	*** getDomain();
	*** getKey();
}

-keep class org.apache.xerces.impl.io.UCSReader {
	*** fBuffer;
	*** fEncoding;
	*** fInputStream;
	org.apache.xerces.impl.io.UCSReader(java.io.InputStream,byte[],short);
	org.apache.xerces.impl.io.UCSReader(java.io.InputStream,int,short);
}

-keep class org.apache.xerces.impl.io.UTF16Reader {
	*** fBuffer;
	*** fFormatter;
	*** fInputStream;
	*** fIsBigEndian;
	*** fLocale;
	org.apache.xerces.impl.io.UTF16Reader(java.io.InputStream,byte[],boolean,org.apache.xerces.util.MessageFormatter,java.util.Locale);
	org.apache.xerces.impl.io.UTF16Reader(java.io.InputStream,int,boolean,org.apache.xerces.util.MessageFormatter,java.util.Locale);
	*** expectedTwoBytes();
	*** processBE(char[],int,int);
	*** processLE(char[],int,int);
}

-keep class org.apache.xerces.impl.io.UTF8Reader {
	*** fBuffer;
	*** fFormatter;
	*** fInputStream;
	*** fLocale;
	*** fOffset;
	*** fSurrogate;
	org.apache.xerces.impl.io.UTF8Reader(java.io.InputStream,byte[],org.apache.xerces.util.MessageFormatter,java.util.Locale);
	org.apache.xerces.impl.io.UTF8Reader(java.io.InputStream,int,org.apache.xerces.util.MessageFormatter,java.util.Locale);
	*** expectedByte(int,int);
	*** invalidByte(int,int,int);
	*** invalidSurrogate(int);
	*** read(char[],int,int);
}

-keep class org.apache.xerces.impl.msg.XMLMessageFormatter {
	*** fLocale;
	*** fResourceBundle;
}

-keep class org.apache.xerces.impl.validation.ConfigurableValidationState {
	*** checkIDRefID();
	*** setIdIdrefChecking(boolean);
	*** setUnparsedEntityChecking(boolean);
}

-keep class org.apache.xerces.impl.validation.EntityState {
	*** isEntityDeclared(java.lang.String);
	*** isEntityUnparsed(java.lang.String);
}

-keep class org.apache.xerces.impl.validation.ValidationManager {
	*** fCachedDTD;
	*** fGrammarFound;
	*** fVSs;
	*** addValidationState(org.apache.xerces.impl.validation.ValidationState);
	*** isCachedDTD();
	*** isGrammarFound();
	*** reset();
	*** setCachedDTD(boolean);
	*** setEntityState(org.apache.xerces.impl.validation.EntityState);
	*** setGrammarFound(boolean);
}

-keep class org.apache.xerces.impl.validation.ValidationState {
	*** fEntityState;
	*** fExtraChecking;
	*** fFacetChecking;
	*** fIdRefTable;
	*** fIdTable;
	*** fLocale;
	*** fNamespaceContext;
	*** fNamespaces;
	*** fNormalize;
	*** fNullValue;
	*** fSymbolTable;
	*** checkIDRefID();
	*** getSymbol(java.lang.String);
	*** resetIDTables();
	*** setEntityState(org.apache.xerces.impl.validation.EntityState);
	*** setExtraChecking(boolean);
	*** setFacetChecking(boolean);
	*** setNamespaceSupport(org.apache.xerces.xni.NamespaceContext);
	*** setNormalizationRequired(boolean);
	*** setSymbolTable(org.apache.xerces.util.SymbolTable);
	*** setUsingNamespaces(boolean);
}

-keep class org.apache.xerces.impl.xs.AttributePSVImpl {
	*** fActualValue;
	*** fActualValueType;
	*** fDeclaration;
	*** fErrors;
	*** fItemValueTypes;
	*** fMemberType;
	*** fNormalizedValue;
	*** fSpecified;
	*** fTypeDecl;
	*** fValidationAttempted;
	*** fValidationContext;
	*** fValidity;
	*** reset();
}

-keep class org.apache.xerces.impl.xs.ElementPSVImpl {
	*** fActualValue;
	*** fActualValueType;
	*** fDeclaration;
	*** fErrors;
	*** fGrammars;
	*** fItemValueTypes;
	*** fMemberType;
	*** fNil;
	*** fNormalizedValue;
	*** fNotation;
	*** fSchemaInformation;
	*** fSpecified;
	*** fTypeDecl;
	*** fValidationAttempted;
	*** fValidationContext;
	*** fValidity;
	*** reset();
}

-keep class org.apache.xerces.impl.xs.SchemaGrammar {
	*** SG_SchemaNS;
	*** SG_XSI;
	*** fAnyType;
	*** getAttributeDeclaration(java.lang.String);
	*** getDocumentLocations();
	*** getElementDeclaration(java.lang.String);
	*** getGlobalAttributeDecl(java.lang.String);
	*** getGlobalElementDecl(java.lang.String);
	*** getGlobalNotationDecl(java.lang.String);
	*** getGlobalTypeDecl(java.lang.String);
	*** getTypeDefinition(java.lang.String);
	*** setImmutable(boolean);
}

-keep class org.apache.xerces.impl.xs.SchemaSymbols {
	*** URI_SCHEMAFORSCHEMA;
	*** URI_XSI;
	*** XSI_NIL;
	*** XSI_NONAMESPACESCHEMALOCATION;
	*** XSI_SCHEMALOCATION;
	*** XSI_TYPE;
}

-keep class org.apache.xerces.impl.xs.XMLSchemaLoader {
	*** loadSchema(org.apache.xerces.impl.xs.XSDDescription,org.apache.xerces.xni.parser.XMLInputSource,java.util.Hashtable);
	*** processExternalHints(java.lang.String,java.lang.String,java.util.Hashtable,org.apache.xerces.impl.XMLErrorReporter);
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** resolveDocument(org.apache.xerces.impl.xs.XSDDescription,java.util.Hashtable,org.apache.xerces.xni.parser.XMLEntityResolver);
	*** tokenizeSchemaLocationStr(java.lang.String,java.util.Hashtable);
}

-keep class org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray {
	*** addLocation(java.lang.String);
	*** getLocationArray();
}

-keep class org.apache.xerces.impl.xs.XMLSchemaValidator {
	*** EMPTY_TABLE;
	*** FEATURE_DEFAULTS;
	*** PROPERTY_DEFAULTS;
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** XSI_NIL;
	*** XSI_NONAMESPACESCHEMALOCATION;
	*** XSI_SCHEMALOCATION;
	*** XSI_TYPE;
	*** fAppendBuffer;
	*** fAugPSVI;
	*** fAugmentations;
	*** fBuffer;
	*** fCMBuilder;
	*** fCMStack;
	*** fCMStateStack;
	*** fCurrCMState;
	*** fCurrentCM;
	*** fCurrentElemDecl;
	*** fCurrentPSVI;
	*** fCurrentType;
	*** fDefaultValue;
	*** fDoValidation;
	*** fDocumentHandler;
	*** fDocumentSource;
	*** fDynamicValidation;
	*** fElemDeclStack;
	*** fElementDepth;
	*** fEmptyXMLStr;
	*** fEntityRef;
	*** fEntityResolver;
	*** fExpandedLocationPairs;
	*** fExternalNoNamespaceSchema;
	*** fExternalSchemas;
	*** fFirstChunk;
	*** fFullChecking;
	*** fGrammarBucket;
	*** fGrammarPool;
	*** fIDCChecking;
	*** fIdConstraint;
	*** fIgnoreXSITypeDepth;
	*** fInCDATA;
	*** fJaxpSchemaSource;
	*** fLocationPairs;
	*** fLocator;
	*** fMatcherStack;
	*** fNFullValidationDepth;
	*** fNNoneValidationDepth;
	*** fNamespaceGrowth;
	*** fNil;
	*** fNilStack;
	*** fNormalizeData;
	*** fNormalizedStr;
	*** fNotation;
	*** fNotationStack;
	*** fQNameDV;
	*** fRootElementDeclQName;
	*** fRootElementDeclaration;
	*** fRootTypeDefinition;
	*** fRootTypeQName;
	*** fSawCharacters;
	*** fSawText;
	*** fSawTextStack;
	*** fSchemaDynamicValidation;
	*** fSchemaElementDefault;
	*** fSchemaLoader;
	*** fSchemaType;
	*** fSkipValidationDepth;
	*** fState4ApplyDefault;
	*** fState4XsiType;
	*** fStrictAssess;
	*** fStrictAssessStack;
	*** fStringContent;
	*** fSubElement;
	*** fSubElementStack;
	*** fSubGroupHandler;
	*** fSymbolTable;
	*** fTempQName;
	*** fTrailing;
	*** fTypeStack;
	*** fUnionType;
	*** fUnparsedLocations;
	*** fUseGrammarPoolOnly;
	*** fValidatedInfo;
	*** fValidationManager;
	*** fValidationRoot;
	*** fValidationState;
	*** fValueStoreCache;
	*** fWhiteSpace;
	*** fXSDDescription;
	*** fXSIErrorReporter;
	*** nodeFactory;
	*** activateSelectorFor(org.apache.xerces.impl.xs.identity.IdentityConstraint);
	*** addDefaultAttributes(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.impl.xs.XSAttributeGroupDecl);
	*** checkElementMatchesRootElementDecl(org.apache.xerces.impl.xs.XSElementDecl,org.apache.xerces.xni.QName);
	*** elementLocallyValidComplexType(org.apache.xerces.xni.QName,java.lang.Object);
	*** elementLocallyValidType(org.apache.xerces.xni.QName,java.lang.Object);
	*** endElementPSVI(boolean,org.apache.xerces.impl.xs.SchemaGrammar[],org.apache.xerces.xni.Augmentations);
	*** ensureStackCapacity();
	*** expectedStr(java.util.Vector);
	*** findSchemaGrammar(short,java.lang.String,org.apache.xerces.xni.QName,org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes);
	*** getAndCheckXsiType(org.apache.xerces.xni.QName,java.lang.String,org.apache.xerces.xni.XMLAttributes);
	*** getDocumentSource();
	*** getEmptyAugs(org.apache.xerces.xni.Augmentations);
	*** getXsiNil(org.apache.xerces.xni.QName,java.lang.String);
	*** handleCharacters(org.apache.xerces.xni.XMLString);
	*** handleEndDocument();
	*** handleEndElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations);
	*** handleIgnorableWhitespace(org.apache.xerces.xni.XMLString);
	*** handleStartDocument(org.apache.xerces.xni.XMLLocator,java.lang.String);
	*** handleStartElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
	*** hasSchemaComponent(org.apache.xerces.impl.xs.SchemaGrammar,short,org.apache.xerces.xni.QName);
	*** normalizeWhitespace(java.lang.String,boolean);
	*** normalizeWhitespace(org.apache.xerces.xni.XMLString,boolean);
	*** processAttributes(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.impl.xs.XSAttributeGroupDecl);
	*** processElementContent(org.apache.xerces.xni.QName);
	*** processOneAttribute(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,int,org.apache.xerces.impl.xs.XSAttributeDecl,org.apache.xerces.impl.xs.XSAttributeUseImpl,org.apache.xerces.impl.xs.AttributePSVImpl);
	*** processRootElementDeclQName(javax.xml.namespace.QName,org.apache.xerces.xni.QName);
	*** processRootTypeQName(javax.xml.namespace.QName);
	*** reportSchemaError(java.lang.String,java.lang.Object[]);
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler);
	*** setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource);
	*** setLocationHints(org.apache.xerces.impl.xs.XSDDescription,java.lang.String[],org.apache.xerces.impl.xs.SchemaGrammar);
	*** setLocationHints(org.apache.xerces.impl.xs.XSDDescription,java.lang.String[],org.apache.xerces.xs.StringList);
	*** storeLocations(java.lang.String,java.lang.String);
}

-keep class org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase {
	*** endDocumentFragment();
	*** endValueScope();
	*** startValueScope();
}

-keep class org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache {
	*** endDocument();
	*** endElement();
	*** getValueStoreFor(org.apache.xerces.impl.xs.identity.IdentityConstraint,int);
	*** initValueStoresFor(org.apache.xerces.impl.xs.XSElementDecl,org.apache.xerces.impl.xs.identity.FieldActivator);
	*** startDocument();
	*** startElement();
	*** transplant(org.apache.xerces.impl.xs.identity.IdentityConstraint,int);
}

-keep class org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack {
	*** addMatcher(org.apache.xerces.impl.xs.identity.XPathMatcher);
	*** clear();
	*** getMatcherAt(int);
	*** getMatcherCount();
	*** popContext();
	*** pushContext();
	*** size();
}

-keep class org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter {
	*** fErrorReporter;
	*** mergeContext();
	*** popContext();
	*** pushContext();
	*** reportError(java.lang.String,java.lang.String,java.lang.Object[],short);
	*** reset(org.apache.xerces.impl.XMLErrorReporter);
}

-keep class org.apache.xerces.impl.xs.XSAttributeDecl {
	*** fDefault;
	*** fName;
	*** fTargetNamespace;
	*** fType;
	*** getConstraintType();
}

-keep class org.apache.xerces.impl.xs.XSAttributeGroupDecl {
	*** fAttributeWC;
	*** fIDAttrName;
	*** getAttributeUses();
}

-keep class org.apache.xerces.impl.xs.XSAttributeUseImpl {
	*** fAttrDecl;
	*** fConstraintType;
	*** fDefault;
	*** fUse;
}

-keep class org.apache.xerces.impl.xs.XSComplexTypeDecl {
	*** fBlock;
	*** fContentType;
	*** fParticle;
	*** fXSSimpleType;
	*** getAbstract();
	*** getAttrGrp();
	*** getContentModel(org.apache.xerces.impl.xs.models.CMBuilder);
	*** getTypeName();
	*** isDOMDerivedFrom(java.lang.String,java.lang.String,int);
}

-keep class org.apache.xerces.impl.xs.XSConstraints {
	*** ElementDefaultValidImmediate(org.apache.xerces.xs.XSTypeDefinition,java.lang.String,org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo);
	*** checkTypeDerivationOk(org.apache.xerces.xs.XSTypeDefinition,org.apache.xerces.xs.XSTypeDefinition,short);
	*** fullSchemaChecking(org.apache.xerces.impl.xs.XSGrammarBucket,org.apache.xerces.impl.xs.SubstitutionGroupHandler,org.apache.xerces.impl.xs.models.CMBuilder,org.apache.xerces.impl.XMLErrorReporter);
}

-keep class org.apache.xerces.impl.xs.XSDDescription {
	*** fAttributes;
	*** fContextType;
	*** fEnclosedElementName;
	*** fLocationHints;
	*** fTriggeringComponent;
	*** getLocationHints();
	*** reset();
}

-keep class org.apache.xerces.impl.xs.XSElementDecl {
	*** fBlock;
	*** fDefault;
	*** fIDCPos;
	*** fName;
	*** fTargetNamespace;
	*** fType;
	*** getAbstract();
	*** getConstraintType();
	*** getNillable();
}

-keep class org.apache.xerces.impl.xs.XSGrammarBucket {
	*** getGrammar(java.lang.String);
	*** getGrammars();
	*** putGrammar(org.apache.xerces.impl.xs.SchemaGrammar,boolean,boolean);
}

-keep class org.apache.xerces.impl.xs.XSWildcardDecl {
	*** fProcessContents;
	*** allowNamespace(java.lang.String);
}

-keep class org.apache.xerces.impl.xs.identity.Field {
	*** createMatcher(org.apache.xerces.impl.xs.identity.ValueStore);
	*** getIdentityConstraint();
}

-keep class org.apache.xerces.impl.xs.identity.IdentityConstraint {
	*** getCategory();
	*** getSelector();
}

-keep class org.apache.xerces.impl.xs.identity.Selector {
	*** createMatcher(org.apache.xerces.impl.xs.identity.FieldActivator,int);
}

-keep class org.apache.xerces.impl.xs.identity.Selector$Matcher {
	*** getIdentityConstraint();
	*** getInitialDepth();
}

-keep class org.apache.xerces.impl.xs.identity.XPathMatcher {
	*** endElement(org.apache.xerces.xni.QName,org.apache.xerces.xs.XSTypeDefinition,boolean,java.lang.Object,short,org.apache.xerces.xs.ShortList);
	*** startDocumentFragment();
	*** startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes);
}

-keep class org.apache.xerces.impl.xs.models.CMNodeFactory {
	*** reset();
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
}

-keep class org.apache.xerces.impl.xs.models.XSCMValidator {
	*** endContentModel(int[]);
	*** getTermName(int);
	*** occurenceInfo(int[]);
	*** oneTransition(org.apache.xerces.xni.QName,int[],org.apache.xerces.impl.xs.SubstitutionGroupHandler);
	*** startContentModel();
	*** whatCanGoHere(int[]);
}

-keep class org.apache.xerces.jaxp.DocumentBuilderFactoryImpl {
	*** attributes;
	*** fSecureProcess;
	*** features;
	*** grammar;
	*** isXIncludeAware;
	*** getSchema();
	*** isXIncludeAware();
	*** setXIncludeAware(boolean);
}

-keep class org.apache.xerces.jaxp.DocumentBuilderImpl {
	*** domParser;
	*** fInitEntityResolver;
	*** fInitErrorHandler;
	*** fSchemaValidationManager;
	*** fSchemaValidator;
	*** fSchemaValidatorComponentManager;
	*** fUnparsedEntityHandler;
	*** grammar;
	org.apache.xerces.jaxp.DocumentBuilderImpl(org.apache.xerces.jaxp.DocumentBuilderFactoryImpl,java.util.Hashtable,java.util.Hashtable,boolean);
	*** getDOMParser();
	*** isValidating();
	*** resetSchemaValidator();
	*** setDocumentBuilderFactoryAttributes(java.util.Hashtable);
	*** setErrorHandler(org.xml.sax.ErrorHandler);
	*** setFeatures(java.util.Hashtable);
}

-keep class org.apache.xerces.jaxp.JAXPValidatorComponent {
	*** fCurrentAttributes;
	*** fCurrentAug;
	*** fEntityResolver;
	*** fErrorReporter;
	*** fSymbolTable;
	*** noInfoProvider;
	*** sax2xni;
	*** typeInfoProvider;
	*** validator;
	*** xni2sax;
	*** endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations);
	*** startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
	*** symbolize(java.lang.String);
	*** updateAttributes(org.xml.sax.Attributes);
}

-keep class org.apache.xerces.jaxp.JAXPValidatorComponent$XNI2SAX {
	*** characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations);
	*** ignorableWhitespace(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** setContentHandler(org.xml.sax.ContentHandler);
	*** startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.jaxp.TeeXMLDocumentFilterImpl {
	*** next;
	*** side;
	*** source;
	org.apache.xerces.jaxp.TeeXMLDocumentFilterImpl();
	*** setSide(org.apache.xerces.xni.XMLDocumentHandler);
}

-keep class org.apache.xerces.jaxp.UnparsedEntityHandler {
	*** reset();
	*** setDTDHandler(org.apache.xerces.xni.XMLDTDHandler);
}

-keep class org.apache.xerces.parsers.AbstractDOMParser {
	*** RECOGNIZED_FEATURES;
	*** RECOGNIZED_PROPERTIES;
	*** class$org$w3c$dom$Document;
	*** fAttrQName;
	*** fBaseURIStack;
	*** fCreateCDATANodes;
	*** fCreateEntityRefNodes;
	*** fCurrentCDATASection;
	*** fCurrentCDATASectionIndex;
	*** fCurrentEntityDecl;
	*** fCurrentNode;
	*** fCurrentNodeIndex;
	*** fDOMFilter;
	*** fDeferNodeExpansion;
	*** fDeferredDocumentImpl;
	*** fDeferredEntityDecl;
	*** fDocument;
	*** fDocumentClassName;
	*** fDocumentImpl;
	*** fDocumentIndex;
	*** fDocumentType;
	*** fDocumentTypeIndex;
	*** fErrorHandler;
	*** fFilterReject;
	*** fFirstChunk;
	*** fInCDATASection;
	*** fInDTD;
	*** fInDTDExternalSubset;
	*** fInEntityRef;
	*** fIncludeComments;
	*** fIncludeIgnorableWhitespace;
	*** fInternalSubset;
	*** fLocator;
	*** fNamespaceAware;
	*** fRejectedElementDepth;
	*** fRoot;
	*** fSkippedElemStack;
	*** fStorePSVI;
	*** fStringBuffer;
	org.apache.xerces.parsers.AbstractDOMParser(org.apache.xerces.xni.parser.XMLParserConfiguration);
	*** class$(java.lang.String);
	*** createAttrNode(org.apache.xerces.xni.QName);
	*** createElementNode(org.apache.xerces.xni.QName);
	*** dropDocumentReferences();
	*** endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations);
	*** getDocument();
	*** handleBaseURI(int);
	*** handleBaseURI(org.w3c.dom.Node);
	*** setCharacterData(boolean);
	*** setDocumentClassName(java.lang.String);
	*** startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.parsers.AbstractDOMParser$Abort {
	*** INSTANCE;
}

-keep class org.apache.xerces.parsers.AbstractXMLDocumentParser {
	*** fDTDContentModelSource;
	*** fDTDSource;
	*** fDocumentSource;
	*** fInDTD;
	org.apache.xerces.parsers.AbstractXMLDocumentParser(org.apache.xerces.xni.parser.XMLParserConfiguration);
	*** endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations);
	*** reset();
	*** setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource);
	*** setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource);
	*** startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.parsers.DOMParser {
	*** RECOGNIZED_PROPERTIES;
	*** fUseEntityResolver2;
	org.apache.xerces.parsers.DOMParser(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool);
	*** getEntityResolver();
	*** getErrorHandler();
	*** getFeature(java.lang.String);
	*** getProperty(java.lang.String);
	*** getXMLParserConfiguration();
	*** parse(org.xml.sax.InputSource);
	*** setEntityResolver(org.xml.sax.EntityResolver);
	*** setErrorHandler(org.xml.sax.ErrorHandler);
	*** setFeature(java.lang.String,boolean);
	*** setProperty(java.lang.String,java.lang.Object);
}

-keep class org.apache.xerces.parsers.ObjectFactory {
	*** DEBUG;
	*** class$org$apache$xerces$parsers$ObjectFactory;
	*** fLastModified;
	*** fXercesProperties;
	*** class$(java.lang.String);
	*** createObject(java.lang.String,java.lang.String);
	*** createObject(java.lang.String,java.lang.String,java.lang.String);
	*** debugPrintln(java.lang.String);
	*** findClassLoader();
	*** findJarServiceProvider(java.lang.String);
	*** findProviderClass(java.lang.String,java.lang.ClassLoader,boolean);
	*** isDebugEnabled();
	*** newInstance(java.lang.String,java.lang.ClassLoader,boolean);
}

-keep class org.apache.xerces.parsers.ObjectFactory$ConfigurationError {
	*** exception;
}

-keep class org.apache.xerces.parsers.SecuritySupport {
	*** getContextClassLoader();
	*** getFileExists(java.io.File);
	*** getFileInputStream(java.io.File);
	*** getLastModified(java.io.File);
	*** getParentClassLoader(java.lang.ClassLoader);
	*** getResourceAsStream(java.lang.ClassLoader,java.lang.String);
	*** getSystemClassLoader();
	*** getSystemProperty(java.lang.String);
}

-keep class org.apache.xerces.parsers.SecuritySupport$4 {
	*** val$propName;
}

-keep class org.apache.xerces.parsers.SecuritySupport$6 {
	*** val$cl;
	*** val$name;
}

-keep class org.apache.xerces.parsers.SecuritySupport$7 {
	*** val$f;
}

-keep class org.apache.xerces.parsers.XIncludeAwareParserConfiguration {
	*** fCurrentNSContext;
	*** fNonXIncludeNSContext;
	*** fXIncludeEnabled;
	*** fXIncludeHandler;
	*** fXIncludeNSContext;
	org.apache.xerces.parsers.XIncludeAwareParserConfiguration(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool,org.apache.xerces.xni.parser.XMLComponentManager);
	*** setFeature(java.lang.String,boolean);
}

-keep class org.apache.xerces.parsers.XML11Configuration {
	*** f11Initialized;
	*** fCommonComponents;
	*** fComponents;
	*** fConfigUpdated;
	*** fCurrentDTDScanner;
	*** fCurrentDVFactory;
	*** fCurrentScanner;
	*** fDTDContentModelHandler;
	*** fDTDHandler;
	*** fDTDProcessor;
	*** fDTDScanner;
	*** fDTDValidator;
	*** fDatatypeValidatorFactory;
	*** fDocumentHandler;
	*** fEntityManager;
	*** fErrorReporter;
	*** fGrammarPool;
	*** fInputSource;
	*** fLastComponent;
	*** fLocale;
	*** fNamespaceScanner;
	*** fNonNSDTDValidator;
	*** fNonNSScanner;
	*** fParseInProgress;
	*** fSchemaValidator;
	*** fSymbolTable;
	*** fValidationManager;
	*** fVersionDetector;
	*** fXML11Components;
	*** fXML11DTDProcessor;
	*** fXML11DTDScanner;
	*** fXML11DTDValidator;
	*** fXML11DatatypeFactory;
	*** fXML11DocScanner;
	*** fXML11NSDTDValidator;
	*** fXML11NSDocScanner;
	org.apache.xerces.parsers.XML11Configuration(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool,org.apache.xerces.xni.parser.XMLComponentManager);
	*** addCommonComponent(org.apache.xerces.xni.parser.XMLComponent);
	*** addComponent(org.apache.xerces.xni.parser.XMLComponent);
	*** addRecognizedParamsAndSetDefaults(org.apache.xerces.xni.parser.XMLComponent);
	*** addXML11Component(org.apache.xerces.xni.parser.XMLComponent);
	*** cleanup();
	*** configurePipeline();
	*** configureXML11Pipeline();
	*** getFeature0(java.lang.String);
	*** getLocale();
	*** initXML11Components();
	*** parse(boolean);
	*** reset();
	*** resetCommon();
	*** resetXML11();
	*** setFeature(java.lang.String,boolean);
	*** setInputSource(org.apache.xerces.xni.parser.XMLInputSource);
	*** setLocale(java.util.Locale);
	*** setProperty(java.lang.String,java.lang.Object);
}

-keep class org.apache.xerces.parsers.XMLParser {
	*** RECOGNIZED_PROPERTIES;
	*** fConfiguration;
	org.apache.xerces.parsers.XMLParser(org.apache.xerces.xni.parser.XMLParserConfiguration);
	*** parse(org.apache.xerces.xni.parser.XMLInputSource);
	*** reset();
}

-keep class org.apache.xerces.util.AugmentationsImpl {
	*** fAugmentationsContainer;
}

-keep class org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer {
	org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer();
	*** clear();
	*** expand();
	*** getItem(java.lang.Object);
	*** isFull();
	*** keys();
	*** putItem(java.lang.Object,java.lang.Object);
	*** removeItem(java.lang.Object);
}

-keep class org.apache.xerces.util.AugmentationsImpl$LargeContainer {
	*** fAugmentations;
	*** putItem(java.lang.Object,java.lang.Object);
}

-keep class org.apache.xerces.util.AugmentationsImpl$SmallContainer {
	*** fAugmentations;
	*** fNumEntries;
}

-keep class org.apache.xerces.util.DOMErrorHandlerWrapper {
	*** getErrorHandler();
}

-keep class org.apache.xerces.util.EncodingMap {
	*** getIANA2JavaMapping(java.lang.String);
}

-keep class org.apache.xerces.util.EntityResolver2Wrapper {
	*** getEntityResolver();
	*** setEntityResolver(org.xml.sax.ext.EntityResolver2);
}

-keep class org.apache.xerces.util.EntityResolverWrapper {
	*** getEntityResolver();
	*** setEntityResolver(org.xml.sax.EntityResolver);
}

-keep class org.apache.xerces.util.ErrorHandlerWrapper {
	*** getErrorHandler();
	*** setErrorHandler(org.xml.sax.ErrorHandler);
}

-keep class org.apache.xerces.util.HTTPInputSource {
	*** getFollowHTTPRedirects();
	*** getHTTPRequestProperties();
}

-keep class org.apache.xerces.util.MessageFormatter {
	*** formatMessage(java.util.Locale,java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xerces.util.NamespaceSupport {
	*** fContext;
	*** fCurrentContext;
	*** fNamespace;
	*** fNamespaceSize;
	*** fPrefixes;
	*** declarePrefix(java.lang.String,java.lang.String);
	*** getURI(java.lang.String);
	*** pushContext();
}

-keep class org.apache.xerces.util.ParserConfigurationSettings {
	*** fFeatures;
	*** fParentSettings;
	*** fProperties;
	*** fRecognizedFeatures;
	*** fRecognizedProperties;
	org.apache.xerces.util.ParserConfigurationSettings(org.apache.xerces.xni.parser.XMLComponentManager);
	*** addRecognizedFeatures(java.lang.String[]);
	*** addRecognizedProperties(java.lang.String[]);
	*** checkFeature(java.lang.String);
	*** checkProperty(java.lang.String);
	*** getFeature(java.lang.String);
	*** getProperty(java.lang.String);
	*** setFeature(java.lang.String,boolean);
	*** setProperty(java.lang.String,java.lang.Object);
}

-keep class org.apache.xerces.util.SAXMessageFormatter {
	*** formatMessage(java.util.Locale,java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xerces.util.SecurityManager {
	*** getEntityExpansionLimit();
}

-keep class org.apache.xerces.util.SymbolTable {
	*** fBuckets;
	*** fCount;
	*** fLoadFactor;
	*** fTableSize;
	*** fThreshold;
	org.apache.xerces.util.SymbolTable(int,float);
	*** addSymbol(char[],int,int);
	*** addSymbol(java.lang.String);
	*** hash(char[],int,int);
	*** hash(java.lang.String);
	*** rehash();
}

-keep class org.apache.xerces.util.SymbolTable$Entry {
	*** characters;
	*** next;
	*** symbol;
}

-keep class org.apache.xerces.util.URI {
	*** absolutize(org.apache.xerces.util.URI);
	*** getScheme();
	*** isAbsoluteURI();
	*** toString();
}

-keep class org.apache.xerces.util.XML11Char {
	*** isXML11Content(int);
	*** isXML11InternalEntityContent(int);
	*** isXML11NCName(int);
	*** isXML11NCNameStart(int);
	*** isXML11Name(int);
	*** isXML11NameHighSurrogate(int);
	*** isXML11NameStart(int);
	*** isXML11Space(int);
	*** isXML11Valid(int);
	*** isXML11ValidLiteral(int);
	*** isXML11ValidNCName(java.lang.String);
	*** isXML11ValidName(java.lang.String);
}

-keep class org.apache.xerces.util.XMLAttributesImpl {
	*** fAttributeTableView;
	*** fAttributeTableViewChainState;
	*** fAttributes;
	*** fIsTableViewConsistent;
	*** fLargeCount;
	*** fLength;
	*** fNamespaces;
	*** fTableViewBuckets;
	org.apache.xerces.util.XMLAttributesImpl(int);
	*** addAttribute(org.apache.xerces.xni.QName,java.lang.String,java.lang.String);
	*** addAttributeNS(org.apache.xerces.xni.QName,java.lang.String,java.lang.String);
	*** checkDuplicatesNS();
	*** cleanTableView();
	*** getIndex(java.lang.String);
	*** getIndex(java.lang.String,java.lang.String);
	*** getIndexFast(java.lang.String);
	*** getIndexFast(java.lang.String,java.lang.String);
	*** getLength();
	*** getName(int,org.apache.xerces.xni.QName);
	*** getReportableType(java.lang.String);
	*** getTableViewBucket(java.lang.String);
	*** getTableViewBucket(java.lang.String,java.lang.String);
	*** getValue(int);
	*** prepareAndPopulateTableView();
	*** prepareTableView();
	*** removeAllAttributes();
	*** setNamespaces(boolean);
	*** setNonNormalizedValue(int,java.lang.String);
	*** setSpecified(int,boolean);
	*** setURI(int,java.lang.String);
	*** setValue(int,java.lang.String);
}

-keep class org.apache.xerces.util.XMLAttributesImpl$Attribute {
	*** augs;
	*** name;
	*** next;
	*** nonNormalizedValue;
	*** specified;
	*** type;
	*** value;
}

-keep class org.apache.xerces.util.XMLChar {
	*** CHARS;
	*** highSurrogate(int);
	*** isContent(int);
	*** isHighSurrogate(int);
	*** isInvalid(int);
	*** isLowSurrogate(int);
	*** isMarkup(int);
	*** isNCName(int);
	*** isNCNameStart(int);
	*** isName(int);
	*** isNameStart(int);
	*** isPubid(int);
	*** isSpace(int);
	*** isSupplemental(int);
	*** isValid(int);
	*** isValidIANAEncoding(java.lang.String);
	*** isValidJavaEncoding(java.lang.String);
	*** isValidNCName(java.lang.String);
	*** isValidName(java.lang.String);
	*** isValidNmtoken(java.lang.String);
	*** lowSurrogate(int);
	*** supplemental(char,char);
	*** trim(java.lang.String);
}

-keep class org.apache.xerces.util.XMLResourceIdentifierImpl {
	*** fBaseSystemId;
	*** fExpandedSystemId;
	*** fLiteralSystemId;
	*** fNamespace;
	*** fPublicId;
	org.apache.xerces.util.XMLResourceIdentifierImpl();
	*** clear();
	*** getBaseSystemId();
	*** setBaseSystemId(java.lang.String);
	*** setNamespace(java.lang.String);
	*** setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.apache.xerces.util.XMLStringBuffer {
	org.apache.xerces.util.XMLStringBuffer(int);
	*** append(char);
	*** append(char[],int,int);
	*** append(java.lang.String);
	*** append(org.apache.xerces.xni.XMLString);
	*** clear();
}

-keep class org.apache.xerces.util.XMLSymbols {
	*** EMPTY_STRING;
	*** PREFIX_XML;
	*** PREFIX_XMLNS;
	*** fANYSymbol;
	*** fCDATASymbol;
	*** fENTITIESSymbol;
	*** fENTITYSymbol;
	*** fENUMERATIONSymbol;
	*** fFIXEDSymbol;
	*** fIDREFSSymbol;
	*** fIDREFSymbol;
	*** fIDSymbol;
	*** fIMPLIEDSymbol;
	*** fNMTOKENSSymbol;
	*** fNMTOKENSymbol;
	*** fNOTATIONSymbol;
	*** fREQUIREDSymbol;
}

-keep class org.apache.xerces.xinclude.XIncludeHandler {
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** setDTDHandler(org.apache.xerces.xni.XMLDTDHandler);
	*** setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource);
	*** setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler);
	*** setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource);
}

-keep class org.apache.xerces.xni.Augmentations {
	*** getItem(java.lang.String);
	*** putItem(java.lang.String,java.lang.Object);
	*** removeAllItems();
}

-keep class org.apache.xerces.xni.NamespaceContext {
	*** XMLNS_URI;
	*** XML_URI;
	*** declarePrefix(java.lang.String,java.lang.String);
	*** getAllPrefixes();
	*** getURI(java.lang.String);
	*** popContext();
	*** pushContext();
	*** reset();
}

-keep class org.apache.xerces.xni.QName {
	*** localpart;
	*** prefix;
	*** rawname;
	*** uri;
	*** clear();
	*** setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** setValues(org.apache.xerces.xni.QName);
}

-keep class org.apache.xerces.xni.XMLAttributes {
	*** addAttribute(org.apache.xerces.xni.QName,java.lang.String,java.lang.String);
	*** getAugmentations(int);
	*** getIndex(java.lang.String);
	*** getLength();
	*** getLocalName(int);
	*** getName(int,org.apache.xerces.xni.QName);
	*** getNonNormalizedValue(int);
	*** getPrefix(int);
	*** getQName(int);
	*** getType(int);
	*** getURI(int);
	*** getValue(int);
	*** getValue(java.lang.String,java.lang.String);
	*** isSpecified(int);
	*** setName(int,org.apache.xerces.xni.QName);
	*** setNonNormalizedValue(int,java.lang.String);
	*** setSpecified(int,boolean);
	*** setType(int,java.lang.String);
	*** setValue(int,java.lang.String);
}

-keep class org.apache.xerces.xni.XMLDTDContentModelHandler {
	*** any(org.apache.xerces.xni.Augmentations);
	*** element(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** empty(org.apache.xerces.xni.Augmentations);
	*** endContentModel(org.apache.xerces.xni.Augmentations);
	*** endGroup(org.apache.xerces.xni.Augmentations);
	*** occurrence(short,org.apache.xerces.xni.Augmentations);
	*** pcdata(org.apache.xerces.xni.Augmentations);
	*** separator(short,org.apache.xerces.xni.Augmentations);
	*** setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource);
	*** startContentModel(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** startGroup(org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.xni.XMLDTDHandler {
	*** attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String[],java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** elementDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** endAttlist(org.apache.xerces.xni.Augmentations);
	*** endConditional(org.apache.xerces.xni.Augmentations);
	*** endDTD(org.apache.xerces.xni.Augmentations);
	*** endExternalSubset(org.apache.xerces.xni.Augmentations);
	*** endParameterEntity(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** externalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations);
	*** ignoredCharacters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** internalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** notationDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations);
	*** processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource);
	*** startAttlist(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** startConditional(short,org.apache.xerces.xni.Augmentations);
	*** startDTD(org.apache.xerces.xni.XMLLocator,org.apache.xerces.xni.Augmentations);
	*** startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations);
	*** startParameterEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** unparsedEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.xni.XMLDocumentHandler {
	*** characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** doctypeDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
	*** endCDATA(org.apache.xerces.xni.Augmentations);
	*** endDocument(org.apache.xerces.xni.Augmentations);
	*** endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations);
	*** endGeneralEntity(java.lang.String,org.apache.xerces.xni.Augmentations);
	*** getDocumentSource();
	*** ignorableWhitespace(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations);
	*** setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource);
	*** startCDATA(org.apache.xerces.xni.Augmentations);
	*** startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations);
	*** startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations);
	*** startGeneralEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
	*** xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations);
}

-keep class org.apache.xerces.xni.XMLLocator {
	*** getBaseSystemId();
	*** getCharacterOffset();
	*** getColumnNumber();
	*** getEncoding();
	*** getExpandedSystemId();
	*** getLineNumber();
	*** getLiteralSystemId();
	*** getPublicId();
}

-keep class org.apache.xerces.xni.XMLResourceIdentifier {
	*** getBaseSystemId();
	*** getExpandedSystemId();
	*** getLiteralSystemId();
	*** getPublicId();
	*** setBaseSystemId(java.lang.String);
	*** setExpandedSystemId(java.lang.String);
}

-keep class org.apache.xerces.xni.XMLString {
	*** ch;
	*** length;
	*** offset;
	org.apache.xerces.xni.XMLString();
	*** clear();
	*** equals(char[],int,int);
	*** equals(java.lang.String);
	*** setValues(char[],int,int);
	*** setValues(org.apache.xerces.xni.XMLString);
	*** toString();
}

-keep class org.apache.xerces.xni.XNIException {
	*** fException;
	org.apache.xerces.xni.XNIException(java.lang.String);
	org.apache.xerces.xni.XNIException(java.lang.String,java.lang.Exception);
	*** getException();
}

-keep class org.apache.xerces.xni.grammars.XMLGrammarDescription {
	*** getGrammarType();
}

-keep class org.apache.xerces.xni.grammars.XMLGrammarPool {
	*** cacheGrammars(java.lang.String,org.apache.xerces.xni.grammars.Grammar[]);
	*** retrieveGrammar(org.apache.xerces.xni.grammars.XMLGrammarDescription);
	*** retrieveInitialGrammarSet(java.lang.String);
}

-keep class org.apache.xerces.xni.parser.XMLComponent {
	*** getFeatureDefault(java.lang.String);
	*** getPropertyDefault(java.lang.String);
	*** getRecognizedFeatures();
	*** getRecognizedProperties();
	*** reset(org.apache.xerces.xni.parser.XMLComponentManager);
	*** setFeature(java.lang.String,boolean);
	*** setProperty(java.lang.String,java.lang.Object);
}

-keep class org.apache.xerces.xni.parser.XMLComponentManager {
	*** getFeature(java.lang.String);
	*** getProperty(java.lang.String);
}

-keep class org.apache.xerces.xni.parser.XMLConfigurationException {
	*** fIdentifier;
	*** fType;
	*** getIdentifier();
	*** getType();
}

-keep class org.apache.xerces.xni.parser.XMLDTDContentModelSource {
	*** setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler);
}

-keep class org.apache.xerces.xni.parser.XMLDTDScanner {
	*** scanDTDExternalSubset(boolean);
	*** scanDTDInternalSubset(boolean,boolean,boolean);
	*** setInputSource(org.apache.xerces.xni.parser.XMLInputSource);
}

-keep class org.apache.xerces.xni.parser.XMLDTDSource {
	*** setDTDHandler(org.apache.xerces.xni.XMLDTDHandler);
}

-keep class org.apache.xerces.xni.parser.XMLDocumentScanner {
	*** scanDocument(boolean);
}

-keep class org.apache.xerces.xni.parser.XMLDocumentSource {
	*** getDocumentHandler();
	*** setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler);
}

-keep class org.apache.xerces.xni.parser.XMLEntityResolver {
	*** resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier);
}

-keep class org.apache.xerces.xni.parser.XMLErrorHandler {
	*** error(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException);
	*** fatalError(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException);
	*** warning(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException);
}

-keep class org.apache.xerces.xni.parser.XMLInputSource {
	*** fBaseSystemId;
	*** fByteStream;
	*** fCharStream;
	*** fEncoding;
	*** fPublicId;
	*** fSystemId;
	*** getBaseSystemId();
	*** getByteStream();
	*** getCharacterStream();
	*** getEncoding();
	*** getPublicId();
	*** getSystemId();
	*** setByteStream(java.io.InputStream);
	*** setCharacterStream(java.io.Reader);
	*** setEncoding(java.lang.String);
}

-keep class org.apache.xerces.xni.parser.XMLParseException {
	*** fBaseSystemId;
	*** fCharacterOffset;
	*** fColumnNumber;
	*** fExpandedSystemId;
	*** fLineNumber;
	*** fLiteralSystemId;
	*** fPublicId;
	*** getColumnNumber();
	*** getExpandedSystemId();
	*** getLineNumber();
	*** getPublicId();
}

-keep class org.apache.xerces.xni.parser.XMLParserConfiguration {
	*** addRecognizedFeatures(java.lang.String[]);
	*** addRecognizedProperties(java.lang.String[]);
	*** getFeature(java.lang.String);
	*** getLocale();
	*** getProperty(java.lang.String);
	*** parse(org.apache.xerces.xni.parser.XMLInputSource);
	*** setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler);
	*** setDTDHandler(org.apache.xerces.xni.XMLDTDHandler);
	*** setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler);
	*** setFeature(java.lang.String,boolean);
	*** setLocale(java.util.Locale);
	*** setProperty(java.lang.String,java.lang.Object);
}

-keep class org.apache.xerces.xs.ItemPSVI {
	*** getMemberTypeDefinition();
	*** getTypeDefinition();
}

-keep class org.apache.xerces.xs.StringList {
	*** contains(java.lang.String);
}

-keep class org.apache.xerces.xs.XSObject {
	*** getName();
	*** getNamespace();
}

-keep class org.apache.xerces.xs.XSObjectList {
	*** getLength();
	*** item(int);
}

-keep class org.apache.xerces.xs.XSSimpleTypeDefinition {
	*** getVariety();
}

-keep class org.apache.xerces.xs.XSTypeDefinition {
	*** getTypeCategory();
}

-keep class org.apache.xml.dtm.Axis {
	*** isReverse;
	*** names;
	*** getNames(int);
	*** getNamesLength();
}

-keep class org.apache.xml.dtm.DTM {
	*** appendTextChild(java.lang.String);
	*** dispatchCharactersEvents(int,org.xml.sax.ContentHandler,boolean);
	*** documentRegistration();
	*** documentRelease();
	*** getAttributeNode(int,java.lang.String,java.lang.String);
	*** getAxisIterator(int);
	*** getAxisTraverser(int);
	*** getDocument();
	*** getDocumentBaseURI();
	*** getDocumentRoot(int);
	*** getElementById(java.lang.String);
	*** getExpandedTypeID(int);
	*** getExpandedTypeID(java.lang.String,java.lang.String,int);
	*** getFirstAttribute(int);
	*** getFirstChild(int);
	*** getLastChild(int);
	*** getLocalName(int);
	*** getNamespaceURI(int);
	*** getNextAttribute(int);
	*** getNextSibling(int);
	*** getNode(int);
	*** getNodeName(int);
	*** getNodeNameX(int);
	*** getNodeType(int);
	*** getNodeValue(int);
	*** getOwnerDocument(int);
	*** getParent(int);
	*** getPrefix(int);
	*** getPreviousSibling(int);
	*** getStringValue(int);
	*** getUnparsedEntityURI(java.lang.String);
	*** isNodeAfter(int,int);
}

-keep class org.apache.xml.dtm.DTMAxisIterator {
	*** cloneIterator();
	*** isReverse();
	*** next();
	*** reset();
	*** setStartNode(int);
}

-keep class org.apache.xml.dtm.DTMAxisTraverser {
	org.apache.xml.dtm.DTMAxisTraverser();
	*** first(int);
	*** first(int,int);
	*** next(int,int);
	*** next(int,int,int);
}

-keep class org.apache.xml.dtm.DTMException {
	*** class$java$lang$Throwable;
	*** containedException;
	*** locator;
	org.apache.xml.dtm.DTMException(java.lang.String);
	org.apache.xml.dtm.DTMException(java.lang.String,java.lang.Throwable);
	org.apache.xml.dtm.DTMException(java.lang.String,javax.xml.transform.SourceLocator);
	org.apache.xml.dtm.DTMException(java.lang.String,javax.xml.transform.SourceLocator,java.lang.Throwable);
	org.apache.xml.dtm.DTMException(java.lang.Throwable);
	*** class$(java.lang.String);
	*** getException();
	*** getLocationAsString();
	*** printStackTrace(java.io.PrintWriter);
}

-keep class org.apache.xml.dtm.DTMIterator {
	*** allowDetachToRelease(boolean);
	*** clone();
	*** cloneWithReset();
	*** detach();
	*** getAxis();
	*** getCurrentNode();
	*** getCurrentPos();
	*** getDTM(int);
	*** getExpandEntityReferences();
	*** getLength();
	*** getRoot();
	*** getWhatToShow();
	*** isDocOrdered();
	*** item(int);
	*** nextNode();
	*** previousNode();
	*** reset();
	*** runTo(int);
	*** setCurrentPos(int);
	*** setItem(int,int);
	*** setRoot(int,java.lang.Object);
	*** setShouldCacheNodes(boolean);
}

-keep class org.apache.xml.dtm.DTMManager {
	*** debug;
	*** defaultClassName;
	*** m_incremental;
	*** m_source_location;
	*** m_xsf;
	org.apache.xml.dtm.DTMManager();
	*** createDTMIterator(int,org.apache.xml.dtm.DTMFilter,boolean);
	*** createDTMIterator(java.lang.Object,int);
	*** createDTMIterator(java.lang.String,org.apache.xml.utils.PrefixResolver);
	*** createDocumentFragment();
	*** getDTM(int);
	*** getDTM(javax.xml.transform.Source,boolean,org.apache.xml.dtm.DTMWSFilter,boolean,boolean);
	*** getDTMHandleFromNode(org.w3c.dom.Node);
	*** getDTMIdentity(org.apache.xml.dtm.DTM);
	*** getSource_location();
	*** newInstance(org.apache.xml.utils.XMLStringFactory);
	*** release(org.apache.xml.dtm.DTM,boolean);
	*** setXMLStringFactory(org.apache.xml.utils.XMLStringFactory);
}

-keep class org.apache.xml.dtm.DTMWSFilter {
	*** getShouldStripSpace(int,org.apache.xml.dtm.DTM);
}

-keep class org.apache.xml.dtm.ObjectFactory {
	*** class$org$apache$xml$dtm$ObjectFactory;
	*** fLastModified;
	*** fXalanProperties;
	*** class$(java.lang.String);
	*** createObject(java.lang.String,java.lang.String);
	*** createObject(java.lang.String,java.lang.String,java.lang.String);
	*** debugPrintln(java.lang.String);
	*** findClassLoader();
	*** findJarServiceProviderName(java.lang.String);
	*** findProviderClass(java.lang.String,java.lang.ClassLoader,boolean);
	*** lookUpFactoryClass(java.lang.String,java.lang.String,java.lang.String);
	*** lookUpFactoryClassName(java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.apache.xml.dtm.ObjectFactory$ConfigurationError {
	*** exception;
	*** getException();
}

-keep class org.apache.xml.dtm.SecuritySupport {
	*** securitySupport;
	org.apache.xml.dtm.SecuritySupport();
	*** getContextClassLoader();
	*** getFileExists(java.io.File);
	*** getFileInputStream(java.io.File);
	*** getInstance();
	*** getLastModified(java.io.File);
	*** getParentClassLoader(java.lang.ClassLoader);
	*** getResourceAsStream(java.lang.ClassLoader,java.lang.String);
	*** getSystemClassLoader();
	*** getSystemProperty(java.lang.String);
}

-keep class org.apache.xml.dtm.SecuritySupport12$1 {
	*** this$0;
}

-keep class org.apache.xml.dtm.SecuritySupport12$2 {
	*** this$0;
}

-keep class org.apache.xml.dtm.SecuritySupport12$4 {
	*** this$0;
	*** val$propName;
}

-keep class org.apache.xml.dtm.SecuritySupport12$6 {
	*** this$0;
	*** val$cl;
	*** val$name;
}

-keep class org.apache.xml.dtm.SecuritySupport12$7 {
	*** this$0;
	*** val$f;
}

-keep class org.apache.xml.dtm.ref.DTMAxisIteratorBase {
	*** _includeSelf;
	*** _isRestartable;
	*** _last;
	*** _markedNode;
	*** _position;
	*** _startNode;
	org.apache.xml.dtm.ref.DTMAxisIteratorBase();
	*** getLast();
	*** getPosition();
	*** gotoMark();
	*** includeSelf();
	*** isReverse();
	*** next();
	*** reset();
	*** resetPosition();
	*** returnNode(int);
	*** setMark();
	*** setStartNode(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBase {
	*** m_documentBaseURI;
	*** m_dtmIdent;
	*** m_elemIndexes;
	*** m_expandedNameTable;
	*** m_exptype;
	*** m_firstch;
	*** m_indexing;
	*** m_mgr;
	*** m_mgrDefault;
	*** m_namespaceDeclSetElements;
	*** m_namespaceDeclSets;
	*** m_namespaceLists;
	*** m_nextsib;
	*** m_parent;
	*** m_prevsib;
	*** m_shouldStripWS;
	*** m_shouldStripWhitespaceStack;
	*** m_size;
	*** m_traversers;
	*** m_wsfilter;
	*** m_xstrf;
	org.apache.xml.dtm.ref.DTMDefaultBase(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean);
	org.apache.xml.dtm.ref.DTMDefaultBase(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean,int,boolean,boolean);
	*** _exptype(int);
	*** _firstch(int);
	*** _level(int);
	*** _nextsib(int);
	*** _parent(int);
	*** _prevsib(int);
	*** _type(int);
	*** declareNamespaceInContext(int,int);
	*** ensureSizeOfIndex(int,int);
	*** error(java.lang.String);
	*** findElementFromIndex(int,int,int);
	*** findGTE(int[],int,int,int);
	*** findInSortedSuballocatedIntVector(org.apache.xml.utils.SuballocatedIntVector,int);
	*** findNamespaceContext(int);
	*** getDTMIDs();
	*** getDocument();
	*** getDocumentBaseURI();
	*** getDocumentRoot(int);
	*** getExpandedTypeID(int);
	*** getFirstAttribute(int);
	*** getFirstAttributeIdentity(int);
	*** getFirstChild(int);
	*** getFirstNamespaceNode(int,boolean);
	*** getLocalName(int);
	*** getManager();
	*** getNamespaceURI(int);
	*** getNextAttribute(int);
	*** getNextAttributeIdentity(int);
	*** getNextNamespaceNode(int,int,boolean);
	*** getNextNodeIdentity(int);
	*** getNextSibling(int);
	*** getNodeName(int);
	*** getNodeNameX(int);
	*** getNodeType(int);
	*** getNodeValue(int);
	*** getParent(int);
	*** getPrefix(int);
	*** getPreviousSibling(int);
	*** getShouldStripWhitespace();
	*** getStringValue(int);
	*** indexNode(int,int);
	*** makeNodeHandle(int);
	*** makeNodeIdentity(int);
	*** migrateTo(org.apache.xml.dtm.DTMManager);
	*** nextNode();
	*** popShouldStripWhitespace();
	*** pushShouldStripWhitespace(boolean);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators {
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean);
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean,int,boolean,boolean);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$AncestorIterator {
	*** m_ancestors;
	*** m_ancestorsPos;
	*** m_markedPos;
	*** m_realStartNode;
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators$AncestorIterator(org.apache.xml.dtm.ref.DTMDefaultBaseIterators);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$ChildrenIterator {
	*** this$0;
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$DescendantIterator {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators$DescendantIterator(org.apache.xml.dtm.ref.DTMDefaultBaseIterators);
	*** isDescendant(int);
	*** setStartNode(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$InternalAxisIteratorBase {
	*** _currentNode;
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators$InternalAxisIteratorBase(org.apache.xml.dtm.ref.DTMDefaultBaseIterators);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$ParentIterator {
	*** setNodeType(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$SingletonIterator {
	*** _isConstant;
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators$SingletonIterator(org.apache.xml.dtm.ref.DTMDefaultBaseIterators);
	org.apache.xml.dtm.ref.DTMDefaultBaseIterators$SingletonIterator(org.apache.xml.dtm.ref.DTMDefaultBaseIterators,int,boolean);
	*** setStartNode(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$TypedAncestorIterator {
	*** _nodeType;
	*** this$0;
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$TypedChildrenIterator {
	*** _nodeType;
	*** this$0;
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$TypedDescendantIterator {
	*** _nodeType;
	*** this$0;
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseIterators$TypedSingletonIterator {
	*** _nodeType;
	*** this$0;
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers {
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean,int,boolean,boolean);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AllFromNodeTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AllFromNodeTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AllFromNodeTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$1);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AllFromRootTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AllFromRootTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AllFromRootTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$1);
	*** next(int,int,int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AncestorOrSelfTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AncestorOrSelfTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AncestorTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AncestorTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AncestorTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$1);
	*** next(int,int,int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AttributeTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$AttributeTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$ChildTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$ChildTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	*** getNextIndexed(int,int,int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantFromRootTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantFromRootTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	*** getFirstPotential(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantOrSelfFromRootTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantOrSelfFromRootTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	*** first(int);
	*** getFirstPotential(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantOrSelfTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantOrSelfTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantOrSelfTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$1);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$DescendantTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$1);
	*** getFirstPotential(int);
	*** getSubtreeRoot(int);
	*** isDescendant(int,int);
	*** next(int,int,int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$FollowingSiblingTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$FollowingSiblingTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$FollowingTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$FollowingTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	*** next(int,int,int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$IndexedDTMAxisTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$IndexedDTMAxisTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$IndexedDTMAxisTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$1);
	*** axisHasBeenProcessed(int);
	*** getNextIndexed(int,int,int);
	*** isAfterAxis(int,int);
	*** isIndexed(int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$NamespaceDeclsTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$NamespaceDeclsTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$NamespaceTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$NamespaceTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$ParentTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$ParentTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$PrecedingAndAncestorTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$PrecedingAndAncestorTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$PrecedingSiblingTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$PrecedingSiblingTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$PrecedingTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$PrecedingTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
	*** isAncestor(int,int);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$RootTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$RootTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$SelfTraverser {
	*** this$0;
	org.apache.xml.dtm.ref.DTMDefaultBaseTraversers$SelfTraverser(org.apache.xml.dtm.ref.DTMDefaultBaseTraversers);
}

-keep class org.apache.xml.dtm.ref.DTMManagerDefault {
	*** m_defaultHandler;
	*** m_dtm_offsets;
	*** m_dtms;
	*** m_expandedNameTable;
	*** m_readerManager;
	*** addDTM(org.apache.xml.dtm.DTM,int,int);
	*** getDTM(javax.xml.transform.Source,boolean,org.apache.xml.dtm.DTMWSFilter,boolean,boolean);
	*** getDTMIdentity(org.apache.xml.dtm.DTM);
	*** getExpandedNameTable(org.apache.xml.dtm.DTM);
	*** getFirstFreeDTMID();
	*** getXMLReader(javax.xml.transform.Source);
	*** releaseXMLReader(org.xml.sax.XMLReader);
}

-keep class org.apache.xml.dtm.ref.DTMNamedNodeMap {
	*** getNamedItem(java.lang.String);
}

-keep class org.apache.xml.dtm.ref.DTMNodeList {
	*** m_iter;
	*** getDTMIterator();
}

-keep class org.apache.xml.dtm.ref.DTMNodeListBase {
	org.apache.xml.dtm.ref.DTMNodeListBase();
}

-keep class org.apache.xml.dtm.ref.DTMNodeProxy {
	*** actualEncoding;
	*** dtm;
	*** fDocumentURI;
	*** implementation;
	*** node;
	*** xmlEncoding;
	*** xmlStandalone;
	*** xmlVersion;
	*** equals(org.w3c.dom.Node);
	*** getAttributes();
	*** getDTMNodeNumber();
	*** getData();
	*** getLocalName();
	*** getNamespaceURI();
	*** getNodeName();
	*** getNodeType();
	*** getNodeValue();
	*** getOwnerDocument();
	*** getOwnerElement();
	*** getPrefix();
	*** hasAttributes();
	*** isSupported(java.lang.String,java.lang.String);
	*** setNodeValue(java.lang.String);
	*** traverseChildren(java.util.Vector,org.w3c.dom.Node,java.lang.String,boolean);
	*** traverseChildren(java.util.Vector,org.w3c.dom.Node,java.lang.String,java.lang.String,boolean,boolean);
}

-keep class org.apache.xml.dtm.ref.DTMStringPool {
	*** indexToString(int);
	*** stringToIndex(java.lang.String);
}

-keep class org.apache.xml.dtm.ref.DTMTreeWalker {
	*** getcontentHandler();
	*** setDTM(org.apache.xml.dtm.DTM);
	*** setcontentHandler(org.xml.sax.ContentHandler);
	*** traverse(int);
}

-keep class org.apache.xml.dtm.ref.ExpandedNameTable {
	*** hashET;
	*** m_capacity;
	*** m_defaultExtendedTypes;
	*** m_extendedTypes;
	*** m_initialCapacity;
	*** m_initialSize;
	*** m_loadFactor;
	*** m_nextType;
	*** m_table;
	*** m_threshold;
	*** getExpandedTypeID(int);
	*** getExpandedTypeID(java.lang.String,java.lang.String,int);
	*** getExpandedTypeID(java.lang.String,java.lang.String,int,boolean);
	*** getLocalName(int);
	*** getLocalNameID(int);
	*** getNamespace(int);
	*** getNamespaceID(int);
	*** getType(int);
	*** initExtendedTypes();
	*** rehash();
}

-keep class org.apache.xml.dtm.ref.ExpandedNameTable$HashEntry {
	*** hash;
	*** key;
	*** next;
	*** value;
}

-keep class org.apache.xml.dtm.ref.ExtendedType {
	*** hash;
	*** localName;
	*** namespace;
	*** nodetype;
	*** equals(org.apache.xml.dtm.ref.ExtendedType);
	*** getLocalName();
	*** getNamespace();
	*** getNodeType();
	*** redefine(int,java.lang.String,java.lang.String,int);
}

-keep class org.apache.xml.dtm.ref.IncrementalSAXSource {
	*** deliverMoreNodes(boolean);
	*** setContentHandler(org.xml.sax.ContentHandler);
	*** setDTDHandler(org.xml.sax.DTDHandler);
	*** setLexicalHandler(org.xml.sax.ext.LexicalHandler);
	*** startParse(org.xml.sax.InputSource);
}

-keep class org.apache.xml.dtm.ref.IncrementalSAXSource_Filter {
	*** setXMLReader(org.xml.sax.XMLReader);
}

-keep class org.apache.xml.dtm.ref.dom2dtm.DOM2DTM {
	*** m_last_kid;
	*** m_last_parent;
	*** m_nodes;
	*** m_nodesAreProcessed;
	*** m_pos;
	*** m_processedFirstElement;
	*** m_root;
	*** m_walker;
	*** addNode(org.w3c.dom.Node,int,int,int);
	*** dispatchNodeData(org.w3c.dom.Node,org.xml.sax.ContentHandler,int);
	*** getAttributeNode(int,java.lang.String,java.lang.String);
	*** getHandleFromNode(org.w3c.dom.Node);
	*** getHandleOfNode(org.w3c.dom.Node);
	*** getNextNodeIdentity(int);
	*** getNode(int);
	*** getNodeData(org.w3c.dom.Node,org.apache.xml.utils.FastStringBuffer);
	*** getStringValue(int);
	*** logicalNextDOMTextNode(org.w3c.dom.Node);
	*** lookupNode(int);
	*** nextNode();
}

-keep class org.apache.xml.dtm.ref.dom2dtm.DOM2DTM$CharacterNodeHandler {
	*** characters(org.w3c.dom.Node);
}

-keep class org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode {
	*** NOT_SUPPORTED_ERR;
	*** handle;
	*** nodename;
	*** prefix;
	*** pseudoparent;
	*** uri;
	*** getAttributes();
	*** getLocalName();
	*** getNamespaceURI();
	*** getNodeName();
	*** getNodeType();
	*** getNodeValue();
	*** getOwnerDocument();
	*** getOwnerElement();
	*** getPrefix();
	*** hasAttributes();
	*** isSupported(java.lang.String,java.lang.String);
	*** setNodeValue(java.lang.String);
}

-keep class org.apache.xml.dtm.ref.sax2dtm.SAX2DTM {
	*** m_chars;
	*** m_coalescedTextType;
	*** m_contextIndexes;
	*** m_data;
	*** m_dataOrQName;
	*** m_endDocumentOccured;
	*** m_entities;
	*** m_fixednames;
	*** m_idAttributes;
	*** m_incrementalSAXSource;
	*** m_insideDTD;
	*** m_locator;
	*** m_parents;
	*** m_pastFirstElement;
	*** m_prefixMappings;
	*** m_previous;
	*** m_sourceColumn;
	*** m_sourceLine;
	*** m_sourceSystemId;
	*** m_systemId;
	*** m_textPendingStart;
	*** m_textType;
	*** m_useSourceLocationProperty;
	*** m_valuesOrPrefixes;
	*** m_walker;
	org.apache.xml.dtm.ref.sax2dtm.SAX2DTM(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean);
	org.apache.xml.dtm.ref.sax2dtm.SAX2DTM(org.apache.xml.dtm.DTMManager,javax.xml.transform.Source,int,org.apache.xml.dtm.DTMWSFilter,org.apache.xml.utils.XMLStringFactory,boolean,int,boolean,boolean);
	*** _dataOrQName(int);
	*** addNewDTMID(int);
	*** addNode(int,int,int,int,int,boolean);
	*** characters(char[],int,int);
	*** charactersFlush();
	*** clearCoRoutine();
	*** clearCoRoutine(boolean);
	*** declAlreadyDeclared(java.lang.String);
	*** getLocalName(int);
	*** getNamespaceURI(int);
	*** getNextNodeIdentity(int);
	*** getPrefix(java.lang.String,java.lang.String);
	*** isTextType(int);
	*** nextNode();
	*** setIDAttribute(java.lang.String,int);
	*** setIncrementalSAXSource(org.apache.xml.dtm.ref.IncrementalSAXSource);
	*** setSourceLocation();
	*** startDocument();
}

-keep class org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM {
	*** m_currentDocumentNode;
	*** m_emptyCharsCount;
	*** m_emptyDataCount;
	*** m_emptyDataQNCount;
	*** m_emptyNSDeclSetCount;
	*** m_emptyNSDeclSetElemsCount;
	*** m_emptyNodeCount;
	*** mark_char_size;
	*** mark_data_size;
	*** mark_doq_size;
	*** mark_nsdeclelem_size;
	*** mark_nsdeclset_size;
	*** mark_size;
	*** isTreeIncomplete();
	*** popRewindMark();
	*** pushRewindMark();
}

-keep class org.apache.xml.res.XMLMessages {
	*** createXMLMessage(java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xml.utils.BoolStack {
	*** popAndTop();
	*** push(boolean);
	*** setTop(boolean);
}

-keep class org.apache.xml.utils.DOM2Helper {
	*** m_doc;
	*** setDocument(org.w3c.dom.Document);
}

-keep class org.apache.xml.utils.DOMHelper {
	*** m_DOMFactory;
	*** m_NSInfoNullNoAncestorXMLNS;
	*** m_NSInfoNullWithXMLNS;
	*** m_NSInfoNullWithoutXMLNS;
	*** m_NSInfoUnProcNoAncestorXMLNS;
	*** m_NSInfoUnProcWithXMLNS;
	*** m_NSInfoUnProcWithoutXMLNS;
	*** m_NSInfos;
	*** m_candidateNoAncestorXMLNS;
	org.apache.xml.utils.DOMHelper();
	*** createDocument();
	*** createDocument(boolean);
	*** getLocalNameOfNode(org.w3c.dom.Node);
	*** getNamespaceOfNode(org.w3c.dom.Node);
	*** getNodeData(org.w3c.dom.Node,org.apache.xml.utils.FastStringBuffer);
	*** getParentOfNode(org.w3c.dom.Node);
	*** isNodeAfter(org.w3c.dom.Node,org.w3c.dom.Node);
	*** isNodeAfterSibling(org.w3c.dom.Node,org.w3c.dom.Node,org.w3c.dom.Node);
	*** isNodeTheSame(org.w3c.dom.Node,org.w3c.dom.Node);
	*** locateAttrParent(org.w3c.dom.Element,org.w3c.dom.Node);
}

-keep class org.apache.xml.utils.DOMOrder {
	*** getUid();
}

-keep class org.apache.xml.utils.DefaultErrorHandler {
	*** m_pw;
	*** m_throwExceptionOnError;
	org.apache.xml.utils.DefaultErrorHandler(boolean);
	*** getErrorWriter();
	*** printLocation(java.io.PrintWriter,java.lang.Throwable);
}

-keep class org.apache.xml.utils.FastStringBuffer {
	*** append(char[],int,int);
	*** append(java.lang.String);
	*** getString(int,int);
	*** isWhitespace(int,int);
	*** length();
	*** sendNormalizedSAXcharacters(char[],int,int,org.xml.sax.ContentHandler);
	*** sendNormalizedSAXcharacters(org.xml.sax.ContentHandler,int,int);
	*** sendSAXcharacters(org.xml.sax.ContentHandler,int,int);
	*** setLength(int);
	*** size();
	*** toString();
}

-keep class org.apache.xml.utils.IntStack {
	*** empty();
	*** peek();
	*** pop();
	*** push(int);
	*** quickPop(int);
}

-keep class org.apache.xml.utils.IntVector {
	*** m_blocksize;
	*** m_firstFree;
	*** m_map;
	*** m_mapSize;
	org.apache.xml.utils.IntVector();
	org.apache.xml.utils.IntVector(int);
	org.apache.xml.utils.IntVector(org.apache.xml.utils.IntVector);
	*** addElement(int);
	*** clone();
	*** elementAt(int);
	*** lastIndexOf(int);
	*** removeAllElements();
	*** size();
}

-keep class org.apache.xml.utils.NSInfo {
	*** m_ancestorHasXMLNSAttrs;
	*** m_hasProcessedNS;
	*** m_hasXMLNSAttrs;
	*** m_namespace;
}

-keep class org.apache.xml.utils.NodeConsumer {
	*** setOriginatingNode(org.w3c.dom.Node);
}

-keep class org.apache.xml.utils.NodeVector {
	*** m_blocksize;
	*** m_firstFree;
	*** m_map;
	*** m_mapSize;
	*** RemoveAllNoClear();
	*** addElement(int);
	*** clone();
	*** elementAt(int);
	*** insertElementAt(int,int);
	*** peepOrNull();
	*** popQuick();
	*** push(int);
	*** setElementAt(int,int);
	*** size();
	*** sort(int[],int,int);
}

-keep class org.apache.xml.utils.ObjectStack {
	*** peek();
	*** pop();
	*** push(java.lang.Object);
	*** setTop(java.lang.Object);
}

-keep class org.apache.xml.utils.ObjectVector {
	*** m_blocksize;
	*** m_firstFree;
	*** m_map;
	*** m_mapSize;
	org.apache.xml.utils.ObjectVector();
	org.apache.xml.utils.ObjectVector(int);
	org.apache.xml.utils.ObjectVector(org.apache.xml.utils.ObjectVector);
	*** addElement(java.lang.Object);
	*** clone();
	*** elementAt(int);
	*** lastIndexOf(java.lang.Object);
	*** removeAllElements();
	*** setElementAt(java.lang.Object,int);
	*** setToSize(int);
	*** size();
}

-keep class org.apache.xml.utils.PrefixResolver {
	*** getNamespaceForPrefix(java.lang.String);
	*** handlesNullPrefixes();
}

-keep class org.apache.xml.utils.QName {
	*** equals(java.lang.Object);
	*** getLocalName();
	*** getLocalPart();
	*** getLocalPart(java.lang.String);
	*** getNamespace();
	*** getNamespaceURI();
	*** toString();
}

-keep class org.apache.xml.utils.SAXSourceLocator {
	*** m_locator;
}

-keep class org.apache.xml.utils.StringBufferPool {
	*** free(org.apache.xml.utils.FastStringBuffer);
	*** get();
}

-keep class org.apache.xml.utils.StringVector {
	*** addElement(java.lang.String);
	*** contains(java.lang.String);
	*** elementAt(int);
	*** size();
}

-keep class org.apache.xml.utils.SuballocatedIntVector {
	*** m_MASK;
	*** m_SHIFT;
	*** m_blocksize;
	*** m_buildCache;
	*** m_buildCacheStartIndex;
	*** m_firstFree;
	*** m_map;
	*** m_map0;
	*** m_numblocks;
	org.apache.xml.utils.SuballocatedIntVector(int);
	org.apache.xml.utils.SuballocatedIntVector(int,int);
	*** addElement(int);
	*** elementAt(int);
	*** indexOf(int);
	*** indexOf(int,int);
	*** removeElementAt(int);
	*** setElementAt(int,int);
	*** setSize(int);
	*** size();
}

-keep class org.apache.xml.utils.SystemIDResolver {
	*** getAbsoluteURI(java.lang.String);
	*** getAbsoluteURI(java.lang.String,java.lang.String);
}

-keep class org.apache.xml.utils.TreeWalker {
	*** m_contentHandler;
	*** m_dh;
	*** m_locator;
	*** nextIsRaw;
	*** dispatachChars(org.w3c.dom.Node);
	*** endNode(org.w3c.dom.Node);
	*** getContentHandler();
	*** setContentHandler(org.xml.sax.ContentHandler);
	*** startNode(org.w3c.dom.Node);
	*** traverseFragment(org.w3c.dom.Node);
}

-keep class org.apache.xml.utils.WrappedRuntimeException {
	*** m_exception;
	*** getException();
}

-keep class org.apache.xml.utils.XMLCharacterRecognizer {
	*** isWhiteSpace(char);
	*** isWhiteSpace(java.lang.String);
}

-keep class org.apache.xml.utils.XMLReaderManager {
	*** getInstance();
	*** getXMLReader();
	*** releaseXMLReader(org.xml.sax.XMLReader);
}

-keep class org.apache.xml.utils.XMLString {
	*** charAt(int);
	*** dispatchCharactersEvents(org.xml.sax.ContentHandler);
	*** equals(java.lang.String);
	*** equals(org.apache.xml.utils.XMLString);
	*** fixWhiteSpace(boolean,boolean,boolean);
	*** hasString();
	*** indexOf(org.apache.xml.utils.XMLString);
	*** length();
	*** startsWith(org.apache.xml.utils.XMLString);
	*** substring(int);
	*** substring(int,int);
	*** toDouble();
	*** toString();
}

-keep class org.apache.xml.utils.XMLStringFactory {
	org.apache.xml.utils.XMLStringFactory();
	*** emptystr();
	*** newstr(java.lang.String);
	*** newstr(org.apache.xml.utils.FastStringBuffer,int,int);
}

-keep class org.apache.xpath.Expression {
	*** m_parent;
	org.apache.xpath.Expression();
	*** asIterator(org.apache.xpath.XPathContext,int);
	*** asNode(org.apache.xpath.XPathContext);
	*** assertion(boolean,java.lang.String);
	*** bool(org.apache.xpath.XPathContext);
	*** callVisitors(org.apache.xpath.ExpressionOwner,org.apache.xpath.XPathVisitor);
	*** canTraverseOutsideSubtree();
	*** deepEquals(org.apache.xpath.Expression);
	*** error(org.apache.xpath.XPathContext,java.lang.String,java.lang.Object[]);
	*** execute(org.apache.xpath.XPathContext);
	*** execute(org.apache.xpath.XPathContext,boolean);
	*** exprGetParent();
	*** exprSetParent(org.apache.xpath.ExpressionNode);
	*** fixupVariables(java.util.Vector,int);
	*** getExpressionOwner();
	*** isNodesetExpr();
	*** isSameClass(org.apache.xpath.Expression);
	*** isStableNumber();
	*** num(org.apache.xpath.XPathContext);
	*** warn(org.apache.xpath.XPathContext,java.lang.String,java.lang.Object[]);
}

-keep class org.apache.xpath.ExpressionNode {
	*** exprGetParent();
}

-keep class org.apache.xpath.ExtensionsProvider {
	*** elementAvailable(java.lang.String,java.lang.String);
	*** extFunction(org.apache.xpath.functions.FuncExtFunction,java.util.Vector);
	*** functionAvailable(java.lang.String,java.lang.String);
}

-keep class org.apache.xpath.NodeSet {
	*** addNode(org.w3c.dom.Node);
}

-keep class org.apache.xpath.NodeSetDTM {
	*** addNode(int);
	*** addNodeInDocOrder(int,org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.SourceTree {
	*** m_root;
	*** m_url;
}

-keep class org.apache.xpath.SourceTreeManager {
	*** m_sourceTree;
	*** m_uriResolver;
	*** getNode(javax.xml.transform.Source);
	*** getSourceTree(javax.xml.transform.Source,javax.xml.transform.SourceLocator,org.apache.xpath.XPathContext);
	*** parseToNode(javax.xml.transform.Source,javax.xml.transform.SourceLocator,org.apache.xpath.XPathContext);
	*** putDocumentInCache(int,javax.xml.transform.Source);
	*** resolveURI(java.lang.String,java.lang.String,javax.xml.transform.SourceLocator);
}

-keep class org.apache.xpath.VariableStack {
	*** _currentFrameBottom;
	*** _frameTop;
	*** _links;
	*** _linksTop;
	*** _stackFrames;
	*** m_nulls;
	org.apache.xpath.VariableStack(int);
	*** getGlobalVariable(org.apache.xpath.XPathContext,int);
	*** getGlobalVariable(org.apache.xpath.XPathContext,int,boolean);
	*** getLocalVariable(org.apache.xpath.XPathContext,int);
	*** getLocalVariable(org.apache.xpath.XPathContext,int,boolean);
	*** getStackFrame();
	*** getVariableOrParam(org.apache.xpath.XPathContext,org.apache.xml.utils.QName);
	*** reset();
	*** reset(int,int);
	*** setStackFrame(int);
}

-keep class org.apache.xpath.XPath {
	*** m_funcTable;
	*** m_mainExp;
	*** m_patternString;
	org.apache.xpath.XPath(java.lang.String,javax.xml.transform.SourceLocator,org.apache.xml.utils.PrefixResolver,int,javax.xml.transform.ErrorListener);
	*** execute(org.apache.xpath.XPathContext,int,org.apache.xml.utils.PrefixResolver);
	*** execute(org.apache.xpath.XPathContext,org.w3c.dom.Node,org.apache.xml.utils.PrefixResolver);
	*** getExpression();
	*** getLocator();
	*** initFunctionTable();
	*** setExpression(org.apache.xpath.Expression);
}

-keep class org.apache.xpath.XPathContext {
	*** expressionContext;
	*** m_DTMXRTreeFrags;
	*** m_axesIteratorStack;
	*** m_contextNodeLists;
	*** m_currentExpressionNodes;
	*** m_currentNodes;
	*** m_defaultErrorListener;
	*** m_dtmManager;
	*** m_errorListener;
	*** m_global_rtfdtm;
	*** m_isSecureProcessing;
	*** m_iteratorRoots;
	*** m_last_pushed_rtfdtm;
	*** m_owner;
	*** m_ownerGetErrorListener;
	*** m_predicatePos;
	*** m_predicateRoots;
	*** m_prefixResolvers;
	*** m_primaryReader;
	*** m_rtfdtm_stack;
	*** m_saxLocations;
	*** m_sourceTreeManager;
	*** m_uriResolver;
	*** m_variableStacks;
	*** m_which_rtfdtm;
	org.apache.xpath.XPathContext(boolean);
	org.apache.xpath.XPathContext(java.lang.Object,boolean);
	*** access$000(org.apache.xpath.XPathContext);
	*** createDocumentFragment();
	*** getContextNode();
	*** getContextNodeList();
	*** getCurrentNode();
	*** getCurrentNodeList();
	*** getDTM(int);
	*** getDTM(javax.xml.transform.Source,boolean,org.apache.xml.dtm.DTMWSFilter,boolean,boolean);
	*** getDTMHandleFromNode(org.w3c.dom.Node);
	*** getDTMManager();
	*** getErrorListener();
	*** getIteratorRoot();
	*** getNamespaceContext();
	*** getOwnerObject();
	*** getPredicatePos();
	*** getRTFDTM();
	*** getSAXLocator();
	*** getSubContextList();
	*** getVarStack();
	*** isSecureProcessing();
	*** popCurrentExpressionNode();
	*** popCurrentNode();
	*** popCurrentNodeAndExpression();
	*** popNamespaceContext();
	*** popPredicatePos();
	*** popSubContextList();
	*** pushCurrentExpressionNode(int);
	*** pushCurrentNode(int);
	*** pushCurrentNodeAndExpression(int,int);
	*** pushNamespaceContext(org.apache.xml.utils.PrefixResolver);
	*** pushPredicatePos(int);
	*** pushSubContextList(org.apache.xpath.axes.SubContextList);
	*** releaseDTMXRTreeFrags();
	*** setVarStack(org.apache.xpath.VariableStack);
}

-keep class org.apache.xpath.XPathContext$XPathExpressionContext {
	*** this$0;
}

-keep class org.apache.xpath.XPathException {
	*** class$java$lang$Throwable;
	*** m_exception;
	*** m_styleNode;
	org.apache.xpath.XPathException(java.lang.String);
	org.apache.xpath.XPathException(java.lang.String,java.lang.Exception);
	*** class$(java.lang.String);
	*** getExpressionOwner(org.apache.xpath.ExpressionNode);
	*** getMessage();
	*** getStylesheetNode(org.apache.xpath.ExpressionNode);
	*** setStylesheetNode(java.lang.Object);
}

-keep class org.apache.xpath.XPathVisitor {
	*** visitBinaryOperation(org.apache.xpath.ExpressionOwner,org.apache.xpath.operations.Operation);
	*** visitFunction(org.apache.xpath.ExpressionOwner,org.apache.xpath.functions.Function);
	*** visitLocationPath(org.apache.xpath.ExpressionOwner,org.apache.xpath.axes.LocPathIterator);
	*** visitMatchPattern(org.apache.xpath.ExpressionOwner,org.apache.xpath.patterns.StepPattern);
	*** visitNumberLiteral(org.apache.xpath.ExpressionOwner,org.apache.xpath.objects.XNumber);
	*** visitPredicate(org.apache.xpath.ExpressionOwner,org.apache.xpath.Expression);
	*** visitStep(org.apache.xpath.ExpressionOwner,org.apache.xpath.patterns.NodeTest);
	*** visitStringLiteral(org.apache.xpath.ExpressionOwner,org.apache.xpath.objects.XString);
	*** visitUnaryOperation(org.apache.xpath.ExpressionOwner,org.apache.xpath.operations.UnaryOperation);
	*** visitUnionPath(org.apache.xpath.ExpressionOwner,org.apache.xpath.axes.UnionPathIterator);
	*** visitUnionPattern(org.apache.xpath.ExpressionOwner,org.apache.xpath.patterns.UnionPattern);
	*** visitVariableRef(org.apache.xpath.ExpressionOwner,org.apache.xpath.operations.Variable);
}

-keep class org.apache.xpath.axes.AxesWalker {
	*** m_axis;
	*** m_currentNode;
	*** m_dtm;
	*** m_isFresh;
	*** m_nextWalker;
	*** m_prevWalker;
	*** m_root;
	*** m_traverser;
	org.apache.xpath.axes.AxesWalker(org.apache.xpath.axes.LocPathIterator,int);
	*** callVisitors(org.apache.xpath.ExpressionOwner,org.apache.xpath.XPathVisitor);
	*** clone();
	*** cloneDeep(org.apache.xpath.axes.WalkingIterator,java.util.Vector);
	*** deepEquals(org.apache.xpath.Expression);
	*** detach();
	*** findClone(org.apache.xpath.axes.AxesWalker,java.util.Vector);
	*** getAnalysisBits();
	*** getAxis();
	*** getDTM(int);
	*** getNextNode();
	*** getNextWalker();
	*** getRoot();
	*** init(org.apache.xpath.compiler.Compiler,int,int);
	*** isDocOrdered();
	*** nextNode();
	*** setNextWalker(org.apache.xpath.axes.AxesWalker);
	*** setPrevWalker(org.apache.xpath.axes.AxesWalker);
	*** setRoot(int);
	*** wi();
}

-keep class org.apache.xpath.axes.BasicTestIterator {
	org.apache.xpath.axes.BasicTestIterator(org.apache.xml.utils.PrefixResolver);
	org.apache.xpath.axes.BasicTestIterator(org.apache.xpath.compiler.Compiler,int,int);
	*** cloneWithReset();
	*** getNextNode();
	*** nextNode();
}

-keep class org.apache.xpath.axes.ChildTestIterator {
	*** m_traverser;
	org.apache.xpath.axes.ChildTestIterator(org.apache.xml.dtm.DTMAxisTraverser);
	org.apache.xpath.axes.ChildTestIterator(org.apache.xpath.compiler.Compiler,int,int);
	*** cloneWithReset();
	*** detach();
	*** setRoot(int,java.lang.Object);
}

-keep class org.apache.xpath.axes.DescendantIterator {
	*** m_axis;
	*** m_extendedTypeID;
	*** m_traverser;
}

-keep class org.apache.xpath.axes.FilterExprIteratorSimple {
	*** executeFilterExpr(int,org.apache.xpath.XPathContext,org.apache.xml.utils.PrefixResolver,boolean,int,org.apache.xpath.Expression);
}

-keep class org.apache.xpath.axes.FilterExprWalker {
	*** m_canDetachNodeset;
	*** m_expr;
	*** m_exprObj;
	*** m_mustHardReset;
}

-keep class org.apache.xpath.axes.HasPositionalPredChecker {
	*** check(org.apache.xpath.axes.LocPathIterator);
}

-keep class org.apache.xpath.axes.IteratorPool {
	*** m_freeStack;
	*** m_orig;
	*** freeInstance(org.apache.xml.dtm.DTMIterator);
	*** getInstance();
	*** getInstanceOrThrow();
}

-keep class org.apache.xpath.axes.LocPathIterator {
	*** m_allowDetach;
	*** m_cdtm;
	*** m_clones;
	*** m_context;
	*** m_currentContextNode;
	*** m_execContext;
	*** m_isTopLevel;
	*** m_lastFetched;
	*** m_length;
	*** m_pos;
	*** m_prefixResolver;
	*** m_stackFrame;
	org.apache.xpath.axes.LocPathIterator();
	org.apache.xpath.axes.LocPathIterator(org.apache.xml.utils.PrefixResolver);
	org.apache.xpath.axes.LocPathIterator(org.apache.xpath.compiler.Compiler,int,int,boolean);
	*** asIterator(org.apache.xpath.XPathContext,int);
	*** asNode(org.apache.xpath.XPathContext);
	*** callVisitors(org.apache.xpath.ExpressionOwner,org.apache.xpath.XPathVisitor);
	*** cloneWithReset();
	*** detach();
	*** getAnalysisBits();
	*** getAxis();
	*** getCurrentContextNode();
	*** getCurrentPos();
	*** getDTM(int);
	*** getIsTopLevel();
	*** getLength();
	*** getPrefixResolver();
	*** getRoot();
	*** getXPathContext();
	*** incrementCurrentPos();
	*** nextNode();
	*** reset();
	*** returnNextNode(int);
	*** setIsTopLevel(boolean);
	*** setRoot(int,java.lang.Object);
}

-keep class org.apache.xpath.axes.NodeSequence {
	*** m_cache;
	*** m_dtmMgr;
	*** m_iter;
	*** m_last;
	*** m_next;
	org.apache.xpath.axes.NodeSequence();
	org.apache.xpath.axes.NodeSequence(java.lang.Object);
	*** SetVector(org.apache.xml.utils.NodeVector);
	*** addNodeInDocOrder(int);
	*** cacheComplete();
	*** clone();
	*** cloneWithReset();
	*** detach();
	*** getAxis();
	*** getCache();
	*** getDTMManager();
	*** getIteratorCache();
	*** getLength();
	*** getVector();
	*** hasCache();
	*** isDocOrdered();
	*** item(int);
	*** markCacheComplete();
	*** nextNode();
	*** previousNode();
	*** runTo(int);
	*** setCurrentPos(int);
	*** setIter(org.apache.xml.dtm.DTMIterator);
	*** setObject(java.lang.Object);
	*** setRoot(int,java.lang.Object);
	*** setShouldCacheNodes(boolean);
}

-keep class org.apache.xpath.axes.NodeSequence$IteratorCache {
	*** m_isComplete2;
	*** m_useCount2;
	*** m_vec2;
	*** access$000(org.apache.xpath.axes.NodeSequence$IteratorCache);
	*** access$100(org.apache.xpath.axes.NodeSequence$IteratorCache);
	*** access$200(org.apache.xpath.axes.NodeSequence$IteratorCache,boolean);
	*** access$300(org.apache.xpath.axes.NodeSequence$IteratorCache);
	*** access$400(org.apache.xpath.axes.NodeSequence$IteratorCache,org.apache.xml.utils.NodeVector);
	*** access$500(org.apache.xpath.axes.NodeSequence$IteratorCache);
	*** getVector();
	*** increaseUseCount();
	*** isComplete();
	*** setCacheComplete(boolean);
	*** setVector(org.apache.xml.utils.NodeVector);
	*** useCount();
}

-keep class org.apache.xpath.axes.OneStepIterator {
	*** m_axis;
	*** m_iterator;
	*** clone();
	*** cloneWithReset();
	*** isReverseAxes();
	*** setRoot(int,java.lang.Object);
}

-keep class org.apache.xpath.axes.OneStepIteratorForward {
	*** m_axis;
}

-keep class org.apache.xpath.axes.PathComponent {
	*** getAnalysisBits();
}

-keep class org.apache.xpath.axes.PredicatedNodeTest {
	*** m_foundLast;
	*** m_lpi;
	*** m_predCount;
	*** m_predicateIndex;
	*** m_predicates;
	*** m_proximityPositions;
	org.apache.xpath.axes.PredicatedNodeTest();
	org.apache.xpath.axes.PredicatedNodeTest(org.apache.xpath.axes.LocPathIterator);
	*** acceptNode(int);
	*** callPredicateVisitors(org.apache.xpath.XPathVisitor);
	*** clone();
	*** countProximityPosition(int);
	*** deepEquals(org.apache.xpath.Expression);
	*** executePredicates(int,org.apache.xpath.XPathContext);
	*** fixupVariables(java.util.Vector,int);
	*** getLocPathIterator();
	*** getPredicate(int);
	*** getPredicateCount();
	*** getProximityPosition();
	*** getProximityPosition(int);
	*** initPredicateInfo(org.apache.xpath.compiler.Compiler,int);
	*** initProximityPosition(int);
	*** resetProximityPositions();
	*** setLocPathIterator(org.apache.xpath.axes.LocPathIterator);
	*** setPredicateCount(int);
}

-keep class org.apache.xpath.axes.ReverseAxesWalker {
	*** m_iterator;
	*** setRoot(int);
}

-keep class org.apache.xpath.axes.SubContextList {
	*** getLastPos(org.apache.xpath.XPathContext);
	*** getProximityPosition(org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.axes.UnionChildIterator {
	*** addNodeTest(org.apache.xpath.axes.PredicatedNodeTest);
}

-keep class org.apache.xpath.axes.UnionPathIterator {
	*** m_exprs;
	*** m_iterators;
	*** addIterator(org.apache.xml.dtm.DTMIterator);
	*** createDTMIterator(org.apache.xpath.compiler.Compiler,int);
	*** createUnionIterator(org.apache.xpath.compiler.Compiler,int);
	*** loadLocationPaths(org.apache.xpath.compiler.Compiler,int,int);
	*** setRoot(int,java.lang.Object);
}

-keep class org.apache.xpath.axes.WalkerFactory {
	*** analyze(org.apache.xpath.compiler.Compiler,int,int);
	*** analyzePredicate(org.apache.xpath.compiler.Compiler,int,int);
	*** canCrissCross(int);
	*** canSkipSubtrees(int);
	*** createDefaultStepPattern(org.apache.xpath.compiler.Compiler,int,org.apache.xpath.axes.MatchPatternIterator,int,org.apache.xpath.patterns.StepPattern,org.apache.xpath.patterns.StepPattern);
	*** createDefaultWalker(org.apache.xpath.compiler.Compiler,int,org.apache.xpath.axes.WalkingIterator,int);
	*** functionProximateOrContainsProximate(org.apache.xpath.compiler.Compiler,int);
	*** getAnalysisBitFromAxes(int);
	*** getAnalysisString(int);
	*** getAxisFromStep(org.apache.xpath.compiler.Compiler,int);
	*** getStepCount(int);
	*** hasPredicate(int);
	*** isAbsolute(int);
	*** isDownwardAxisOfMany(int);
	*** isNaturalDocOrder(int);
	*** isNaturalDocOrder(org.apache.xpath.compiler.Compiler,int,int,int);
	*** isOneStep(int);
	*** isOptimizableForDescendantIterator(org.apache.xpath.compiler.Compiler,int,int);
	*** isProximateInnerExpr(org.apache.xpath.compiler.Compiler,int);
	*** isSet(int,int);
	*** isWild(int);
	*** loadWalkers(org.apache.xpath.axes.WalkingIterator,org.apache.xpath.compiler.Compiler,int,int);
	*** mightBeProximate(org.apache.xpath.compiler.Compiler,int,int);
	*** newDTMIterator(org.apache.xpath.compiler.Compiler,int,boolean);
	*** walksAttributes(int);
	*** walksChildren(int);
	*** walksChildrenAndExtraAndSelfOnly(int);
	*** walksChildrenOnly(int);
	*** walksDescendants(int);
	*** walksDescendantsAndExtraAndSelfOnly(int);
	*** walksDownOnly(int);
	*** walksExtraNodes(int);
	*** walksExtraNodesOnly(int);
	*** walksFilteredList(int);
	*** walksFollowingOnlyMaybeAbsolute(int);
	*** walksInDocOrder(int);
	*** walksNamespaces(int);
	*** walksSelfOnly(int);
	*** walksSideways(int);
	*** walksSubtree(int);
	*** walksSubtreeOnlyMaybeAbsolute(int);
	*** walksUp(int);
	*** walksUpOnly(int);
}

-keep class org.apache.xpath.axes.WalkingIterator {
	*** m_firstWalker;
	*** m_lastUsedWalker;
	org.apache.xpath.axes.WalkingIterator(org.apache.xml.utils.PrefixResolver);
	org.apache.xpath.axes.WalkingIterator(org.apache.xpath.compiler.Compiler,int,int,boolean);
	*** fixupVariables(java.util.Vector,int);
	*** getAnalysisBits();
	*** getLastUsedWalker();
	*** setLastUsedWalker(org.apache.xpath.axes.AxesWalker);
}

-keep class org.apache.xpath.axes.WalkingIteratorSorted {
	*** m_inNaturalOrderStatic;
}

-keep class org.apache.xpath.compiler.Compiler {
	*** locPathDepth;
	*** m_currentPrefixResolver;
	*** m_errorHandler;
	*** m_functionTable;
	*** m_locator;
	*** s_nextMethodId;
	*** and(int);
	*** arg(int);
	*** bool(int);
	*** compile(int);
	*** compileExtension(int);
	*** compileFunction(int);
	*** compileOperation(org.apache.xpath.operations.Operation,int);
	*** compilePredicates(int,org.apache.xpath.Expression[]);
	*** compileUnary(org.apache.xpath.operations.UnaryOperation,int);
	*** countPredicates(int);
	*** div(int);
	*** equals(int);
	*** error(java.lang.String,java.lang.Object[]);
	*** getCompiledPredicates(int);
	*** getFunctionTable();
	*** getLocationPathDepth();
	*** getNamespaceContext();
	*** getNextMethodId();
	*** getWhatToShow(int);
	*** group(int);
	*** gt(int);
	*** gte(int);
	*** literal(int);
	*** locationPath(int);
	*** locationPathPattern(int);
	*** lt(int);
	*** lte(int);
	*** matchPattern(int);
	*** minus(int);
	*** mod(int);
	*** mult(int);
	*** neg(int);
	*** notequals(int);
	*** number(int);
	*** numberlit(int);
	*** or(int);
	*** plus(int);
	*** predicate(int);
	*** stepPattern(int,int,org.apache.xpath.patterns.StepPattern);
	*** string(int);
	*** union(int);
	*** variable(int);
}

-keep class org.apache.xpath.compiler.FunctionTable {
	*** class$org$apache$xalan$templates$FuncKey;
	*** class$org$apache$xpath$functions$FuncBoolean;
	*** class$org$apache$xpath$functions$FuncCeiling;
	*** class$org$apache$xpath$functions$FuncConcat;
	*** class$org$apache$xpath$functions$FuncContains;
	*** class$org$apache$xpath$functions$FuncCount;
	*** class$org$apache$xpath$functions$FuncCurrent;
	*** class$org$apache$xpath$functions$FuncDoclocation;
	*** class$org$apache$xpath$functions$FuncExtElementAvailable;
	*** class$org$apache$xpath$functions$FuncExtFunctionAvailable;
	*** class$org$apache$xpath$functions$FuncFalse;
	*** class$org$apache$xpath$functions$FuncFloor;
	*** class$org$apache$xpath$functions$FuncGenerateId;
	*** class$org$apache$xpath$functions$FuncId;
	*** class$org$apache$xpath$functions$FuncLang;
	*** class$org$apache$xpath$functions$FuncLast;
	*** class$org$apache$xpath$functions$FuncLocalPart;
	*** class$org$apache$xpath$functions$FuncNamespace;
	*** class$org$apache$xpath$functions$FuncNormalizeSpace;
	*** class$org$apache$xpath$functions$FuncNot;
	*** class$org$apache$xpath$functions$FuncNumber;
	*** class$org$apache$xpath$functions$FuncPosition;
	*** class$org$apache$xpath$functions$FuncQname;
	*** class$org$apache$xpath$functions$FuncRound;
	*** class$org$apache$xpath$functions$FuncStartsWith;
	*** class$org$apache$xpath$functions$FuncString;
	*** class$org$apache$xpath$functions$FuncStringLength;
	*** class$org$apache$xpath$functions$FuncSubstring;
	*** class$org$apache$xpath$functions$FuncSubstringAfter;
	*** class$org$apache$xpath$functions$FuncSubstringBefore;
	*** class$org$apache$xpath$functions$FuncSum;
	*** class$org$apache$xpath$functions$FuncSystemProperty;
	*** class$org$apache$xpath$functions$FuncTranslate;
	*** class$org$apache$xpath$functions$FuncTrue;
	*** class$org$apache$xpath$functions$FuncUnparsedEntityURI;
	*** m_funcNextFreeIndex;
	*** m_functionID;
	*** m_functionID_customer;
	*** m_functions;
	*** m_functions_customer;
	*** class$(java.lang.String);
	*** functionAvailable(java.lang.String);
	*** getFunction(int);
	*** getFunctionID(java.lang.String);
	*** getFunctionName(int);
}

-keep class org.apache.xpath.compiler.Keywords {
	*** getAxisName(java.lang.String);
	*** getKeyWord(java.lang.String);
	*** getNodeType(java.lang.String);
	*** lookupNodeTest(java.lang.String);
}

-keep class org.apache.xpath.compiler.Lexer {
	*** m_compiler;
	*** m_namespaceContext;
	*** m_patternMap;
	*** m_patternMapSize;
	*** m_processor;
	*** addToTokenQueue(java.lang.String);
	*** getKeywordToken(java.lang.String);
	*** getTokenQueuePosFromMap(int);
	*** mapNSTokens(java.lang.String,int,int,int);
	*** mapPatternElemPos(int,boolean,boolean);
	*** recordTokenString(java.util.Vector);
	*** resetTokenMark(int);
	*** tokenize(java.lang.String);
	*** tokenize(java.lang.String,java.util.Vector);
}

-keep class org.apache.xpath.compiler.OpMap {
	*** m_currentPattern;
	*** m_opMap;
	*** m_tokenQueue;
	org.apache.xpath.compiler.OpMap();
	*** error(java.lang.String,java.lang.Object[]);
	*** getArgLength(int);
	*** getArgLengthOfStep(int);
	*** getFirstChildPos(int);
	*** getFirstChildPosOfStep(int);
	*** getFirstPredicateOpPos(int);
	*** getNextOpPos(int);
	*** getNextStepPos(int);
	*** getOp(int);
	*** getStepLocalName(int);
	*** getStepNS(int);
	*** getStepTestType(int);
	*** getTokenQueue();
	*** getTokenQueueSize();
	*** setOp(int,int);
	*** shrink();
	*** toString();
}

-keep class org.apache.xpath.compiler.OpMapVector {
	*** m_blocksize;
	*** m_lengthPos;
	*** m_map;
	*** m_mapSize;
	*** elementAt(int);
	*** setElementAt(int,int);
	*** setToSize(int);
}

-keep class org.apache.xpath.compiler.XPathParser {
	*** m_errorListener;
	*** m_functionTable;
	*** m_namespaceContext;
	*** m_ops;
	*** m_queueMark;
	*** m_sourceLocator;
	*** m_token;
	*** m_tokenChar;
	*** AbbreviatedNodeTestStep(boolean);
	*** AdditiveExpr(int);
	*** AndExpr();
	*** Argument();
	*** AxisName();
	*** Basis();
	*** EqualityExpr(int);
	*** Expr();
	*** FilterExpr();
	*** FunctionCall();
	*** IdKeyPattern();
	*** Literal();
	*** LocationPath();
	*** LocationPathPattern();
	*** MultiplicativeExpr(int);
	*** NodeTest(int);
	*** Number();
	*** OrExpr();
	*** PathExpr();
	*** Pattern();
	*** Predicate();
	*** PredicateExpr();
	*** PrimaryExpr();
	*** QName();
	*** RelationalExpr(int);
	*** RelativeLocationPath();
	*** RelativePathPattern();
	*** Step();
	*** StepPattern(boolean);
	*** UnaryExpr();
	*** UnionExpr();
	*** appendOp(int,int);
	*** consumeExpected(char);
	*** error(java.lang.String,java.lang.Object[]);
	*** errorForDOM3(java.lang.String,java.lang.Object[]);
	*** getErrorListener();
	*** getFunctionToken(java.lang.String);
	*** initMatchPattern(org.apache.xpath.compiler.Compiler,java.lang.String,org.apache.xml.utils.PrefixResolver);
	*** initXPath(org.apache.xpath.compiler.Compiler,java.lang.String,org.apache.xml.utils.PrefixResolver);
	*** insertOp(int,int,int);
	*** lookahead(char,int);
	*** lookahead(java.lang.String,int);
	*** nextToken();
	*** tokenIs(char);
	*** tokenIs(java.lang.String);
}

-keep class org.apache.xpath.functions.FuncConcat {
	*** reportWrongNumberArgs();
}

-keep class org.apache.xpath.functions.FuncExtFunction {
	*** m_argVec;
	*** m_extensionName;
	*** m_methodKey;
	*** m_namespace;
	*** toString();
}

-keep class org.apache.xpath.functions.FuncExtFunctionAvailable {
	*** m_functionTable;
	*** setFunctionTable(org.apache.xpath.compiler.FunctionTable);
}

-keep class org.apache.xpath.functions.FuncId {
	*** getNodesByID(org.apache.xpath.XPathContext,int,java.lang.String,org.apache.xml.utils.StringVector,org.apache.xpath.NodeSetDTM,boolean);
}

-keep class org.apache.xpath.functions.FuncLast {
	*** m_isTopLevel;
	*** getCountOfContextNodeList(org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.functions.FuncNormalizeSpace {
	*** execute(org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.functions.FuncPosition {
	*** m_isTopLevel;
	*** getPositionInContextNodeList(org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.functions.FuncSubstring {
	*** reportWrongNumberArgs();
}

-keep class org.apache.xpath.functions.FuncSystemProperty {
	*** loadPropertyFile(java.lang.String,java.util.Properties);
}

-keep class org.apache.xpath.functions.Function {
	org.apache.xpath.functions.Function();
	*** callArgVisitors(org.apache.xpath.XPathVisitor);
	*** checkNumberArgs(int);
	*** deepEquals(org.apache.xpath.Expression);
	*** postCompileStep(org.apache.xpath.compiler.Compiler);
	*** reportWrongNumberArgs();
	*** setArg(org.apache.xpath.Expression,int);
}

-keep class org.apache.xpath.functions.Function2Args {
	*** m_arg1;
	org.apache.xpath.functions.Function2Args();
	*** callArgVisitors(org.apache.xpath.XPathVisitor);
	*** canTraverseOutsideSubtree();
	*** deepEquals(org.apache.xpath.Expression);
	*** fixupVariables(java.util.Vector,int);
	*** getArg1();
	*** reportWrongNumberArgs();
	*** setArg(org.apache.xpath.Expression,int);
}

-keep class org.apache.xpath.functions.Function3Args {
	*** m_arg2;
	org.apache.xpath.functions.Function3Args();
	*** callArgVisitors(org.apache.xpath.XPathVisitor);
	*** canTraverseOutsideSubtree();
	*** deepEquals(org.apache.xpath.Expression);
	*** fixupVariables(java.util.Vector,int);
	*** reportWrongNumberArgs();
	*** setArg(org.apache.xpath.Expression,int);
}

-keep class org.apache.xpath.functions.FunctionDef1Arg {
	org.apache.xpath.functions.FunctionDef1Arg();
	*** Arg0IsNodesetExpr();
	*** getArg0AsNode(org.apache.xpath.XPathContext);
	*** getArg0AsNumber(org.apache.xpath.XPathContext);
	*** getArg0AsString(org.apache.xpath.XPathContext);
	*** reportWrongNumberArgs();
}

-keep class org.apache.xpath.functions.FunctionMultiArgs {
	*** m_args;
	org.apache.xpath.functions.FunctionMultiArgs();
}

-keep class org.apache.xpath.functions.FunctionOneArg {
	*** m_arg0;
	org.apache.xpath.functions.FunctionOneArg();
	*** callArgVisitors(org.apache.xpath.XPathVisitor);
	*** canTraverseOutsideSubtree();
	*** deepEquals(org.apache.xpath.Expression);
	*** fixupVariables(java.util.Vector,int);
	*** getArg0();
	*** reportWrongNumberArgs();
	*** setArg(org.apache.xpath.Expression,int);
}

-keep class org.apache.xpath.functions.ObjectFactory {
	*** findClassLoader();
}

-keep class org.apache.xpath.functions.SecuritySupport {
	*** getInstance();
	*** getResourceAsStream(java.lang.ClassLoader,java.lang.String);
}

-keep class org.apache.xpath.jaxp.JAXPVariableStack {
	*** resolver;
}

-keep class org.apache.xpath.jaxp.XPathFactoryImpl {
	*** featureSecureProcessing;
	*** xPathFunctionResolver;
	*** xPathVariableResolver;
}

-keep class org.apache.xpath.jaxp.XPathImpl {
	*** d;
	*** featureSecureProcessing;
	*** functionResolver;
	*** namespaceContext;
	*** origFunctionResolver;
	*** origVariableResolver;
	*** prefixResolver;
	*** variableResolver;
	*** eval(java.lang.String,java.lang.Object);
	*** evaluate(java.lang.String,java.lang.Object,javax.xml.namespace.QName);
	*** evaluate(java.lang.String,org.xml.sax.InputSource,javax.xml.namespace.QName);
	*** getParser();
	*** getResultAsType(org.apache.xpath.objects.XObject,javax.xml.namespace.QName);
	*** isSupported(javax.xml.namespace.QName);
}

-keep class org.apache.xpath.objects.Comparator {
	org.apache.xpath.objects.Comparator();
	*** compareNumbers(double,double);
	*** compareStrings(org.apache.xml.utils.XMLString,org.apache.xml.utils.XMLString);
}

-keep class org.apache.xpath.objects.DTMXRTreeFrag {
	*** destruct();
}

-keep class org.apache.xpath.objects.XBoolean {
	*** S_FALSE;
	*** S_TRUE;
	*** m_val;
}

-keep class org.apache.xpath.objects.XMLStringFactoryImpl {
	*** m_xstringfactory;
	*** getFactory();
}

-keep class org.apache.xpath.objects.XNodeSet {
	*** S_EQ;
	*** S_GT;
	*** S_GTE;
	*** S_LT;
	*** S_LTE;
	*** S_NEQ;
	org.apache.xpath.objects.XNodeSet(int,org.apache.xml.dtm.DTMManager);
	*** bool();
	*** compare(org.apache.xpath.objects.XObject,org.apache.xpath.objects.Comparator);
	*** getNumberFromNode(int);
	*** getStringFromNode(int);
	*** iter();
	*** iterRaw();
	*** mutableNodeset();
	*** num();
	*** xstr();
}

-keep class org.apache.xpath.objects.XNumber {
	*** m_val;
	*** bool();
	*** num();
	*** zeros(int);
}

-keep class org.apache.xpath.objects.XObject {
	*** m_obj;
	org.apache.xpath.objects.XObject();
	org.apache.xpath.objects.XObject(java.lang.Object);
	*** allowDetachToRelease(boolean);
	*** appendToFsb(org.apache.xml.utils.FastStringBuffer);
	*** bool();
	*** boolWithSideEffects();
	*** create(java.lang.Object,org.apache.xpath.XPathContext);
	*** detach();
	*** dispatchCharactersEvents(org.xml.sax.ContentHandler);
	*** equals(org.apache.xpath.objects.XObject);
	*** error(java.lang.String,java.lang.Object[]);
	*** execute(org.apache.xpath.XPathContext);
	*** fixupVariables(java.util.Vector,int);
	*** getFresh();
	*** getType();
	*** getTypeString();
	*** greaterThan(org.apache.xpath.objects.XObject);
	*** greaterThanOrEqual(org.apache.xpath.objects.XObject);
	*** iter();
	*** lessThan(org.apache.xpath.objects.XObject);
	*** lessThanOrEqual(org.apache.xpath.objects.XObject);
	*** nodelist();
	*** nodeset();
	*** notEquals(org.apache.xpath.objects.XObject);
	*** num();
	*** numWithSideEffects();
	*** object();
	*** rtf();
	*** setObject(java.lang.Object);
	*** str();
	*** xstr();
}

-keep class org.apache.xpath.objects.XObjectFactory {
	*** create(java.lang.Object);
	*** create(java.lang.Object,org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.objects.XString {
	*** EMPTYSTRING;
	*** bool();
	*** charAt(int);
	*** getChars(int,int,char[],int);
	*** isSpace(char);
	*** length();
	*** num();
	*** startsWith(java.lang.String,int);
	*** startsWith(org.apache.xml.utils.XMLString,int);
	*** str();
	*** toDouble();
	*** trim();
	*** xstr();
}

-keep class org.apache.xpath.operations.Operation {
	*** m_left;
	*** m_right;
	org.apache.xpath.operations.Operation();
	*** operate(org.apache.xpath.objects.XObject,org.apache.xpath.objects.XObject);
	*** setLeftRight(org.apache.xpath.Expression,org.apache.xpath.Expression);
}

-keep class org.apache.xpath.operations.UnaryOperation {
	*** m_right;
	org.apache.xpath.operations.UnaryOperation();
	*** operate(org.apache.xpath.objects.XObject);
	*** setRight(org.apache.xpath.Expression);
}

-keep class org.apache.xpath.operations.Variable {
	*** m_fixUpWasCalled;
	*** m_index;
	*** m_isGlobal;
	*** m_qname;
	*** execute(org.apache.xpath.XPathContext,boolean);
	*** getElemVariable();
	*** setQName(org.apache.xml.utils.QName);
}

-keep class org.apache.xpath.patterns.ContextMatchStepPattern {
	*** execute(org.apache.xpath.XPathContext);
}

-keep class org.apache.xpath.patterns.FunctionPattern {
	*** m_functionExpr;
}

-keep class org.apache.xpath.patterns.NodeTest {
	*** SCORE_NODETEST;
	*** SCORE_NONE;
	*** SCORE_NSWILD;
	*** SCORE_OTHER;
	*** SCORE_QNAME;
	*** m_isTotallyWild;
	*** m_name;
	*** m_namespace;
	*** m_score;
	*** m_whatToShow;
	org.apache.xpath.patterns.NodeTest();
	org.apache.xpath.patterns.NodeTest(int);
	org.apache.xpath.patterns.NodeTest(int,java.lang.String,java.lang.String);
	*** calcScore();
	*** deepEquals(org.apache.xpath.Expression);
	*** execute(org.apache.xpath.XPathContext,int);
	*** execute(org.apache.xpath.XPathContext,int,org.apache.xml.dtm.DTM,int);
	*** fixupVariables(java.util.Vector,int);
	*** getLocalName();
	*** getNamespace();
	*** getNodeTypeTest(int);
	*** getStaticScore();
	*** getWhatToShow();
	*** initNodeTest(int);
	*** initNodeTest(int,java.lang.String,java.lang.String);
	*** setLocalName(java.lang.String);
	*** setNamespace(java.lang.String);
	*** setStaticScore(org.apache.xpath.objects.XNumber);
	*** setWhatToShow(int);
	*** subPartMatch(java.lang.String,java.lang.String);
	*** subPartMatchNS(java.lang.String,java.lang.String);
}

-keep class org.apache.xpath.patterns.StepPattern {
	*** m_axis;
	*** m_predicates;
	*** m_relativePathPattern;
	*** m_targetString;
	org.apache.xpath.patterns.StepPattern(int,int,int);
	org.apache.xpath.patterns.StepPattern(int,java.lang.String,java.lang.String,int,int);
	*** calcScore();
	*** calcTargetString();
	*** callSubtreeVisitors(org.apache.xpath.XPathVisitor);
	*** callVisitors(org.apache.xpath.ExpressionOwner,org.apache.xpath.XPathVisitor);
	*** canTraverseOutsideSubtree();
	*** checkProximityPosition(org.apache.xpath.XPathContext,int,org.apache.xml.dtm.DTM,int,int);
	*** deepEquals(org.apache.xpath.Expression);
	*** execute(org.apache.xpath.XPathContext);
	*** execute(org.apache.xpath.XPathContext,int);
	*** execute(org.apache.xpath.XPathContext,int,org.apache.xml.dtm.DTM,int);
	*** executePredicates(org.apache.xpath.XPathContext,org.apache.xml.dtm.DTM,int);
	*** executeRelativePathPattern(org.apache.xpath.XPathContext,org.apache.xml.dtm.DTM,int);
	*** fixupVariables(java.util.Vector,int);
	*** getAxis();
	*** getPredicate(int);
	*** getPredicateCount();
	*** getPredicates();
	*** getProximityPosition(org.apache.xpath.XPathContext,int,boolean);
	*** getRelativePathPattern();
	*** setAxis(int);
	*** setPredicates(org.apache.xpath.Expression[]);
	*** setRelativePathPattern(org.apache.xpath.patterns.StepPattern);
}

-keep class org.apache.xpath.patterns.UnionPattern {
	*** m_patterns;
	*** setPatterns(org.apache.xpath.patterns.StepPattern[]);
}

-keep class org.apache.xpath.res.XPATHMessages {
	*** createXPATHMessage(java.lang.String,java.lang.Object[]);
	*** createXPATHWarning(java.lang.String,java.lang.Object[]);
}

-keep class org.bouncycastle.asn1.ASN1Encodable {
	org.bouncycastle.asn1.ASN1Encodable();
	*** getEncoded();
	*** getEncoded(java.lang.String);
	*** toASN1Object();
}

-keep class org.bouncycastle.asn1.ASN1InputStream {
	*** readObject();
}

-keep class org.bouncycastle.asn1.ASN1Object {
	org.bouncycastle.asn1.ASN1Object();
	*** asn1Equals(org.bouncycastle.asn1.DERObject);
}

-keep class org.bouncycastle.asn1.ASN1OctetString {
	*** getInstance(java.lang.Object);
	*** getOctets();
}

-keep class org.bouncycastle.asn1.ASN1OutputStream {
	*** writeObject(java.lang.Object);
}

-keep class org.bouncycastle.asn1.ASN1TaggedObject {
	*** getObject();
}

-keep class org.bouncycastle.asn1.DEREncodable {
	*** getDERObject();
}

-keep class org.bouncycastle.asn1.DERObject {
	org.bouncycastle.asn1.DERObject();
	*** equals(java.lang.Object);
	*** hashCode();
}

-keep class org.bouncycastle.asn1.DERObjectIdentifier {
	*** identifier;
	org.bouncycastle.asn1.DERObjectIdentifier(byte[]);
	org.bouncycastle.asn1.DERObjectIdentifier(java.lang.String);
	*** getId();
	*** getInstance(java.lang.Object);
	*** isValidIdentifier(java.lang.String);
	*** writeField(java.io.OutputStream,java.math.BigInteger);
	*** writeField(java.io.OutputStream,long);
}

-keep class org.bouncycastle.asn1.DEROutputStream {
	*** writeEncoded(int,byte[]);
	*** writeObject(java.lang.Object);
}

-keep class org.bouncycastle.asn1.OIDTokenizer {
	*** hasMoreTokens();
	*** nextToken();
}

-keep class org.bouncycastle.asn1.bc.BCObjectIdentifiers {
	*** bc_pbe_sha1_pkcs12_aes128_cbc;
	*** bc_pbe_sha1_pkcs12_aes192_cbc;
	*** bc_pbe_sha1_pkcs12_aes256_cbc;
	*** bc_pbe_sha256_pkcs12_aes128_cbc;
	*** bc_pbe_sha256_pkcs12_aes192_cbc;
	*** bc_pbe_sha256_pkcs12_aes256_cbc;
}

-keep class org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers {
	*** gostR28147_cbc;
	*** gostR3410_2001;
	*** gostR3410_94;
	*** gostR3411;
	*** gostR3411_94_with_gostR3410_2001;
	*** gostR3411_94_with_gostR3410_94;
}

-keep class org.bouncycastle.asn1.eac.EACObjectIdentifiers {
	*** id_TA_ECDSA_SHA_1;
	*** id_TA_ECDSA_SHA_224;
	*** id_TA_ECDSA_SHA_256;
}

-keep class org.bouncycastle.asn1.iana.IANAObjectIdentifiers {
	*** hmacMD5;
	*** hmacRIPEMD160;
	*** hmacSHA1;
	*** hmacTIGER;
}

-keep class org.bouncycastle.asn1.kisa.KISAObjectIdentifiers {
	*** id_npki_app_cmsSeed_wrap;
	*** id_seedCBC;
}

-keep class org.bouncycastle.asn1.nist.NISTObjectIdentifiers {
	*** dsa_with_sha224;
	*** dsa_with_sha256;
	*** dsa_with_sha384;
	*** dsa_with_sha512;
	*** id_aes128_CBC;
	*** id_aes128_CFB;
	*** id_aes128_ECB;
	*** id_aes128_OFB;
	*** id_aes128_wrap;
	*** id_aes192_CBC;
	*** id_aes192_CFB;
	*** id_aes192_ECB;
	*** id_aes192_OFB;
	*** id_aes192_wrap;
	*** id_aes256_CBC;
	*** id_aes256_CFB;
	*** id_aes256_ECB;
	*** id_aes256_OFB;
	*** id_aes256_wrap;
	*** id_sha224;
	*** id_sha256;
	*** id_sha384;
	*** id_sha512;
}

-keep class org.bouncycastle.asn1.ntt.NTTObjectIdentifiers {
	*** id_camellia128_cbc;
	*** id_camellia128_wrap;
	*** id_camellia192_cbc;
	*** id_camellia192_wrap;
	*** id_camellia256_cbc;
	*** id_camellia256_wrap;
}

-keep class org.bouncycastle.asn1.oiw.OIWObjectIdentifiers {
	*** desCBC;
	*** idSHA1;
	*** sha1WithRSA;
}

-keep class org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers {
	*** des_EDE3_CBC;
	*** id_PBKDF2;
	*** id_RSAES_OAEP;
	*** id_RSASSA_PSS;
	*** id_alg_CMS3DESwrap;
	*** id_hmacWithSHA1;
	*** id_hmacWithSHA224;
	*** id_hmacWithSHA256;
	*** id_hmacWithSHA384;
	*** id_hmacWithSHA512;
	*** md2;
	*** md2WithRSAEncryption;
	*** md4;
	*** md4WithRSAEncryption;
	*** md5;
	*** md5WithRSAEncryption;
	*** pbeWithMD2AndDES_CBC;
	*** pbeWithMD2AndRC2_CBC;
	*** pbeWithMD5AndDES_CBC;
	*** pbeWithMD5AndRC2_CBC;
	*** pbeWithSHA1AndDES_CBC;
	*** pbeWithSHA1AndRC2_CBC;
	*** sha1WithRSAEncryption;
	*** sha224WithRSAEncryption;
	*** sha256WithRSAEncryption;
	*** sha384WithRSAEncryption;
	*** sha512WithRSAEncryption;
}

-keep class org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers {
	*** ecSignWithRipemd160;
	*** ecSignWithSha1;
	*** ripemd128;
	*** ripemd160;
	*** ripemd256;
}

-keep class org.bouncycastle.asn1.x9.X9ObjectIdentifiers {
	*** dhSinglePass_stdDH_sha1kdf_scheme;
	*** ecdsa_with_SHA224;
	*** ecdsa_with_SHA256;
	*** ecdsa_with_SHA384;
	*** ecdsa_with_SHA512;
	*** id_ecPublicKey;
	*** mqvSinglePass_sha1kdf_scheme;
}

-keep class org.bouncycastle.jce.provider.BouncyCastleProvider {
	*** ASYMMETRIC_CIPHERS;
	*** PROVIDER_NAME;
	*** SYMMETRIC_CIPHERS;
	*** info;
	*** access$000(org.bouncycastle.jce.provider.BouncyCastleProvider);
	*** addHMACAlgorithm(java.lang.String,java.lang.String,java.lang.String);
	*** addHMACAlias(java.lang.String,org.bouncycastle.asn1.DERObjectIdentifier);
	*** addMacAlgorithms();
	*** addMappings(java.util.Map);
	*** addMessageDigestAlgorithms();
	*** addSignatureAlgorithm(java.lang.String,java.lang.String,java.lang.String,org.bouncycastle.asn1.DERObjectIdentifier);
	*** addSignatureAlgorithms();
	*** loadAlgorithms(java.lang.String,java.lang.String[]);
	*** setup();
}

-keep class org.bouncycastle.jce.provider.BouncyCastleProvider$1 {
	*** this$0;
}

-keep class org.bouncycastle.jce.provider.ProviderUtil {
	*** setParameter(java.lang.String,java.lang.Object);
}

-keep class org.bouncycastle.jce.provider.asymmetric.EC$Mappings {
	*** addSignatureAlgorithm(java.lang.String,java.lang.String,java.lang.String,org.bouncycastle.asn1.DERObjectIdentifier);
}

-keep class org.codehaus.jackson.Base64Variant {
	*** decodeBase64Char(char);
	*** decodeBase64Char(int);
	*** encode(byte[],boolean);
	*** encodeBase64Chunk(int,byte[],int);
	*** encodeBase64Chunk(int,char[],int);
	*** encodeBase64Partial(int,int,byte[],int);
	*** encodeBase64Partial(int,int,char[],int);
	*** getMaxLineLength();
	*** getPaddingChar();
	*** usesPadding();
	*** usesPaddingChar(char);
	*** usesPaddingChar(int);
}

-keep class org.codehaus.jackson.Base64Variants {
	*** getDefaultVariant();
}

-keep class org.codehaus.jackson.FormatSchema {
	*** getSchemaType();
}

-keep class org.codehaus.jackson.JsonEncoding {
	*** $VALUES;
	*** UTF16_BE;
	*** UTF16_LE;
	*** UTF32_BE;
	*** UTF32_LE;
	*** UTF8;
	*** _bigEndian;
	*** _javaName;
	*** getJavaName();
	*** isBigEndian();
}

-keep class org.codehaus.jackson.JsonFactory {
	*** DEFAULT_GENERATOR_FEATURE_FLAGS;
	*** DEFAULT_PARSER_FEATURE_FLAGS;
	*** _characterEscapes;
	*** _generatorFeatures;
	*** _inputDecorator;
	*** _objectCodec;
	*** _outputDecorator;
	*** _parserFeatures;
	*** _recyclerRef;
	*** _rootByteSymbols;
	*** _rootCharSymbols;
	org.codehaus.jackson.JsonFactory(org.codehaus.jackson.ObjectCodec);
	*** _createContext(java.lang.Object,boolean);
	*** _createJsonGenerator(java.io.Writer,org.codehaus.jackson.io.IOContext);
	*** _createJsonParser(byte[],int,int,org.codehaus.jackson.io.IOContext);
	*** _createJsonParser(java.io.InputStream,org.codehaus.jackson.io.IOContext);
	*** _createJsonParser(java.io.Reader,org.codehaus.jackson.io.IOContext);
	*** _createUTF8JsonGenerator(java.io.OutputStream,org.codehaus.jackson.io.IOContext);
	*** _createWriter(java.io.OutputStream,org.codehaus.jackson.JsonEncoding,org.codehaus.jackson.io.IOContext);
	*** _getBufferRecycler();
	*** _optimizedStreamFromURL(java.net.URL);
	*** configure(org.codehaus.jackson.JsonGenerator$Feature,boolean);
	*** configure(org.codehaus.jackson.JsonParser$Feature,boolean);
	*** createJsonGenerator(java.io.File,org.codehaus.jackson.JsonEncoding);
	*** createJsonGenerator(java.io.OutputStream,org.codehaus.jackson.JsonEncoding);
	*** createJsonGenerator(java.io.Writer);
	*** createJsonParser(byte[]);
	*** createJsonParser(byte[],int,int);
	*** createJsonParser(java.io.File);
	*** createJsonParser(java.io.InputStream);
	*** createJsonParser(java.io.Reader);
	*** createJsonParser(java.lang.String);
	*** createJsonParser(java.net.URL);
	*** disable(org.codehaus.jackson.JsonGenerator$Feature);
	*** disable(org.codehaus.jackson.JsonParser$Feature);
	*** enable(org.codehaus.jackson.JsonGenerator$Feature);
	*** enable(org.codehaus.jackson.JsonParser$Feature);
	*** getCodec();
	*** hasJSONFormat(org.codehaus.jackson.format.InputAccessor);
	*** isEnabled(org.codehaus.jackson.JsonGenerator$Feature);
	*** isEnabled(org.codehaus.jackson.JsonParser$Feature);
	*** setCodec(org.codehaus.jackson.ObjectCodec);
}

-keep class org.codehaus.jackson.JsonGenerator {
	*** _cfgPrettyPrinter;
	org.codehaus.jackson.JsonGenerator();
	*** close();
	*** configure(org.codehaus.jackson.JsonGenerator$Feature,boolean);
	*** disable(org.codehaus.jackson.JsonGenerator$Feature);
	*** enable(org.codehaus.jackson.JsonGenerator$Feature);
	*** flush();
	*** isEnabled(org.codehaus.jackson.JsonGenerator$Feature);
	*** setHighestNonEscapedChar(int);
	*** setPrettyPrinter(org.codehaus.jackson.PrettyPrinter);
	*** setSchema(org.codehaus.jackson.FormatSchema);
	*** useDefaultPrettyPrinter();
	*** writeBinary(byte[]);
	*** writeBinary(org.codehaus.jackson.Base64Variant,byte[],int,int);
	*** writeBoolean(boolean);
	*** writeEndArray();
	*** writeEndObject();
	*** writeFieldName(java.lang.String);
	*** writeFieldName(org.codehaus.jackson.SerializableString);
	*** writeFieldName(org.codehaus.jackson.io.SerializedString);
	*** writeNull();
	*** writeNumber(double);
	*** writeNumber(float);
	*** writeNumber(int);
	*** writeNumber(java.lang.String);
	*** writeNumber(java.math.BigDecimal);
	*** writeNumber(java.math.BigInteger);
	*** writeNumber(long);
	*** writeObject(java.lang.Object);
	*** writeObjectField(java.lang.String,java.lang.Object);
	*** writeRaw(char);
	*** writeRaw(char[],int,int);
	*** writeRaw(java.lang.String);
	*** writeRaw(java.lang.String,int,int);
	*** writeStartArray();
	*** writeStartObject();
	*** writeString(char[],int,int);
	*** writeString(java.lang.String);
	*** writeString(org.codehaus.jackson.SerializableString);
}

-keep class org.codehaus.jackson.JsonGenerator$Feature {
	*** $VALUES;
	*** AUTO_CLOSE_JSON_CONTENT;
	*** AUTO_CLOSE_TARGET;
	*** ESCAPE_NON_ASCII;
	*** FLUSH_PASSED_TO_STREAM;
	*** QUOTE_FIELD_NAMES;
	*** QUOTE_NON_NUMERIC_NUMBERS;
	*** WRITE_NUMBERS_AS_STRINGS;
	*** _defaultState;
	*** _mask;
	*** collectDefaults();
	*** enabledByDefault();
	*** getMask();
	*** values();
}

-keep class org.codehaus.jackson.JsonLocation {
	*** NA;
	*** _columnNr;
	*** _lineNr;
	*** _sourceRef;
	*** _totalBytes;
	*** _totalChars;
	org.codehaus.jackson.JsonLocation(java.lang.Object,long,long,int,int);
	*** getByteOffset();
	*** toString();
}

-keep class org.codehaus.jackson.JsonNode {
	*** NO_NODES;
	*** NO_STRINGS;
	org.codehaus.jackson.JsonNode();
	*** asBoolean(boolean);
	*** asDouble(double);
	*** asInt(int);
	*** asLong(long);
	*** asText();
	*** asToken();
	*** equals(java.lang.Object);
	*** findParent(java.lang.String);
	*** findParents(java.lang.String,java.util.List);
	*** findValue(java.lang.String);
	*** findValues(java.lang.String,java.util.List);
	*** findValuesAsText(java.lang.String,java.util.List);
	*** get(int);
	*** get(java.lang.String);
	*** getBigIntegerValue();
	*** getBinaryValue();
	*** getDecimalValue();
	*** getDoubleValue();
	*** getElements();
	*** getIntValue();
	*** getLongValue();
	*** getNumberType();
	*** getNumberValue();
	*** getTextValue();
	*** isArray();
	*** isBinary();
	*** isNumber();
	*** isObject();
	*** isPojo();
	*** path(int);
	*** path(java.lang.String);
	*** toString();
}

-keep class org.codehaus.jackson.JsonParser {
	*** _currToken;
	*** _features;
	*** _lastClearedToken;
	org.codehaus.jackson.JsonParser();
	org.codehaus.jackson.JsonParser(int);
	*** _constructError(java.lang.String);
	*** clearCurrentToken();
	*** close();
	*** configure(org.codehaus.jackson.JsonParser$Feature,boolean);
	*** disable(org.codehaus.jackson.JsonParser$Feature);
	*** disableFeature(org.codehaus.jackson.JsonParser$Feature);
	*** enable(org.codehaus.jackson.JsonParser$Feature);
	*** enableFeature(org.codehaus.jackson.JsonParser$Feature);
	*** getBigIntegerValue();
	*** getBinaryValue(org.codehaus.jackson.Base64Variant);
	*** getByteValue();
	*** getCodec();
	*** getCurrentLocation();
	*** getCurrentName();
	*** getCurrentToken();
	*** getDecimalValue();
	*** getDoubleValue();
	*** getEmbeddedObject();
	*** getFloatValue();
	*** getIntValue();
	*** getLongValue();
	*** getNumberType();
	*** getNumberValue();
	*** getShortValue();
	*** getText();
	*** getTextCharacters();
	*** getTextLength();
	*** getTextOffset();
	*** getTokenLocation();
	*** getValueAsBoolean(boolean);
	*** getValueAsDouble(double);
	*** getValueAsInt();
	*** getValueAsInt(int);
	*** getValueAsLong();
	*** getValueAsLong(long);
	*** hasTextCharacters();
	*** isEnabled(org.codehaus.jackson.JsonParser$Feature);
	*** isExpectedStartArrayToken();
	*** nextToken();
	*** nextValue();
	*** readValueAsTree();
	*** skipChildren();
}

-keep class org.codehaus.jackson.JsonParser$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.JsonParser$Feature {
	*** $VALUES;
	*** ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
	*** ALLOW_COMMENTS;
	*** ALLOW_NON_NUMERIC_NUMBERS;
	*** ALLOW_NUMERIC_LEADING_ZEROS;
	*** ALLOW_SINGLE_QUOTES;
	*** ALLOW_UNQUOTED_CONTROL_CHARS;
	*** ALLOW_UNQUOTED_FIELD_NAMES;
	*** AUTO_CLOSE_SOURCE;
	*** CANONICALIZE_FIELD_NAMES;
	*** INTERN_FIELD_NAMES;
	*** _defaultState;
	*** collectDefaults();
	*** enabledByDefault();
	*** enabledIn(int);
	*** getMask();
	*** values();
}

-keep class org.codehaus.jackson.JsonParser$NumberType {
	*** $VALUES;
	*** BIG_DECIMAL;
	*** BIG_INTEGER;
	*** DOUBLE;
	*** FLOAT;
	*** INT;
	*** LONG;
}

-keep class org.codehaus.jackson.JsonProcessingException {
	*** mLocation;
	org.codehaus.jackson.JsonProcessingException(java.lang.String);
	org.codehaus.jackson.JsonProcessingException(java.lang.String,java.lang.Throwable);
	org.codehaus.jackson.JsonProcessingException(java.lang.String,org.codehaus.jackson.JsonLocation);
	org.codehaus.jackson.JsonProcessingException(java.lang.String,org.codehaus.jackson.JsonLocation,java.lang.Throwable);
	org.codehaus.jackson.JsonProcessingException(java.lang.Throwable);
	*** getLocation();
	*** getMessage();
}

-keep class org.codehaus.jackson.JsonStreamContext {
	*** _index;
	*** _type;
	org.codehaus.jackson.JsonStreamContext();
	*** getCurrentIndex();
	*** getEntryCount();
	*** getTypeDesc();
	*** inArray();
	*** inObject();
	*** inRoot();
}

-keep class org.codehaus.jackson.JsonToken {
	*** $VALUES;
	*** END_ARRAY;
	*** END_OBJECT;
	*** FIELD_NAME;
	*** NOT_AVAILABLE;
	*** START_ARRAY;
	*** START_OBJECT;
	*** VALUE_EMBEDDED_OBJECT;
	*** VALUE_FALSE;
	*** VALUE_NULL;
	*** VALUE_NUMBER_FLOAT;
	*** VALUE_NUMBER_INT;
	*** VALUE_STRING;
	*** VALUE_TRUE;
	*** _serialized;
	*** _serializedBytes;
	*** _serializedChars;
	*** asCharArray();
	*** asString();
	*** isNumeric();
	*** isScalarValue();
	*** values();
}

-keep class org.codehaus.jackson.ObjectCodec {
	org.codehaus.jackson.ObjectCodec();
	*** readTree(org.codehaus.jackson.JsonParser);
	*** readValue(org.codehaus.jackson.JsonParser,java.lang.Class);
	*** readValue(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.TypeReference);
	*** readValues(org.codehaus.jackson.JsonParser,java.lang.Class);
	*** readValues(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.TypeReference);
	*** writeTree(org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.JsonNode);
	*** writeValue(org.codehaus.jackson.JsonGenerator,java.lang.Object);
}

-keep class org.codehaus.jackson.PrettyPrinter {
	*** beforeArrayValues(org.codehaus.jackson.JsonGenerator);
	*** beforeObjectEntries(org.codehaus.jackson.JsonGenerator);
	*** writeArrayValueSeparator(org.codehaus.jackson.JsonGenerator);
	*** writeEndArray(org.codehaus.jackson.JsonGenerator,int);
	*** writeEndObject(org.codehaus.jackson.JsonGenerator,int);
	*** writeObjectEntrySeparator(org.codehaus.jackson.JsonGenerator);
	*** writeObjectFieldValueSeparator(org.codehaus.jackson.JsonGenerator);
	*** writeRootValueSeparator(org.codehaus.jackson.JsonGenerator);
	*** writeStartArray(org.codehaus.jackson.JsonGenerator);
	*** writeStartObject(org.codehaus.jackson.JsonGenerator);
}

-keep class org.codehaus.jackson.SerializableString {
	*** asQuotedChars();
	*** asQuotedUTF8();
	*** asUnquotedUTF8();
	*** getValue();
}

-keep class org.codehaus.jackson.Version {
	*** unknownVersion();
}

-keep class org.codehaus.jackson.annotate.JsonAutoDetect {
	*** creatorVisibility();
	*** fieldVisibility();
	*** getterVisibility();
	*** isGetterVisibility();
	*** setterVisibility();
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonAutoDetect$1 {
	*** $SwitchMap$org$codehaus$jackson$annotate$JsonAutoDetect$Visibility;
}

-keep class org.codehaus.jackson.annotate.JsonAutoDetect$Visibility {
	*** $VALUES;
	*** ANY;
	*** DEFAULT;
	*** NONE;
	*** NON_PRIVATE;
	*** PROTECTED_AND_PUBLIC;
	*** PUBLIC_ONLY;
	*** isVisible(java.lang.reflect.Member);
	*** values();
}

-keep class org.codehaus.jackson.annotate.JsonBackReference {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonGetter {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonIgnore {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonIgnoreProperties {
	*** ignoreUnknown();
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonIgnoreType {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonManagedReference {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonMethod {
	*** $VALUES;
	*** ALL;
	*** CREATOR;
	*** FIELD;
	*** GETTER;
	*** IS_GETTER;
	*** NONE;
	*** SETTER;
}

-keep class org.codehaus.jackson.annotate.JsonProperty {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonPropertyOrder {
	*** alphabetic();
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonRawValue {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonSetter {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonSubTypes {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonSubTypes$Type {
	*** name();
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonTypeInfo {
	*** defaultImpl();
	*** include();
	*** property();
	*** use();
}

-keep class org.codehaus.jackson.annotate.JsonTypeInfo$As {
	*** EXTERNAL_PROPERTY;
	*** PROPERTY;
	*** WRAPPER_ARRAY;
}

-keep class org.codehaus.jackson.annotate.JsonTypeInfo$Id {
	*** CLASS;
	*** NONE;
}

-keep class org.codehaus.jackson.annotate.JsonTypeName {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonUnwrapped {
	*** enabled();
}

-keep class org.codehaus.jackson.annotate.JsonValue {
	*** value();
}

-keep class org.codehaus.jackson.annotate.JsonWriteNullProperties {
	*** value();
}

-keep class org.codehaus.jackson.format.InputAccessor {
	*** hasMoreBytes();
	*** nextByte();
}

-keep class org.codehaus.jackson.format.MatchStrength {
	*** INCONCLUSIVE;
	*** NO_MATCH;
	*** SOLID_MATCH;
	*** WEAK_MATCH;
}

-keep class org.codehaus.jackson.impl.ByteSourceBootstrapper {
	*** _bigEndian;
	*** _bufferRecyclable;
	*** _bytesPerChar;
	*** _context;
	*** _in;
	*** _inputBuffer;
	*** _inputEnd;
	*** _inputProcessed;
	*** _inputPtr;
	*** checkUTF16(int);
	*** checkUTF32(int);
	*** constructParser(int,org.codehaus.jackson.ObjectCodec,org.codehaus.jackson.sym.BytesToNameCanonicalizer,org.codehaus.jackson.sym.CharsToNameCanonicalizer);
	*** constructReader();
	*** detectEncoding();
	*** ensureLoaded(int);
	*** handleBOM(int);
	*** hasJSONFormat(org.codehaus.jackson.format.InputAccessor);
	*** reportWeirdUCS4(java.lang.String);
	*** skipSpace(org.codehaus.jackson.format.InputAccessor);
	*** skipSpace(org.codehaus.jackson.format.InputAccessor,byte);
	*** tryMatch(org.codehaus.jackson.format.InputAccessor,java.lang.String,org.codehaus.jackson.format.MatchStrength);
}

-keep class org.codehaus.jackson.impl.ByteSourceBootstrapper$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonEncoding;
}

-keep class org.codehaus.jackson.impl.Indenter {
	*** isInline();
	*** writeIndentation(org.codehaus.jackson.JsonGenerator,int);
}

-keep class org.codehaus.jackson.impl.JsonGeneratorBase {
	*** _cfgNumbersAsStrings;
	*** _closed;
	*** _features;
	*** _objectCodec;
	*** _writeContext;
	org.codehaus.jackson.impl.JsonGeneratorBase(int,org.codehaus.jackson.ObjectCodec);
	*** _cantHappen();
	*** _reportError(java.lang.String);
	*** _reportUnsupportedOperation();
	*** _verifyValueWrite(java.lang.String);
	*** _writeEndArray();
	*** _writeEndObject();
	*** _writeSimpleObject(java.lang.Object);
	*** _writeStartArray();
	*** _writeStartObject();
	*** close();
	*** copyCurrentEvent(org.codehaus.jackson.JsonParser);
	*** copyCurrentStructure(org.codehaus.jackson.JsonParser);
	*** getOutputContext();
	*** isEnabled(org.codehaus.jackson.JsonGenerator$Feature);
	*** writeEndArray();
	*** writeEndObject();
	*** writeObject(java.lang.Object);
	*** writeStartArray();
	*** writeStartObject();
}

-keep class org.codehaus.jackson.impl.JsonGeneratorBase$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonParser$NumberType;
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.impl.JsonParserBase {
	*** BD_MAX_INT;
	*** BD_MAX_LONG;
	*** BD_MIN_INT;
	*** BD_MIN_LONG;
	*** BI_MAX_INT;
	*** BI_MAX_LONG;
	*** BI_MIN_INT;
	*** BI_MIN_LONG;
	*** _binaryValue;
	*** _byteArrayBuilder;
	*** _closed;
	*** _currInputProcessed;
	*** _currInputRow;
	*** _currInputRowStart;
	*** _expLength;
	*** _fractLength;
	*** _inputEnd;
	*** _inputPtr;
	*** _intLength;
	*** _ioContext;
	*** _nameCopied;
	*** _nameCopyBuffer;
	*** _nextToken;
	*** _numTypesValid;
	*** _numberBigDecimal;
	*** _numberBigInt;
	*** _numberDouble;
	*** _numberInt;
	*** _numberLong;
	*** _numberNegative;
	*** _parsingContext;
	*** _textBuffer;
	*** _tokenInputCol;
	*** _tokenInputRow;
	*** _tokenInputTotal;
	org.codehaus.jackson.impl.JsonParserBase(org.codehaus.jackson.io.IOContext,int);
	*** _closeInput();
	*** _decodeBase64Escape(org.codehaus.jackson.Base64Variant,char,int);
	*** _decodeBase64Escape(org.codehaus.jackson.Base64Variant,int,int);
	*** _decodeEscaped();
	*** _getByteArrayBuilder();
	*** _handleEOF();
	*** _parseNumericValue(int);
	*** _parseSlowFloatValue(int);
	*** _parseSlowIntValue(int,char[],int,int);
	*** _releaseBuffers();
	*** _reportMismatchedEndMarker(int,char);
	*** close();
	*** convertNumberToBigDecimal();
	*** convertNumberToBigInteger();
	*** convertNumberToDouble();
	*** convertNumberToInt();
	*** convertNumberToLong();
	*** getDoubleValue();
	*** getIntValue();
	*** getLongValue();
	*** getParsingContext();
	*** getTokenCharacterOffset();
	*** getTokenColumnNr();
	*** getTokenLineNr();
	*** loadMore();
	*** loadMoreGuaranteed();
	*** reportInvalidBase64Char(org.codehaus.jackson.Base64Variant,int,int);
	*** reportInvalidBase64Char(org.codehaus.jackson.Base64Variant,int,int,java.lang.String);
	*** reportInvalidNumber(java.lang.String);
	*** reportOverflowInt();
	*** reportOverflowLong();
	*** reportUnexpectedNumberChar(int,java.lang.String);
	*** reset(boolean,int,int,int);
	*** resetAsNaN(java.lang.String,double);
	*** resetFloat(boolean,int,int,int);
	*** resetInt(boolean,int);
}

-keep class org.codehaus.jackson.impl.JsonParserMinimalBase {
	org.codehaus.jackson.impl.JsonParserMinimalBase();
	org.codehaus.jackson.impl.JsonParserMinimalBase(int);
	*** _constructError(java.lang.String,java.lang.Throwable);
	*** _decodeBase64(java.lang.String,org.codehaus.jackson.util.ByteArrayBuilder,org.codehaus.jackson.Base64Variant);
	*** _getCharDesc(int);
	*** _handleEOF();
	*** _handleUnrecognizedCharacterEscape(char);
	*** _reportBase64EOF();
	*** _reportError(java.lang.String);
	*** _reportInvalidBase64(org.codehaus.jackson.Base64Variant,char,int,java.lang.String);
	*** _reportInvalidEOF();
	*** _reportInvalidEOF(java.lang.String);
	*** _reportInvalidEOFInValue();
	*** _reportUnexpectedChar(int,java.lang.String);
	*** _throwInternal();
	*** _throwInvalidSpace(int);
	*** _throwUnquotedSpace(int,java.lang.String);
	*** _wrapError(java.lang.String,java.lang.Throwable);
	*** getText();
	*** nextToken();
}

-keep class org.codehaus.jackson.impl.JsonParserMinimalBase$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.impl.JsonReadContext {
	*** _child;
	*** _columnNr;
	*** _currentName;
	*** _lineNr;
	*** _parent;
	*** createChildArrayContext(int,int);
	*** createChildObjectContext(int,int);
	*** createRootContext();
	*** expectComma();
	*** getCurrentName();
	*** getParent();
	*** getStartLocation(java.lang.Object);
	*** reset(int,int,int);
	*** setCurrentName(java.lang.String);
}

-keep class org.codehaus.jackson.impl.JsonWriteContext {
	*** _child;
	*** _currentName;
	*** _parent;
	*** appendDesc(java.lang.StringBuilder);
	*** createChildArrayContext();
	*** createChildObjectContext();
	*** createRootContext();
	*** getParent();
	*** reset(int);
	*** writeFieldName(java.lang.String);
	*** writeValue();
}

-keep class org.codehaus.jackson.impl.ReaderBasedParser {
	*** _inputBuffer;
	*** _objectCodec;
	*** _reader;
	*** _symbols;
	*** _tokenIncomplete;
	*** _closeInput();
	*** _decodeBase64(org.codehaus.jackson.Base64Variant);
	*** _decodeEscaped();
	*** _finishString();
	*** _finishString2();
	*** _getText2(org.codehaus.jackson.JsonToken);
	*** _handleApostropheValue();
	*** _handleInvalidNumberStart(int,boolean);
	*** _handleUnexpectedValue(int);
	*** _handleUnusualFieldName(int);
	*** _matchToken(java.lang.String,int);
	*** _nextAfterName();
	*** _parseApostropheFieldName();
	*** _parseFieldName(int);
	*** _parseFieldName2(int,int,int);
	*** _parseUnusualFieldName2(int,int,int[]);
	*** _reportInvalidToken(java.lang.String,java.lang.String);
	*** _skipCComment();
	*** _skipCR();
	*** _skipComment();
	*** _skipCppComment();
	*** _skipLF();
	*** _skipString();
	*** _skipWS();
	*** _skipWSOrEnd();
	*** _verifyNoLeadingZeroes();
	*** close();
	*** getNextChar(java.lang.String);
	*** getText();
	*** loadMore();
	*** nextToken();
	*** parseNumberText(int);
	*** parseNumberText2(boolean);
}

-keep class org.codehaus.jackson.impl.ReaderBasedParser$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.impl.Utf8Generator {
	*** FALSE_BYTES;
	*** HEX_CHARS;
	*** NULL_BYTES;
	*** TRUE_BYTES;
	*** _bufferRecyclable;
	*** _charBuffer;
	*** _charBufferLength;
	*** _characterEscapes;
	*** _ioContext;
	*** _maximumNonEscapedChar;
	*** _outputBuffer;
	*** _outputEnd;
	*** _outputEscapes;
	*** _outputMaxContiguous;
	*** _outputStream;
	*** _outputTail;
	*** sOutputEscapes;
	*** _decodeSurrogate(int,int);
	*** _flushBuffer();
	*** _handleLongCustomEscape(byte[],int,int,byte[],int);
	*** _outputMultiByteChar(int,int);
	*** _outputRawMultiByteChar(int,char[],int,int);
	*** _outputSurrogates(int,int);
	*** _releaseBuffers();
	*** _verifyPrettyValueWrite(java.lang.String,int);
	*** _verifyValueWrite(java.lang.String);
	*** _writeBinary(org.codehaus.jackson.Base64Variant,byte[],int,int);
	*** _writeBytes(byte[]);
	*** _writeBytes(byte[],int,int);
	*** _writeCustomEscape(byte[],int,org.codehaus.jackson.SerializableString,int);
	*** _writeCustomStringSegment2(char[],int,int);
	*** _writeFieldName(java.lang.String);
	*** _writeFieldName(org.codehaus.jackson.SerializableString);
	*** _writeGenericEscape(int,int);
	*** _writeLongString(char[],int,int);
	*** _writeLongString(java.lang.String);
	*** _writeNull();
	*** _writePPFieldName(java.lang.String,boolean);
	*** _writePPFieldName(org.codehaus.jackson.SerializableString,boolean);
	*** _writeQuotedInt(int);
	*** _writeQuotedLong(long);
	*** _writeQuotedRaw(java.lang.Object);
	*** _writeSegmentedRaw(char[],int,int);
	*** _writeStringSegment(char[],int,int);
	*** _writeStringSegment2(char[],int,int);
	*** _writeStringSegmentASCII2(char[],int,int);
	*** _writeStringSegments(char[],int,int);
	*** _writeStringSegments(java.lang.String);
	*** _writeUTF8Segment(byte[],int,int);
	*** _writeUTF8Segment2(byte[],int,int);
	*** _writeUTF8Segments(byte[],int,int);
	*** setCharacterEscapes(org.codehaus.jackson.io.CharacterEscapes);
	*** setHighestNonEscapedChar(int);
	*** writeEndArray();
	*** writeEndObject();
	*** writeFieldName(java.lang.String);
	*** writeRaw(char[],int,int);
	*** writeRaw(java.lang.String);
	*** writeString(java.lang.String);
}

-keep class org.codehaus.jackson.impl.Utf8StreamParser {
	*** _bufferRecyclable;
	*** _inputBuffer;
	*** _inputStream;
	*** _objectCodec;
	*** _quad1;
	*** _quadBuffer;
	*** _symbols;
	*** _tokenIncomplete;
	*** sInputCodesLatin1;
	*** sInputCodesUtf8;
	*** _closeInput();
	*** _decodeBase64(org.codehaus.jackson.Base64Variant);
	*** _decodeCharForError(int);
	*** _decodeEscaped();
	*** _decodeUtf8_2(int);
	*** _decodeUtf8_3(int);
	*** _decodeUtf8_3fast(int);
	*** _decodeUtf8_4(int);
	*** _finishString();
	*** _finishString2(char[],int);
	*** _getText2(org.codehaus.jackson.JsonToken);
	*** _handleApostropheValue();
	*** _handleInvalidNumberStart(int,boolean);
	*** _handleUnexpectedValue(int);
	*** _handleUnusualFieldName(int);
	*** _isNextTokenNameNo(int);
	*** _isNextTokenNameYes();
	*** _matchToken(java.lang.String,int);
	*** _nextAfterName();
	*** _nextTokenNotInObject(int);
	*** _parseApostropheFieldName();
	*** _parseFieldName(int);
	*** _parseFloatText(char[],int,int,boolean,int);
	*** _parserNumber2(char[],int,boolean,int);
	*** _reportInvalidChar(int);
	*** _reportInvalidInitial(int);
	*** _reportInvalidOther(int);
	*** _reportInvalidOther(int,int);
	*** _reportInvalidToken(java.lang.String,java.lang.String);
	*** _skipCComment();
	*** _skipCR();
	*** _skipColon();
	*** _skipComment();
	*** _skipCppComment();
	*** _skipLF();
	*** _skipString();
	*** _skipUtf8_2(int);
	*** _skipUtf8_3(int);
	*** _skipUtf8_4(int);
	*** _skipWS();
	*** _skipWSOrEnd();
	*** _verifyNoLeadingZeroes();
	*** addName(int[],int,int);
	*** close();
	*** findName(int,int);
	*** findName(int,int,int);
	*** findName(int[],int,int,int);
	*** getText();
	*** growArrayBy(int[],int);
	*** loadMore();
	*** nextByte();
	*** nextToken();
	*** parseEscapedFieldName(int[],int,int,int,int);
	*** parseFieldName(int,int,int);
	*** parseFieldName(int,int,int,int);
	*** parseLongFieldName(int);
	*** parseMediumFieldName(int,int[]);
	*** parseNumberText(int);
	*** slowParseFieldName();
}

-keep class org.codehaus.jackson.impl.Utf8StreamParser$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.impl.WriterBasedGenerator {
	*** HEX_CHARS;
	*** _characterEscapes;
	*** _currentEscape;
	*** _entityBuffer;
	*** _ioContext;
	*** _maximumNonEscapedChar;
	*** _outputBuffer;
	*** _outputEnd;
	*** _outputEscapes;
	*** _outputHead;
	*** _outputTail;
	*** _writer;
	*** sOutputEscapes;
	*** _allocateEntityBuffer();
	*** _appendCharacterEscape(char,int);
	*** _flushBuffer();
	*** _prependOrWriteCharacterEscape(char,int);
	*** _prependOrWriteCharacterEscape(char[],int,int,char,int);
	*** _releaseBuffers();
	*** _verifyPrettyValueWrite(java.lang.String,int);
	*** _verifyValueWrite(java.lang.String);
	*** _writeBinary(org.codehaus.jackson.Base64Variant,byte[],int,int);
	*** _writeFieldName(java.lang.String,boolean);
	*** _writeFieldName(org.codehaus.jackson.SerializableString,boolean);
	*** _writeLongString(java.lang.String);
	*** _writeNull();
	*** _writePPFieldName(java.lang.String,boolean);
	*** _writePPFieldName(org.codehaus.jackson.SerializableString,boolean);
	*** _writeQuotedInt(int);
	*** _writeQuotedLong(long);
	*** _writeQuotedRaw(java.lang.Object);
	*** _writeSegment(int);
	*** _writeSegmentASCII(int,int);
	*** _writeSegmentCustom(int);
	*** _writeString(char[],int,int);
	*** _writeString(java.lang.String);
	*** _writeString2(int);
	*** _writeStringASCII(char[],int,int,int);
	*** _writeStringASCII(int,int);
	*** _writeStringCustom(char[],int,int);
	*** _writeStringCustom(int);
	*** setCharacterEscapes(org.codehaus.jackson.io.CharacterEscapes);
	*** setHighestNonEscapedChar(int);
	*** writeEndArray();
	*** writeEndObject();
	*** writeFieldName(java.lang.String);
	*** writeRaw(char[],int,int);
	*** writeRaw(java.lang.String);
	*** writeRawLong(java.lang.String);
	*** writeString(java.lang.String);
}

-keep class org.codehaus.jackson.io.BaseReader {
	*** _buffer;
	*** _context;
	*** _in;
	*** _length;
	*** _ptr;
	*** _tmpBuf;
	org.codehaus.jackson.io.BaseReader(org.codehaus.jackson.io.IOContext,java.io.InputStream,byte[],int,int);
	*** close();
	*** freeBuffers();
	*** read();
	*** reportBounds(char[],int,int);
	*** reportStrangeStream();
}

-keep class org.codehaus.jackson.io.CharacterEscapes {
	*** getEscapeCodesForAscii();
	*** getEscapeSequence(int);
}

-keep class org.codehaus.jackson.io.IOContext {
	*** _bufferRecycler;
	*** _concatCBuffer;
	*** _encoding;
	*** _managedResource;
	*** _nameCopyBuffer;
	*** _readIOBuffer;
	*** _sourceRef;
	*** _tokenCBuffer;
	*** _writeEncodingBuffer;
	*** allocConcatBuffer();
	*** allocNameCopyBuffer(int);
	*** allocReadIOBuffer();
	*** allocTokenBuffer();
	*** allocWriteEncodingBuffer();
	*** constructTextBuffer();
	*** getEncoding();
	*** getSourceReference();
	*** isResourceManaged();
	*** releaseConcatBuffer(char[]);
	*** releaseNameCopyBuffer(char[]);
	*** releaseReadIOBuffer(byte[]);
	*** releaseTokenBuffer(char[]);
	*** releaseWriteEncodingBuffer(byte[]);
	*** setEncoding(org.codehaus.jackson.JsonEncoding);
}

-keep class org.codehaus.jackson.io.InputDecorator {
	*** decorate(org.codehaus.jackson.io.IOContext,byte[],int,int);
	*** decorate(org.codehaus.jackson.io.IOContext,java.io.InputStream);
	*** decorate(org.codehaus.jackson.io.IOContext,java.io.Reader);
}

-keep class org.codehaus.jackson.io.JsonStringEncoder {
	*** HEX_BYTES;
	*** HEX_CHARS;
	*** _byteBuilder;
	*** _quoteBuffer;
	*** _textBuffer;
	*** _threadEncoder;
	*** _appendByteEscape(int,int,org.codehaus.jackson.util.ByteArrayBuilder,int);
	*** _appendSingleEscape(int,char[]);
	*** _convertSurrogate(int,int);
	*** _throwIllegalSurrogate(int);
	*** encodeAsUTF8(java.lang.String);
	*** getInstance();
	*** quoteAsString(java.lang.String);
	*** quoteAsUTF8(java.lang.String);
}

-keep class org.codehaus.jackson.io.MergedStream {
	*** _buffer;
	*** _context;
	*** _end;
	*** _in;
	*** _ptr;
	*** freeMergedBuffer();
	*** read(byte[],int,int);
}

-keep class org.codehaus.jackson.io.NumberInput {
	*** MAX_LONG_STR;
	*** MIN_LONG_STR_NO_SIGN;
	*** inLongRange(char[],int,int,boolean);
	*** inLongRange(java.lang.String,boolean);
	*** parseAsDouble(java.lang.String,double);
	*** parseAsInt(java.lang.String,int);
	*** parseAsLong(java.lang.String,long);
	*** parseDouble(java.lang.String);
	*** parseInt(char[],int,int);
	*** parseInt(java.lang.String);
	*** parseLong(char[],int,int);
	*** parseLong(java.lang.String);
}

-keep class org.codehaus.jackson.io.NumberOutput {
	*** BILLION;
	*** FULL_TRIPLETS;
	*** FULL_TRIPLETS_B;
	*** LEADING_TRIPLETS;
	*** MAX_INT_AS_LONG;
	*** MILLION;
	*** MIN_INT_AS_LONG;
	*** SMALLEST_LONG;
	*** TEN_BILLION_L;
	*** THOUSAND_L;
	*** sSmallIntStrs;
	*** sSmallIntStrs2;
	*** calcLongStrLength(long);
	*** outputFullTriplet(int,byte[],int);
	*** outputFullTriplet(int,char[],int);
	*** outputInt(int,byte[],int);
	*** outputInt(int,char[],int);
	*** outputLeadingTriplet(int,byte[],int);
	*** outputLeadingTriplet(int,char[],int);
	*** outputLong(long,byte[],int);
	*** outputLong(long,char[],int);
	*** toString(double);
	*** toString(int);
	*** toString(long);
}

-keep class org.codehaus.jackson.io.OutputDecorator {
	*** decorate(org.codehaus.jackson.io.IOContext,java.io.OutputStream);
	*** decorate(org.codehaus.jackson.io.IOContext,java.io.Writer);
}

-keep class org.codehaus.jackson.io.SegmentedStringWriter {
	*** _buffer;
	*** append(char);
	*** append(java.lang.CharSequence);
	*** append(java.lang.CharSequence,int,int);
	*** getAndClear();
	*** write(int);
}

-keep class org.codehaus.jackson.io.SerializedString {
	*** _quotedChars;
	*** _quotedUTF8Ref;
	*** _unquotedUTF8Ref;
	*** _value;
	*** getValue();
}

-keep class org.codehaus.jackson.io.UTF32Reader {
	*** mBigEndian;
	*** mByteCount;
	*** mCharCount;
	*** mSurrogate;
	*** loadMore(int);
	*** reportInvalid(int,int,java.lang.String);
	*** reportUnexpectedEOF(int,int);
}

-keep class org.codehaus.jackson.io.UTF8Writer {
	*** _context;
	*** _out;
	*** _outBuffer;
	*** _outBufferEnd;
	*** _outPtr;
	*** _surrogate;
	*** append(char);
	*** convertSurrogate(int);
	*** throwIllegal(int);
	*** write(char[],int,int);
	*** write(int);
	*** write(java.lang.String,int,int);
}

-keep class org.codehaus.jackson.map.AbstractTypeResolver {
	*** findTypeMapping(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** resolveAbstractType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.AnnotationIntrospector {
	org.codehaus.jackson.map.AnnotationIntrospector();
	*** allIntrospectors(java.util.Collection);
	*** findAutoDetectVisibility(org.codehaus.jackson.map.introspect.AnnotatedClass,org.codehaus.jackson.map.introspect.VisibilityChecker);
	*** findCachability(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findContentDeserializer(org.codehaus.jackson.map.introspect.Annotated);
	*** findContentSerializer(org.codehaus.jackson.map.introspect.Annotated);
	*** findDeserializablePropertyName(org.codehaus.jackson.map.introspect.AnnotatedField);
	*** findDeserializationContentType(org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType,java.lang.String);
	*** findDeserializationKeyType(org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType,java.lang.String);
	*** findDeserializationType(org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType,java.lang.String);
	*** findDeserializer(org.codehaus.jackson.map.introspect.Annotated);
	*** findEnumValue(java.lang.Enum);
	*** findFilterId(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findGettablePropertyName(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** findIgnoreUnknownProperties(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findInjectableValueId(org.codehaus.jackson.map.introspect.AnnotatedMember);
	*** findKeyDeserializer(org.codehaus.jackson.map.introspect.Annotated);
	*** findKeySerializer(org.codehaus.jackson.map.introspect.Annotated);
	*** findPropertiesToIgnore(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findPropertyContentTypeResolver(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.type.JavaType);
	*** findPropertyNameForParam(org.codehaus.jackson.map.introspect.AnnotatedParameter);
	*** findPropertyTypeResolver(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.type.JavaType);
	*** findReferenceType(org.codehaus.jackson.map.introspect.AnnotatedMember);
	*** findRootName(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findSerializablePropertyName(org.codehaus.jackson.map.introspect.AnnotatedField);
	*** findSerializationContentType(org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType);
	*** findSerializationInclusion(org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.map.annotate.JsonSerialize$Inclusion);
	*** findSerializationKeyType(org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType);
	*** findSerializationPropertyOrder(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findSerializationSortAlphabetically(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findSerializationType(org.codehaus.jackson.map.introspect.Annotated);
	*** findSerializationTyping(org.codehaus.jackson.map.introspect.Annotated);
	*** findSerializationViews(org.codehaus.jackson.map.introspect.Annotated);
	*** findSerializer(org.codehaus.jackson.map.introspect.Annotated);
	*** findSettablePropertyName(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** findSubtypes(org.codehaus.jackson.map.introspect.Annotated);
	*** findTypeName(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** findTypeResolver(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedClass,org.codehaus.jackson.type.JavaType);
	*** findValueInstantiator(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** hasAnyGetterAnnotation(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** hasAnySetterAnnotation(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** hasAsValueAnnotation(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** hasCreatorAnnotation(org.codehaus.jackson.map.introspect.Annotated);
	*** hasIgnoreMarker(org.codehaus.jackson.map.introspect.AnnotatedMember);
	*** isHandled(java.lang.annotation.Annotation);
	*** isIgnorableConstructor(org.codehaus.jackson.map.introspect.AnnotatedConstructor);
	*** isIgnorableField(org.codehaus.jackson.map.introspect.AnnotatedField);
	*** isIgnorableMethod(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** isIgnorableType(org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** nopInstance();
	*** shouldUnwrapProperty(org.codehaus.jackson.map.introspect.AnnotatedMember);
}

-keep class org.codehaus.jackson.map.AnnotationIntrospector$Pair {
	*** _primary;
	*** _secondary;
	*** allIntrospectors(java.util.Collection);
	*** create(org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.AnnotationIntrospector);
}

-keep class org.codehaus.jackson.map.AnnotationIntrospector$ReferenceProperty {
	*** back(java.lang.String);
	*** getName();
	*** isBackReference();
	*** isManagedReference();
	*** managed(java.lang.String);
}

-keep class org.codehaus.jackson.map.BeanDescription {
	*** _type;
	org.codehaus.jackson.map.BeanDescription(org.codehaus.jackson.type.JavaType);
	*** getBeanClass();
	*** getClassInfo();
	*** getType();
}

-keep class org.codehaus.jackson.map.BeanProperty {
	*** getMember();
	*** getType();
}

-keep class org.codehaus.jackson.map.BeanProperty$Std {
	*** _contextAnnotations;
	*** _member;
	*** _name;
	*** _type;
	*** getName();
	*** withType(org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.BeanPropertyDefinition {
	org.codehaus.jackson.map.BeanPropertyDefinition();
	*** couldDeserialize();
	*** getAccessor();
	*** getField();
	*** getGetter();
	*** getMutator();
	*** getName();
	*** getSetter();
	*** hasConstructorParameter();
	*** hasField();
	*** hasGetter();
	*** hasSetter();
	*** isExplicitlyIncluded();
}

-keep class org.codehaus.jackson.map.ClassIntrospector {
	org.codehaus.jackson.map.ClassIntrospector();
	*** forClassAnnotations(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forCreation(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forDeserialization(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forDirectClassAnnotations(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forSerialization(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
}

-keep class org.codehaus.jackson.map.ClassIntrospector$MixInResolver {
	*** findMixInClassFor(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ContextualDeserializer {
	*** createContextual(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.ContextualKeyDeserializer {
	*** createContextual(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.ContextualSerializer {
	*** createContextual(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.DeserializationConfig {
	*** _nodeFactory;
	*** _problemHandlers;
	*** _sortPropertiesAlphabetically;
	org.codehaus.jackson.map.DeserializationConfig(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.MapperConfig$Base);
	*** canOverrideAccessModifiers();
	*** createUnshared(org.codehaus.jackson.map.jsontype.SubtypeResolver);
	*** deserializerInstance(org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** disable(org.codehaus.jackson.map.DeserializationConfig$Feature);
	*** enable(org.codehaus.jackson.map.DeserializationConfig$Feature);
	*** getAnnotationIntrospector();
	*** getBase64Variant();
	*** getDefaultVisibilityChecker();
	*** getNodeFactory();
	*** getProblemHandlers();
	*** introspect(org.codehaus.jackson.type.JavaType);
	*** introspectForCreation(org.codehaus.jackson.type.JavaType);
	*** isEnabled(org.codehaus.jackson.map.DeserializationConfig$Feature);
	*** keyDeserializerInstance(org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** passSerializationFeatures(int);
	*** set(org.codehaus.jackson.map.DeserializationConfig$Feature,boolean);
	*** valueInstantiatorInstance(org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** with(org.codehaus.jackson.map.DeserializationConfig$Feature[]);
	*** withAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withAppendedAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withClassIntrospector(org.codehaus.jackson.map.ClassIntrospector);
	*** withDateFormat(java.text.DateFormat);
	*** withHandlerInstantiator(org.codehaus.jackson.map.HandlerInstantiator);
	*** withInsertedAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withNodeFactory(org.codehaus.jackson.node.JsonNodeFactory);
	*** withPropertyNamingStrategy(org.codehaus.jackson.map.PropertyNamingStrategy);
	*** withSubtypeResolver(org.codehaus.jackson.map.jsontype.SubtypeResolver);
	*** withTypeFactory(org.codehaus.jackson.map.type.TypeFactory);
	*** withTypeResolverBuilder(org.codehaus.jackson.map.jsontype.TypeResolverBuilder);
	*** withVisibility(org.codehaus.jackson.annotate.JsonMethod,org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withVisibilityChecker(org.codehaus.jackson.map.introspect.VisibilityChecker);
	*** without(org.codehaus.jackson.map.DeserializationConfig$Feature[]);
}

-keep class org.codehaus.jackson.map.DeserializationConfig$Feature {
	*** $VALUES;
	*** ACCEPT_EMPTY_STRING_AS_NULL_OBJECT;
	*** ACCEPT_SINGLE_VALUE_AS_ARRAY;
	*** AUTO_DETECT_CREATORS;
	*** AUTO_DETECT_FIELDS;
	*** AUTO_DETECT_SETTERS;
	*** CAN_OVERRIDE_ACCESS_MODIFIERS;
	*** FAIL_ON_NULL_FOR_PRIMITIVES;
	*** FAIL_ON_NUMBERS_FOR_ENUMS;
	*** FAIL_ON_UNKNOWN_PROPERTIES;
	*** READ_ENUMS_USING_TO_STRING;
	*** UNWRAP_ROOT_VALUE;
	*** USE_ANNOTATIONS;
	*** USE_BIG_DECIMAL_FOR_FLOATS;
	*** USE_BIG_INTEGER_FOR_INTS;
	*** USE_GETTERS_AS_SETTERS;
	*** USE_JAVA_ARRAY_FOR_JSON_ARRAY;
	*** WRAP_EXCEPTIONS;
	*** _defaultState;
	*** getMask();
}

-keep class org.codehaus.jackson.map.DeserializationContext {
	*** _config;
	*** _featureFlags;
	org.codehaus.jackson.map.DeserializationContext(org.codehaus.jackson.map.DeserializationConfig);
	*** constructCalendar(java.util.Date);
	*** constructType(java.lang.Class);
	*** findInjectableValue(java.lang.Object,org.codehaus.jackson.map.BeanProperty,java.lang.Object);
	*** getArrayBuilders();
	*** getBase64Variant();
	*** getConfig();
	*** getDeserializerProvider();
	*** getNodeFactory();
	*** getParser();
	*** getTypeFactory();
	*** handleUnknownProperty(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.JsonDeserializer,java.lang.Object,java.lang.String);
	*** instantiationException(java.lang.Class,java.lang.String);
	*** instantiationException(java.lang.Class,java.lang.Throwable);
	*** isEnabled(org.codehaus.jackson.map.DeserializationConfig$Feature);
	*** leaseObjectBuffer();
	*** mappingException(java.lang.Class);
	*** mappingException(java.lang.Class,org.codehaus.jackson.JsonToken);
	*** mappingException(java.lang.String);
	*** parseDate(java.lang.String);
	*** returnObjectBuffer(org.codehaus.jackson.map.util.ObjectBuffer);
	*** unknownFieldException(java.lang.Object,java.lang.String);
	*** weirdKeyException(java.lang.Class,java.lang.String,java.lang.String);
	*** weirdNumberException(java.lang.Class,java.lang.String);
	*** weirdStringException(java.lang.Class,java.lang.String);
}

-keep class org.codehaus.jackson.map.DeserializationProblemHandler {
	*** handleUnknownProperty(org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.JsonDeserializer,java.lang.Object,java.lang.String);
}

-keep class org.codehaus.jackson.map.DeserializerFactory {
	*** NO_DESERIALIZERS;
	org.codehaus.jackson.map.DeserializerFactory();
	*** createArrayDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.type.ArrayType,org.codehaus.jackson.map.BeanProperty);
	*** createBeanDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** createCollectionDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.type.CollectionType,org.codehaus.jackson.map.BeanProperty);
	*** createCollectionLikeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.type.CollectionLikeType,org.codehaus.jackson.map.BeanProperty);
	*** createEnumDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** createKeyDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** createMapDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.type.MapType,org.codehaus.jackson.map.BeanProperty);
	*** createMapLikeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.type.MapLikeType,org.codehaus.jackson.map.BeanProperty);
	*** createTreeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findTypeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** getConfig();
	*** mapAbstractType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** withAbstractTypeResolver(org.codehaus.jackson.map.AbstractTypeResolver);
	*** withAdditionalDeserializers(org.codehaus.jackson.map.Deserializers);
	*** withAdditionalKeyDeserializers(org.codehaus.jackson.map.KeyDeserializers);
	*** withConfig(org.codehaus.jackson.map.DeserializerFactory$Config);
	*** withDeserializerModifier(org.codehaus.jackson.map.deser.BeanDeserializerModifier);
	*** withValueInstantiators(org.codehaus.jackson.map.deser.ValueInstantiators);
}

-keep class org.codehaus.jackson.map.DeserializerFactory$Config {
	org.codehaus.jackson.map.DeserializerFactory$Config();
	*** abstractTypeResolvers();
	*** deserializerModifiers();
	*** deserializers();
	*** hasAbstractTypeResolvers();
	*** hasDeserializerModifiers();
	*** hasKeyDeserializers();
	*** hasValueInstantiators();
	*** keyDeserializers();
	*** valueInstantiators();
	*** withAbstractTypeResolver(org.codehaus.jackson.map.AbstractTypeResolver);
	*** withAdditionalDeserializers(org.codehaus.jackson.map.Deserializers);
	*** withAdditionalKeyDeserializers(org.codehaus.jackson.map.KeyDeserializers);
	*** withDeserializerModifier(org.codehaus.jackson.map.deser.BeanDeserializerModifier);
	*** withValueInstantiators(org.codehaus.jackson.map.deser.ValueInstantiators);
}

-keep class org.codehaus.jackson.map.DeserializerProvider {
	org.codehaus.jackson.map.DeserializerProvider();
	*** findExpectedRootName(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** findKeyDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findTypedValueDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findValueDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** hasValueDeserializerFor(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.Deserializers {
	*** findArrayDeserializer(org.codehaus.jackson.map.type.ArrayType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** findBeanDeserializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** findCollectionDeserializer(org.codehaus.jackson.map.type.CollectionType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** findCollectionLikeDeserializer(org.codehaus.jackson.map.type.CollectionLikeType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** findEnumDeserializer(java.lang.Class,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** findMapDeserializer(org.codehaus.jackson.map.type.MapType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.KeyDeserializer,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** findMapLikeDeserializer(org.codehaus.jackson.map.type.MapLikeType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.KeyDeserializer,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** findTreeNodeDeserializer(java.lang.Class,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.HandlerInstantiator {
	*** deserializerInstance(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** keyDeserializerInstance(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** serializerInstance(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** typeIdResolverInstance(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** typeResolverBuilderInstance(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** valueInstantiatorInstance(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
}

-keep class org.codehaus.jackson.map.InjectableValues {
	*** findInjectableValue(java.lang.Object,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.BeanProperty,java.lang.Object);
}

-keep class org.codehaus.jackson.map.JsonDeserializer {
	org.codehaus.jackson.map.JsonDeserializer();
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
	*** getEmptyValue();
	*** getNullValue();
	*** unwrappingDeserializer();
}

-keep class org.codehaus.jackson.map.JsonMappingException {
	*** _path;
	org.codehaus.jackson.map.JsonMappingException(java.lang.String,org.codehaus.jackson.JsonLocation);
	*** _appendPathDesc(java.lang.StringBuilder);
	*** from(org.codehaus.jackson.JsonParser,java.lang.String);
	*** from(org.codehaus.jackson.JsonParser,java.lang.String,java.lang.Throwable);
	*** getMessage();
	*** prependPath(java.lang.Object,java.lang.String);
	*** prependPath(org.codehaus.jackson.map.JsonMappingException$Reference);
	*** wrapWithPath(java.lang.Throwable,java.lang.Object,int);
	*** wrapWithPath(java.lang.Throwable,java.lang.Object,java.lang.String);
	*** wrapWithPath(java.lang.Throwable,org.codehaus.jackson.map.JsonMappingException$Reference);
}

-keep class org.codehaus.jackson.map.JsonMappingException$Reference {
	*** toString();
}

-keep class org.codehaus.jackson.map.JsonSerializable {
	*** serialize(org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.JsonSerializableWithType {
	*** serializeWithType(org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.JsonSerializer {
	org.codehaus.jackson.map.JsonSerializer();
	*** isUnwrappingSerializer();
	*** serialize(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
	*** unwrappingSerializer();
}

-keep class org.codehaus.jackson.map.KeyDeserializer {
	org.codehaus.jackson.map.KeyDeserializer();
	*** deserializeKey(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.KeyDeserializers {
	*** findKeyDeserializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.MapperConfig {
	*** DEFAULT_DATE_FORMAT;
	*** _base;
	*** _mixInAnnotations;
	*** _mixInAnnotationsShared;
	*** _subtypeResolver;
	org.codehaus.jackson.map.MapperConfig(org.codehaus.jackson.map.ClassIntrospector,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.introspect.VisibilityChecker,org.codehaus.jackson.map.jsontype.SubtypeResolver,org.codehaus.jackson.map.PropertyNamingStrategy,org.codehaus.jackson.map.type.TypeFactory,org.codehaus.jackson.map.HandlerInstantiator);
	org.codehaus.jackson.map.MapperConfig(org.codehaus.jackson.map.MapperConfig);
	org.codehaus.jackson.map.MapperConfig(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.MapperConfig$Base,org.codehaus.jackson.map.jsontype.SubtypeResolver);
	*** canOverrideAccessModifiers();
	*** constructSpecializedType(org.codehaus.jackson.type.JavaType,java.lang.Class);
	*** constructType(java.lang.Class);
	*** getAnnotationIntrospector();
	*** getClassIntrospector();
	*** getDateFormat();
	*** getDefaultTyper(org.codehaus.jackson.type.JavaType);
	*** getDefaultVisibilityChecker();
	*** getHandlerInstantiator();
	*** getPropertyNamingStrategy();
	*** getSubtypeResolver();
	*** getTypeFactory();
	*** introspectClassAnnotations(java.lang.Class);
	*** introspectClassAnnotations(org.codehaus.jackson.type.JavaType);
	*** introspectDirectClassAnnotations(org.codehaus.jackson.type.JavaType);
	*** isAnnotationProcessingEnabled();
	*** setDateFormat(java.text.DateFormat);
	*** shouldSortPropertiesAlphabetically();
	*** typeIdResolverInstance(org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** typeResolverBuilderInstance(org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
}

-keep class org.codehaus.jackson.map.MapperConfig$Base {
	*** _annotationIntrospector;
	*** _classIntrospector;
	*** _dateFormat;
	*** _handlerInstantiator;
	*** _propertyNamingStrategy;
	*** _typeFactory;
	*** _typeResolverBuilder;
	*** _visibilityChecker;
	*** getAnnotationIntrospector();
	*** getClassIntrospector();
	*** getDateFormat();
	*** getHandlerInstantiator();
	*** getPropertyNamingStrategy();
	*** getTypeFactory();
	*** getTypeResolverBuilder();
	*** getVisibilityChecker();
	*** withAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withAppendedAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withClassIntrospector(org.codehaus.jackson.map.ClassIntrospector);
	*** withDateFormat(java.text.DateFormat);
	*** withHandlerInstantiator(org.codehaus.jackson.map.HandlerInstantiator);
	*** withInsertedAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withPropertyNamingStrategy(org.codehaus.jackson.map.PropertyNamingStrategy);
	*** withTypeFactory(org.codehaus.jackson.map.type.TypeFactory);
	*** withTypeResolverBuilder(org.codehaus.jackson.map.jsontype.TypeResolverBuilder);
	*** withVisibility(org.codehaus.jackson.annotate.JsonMethod,org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withVisibilityChecker(org.codehaus.jackson.map.introspect.VisibilityChecker);
}

-keep class org.codehaus.jackson.map.MapperConfig$ConfigFeature {
	*** enabledByDefault();
	*** getMask();
}

-keep class org.codehaus.jackson.map.MapperConfig$Impl {
	*** _featureFlags;
	org.codehaus.jackson.map.MapperConfig$Impl(org.codehaus.jackson.map.ClassIntrospector,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.introspect.VisibilityChecker,org.codehaus.jackson.map.jsontype.SubtypeResolver,org.codehaus.jackson.map.PropertyNamingStrategy,org.codehaus.jackson.map.type.TypeFactory,org.codehaus.jackson.map.HandlerInstantiator,int);
	org.codehaus.jackson.map.MapperConfig$Impl(org.codehaus.jackson.map.MapperConfig$Impl);
	org.codehaus.jackson.map.MapperConfig$Impl(org.codehaus.jackson.map.MapperConfig$Impl,int);
	org.codehaus.jackson.map.MapperConfig$Impl(org.codehaus.jackson.map.MapperConfig$Impl,org.codehaus.jackson.map.MapperConfig$Base,org.codehaus.jackson.map.jsontype.SubtypeResolver);
	*** collectFeatureDefaults(java.lang.Class);
	*** disable(org.codehaus.jackson.map.MapperConfig$ConfigFeature);
	*** enable(org.codehaus.jackson.map.MapperConfig$ConfigFeature);
	*** isEnabled(org.codehaus.jackson.map.MapperConfig$ConfigFeature);
	*** set(org.codehaus.jackson.map.MapperConfig$ConfigFeature,boolean);
}

-keep class org.codehaus.jackson.map.MappingJsonFactory {
	org.codehaus.jackson.map.MappingJsonFactory(org.codehaus.jackson.map.ObjectMapper);
	*** getCodec();
}

-keep class org.codehaus.jackson.map.Module {
	*** getModuleName();
	*** setupModule(org.codehaus.jackson.map.Module$SetupContext);
	*** version();
}

-keep class org.codehaus.jackson.map.ObjectMapper {
	*** DEFAULT_ANNOTATION_INTROSPECTOR;
	*** DEFAULT_INTROSPECTOR;
	*** JSON_NODE_TYPE;
	*** STD_VISIBILITY_CHECKER;
	*** _deserializationConfig;
	*** _deserializerProvider;
	*** _injectableValues;
	*** _jsonFactory;
	*** _rootDeserializers;
	*** _serializationConfig;
	*** _serializerFactory;
	*** _serializerProvider;
	*** _subtypeResolver;
	*** _typeFactory;
	org.codehaus.jackson.map.ObjectMapper(org.codehaus.jackson.JsonFactory,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.DeserializerProvider);
	org.codehaus.jackson.map.ObjectMapper(org.codehaus.jackson.JsonFactory,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.DeserializationConfig);
	*** _configAndWriteCloseable(org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.map.SerializationConfig);
	*** _configAndWriteValue(org.codehaus.jackson.JsonGenerator,java.lang.Object);
	*** _convert(java.lang.Object,org.codehaus.jackson.type.JavaType);
	*** _createDeserializationContext(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationConfig);
	*** _defaultPrettyPrinter();
	*** _findRootDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** _initForReading(org.codehaus.jackson.JsonParser);
	*** _readMapAndClose(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.JavaType);
	*** _readValue(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.JavaType);
	*** _unwrapAndDeserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.JsonDeserializer);
	*** _writeCloseableValue(org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.map.SerializationConfig);
	*** configure(org.codehaus.jackson.map.SerializationConfig$Feature,boolean);
	*** constructType(java.lang.reflect.Type);
	*** copyDeserializationConfig();
	*** copySerializationConfig();
	*** createArrayNode();
	*** createObjectNode();
	*** enableDefaultTyping(org.codehaus.jackson.map.ObjectMapper$DefaultTyping);
	*** enableDefaultTyping(org.codehaus.jackson.map.ObjectMapper$DefaultTyping,org.codehaus.jackson.annotate.JsonTypeInfo$As);
	*** generateJsonSchema(java.lang.Class,org.codehaus.jackson.map.SerializationConfig);
	*** getNodeFactory();
	*** getSerializationConfig();
	*** getSubtypeResolver();
	*** readTree(org.codehaus.jackson.JsonParser);
	*** readValue(java.io.InputStream,org.codehaus.jackson.type.JavaType);
	*** readValue(java.io.Reader,org.codehaus.jackson.type.JavaType);
	*** readValue(java.lang.String,java.lang.Class);
	*** readValue(java.lang.String,org.codehaus.jackson.type.JavaType);
	*** readValue(org.codehaus.jackson.JsonParser,java.lang.Class);
	*** readValue(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.JavaType);
	*** readValues(org.codehaus.jackson.JsonParser,java.lang.Class);
	*** readValues(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.JavaType);
	*** readValues(org.codehaus.jackson.JsonParser,org.codehaus.jackson.type.TypeReference);
	*** reader(org.codehaus.jackson.FormatSchema);
	*** reader(org.codehaus.jackson.type.JavaType);
	*** readerForUpdating(java.lang.Object);
	*** registerModule(org.codehaus.jackson.map.Module);
	*** setDefaultTyping(org.codehaus.jackson.map.jsontype.TypeResolverBuilder);
	*** setSerializationConfig(org.codehaus.jackson.map.SerializationConfig);
	*** setSerializerFactory(org.codehaus.jackson.map.SerializerFactory);
	*** treeAsTokens(org.codehaus.jackson.JsonNode);
	*** writeValue(org.codehaus.jackson.JsonGenerator,java.lang.Object);
	*** writeValueAsString(java.lang.Object);
	*** writer(org.codehaus.jackson.FormatSchema);
	*** writer(org.codehaus.jackson.PrettyPrinter);
	*** writer(org.codehaus.jackson.map.ser.FilterProvider);
	*** writerWithDefaultPrettyPrinter();
	*** writerWithType(java.lang.Class);
	*** writerWithType(org.codehaus.jackson.type.JavaType);
	*** writerWithType(org.codehaus.jackson.type.TypeReference);
	*** writerWithView(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ObjectMapper$DefaultTyping {
	*** OBJECT_AND_NON_CONCRETE;
}

-keep class org.codehaus.jackson.map.ObjectReader {
	*** withInjectableValues(org.codehaus.jackson.map.InjectableValues);
	*** withNodeFactory(org.codehaus.jackson.node.JsonNodeFactory);
}

-keep class org.codehaus.jackson.map.ObjectWriter {
	*** NULL_PRETTY_PRINTER;
	*** _config;
	*** _jsonFactory;
	*** _prettyPrinter;
	*** _provider;
	*** _rootType;
	*** _schema;
	*** _serializerFactory;
	*** _configAndWriteCloseable(org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.map.SerializationConfig);
	*** _configAndWriteValue(org.codehaus.jackson.JsonGenerator,java.lang.Object);
	*** _writeCloseableValue(org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.map.SerializationConfig);
	*** withPrettyPrinter(org.codehaus.jackson.PrettyPrinter);
	*** withType(org.codehaus.jackson.type.JavaType);
	*** writeValueAsString(java.lang.Object);
}

-keep class org.codehaus.jackson.map.PropertyNamingStrategy {
	*** nameForConstructorParameter(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedParameter,java.lang.String);
	*** nameForField(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedField,java.lang.String);
	*** nameForGetterMethod(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedMethod,java.lang.String);
	*** nameForSetterMethod(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedMethod,java.lang.String);
}

-keep class org.codehaus.jackson.map.ResolvableDeserializer {
	*** resolve(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider);
}

-keep class org.codehaus.jackson.map.ResolvableSerializer {
	*** resolve(org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.SerializationConfig {
	*** _filterProvider;
	*** _serializationInclusion;
	*** _serializationView;
	org.codehaus.jackson.map.SerializationConfig(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.MapperConfig$Base);
	*** canOverrideAccessModifiers();
	*** createUnshared(org.codehaus.jackson.map.jsontype.SubtypeResolver);
	*** disable(org.codehaus.jackson.map.SerializationConfig$Feature);
	*** enable(org.codehaus.jackson.map.SerializationConfig$Feature);
	*** getAnnotationIntrospector();
	*** getDefaultVisibilityChecker();
	*** getFilterProvider();
	*** getSerializationInclusion();
	*** getSerializationView();
	*** introspect(org.codehaus.jackson.type.JavaType);
	*** isEnabled(org.codehaus.jackson.map.SerializationConfig$Feature);
	*** serializerInstance(org.codehaus.jackson.map.introspect.Annotated,java.lang.Class);
	*** set(org.codehaus.jackson.map.SerializationConfig$Feature,boolean);
	*** setSerializationInclusion(org.codehaus.jackson.map.annotate.JsonSerialize$Inclusion);
	*** with(org.codehaus.jackson.map.SerializationConfig$Feature[]);
	*** withAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withAppendedAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withClassIntrospector(org.codehaus.jackson.map.ClassIntrospector);
	*** withDateFormat(java.text.DateFormat);
	*** withFilters(org.codehaus.jackson.map.ser.FilterProvider);
	*** withHandlerInstantiator(org.codehaus.jackson.map.HandlerInstantiator);
	*** withInsertedAnnotationIntrospector(org.codehaus.jackson.map.AnnotationIntrospector);
	*** withPropertyNamingStrategy(org.codehaus.jackson.map.PropertyNamingStrategy);
	*** withSerializationInclusion(org.codehaus.jackson.map.annotate.JsonSerialize$Inclusion);
	*** withSubtypeResolver(org.codehaus.jackson.map.jsontype.SubtypeResolver);
	*** withTypeFactory(org.codehaus.jackson.map.type.TypeFactory);
	*** withTypeResolverBuilder(org.codehaus.jackson.map.jsontype.TypeResolverBuilder);
	*** withView(java.lang.Class);
	*** withVisibility(org.codehaus.jackson.annotate.JsonMethod,org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withVisibilityChecker(org.codehaus.jackson.map.introspect.VisibilityChecker);
	*** without(org.codehaus.jackson.map.SerializationConfig$Feature[]);
}

-keep class org.codehaus.jackson.map.SerializationConfig$Feature {
	*** $VALUES;
	*** AUTO_DETECT_FIELDS;
	*** AUTO_DETECT_GETTERS;
	*** AUTO_DETECT_IS_GETTERS;
	*** CAN_OVERRIDE_ACCESS_MODIFIERS;
	*** CLOSE_CLOSEABLE;
	*** DEFAULT_VIEW_INCLUSION;
	*** FAIL_ON_EMPTY_BEANS;
	*** FLUSH_AFTER_WRITE_VALUE;
	*** INDENT_OUTPUT;
	*** REQUIRE_SETTERS_FOR_GETTERS;
	*** SORT_PROPERTIES_ALPHABETICALLY;
	*** USE_ANNOTATIONS;
	*** USE_STATIC_TYPING;
	*** WRAP_EXCEPTIONS;
	*** WRAP_ROOT_VALUE;
	*** WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS;
	*** WRITE_DATES_AS_TIMESTAMPS;
	*** WRITE_DATE_KEYS_AS_TIMESTAMPS;
	*** WRITE_EMPTY_JSON_ARRAYS;
	*** WRITE_ENUMS_USING_INDEX;
	*** WRITE_ENUMS_USING_TO_STRING;
	*** WRITE_NULL_MAP_VALUES;
	*** WRITE_NULL_PROPERTIES;
	*** _defaultState;
	*** getMask();
}

-keep class org.codehaus.jackson.map.SerializerFactory {
	org.codehaus.jackson.map.SerializerFactory();
	*** createKeySerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** createSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** createTypeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** getConfig();
	*** withConfig(org.codehaus.jackson.map.SerializerFactory$Config);
}

-keep class org.codehaus.jackson.map.SerializerFactory$Config {
	org.codehaus.jackson.map.SerializerFactory$Config();
	*** hasKeySerializers();
	*** hasSerializerModifiers();
	*** keySerializers();
	*** serializerModifiers();
	*** serializers();
	*** withAdditionalKeySerializers(org.codehaus.jackson.map.Serializers);
	*** withAdditionalSerializers(org.codehaus.jackson.map.Serializers);
	*** withSerializerModifier(org.codehaus.jackson.map.ser.BeanSerializerModifier);
}

-keep class org.codehaus.jackson.map.SerializerProvider {
	*** TYPE_OBJECT;
	*** _config;
	*** _serializationView;
	org.codehaus.jackson.map.SerializerProvider(org.codehaus.jackson.map.SerializationConfig);
	*** constructSpecializedType(org.codehaus.jackson.type.JavaType,java.lang.Class);
	*** constructType(java.lang.reflect.Type);
	*** defaultSerializeDateKey(java.util.Date,org.codehaus.jackson.JsonGenerator);
	*** defaultSerializeDateValue(java.util.Date,org.codehaus.jackson.JsonGenerator);
	*** defaultSerializeDateValue(long,org.codehaus.jackson.JsonGenerator);
	*** defaultSerializeNull(org.codehaus.jackson.JsonGenerator);
	*** defaultSerializeValue(java.lang.Object,org.codehaus.jackson.JsonGenerator);
	*** findKeySerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findTypedValueSerializer(java.lang.Class,boolean,org.codehaus.jackson.map.BeanProperty);
	*** findTypedValueSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.BeanProperty);
	*** findValueSerializer(java.lang.Class,org.codehaus.jackson.map.BeanProperty);
	*** findValueSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** generateJsonSchema(java.lang.Class,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.SerializerFactory);
	*** getConfig();
	*** getFilterProvider();
	*** getNullKeySerializer();
	*** getNullValueSerializer();
	*** getSerializationView();
	*** hasSerializerFor(org.codehaus.jackson.map.SerializationConfig,java.lang.Class,org.codehaus.jackson.map.SerializerFactory);
	*** isEnabled(org.codehaus.jackson.map.SerializationConfig$Feature);
	*** serializeValue(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.map.SerializerFactory);
	*** serializeValue(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializerFactory);
}

-keep class org.codehaus.jackson.map.Serializers {
	*** findCollectionLikeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.CollectionLikeType,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** findCollectionSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.CollectionType,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** findMapLikeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.MapLikeType,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** findMapSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.MapType,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** findSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.TypeDeserializer {
	*** deserializeTypedFromAny(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeTypedFromArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeTypedFromObject(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeTypedFromScalar(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** getPropertyName();
	*** getTypeInclusion();
}

-keep class org.codehaus.jackson.map.TypeSerializer {
	*** writeTypePrefixForArray(java.lang.Object,org.codehaus.jackson.JsonGenerator);
	*** writeTypePrefixForObject(java.lang.Object,org.codehaus.jackson.JsonGenerator);
	*** writeTypePrefixForScalar(java.lang.Object,org.codehaus.jackson.JsonGenerator);
	*** writeTypePrefixForScalar(java.lang.Object,org.codehaus.jackson.JsonGenerator,java.lang.Class);
	*** writeTypeSuffixForArray(java.lang.Object,org.codehaus.jackson.JsonGenerator);
	*** writeTypeSuffixForObject(java.lang.Object,org.codehaus.jackson.JsonGenerator);
	*** writeTypeSuffixForScalar(java.lang.Object,org.codehaus.jackson.JsonGenerator);
}

-keep class org.codehaus.jackson.map.annotate.JacksonInject {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonCachable {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonDeserialize {
	*** as();
	*** contentAs();
	*** contentUsing();
	*** keyAs();
	*** keyUsing();
	*** using();
}

-keep class org.codehaus.jackson.map.annotate.JsonFilter {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonRootName {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonSerialize {
	*** as();
	*** contentAs();
	*** contentUsing();
	*** include();
	*** keyAs();
	*** keyUsing();
	*** typing();
	*** using();
}

-keep class org.codehaus.jackson.map.annotate.JsonSerialize$Inclusion {
	*** $VALUES;
	*** ALWAYS;
	*** NON_DEFAULT;
	*** NON_EMPTY;
	*** NON_NULL;
	*** values();
}

-keep class org.codehaus.jackson.map.annotate.JsonSerialize$Typing {
	*** $VALUES;
	*** DYNAMIC;
	*** STATIC;
}

-keep class org.codehaus.jackson.map.annotate.JsonTypeIdResolver {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonTypeResolver {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonValueInstantiator {
	*** value();
}

-keep class org.codehaus.jackson.map.annotate.JsonView {
	*** value();
}

-keep class org.codehaus.jackson.map.deser.AbstractDeserializer {
	*** _acceptBoolean;
	*** _acceptDouble;
	*** _acceptInt;
	*** _acceptString;
	*** _baseType;
	*** _deserializeIfNatural(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.AbstractDeserializer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.map.deser.BasicDeserializerFactory {
	*** _arrayDeserializers;
	*** _collectionFallbacks;
	*** _keyDeserializers;
	*** _mapFallbacks;
	*** _simpleDeserializers;
	*** optionalHandlers;
	org.codehaus.jackson.map.deser.BasicDeserializerFactory();
	*** _constructDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.map.BeanProperty,java.lang.Object);
	*** _findCustomArrayDeserializer(org.codehaus.jackson.map.type.ArrayType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** _findCustomCollectionDeserializer(org.codehaus.jackson.map.type.CollectionType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** _findCustomCollectionLikeDeserializer(org.codehaus.jackson.map.type.CollectionLikeType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** _findCustomEnumDeserializer(java.lang.Class,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** _findCustomMapDeserializer(org.codehaus.jackson.map.type.MapType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.KeyDeserializer,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** _findCustomMapLikeDeserializer(org.codehaus.jackson.map.type.MapLikeType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.KeyDeserializer,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** _findCustomTreeNodeDeserializer(java.lang.Class,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanProperty);
	*** constructEnumResolver(java.lang.Class,org.codehaus.jackson.map.DeserializationConfig);
	*** createEnumDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findDeserializerFromAnnotation(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.map.BeanProperty);
	*** findPropertyContentTypeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.BeanProperty);
	*** findPropertyTypeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.BeanProperty);
	*** findStdBeanDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findTypeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** findValueInstantiator(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** mapAbstractType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** modifyTypeByAnnotation(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType,java.lang.String);
	*** resolveType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.deser.BeanDeserializer {
	*** _anySetter;
	*** _backRefs;
	*** _beanProperties;
	*** _beanType;
	*** _delegateDeserializer;
	*** _externalTypeIdHandler;
	*** _forClass;
	*** _ignorableProps;
	*** _ignoreAllUnknown;
	*** _injectables;
	*** _nonStandardCreation;
	*** _property;
	*** _propertyBasedCreator;
	*** _subDeserializers;
	*** _unwrappedPropertyHandler;
	*** _valueInstantiator;
	org.codehaus.jackson.map.deser.BeanDeserializer(org.codehaus.jackson.map.deser.BeanDeserializer);
	org.codehaus.jackson.map.deser.BeanDeserializer(org.codehaus.jackson.map.deser.BeanDeserializer,boolean);
	org.codehaus.jackson.map.deser.BeanDeserializer(org.codehaus.jackson.map.introspect.AnnotatedClass,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.deser.ValueInstantiator,org.codehaus.jackson.map.deser.impl.BeanPropertyMap,java.util.Map,java.util.HashSet,boolean,org.codehaus.jackson.map.deser.SettableAnyProperty,java.util.List);
	*** _deserializeUsingPropertyBased(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _findSubclassDeserializer(org.codehaus.jackson.map.DeserializationContext,java.lang.Object,org.codehaus.jackson.util.TokenBuffer);
	*** _handleUnknown(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object,java.lang.String);
	*** _resolveInnerClassValuedProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** _resolveManagedReferenceProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** _resolveUnwrappedProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** deserializeFromArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromBoolean(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromDouble(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromNumber(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromObject(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromObjectUsingNonDefault(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromString(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeUsingPropertyBasedWithExternalTypeId(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeUsingPropertyBasedWithUnwrapped(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithExternalTypeId(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithExternalTypeId(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** deserializeWithUnwrapped(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithUnwrapped(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** findBackReference(java.lang.String);
	*** getBeanClass();
	*** getValueInstantiator();
	*** handlePolymorphic(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object,org.codehaus.jackson.util.TokenBuffer);
	*** handleUnknownProperties(org.codehaus.jackson.map.DeserializationContext,java.lang.Object,org.codehaus.jackson.util.TokenBuffer);
	*** handleUnknownProperty(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object,java.lang.String);
	*** injectValues(org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** wrapAndThrow(java.lang.Throwable,java.lang.Object,int,org.codehaus.jackson.map.DeserializationContext);
	*** wrapAndThrow(java.lang.Throwable,java.lang.Object,java.lang.String,org.codehaus.jackson.map.DeserializationContext);
	*** wrapInstantiationProblem(java.lang.Throwable,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.BeanDeserializer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonParser$NumberType;
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.map.deser.BeanDeserializerBuilder {
	*** _anySetter;
	*** _backRefProperties;
	*** _beanDesc;
	*** _ignorableProps;
	*** _ignoreAllUnknown;
	*** _injectables;
	*** _properties;
	*** _valueInstantiator;
	*** _copy(java.util.HashMap);
	*** addBackReferenceProperty(java.lang.String,org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** addCreatorProperty(org.codehaus.jackson.map.BeanPropertyDefinition);
	*** addIgnorable(java.lang.String);
	*** addInjectable(java.lang.String,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.util.Annotations,org.codehaus.jackson.map.introspect.AnnotatedMember,java.lang.Object);
	*** addOrReplaceProperty(org.codehaus.jackson.map.deser.SettableBeanProperty,boolean);
	*** addProperty(org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** build(org.codehaus.jackson.map.BeanProperty);
	*** hasProperty(java.lang.String);
	*** setAnySetter(org.codehaus.jackson.map.deser.SettableAnyProperty);
	*** setIgnoreUnknownProperties(boolean);
	*** setValueInstantiator(org.codehaus.jackson.map.deser.ValueInstantiator);
}

-keep class org.codehaus.jackson.map.deser.BeanDeserializerFactory {
	*** INIT_CAUSE_PARAMS;
	*** _factoryConfig;
	*** instance;
	org.codehaus.jackson.map.deser.BeanDeserializerFactory(org.codehaus.jackson.map.DeserializerFactory$Config);
	*** _addDeserializerConstructors(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.introspect.VisibilityChecker,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.deser.impl.CreatorCollector);
	*** _addDeserializerFactoryMethods(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.introspect.VisibilityChecker,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.deser.impl.CreatorCollector);
	*** _createEnumKeyDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** _findCustomBeanDeserializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** _handleSingleArgumentConstructor(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.introspect.VisibilityChecker,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.deser.impl.CreatorCollector,org.codehaus.jackson.map.introspect.AnnotatedConstructor,boolean,boolean);
	*** _handleSingleArgumentFactory(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.introspect.VisibilityChecker,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.deser.impl.CreatorCollector,org.codehaus.jackson.map.introspect.AnnotatedMethod,boolean);
	*** _mapAbstractType2(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** access$000();
	*** addBeanProps(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.deser.BeanDeserializerBuilder);
	*** addInjectables(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.deser.BeanDeserializerBuilder);
	*** addReferenceProperties(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.deser.BeanDeserializerBuilder);
	*** buildBeanDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** buildThrowableDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** constructAnySetter(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** constructBeanDeserializerBuilder(org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** constructCreatorProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.lang.String,int,org.codehaus.jackson.map.introspect.AnnotatedParameter,java.lang.Object);
	*** constructDefaultValueInstantiator(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** constructSettableProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.lang.String,org.codehaus.jackson.map.introspect.AnnotatedField);
	*** constructSettableProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.lang.String,org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** constructSetterlessProperty(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.lang.String,org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** findValueInstantiator(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** isIgnorableType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.lang.Class,java.util.Map);
	*** isPotentialBeanType(java.lang.Class);
	*** mapAbstractType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** materializeAbstractType(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
}

-keep class org.codehaus.jackson.map.deser.BeanDeserializerFactory$ConfigImpl {
	*** NO_ABSTRACT_TYPE_RESOLVERS;
	*** NO_KEY_DESERIALIZERS;
	*** NO_MODIFIERS;
	*** NO_VALUE_INSTANTIATORS;
	*** _abstractTypeResolvers;
	*** _additionalDeserializers;
	*** _additionalKeyDeserializers;
	*** _modifiers;
	*** _valueInstantiators;
	org.codehaus.jackson.map.deser.BeanDeserializerFactory$ConfigImpl(org.codehaus.jackson.map.Deserializers[],org.codehaus.jackson.map.KeyDeserializers[],org.codehaus.jackson.map.deser.BeanDeserializerModifier[],org.codehaus.jackson.map.AbstractTypeResolver[],org.codehaus.jackson.map.deser.ValueInstantiators[]);
}

-keep class org.codehaus.jackson.map.deser.BeanDeserializerModifier {
	*** modifyDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.JsonDeserializer);
	*** updateBuilder(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.deser.BeanDeserializerBuilder);
}

-keep class org.codehaus.jackson.map.deser.SettableAnyProperty {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeAndSet(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object,java.lang.String);
	*** getProperty();
	*** getType();
	*** hasValueDeserializer();
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty {
	*** _contextAnnotations;
	*** _managedReferenceName;
	*** _nullProvider;
	*** _propName;
	*** _propertyIndex;
	*** _type;
	*** _valueDeserializer;
	*** _valueTypeDeserializer;
	org.codehaus.jackson.map.deser.SettableBeanProperty(java.lang.String,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.TypeDeserializer,org.codehaus.jackson.map.util.Annotations);
	org.codehaus.jackson.map.deser.SettableBeanProperty(org.codehaus.jackson.map.deser.SettableBeanProperty);
	org.codehaus.jackson.map.deser.SettableBeanProperty(org.codehaus.jackson.map.deser.SettableBeanProperty,org.codehaus.jackson.map.JsonDeserializer);
	*** _throwAsIOE(java.lang.Exception);
	*** _throwAsIOE(java.lang.Exception,java.lang.Object);
	*** assignIndex(int);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeAndSet(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** getAnnotation(java.lang.Class);
	*** getDeclaringClass();
	*** getManagedReferenceName();
	*** getMember();
	*** getName();
	*** getPropertyIndex();
	*** getPropertyName();
	*** getType();
	*** getValueDeserializer();
	*** getValueTypeDeserializer();
	*** hasValueDeserializer();
	*** hasValueTypeDeserializer();
	*** set(java.lang.Object,java.lang.Object);
	*** setManagedReferenceName(java.lang.String);
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty$FieldProperty {
	*** _annotated;
	*** _field;
	*** set(java.lang.Object,java.lang.Object);
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty$InnerClassProperty {
	*** _creator;
	*** _delegate;
	*** set(java.lang.Object,java.lang.Object);
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty$ManagedReferenceProperty {
	*** _backProperty;
	*** _isContainer;
	*** _managedProperty;
	*** _referenceName;
	*** set(java.lang.Object,java.lang.Object);
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty$MethodProperty {
	*** _annotated;
	*** _setter;
	*** set(java.lang.Object,java.lang.Object);
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty$NullProvider {
	*** _isPrimitive;
	*** _nullValue;
	*** _rawType;
	*** nullValue(org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.SettableBeanProperty$SetterlessProperty {
	*** _annotated;
	*** _getter;
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.StdDeserializationContext {
	*** _arrayBuilders;
	*** _dateFormat;
	*** _deserProvider;
	*** _injectableValues;
	*** _objectBuffer;
	*** _parser;
	*** _calcName(java.lang.Class);
	*** _desc(java.lang.String);
	*** _valueDesc();
	*** getDateFormat();
	*** mappingException(java.lang.Class,org.codehaus.jackson.JsonToken);
}

-keep class org.codehaus.jackson.map.deser.StdDeserializerProvider {
	*** _cachedDeserializers;
	*** _factory;
	*** _incompleteDeserializers;
	*** _rootNames;
	org.codehaus.jackson.map.deser.StdDeserializerProvider(org.codehaus.jackson.map.DeserializerFactory);
	*** _createAndCache2(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** _createAndCacheValueDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** _createDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** _findCachedDeserializer(org.codehaus.jackson.type.JavaType);
	*** _handleUnknownKeyDeserializer(org.codehaus.jackson.type.JavaType);
	*** _handleUnknownValueDeserializer(org.codehaus.jackson.type.JavaType);
	*** _resolveDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.ResolvableDeserializer);
	*** findValueDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** withFactory(org.codehaus.jackson.map.DeserializerFactory);
}

-keep class org.codehaus.jackson.map.deser.StdDeserializerProvider$WrappedDeserializer {
	*** _deserializer;
	*** _typeDeserializer;
}

-keep class org.codehaus.jackson.map.deser.StdDeserializers {
	*** _deserializers;
	*** add(org.codehaus.jackson.map.deser.std.StdDeserializer);
	*** add(org.codehaus.jackson.map.deser.std.StdDeserializer,java.lang.Class);
	*** constructAll();
}

-keep class org.codehaus.jackson.map.deser.ValueInstantiator {
	org.codehaus.jackson.map.deser.ValueInstantiator();
	*** canCreateFromBoolean();
	*** canCreateFromDouble();
	*** canCreateFromInt();
	*** canCreateFromLong();
	*** canCreateFromObjectWith();
	*** canCreateFromString();
	*** canCreateUsingDefault();
	*** canCreateUsingDelegate();
	*** canInstantiate();
	*** createFromBoolean(boolean);
	*** createFromDouble(double);
	*** createFromInt(int);
	*** createFromLong(long);
	*** createFromString(java.lang.String);
	*** createUsingDefault();
	*** createUsingDelegate(java.lang.Object);
	*** getDefaultCreator();
	*** getDelegateCreator();
	*** getDelegateType();
	*** getValueTypeDesc();
}

-keep class org.codehaus.jackson.map.deser.ValueInstantiators {
	*** findValueInstantiator(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.BeanDescription,org.codehaus.jackson.map.deser.ValueInstantiator);
}

-keep class org.codehaus.jackson.map.deser.impl.BeanPropertyMap {
	*** _buckets;
	*** _hashMask;
	*** _size;
	*** _findWithEquals(java.lang.String,int);
	*** allProperties();
	*** assignIndexes();
	*** find(java.lang.String);
	*** findSize(int);
	*** remove(org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** replace(org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** size();
}

-keep class org.codehaus.jackson.map.deser.impl.BeanPropertyMap$Bucket {
	*** key;
	*** next;
	*** value;
}

-keep class org.codehaus.jackson.map.deser.impl.BeanPropertyMap$IteratorImpl {
	*** _buckets;
	*** _currentBucket;
	*** _nextBucketIndex;
	*** next();
}

-keep class org.codehaus.jackson.map.deser.impl.CreatorCollector {
	*** _beanDesc;
	*** _booleanCreator;
	*** _canFixAccess;
	*** _defaultConstructor;
	*** _delegateCreator;
	*** _doubleCreator;
	*** _intCreator;
	*** _longCreator;
	*** _propertyBasedArgs;
	*** _propertyBasedCreator;
	*** _stringCreator;
	*** addBooleanCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** addDelegatingCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** addDoubleCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** addIntCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** addLongCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** addPropertyCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams,org.codehaus.jackson.map.deser.impl.CreatorProperty[]);
	*** addStringCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** constructValueInstantiator(org.codehaus.jackson.map.DeserializationConfig);
	*** setDefaultConstructor(org.codehaus.jackson.map.introspect.AnnotatedConstructor);
	*** verifyNonDup(org.codehaus.jackson.map.introspect.AnnotatedWithParams,org.codehaus.jackson.map.introspect.AnnotatedWithParams,java.lang.String);
}

-keep class org.codehaus.jackson.map.deser.impl.CreatorProperty {
	*** _annotated;
	*** _injectableValueId;
	*** findInjectableValue(org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** getInjectableValueId();
	*** set(java.lang.Object,java.lang.Object);
	*** withValueDeserializer(org.codehaus.jackson.map.JsonDeserializer);
}

-keep class org.codehaus.jackson.map.deser.impl.ExternalTypeHandler {
	*** complete(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
	*** handleToken(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.String,java.lang.Object);
	*** handleTypePropertyValue(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.String,java.lang.Object);
	*** start();
}

-keep class org.codehaus.jackson.map.deser.impl.ExternalTypeHandler$Builder {
	*** addExternal(org.codehaus.jackson.map.deser.SettableBeanProperty,java.lang.String);
	*** build();
}

-keep class org.codehaus.jackson.map.deser.impl.PropertyBasedCreator {
	*** assignDeserializer(org.codehaus.jackson.map.deser.SettableBeanProperty,org.codehaus.jackson.map.JsonDeserializer);
	*** build(org.codehaus.jackson.map.deser.impl.PropertyValueBuffer);
	*** findCreatorProperty(java.lang.String);
	*** getCreatorProperties();
	*** startBuilding(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.impl.PropertyValueBuffer {
	*** assignParameter(int,java.lang.Object);
	*** bufferAnyProperty(org.codehaus.jackson.map.deser.SettableAnyProperty,java.lang.String,java.lang.Object);
	*** bufferMapProperty(java.lang.Object,java.lang.Object);
	*** bufferProperty(org.codehaus.jackson.map.deser.SettableBeanProperty,java.lang.Object);
}

-keep class org.codehaus.jackson.map.deser.impl.UnwrappedPropertyHandler {
	*** addProperty(org.codehaus.jackson.map.deser.SettableBeanProperty);
	*** processUnwrapped(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object,org.codehaus.jackson.util.TokenBuffer);
}

-keep class org.codehaus.jackson.map.deser.impl.ValueInjector {
	*** inject(org.codehaus.jackson.map.DeserializationContext,java.lang.Object);
}

-keep class org.codehaus.jackson.map.deser.std.AtomicBooleanDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.AtomicReferenceDeserializer {
	*** _property;
	*** _referencedType;
	*** _valueDeserializer;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.BaseNodeDeserializer {
	org.codehaus.jackson.map.deser.std.BaseNodeDeserializer(java.lang.Class);
	*** _handleDuplicateField(java.lang.String,org.codehaus.jackson.node.ObjectNode,org.codehaus.jackson.JsonNode,org.codehaus.jackson.JsonNode);
	*** deserializeAny(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.node.JsonNodeFactory);
	*** deserializeArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.node.JsonNodeFactory);
	*** deserializeObject(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.node.JsonNodeFactory);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
}

-keep class org.codehaus.jackson.map.deser.std.BaseNodeDeserializer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.map.deser.std.CalendarDeserializer {
	*** _calendarClass;
	org.codehaus.jackson.map.deser.std.CalendarDeserializer(java.lang.Class);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.ClassDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.CollectionDeserializer {
	*** _collectionType;
	*** _delegateDeserializer;
	*** _valueDeserializer;
	*** _valueInstantiator;
	*** _valueTypeDeserializer;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Collection);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Collection);
}

-keep class org.codehaus.jackson.map.deser.std.ContainerDeserializerBase {
	org.codehaus.jackson.map.deser.std.ContainerDeserializerBase(java.lang.Class);
	*** getContentDeserializer();
}

-keep class org.codehaus.jackson.map.deser.std.DateDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.EnumDeserializer {
	*** _resolver;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializerForCreator(org.codehaus.jackson.map.DeserializationConfig,java.lang.Class,org.codehaus.jackson.map.introspect.AnnotatedMethod);
}

-keep class org.codehaus.jackson.map.deser.std.EnumDeserializer$FactoryBasedDeserializer {
	*** _enumClass;
	*** _factory;
	*** _inputType;
}

-keep class org.codehaus.jackson.map.deser.std.EnumMapDeserializer {
	*** _enumClass;
	*** _keyDeserializer;
	*** _valueDeserializer;
	org.codehaus.jackson.map.deser.std.EnumMapDeserializer(java.lang.Class,org.codehaus.jackson.map.JsonDeserializer,org.codehaus.jackson.map.JsonDeserializer);
	*** constructMap();
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.EnumSetDeserializer {
	*** _enumClass;
	*** _enumDeserializer;
	org.codehaus.jackson.map.deser.std.EnumSetDeserializer(java.lang.Class,org.codehaus.jackson.map.JsonDeserializer);
	*** constructSet();
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer {
	org.codehaus.jackson.map.deser.std.FromStringDeserializer(java.lang.Class);
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
	*** _deserializeEmbedded(java.lang.Object,org.codehaus.jackson.map.DeserializationContext);
	*** all();
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$CharsetDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$CurrencyDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$InetAddressDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$LocaleDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$PatternDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$TimeZoneDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$URIDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$URLDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.FromStringDeserializer$UUIDDeserializer {
	*** _deserialize(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
	*** _deserializeEmbedded(java.lang.Object,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.JavaTypeDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.JsonNodeDeserializer {
	*** instance;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** getDeserializer(java.lang.Class);
}

-keep class org.codehaus.jackson.map.deser.std.JsonNodeDeserializer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.map.deser.std.JsonNodeDeserializer$ArrayDeserializer {
	*** _instance;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** getInstance();
}

-keep class org.codehaus.jackson.map.deser.std.JsonNodeDeserializer$ObjectDeserializer {
	*** _instance;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** getInstance();
}

-keep class org.codehaus.jackson.map.deser.std.MapDeserializer {
	*** _delegateDeserializer;
	*** _hasDefaultCreator;
	*** _ignorableProperties;
	*** _keyDeserializer;
	*** _mapType;
	*** _propertyBasedCreator;
	*** _valueDeserializer;
	*** _valueInstantiator;
	*** _valueTypeDeserializer;
	*** _deserializeUsingCreator(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _readAndBind(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Map);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Map);
	*** getMapClass();
	*** setIgnorableProperties(java.lang.String[]);
	*** wrapAndThrow(java.lang.Throwable,java.lang.Object);
}

-keep class org.codehaus.jackson.map.deser.std.ObjectArrayDeserializer {
	*** _arrayType;
	*** _elementClass;
	*** _elementDeserializer;
	*** _elementTypeDeserializer;
	*** _untyped;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeFromBase64(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers {
	*** _allDeserializers;
	*** instance;
	*** add(java.lang.Class,org.codehaus.jackson.map.JsonDeserializer);
	*** getAll();
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$Base {
	org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$Base(java.lang.Class);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$BooleanDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$ByteDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$CharDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$DoubleDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$FloatDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$IntDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$LongDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$ShortDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.PrimitiveArrayDeserializers$StringDeser {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer {
	*** _valueClass;
	org.codehaus.jackson.map.deser.std.StdDeserializer(java.lang.Class);
	org.codehaus.jackson.map.deser.std.StdDeserializer(org.codehaus.jackson.type.JavaType);
	*** _parseBoolean(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseBooleanFromNumber(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseBooleanPrimitive(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseByte(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseDate(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseDouble(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseDoublePrimitive(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseFloat(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseFloatPrimitive(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseIntPrimitive(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseInteger(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseLong(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseLongPrimitive(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseShort(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** _parseShortPrimitive(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** findDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** getValueClass();
	*** handleUnknownProperty(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.lang.Object,java.lang.String);
	*** isDefaultSerializer(org.codehaus.jackson.map.JsonDeserializer);
	*** parseDouble(java.lang.String);
	*** reportUnknownProperty(org.codehaus.jackson.map.DeserializationContext,java.lang.Object,java.lang.String);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonParser$NumberType;
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$BigDecimalDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$BigIntegerDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$BooleanDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$ByteDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$CharacterDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$DoubleDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$FloatDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$IntegerDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$LongDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$NumberDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$PrimitiveOrWrapperDeserializer {
	*** _nullValue;
	org.codehaus.jackson.map.deser.std.StdDeserializer$PrimitiveOrWrapperDeserializer(java.lang.Class,java.lang.Object);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$ShortDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$SqlDateDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdDeserializer$StackTraceElementDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer {
	*** _keyClass;
	org.codehaus.jackson.map.deser.std.StdKeyDeserializer(java.lang.Class);
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
	*** _parseDouble(java.lang.String);
	*** _parseInt(java.lang.String);
	*** _parseLong(java.lang.String);
	*** getKeyClass();
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$BoolKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$ByteKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$CalendarKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$CharKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$DateKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$DoubleKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$EnumKD {
	*** _factory;
	*** _resolver;
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$FloatKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$IntKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$LongKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$ShortKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$StringCtorKeyDeserializer {
	*** _ctor;
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$StringFactoryKeyDeserializer {
	*** _factoryMethod;
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$StringKD {
	*** sObject;
	*** sString;
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
	*** forType(java.lang.Class);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializer$UuidKD {
	*** _parse(java.lang.String,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.StdKeyDeserializers {
	*** _keyDeserializers;
	*** add(org.codehaus.jackson.map.deser.std.StdKeyDeserializer);
	*** constructAll();
	*** constructEnumKeyDeserializer(org.codehaus.jackson.map.util.EnumResolver);
	*** constructEnumKeyDeserializer(org.codehaus.jackson.map.util.EnumResolver,org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** constructStringKeyDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
	*** findStringBasedKeyDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.deser.std.StdScalarDeserializer {
	org.codehaus.jackson.map.deser.std.StdScalarDeserializer(java.lang.Class);
}

-keep class org.codehaus.jackson.map.deser.std.StdValueInstantiator {
	*** _cfgEmptyStringsAsObjects;
	*** _constructorArguments;
	*** _defaultCreator;
	*** _delegateCreator;
	*** _delegateType;
	*** _fromBooleanCreator;
	*** _fromDoubleCreator;
	*** _fromIntCreator;
	*** _fromLongCreator;
	*** _fromStringCreator;
	*** _valueTypeDesc;
	*** _withArgsCreator;
	*** _createFromStringFallbacks(java.lang.String);
	*** configureFromBooleanCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** configureFromDoubleCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** configureFromIntCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** configureFromLongCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** configureFromObjectSettings(org.codehaus.jackson.map.introspect.AnnotatedWithParams,org.codehaus.jackson.map.introspect.AnnotatedWithParams,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.AnnotatedWithParams,org.codehaus.jackson.map.deser.impl.CreatorProperty[]);
	*** configureFromStringCreator(org.codehaus.jackson.map.introspect.AnnotatedWithParams);
	*** createFromBoolean(boolean);
	*** getValueTypeDesc();
	*** wrapException(java.lang.Throwable);
}

-keep class org.codehaus.jackson.map.deser.std.StringCollectionDeserializer {
	*** _collectionType;
	*** _delegateDeserializer;
	*** _isDefaultDeserializer;
	*** _valueDeserializer;
	*** _valueInstantiator;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Collection);
	*** deserializeUsingCustom(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Collection);
	*** handleNonArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,java.util.Collection);
}

-keep class org.codehaus.jackson.map.deser.std.StringDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** deserializeWithType(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext,org.codehaus.jackson.map.TypeDeserializer);
}

-keep class org.codehaus.jackson.map.deser.std.TimestampDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.TokenBufferDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.UntypedObjectDeserializer {
	*** NO_OBJECTS;
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** mapArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** mapArrayToArray(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
	*** mapObject(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.codehaus.jackson.map.deser.std.UntypedObjectDeserializer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.map.exc.UnrecognizedPropertyException {
	*** _referringClass;
	*** _unrecognizedPropertyName;
	*** from(org.codehaus.jackson.JsonParser,java.lang.Object,java.lang.String);
}

-keep class org.codehaus.jackson.map.ext.OptionalHandlerFactory {
	*** instance;
	*** doesImplement(java.lang.Class,java.lang.String);
	*** findDeserializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.map.DeserializerProvider);
	*** findSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType);
	*** hasInterface(java.lang.Class,java.lang.String);
	*** hasInterfaceStartingWith(java.lang.Class,java.lang.String);
	*** hasSupertypeStartingWith(java.lang.Class,java.lang.String);
	*** instantiate(java.lang.String);
}

-keep class org.codehaus.jackson.map.introspect.Annotated {
	org.codehaus.jackson.map.introspect.Annotated();
	*** getAllAnnotations();
	*** getAnnotated();
	*** getAnnotation(java.lang.Class);
	*** getGenericType();
	*** getModifiers();
	*** getName();
	*** getRawType();
	*** getType(org.codehaus.jackson.map.type.TypeBindings);
	*** hasAnnotation(java.lang.Class);
	*** withAnnotations(org.codehaus.jackson.map.introspect.AnnotationMap);
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedClass {
	*** NO_ANNOTATION_MAPS;
	*** _annotationIntrospector;
	*** _class;
	*** _classAnnotations;
	*** _constructors;
	*** _creatorMethods;
	*** _defaultConstructor;
	*** _fields;
	*** _memberMethods;
	*** _mixInResolver;
	*** _primaryMixIn;
	*** _superTypes;
	*** _addClassMixIns(org.codehaus.jackson.map.introspect.AnnotationMap,java.lang.Class);
	*** _addClassMixIns(org.codehaus.jackson.map.introspect.AnnotationMap,java.lang.Class,java.lang.Class);
	*** _addConstructorMixIns(java.lang.Class);
	*** _addFactoryMixIns(java.lang.Class);
	*** _addFieldMixIns(java.lang.Class,java.lang.Class,java.util.Map);
	*** _addFields(java.util.Map,java.lang.Class);
	*** _addMemberMethods(java.lang.Class,org.codehaus.jackson.map.introspect.MethodFilter,org.codehaus.jackson.map.introspect.AnnotatedMethodMap,java.lang.Class,org.codehaus.jackson.map.introspect.AnnotatedMethodMap);
	*** _addMethodMixIns(java.lang.Class,org.codehaus.jackson.map.introspect.MethodFilter,org.codehaus.jackson.map.introspect.AnnotatedMethodMap,java.lang.Class,org.codehaus.jackson.map.introspect.AnnotatedMethodMap);
	*** _addMixOvers(java.lang.reflect.Constructor,org.codehaus.jackson.map.introspect.AnnotatedConstructor,boolean);
	*** _addMixOvers(java.lang.reflect.Method,org.codehaus.jackson.map.introspect.AnnotatedMethod,boolean);
	*** _addMixUnders(java.lang.reflect.Method,org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** _collectRelevantAnnotations(java.lang.annotation.Annotation[]);
	*** _collectRelevantAnnotations(java.lang.annotation.Annotation[][]);
	*** _constructConstructor(java.lang.reflect.Constructor,boolean);
	*** _constructCreatorMethod(java.lang.reflect.Method);
	*** _constructField(java.lang.reflect.Field);
	*** _constructMethod(java.lang.reflect.Method);
	*** _emptyAnnotationMap();
	*** _emptyAnnotationMaps(int);
	*** _isIncludableField(java.lang.reflect.Field);
	*** _isIncludableMethod(java.lang.reflect.Method,org.codehaus.jackson.map.introspect.MethodFilter);
	*** construct(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** constructWithoutSuperTypes(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** fields();
	*** findMethod(java.lang.String,java.lang.Class[]);
	*** getAnnotated();
	*** getAnnotation(java.lang.Class);
	*** getAnnotations();
	*** getConstructors();
	*** getDefaultConstructor();
	*** getRawType();
	*** getStaticMethods();
	*** hasAnnotations();
	*** memberMethods();
	*** resolveClassAnnotations();
	*** resolveCreators(boolean);
	*** resolveFields();
	*** resolveMemberMethods(org.codehaus.jackson.map.introspect.MethodFilter);
	*** withAnnotations(org.codehaus.jackson.map.introspect.AnnotationMap);
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedConstructor {
	*** _constructor;
	*** getAnnotated();
	*** getDeclaringClass();
	*** getName();
	*** getParameterClass(int);
	*** getParameterCount();
	*** getRawType();
	*** withAnnotations(org.codehaus.jackson.map.introspect.AnnotationMap);
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedField {
	*** _field;
	*** addOrOverride(java.lang.annotation.Annotation);
	*** getAnnotated();
	*** getAnnotation(java.lang.Class);
	*** getDeclaringClass();
	*** getFullName();
	*** getGenericType();
	*** getName();
	*** getRawType();
	*** withAnnotations(org.codehaus.jackson.map.introspect.AnnotationMap);
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedMember {
	*** _annotations;
	org.codehaus.jackson.map.introspect.AnnotatedMember(org.codehaus.jackson.map.introspect.AnnotationMap);
	*** fixAccess();
	*** getAllAnnotations();
	*** getDeclaringClass();
	*** getMember();
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedMethod {
	*** _method;
	*** _paramTypes;
	*** call1(java.lang.Object);
	*** getAnnotated();
	*** getDeclaringClass();
	*** getFullName();
	*** getMember();
	*** getName();
	*** getParameterClass(int);
	*** getParameterClasses();
	*** getParameterCount();
	*** getParameterType(int);
	*** getParameterTypes();
	*** getRawType();
	*** getType(org.codehaus.jackson.map.type.TypeBindings);
	*** withAnnotations(org.codehaus.jackson.map.introspect.AnnotationMap);
	*** withMethod(java.lang.reflect.Method);
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedMethodMap {
	*** _methods;
	*** add(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** find(java.lang.String,java.lang.Class[]);
	*** find(java.lang.reflect.Method);
	*** isEmpty();
	*** iterator();
	*** remove(java.lang.reflect.Method);
	*** size();
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedParameter {
	*** _index;
	*** _owner;
	*** _type;
	*** getAnnotation(java.lang.Class);
	*** getDeclaringClass();
	*** getIndex();
	*** getOwner();
	*** getParameterType();
	*** withAnnotations(org.codehaus.jackson.map.introspect.AnnotationMap);
}

-keep class org.codehaus.jackson.map.introspect.AnnotatedWithParams {
	*** _paramAnnotations;
	org.codehaus.jackson.map.introspect.AnnotatedWithParams(org.codehaus.jackson.map.introspect.AnnotationMap,org.codehaus.jackson.map.introspect.AnnotationMap[]);
	*** addIfNotPresent(java.lang.annotation.Annotation);
	*** addOrOverride(java.lang.annotation.Annotation);
	*** addOrOverrideParam(int,java.lang.annotation.Annotation);
	*** call();
	*** call(java.lang.Object[]);
	*** call1(java.lang.Object);
	*** getAnnotation(java.lang.Class);
	*** getParameter(int);
	*** getParameterCount();
	*** getParameterType(int);
	*** getType(org.codehaus.jackson.map.type.TypeBindings,java.lang.reflect.TypeVariable[]);
	*** replaceParameterAnnotations(int,org.codehaus.jackson.map.introspect.AnnotationMap);
}

-keep class org.codehaus.jackson.map.introspect.AnnotationMap {
	*** _annotations;
	*** _add(java.lang.annotation.Annotation);
	*** add(java.lang.annotation.Annotation);
	*** addIfNotPresent(java.lang.annotation.Annotation);
	*** get(java.lang.Class);
	*** merge(org.codehaus.jackson.map.introspect.AnnotationMap,org.codehaus.jackson.map.introspect.AnnotationMap);
	*** size();
}

-keep class org.codehaus.jackson.map.introspect.BasicBeanDescription {
	*** _annotationIntrospector;
	*** _anyGetterMethod;
	*** _anySetterMethod;
	*** _bindings;
	*** _classInfo;
	*** _config;
	*** _ignoredPropertyNames;
	*** _ignoredPropertyNamesForDeser;
	*** _injectables;
	*** _jsonValueMethod;
	*** _properties;
	org.codehaus.jackson.map.introspect.BasicBeanDescription(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.AnnotatedClass,java.util.List);
	*** _findPropertyFields(java.util.Collection,boolean);
	*** bindingsForBeanType();
	*** findAnyGetter();
	*** findAnySetter();
	*** findBackReferenceProperties();
	*** findDefaultConstructor();
	*** findFactoryMethod(java.lang.Class[]);
	*** findInjectables();
	*** findJsonValueMethod();
	*** findMethod(java.lang.String,java.lang.Class[]);
	*** findProperties();
	*** findSerializableFields(org.codehaus.jackson.map.introspect.VisibilityChecker,java.util.Collection);
	*** findSerializationInclusion(org.codehaus.jackson.map.annotate.JsonSerialize$Inclusion);
	*** findSingleArgConstructor(java.lang.Class[]);
	*** forDeserialization(org.codehaus.jackson.map.introspect.POJOPropertiesCollector);
	*** forOtherUse(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.AnnotatedClass);
	*** forSerialization(org.codehaus.jackson.map.introspect.POJOPropertiesCollector);
	*** getClassAnnotations();
	*** getClassInfo();
	*** getConstructors();
	*** getFactoryMethods();
	*** getIgnoredPropertyNames();
	*** getIgnoredPropertyNamesForDeser();
	*** hasKnownClassAnnotations();
	*** instantiateBean(boolean);
	*** isFactoryMethod(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** resolveType(java.lang.reflect.Type);
}

-keep class org.codehaus.jackson.map.introspect.BasicClassIntrospector {
	*** BOOLEAN_DESC;
	*** DEFAULT_GETTER_FILTER;
	*** DEFAULT_SETTER_AND_GETTER_FILTER;
	*** DEFAULT_SETTER_FILTER;
	*** INT_DESC;
	*** LONG_DESC;
	*** MINIMAL_FILTER;
	*** STRING_DESC;
	*** instance;
	*** _findCachedDesc(org.codehaus.jackson.type.JavaType);
	*** classWithCreators(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** collectProperties(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver,boolean);
	*** constructPropertyCollector(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.AnnotatedClass,org.codehaus.jackson.type.JavaType,boolean);
	*** forClassAnnotations(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forCreation(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forDeserialization(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forDirectClassAnnotations(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
	*** forSerialization(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ClassIntrospector$MixInResolver);
}

-keep class org.codehaus.jackson.map.introspect.BasicClassIntrospector$GetterMethodFilter {
	org.codehaus.jackson.map.introspect.BasicClassIntrospector$GetterMethodFilter();
}

-keep class org.codehaus.jackson.map.introspect.BasicClassIntrospector$MinimalMethodFilter {
	org.codehaus.jackson.map.introspect.BasicClassIntrospector$MinimalMethodFilter();
}

-keep class org.codehaus.jackson.map.introspect.BasicClassIntrospector$SetterMethodFilter {
	org.codehaus.jackson.map.introspect.BasicClassIntrospector$SetterMethodFilter();
	*** includeMethod(java.lang.reflect.Method);
}

-keep class org.codehaus.jackson.map.introspect.JacksonAnnotationIntrospector {
	*** _constructNoTypeResolverBuilder();
	*** _constructStdTypeResolverBuilder();
	*** _findTypeResolver(org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType);
	*** _isIgnorable(org.codehaus.jackson.map.introspect.Annotated);
	*** findDeserializer(org.codehaus.jackson.map.introspect.Annotated);
}

-keep class org.codehaus.jackson.map.introspect.MemberKey {
	*** NO_CLASSES;
	*** _argTypes;
	*** _name;
	org.codehaus.jackson.map.introspect.MemberKey(java.lang.String,java.lang.Class[]);
	*** equals(java.lang.Object);
}

-keep class org.codehaus.jackson.map.introspect.MethodFilter {
	*** includeMethod(java.lang.reflect.Method);
}

-keep class org.codehaus.jackson.map.introspect.NopAnnotationIntrospector {
	*** instance;
}

-keep class org.codehaus.jackson.map.introspect.POJOPropertiesCollector {
	*** _annotationIntrospector;
	*** _anyGetters;
	*** _anySetters;
	*** _classDef;
	*** _config;
	*** _creatorProperties;
	*** _forSerialization;
	*** _ignoredPropertyNames;
	*** _ignoredPropertyNamesForDeser;
	*** _injectables;
	*** _jsonValueGetters;
	*** _properties;
	*** _type;
	*** _visibilityChecker;
	*** _addCreators();
	*** _addFields();
	*** _addIgnored(org.codehaus.jackson.map.introspect.POJOPropertyBuilder);
	*** _addInjectables();
	*** _addMethods();
	*** _doAddInjectable(java.lang.Object,org.codehaus.jackson.map.introspect.AnnotatedMember);
	*** _property(java.lang.String);
	*** _removeUnwantedProperties();
	*** _renameProperties();
	*** _renameUsing(org.codehaus.jackson.map.PropertyNamingStrategy);
	*** _sortProperties();
	*** addToSet(java.util.Set,java.lang.String);
	*** collect();
	*** getAnyGetterMethod();
	*** getAnySetterMethod();
	*** getClassDef();
	*** getConfig();
	*** getIgnoredPropertyNames();
	*** getIgnoredPropertyNamesForDeser();
	*** getInjectables();
	*** getJsonValueMethod();
	*** getProperties();
	*** getType();
	*** reportProblem(java.lang.String);
}

-keep class org.codehaus.jackson.map.introspect.POJOPropertyBuilder {
	*** _ctorParameters;
	*** _fields;
	*** _getters;
	*** _internalName;
	*** _name;
	*** _setters;
	*** _anyExplicitNames(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** _anyIgnorals(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** _anyVisible(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** _mergeAnnotations(int,org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node[]);
	*** _removeIgnored(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** _removeNonVisible(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** _trimByVisibility(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** addAll(org.codehaus.jackson.map.introspect.POJOPropertyBuilder);
	*** addCtor(org.codehaus.jackson.map.introspect.AnnotatedParameter,java.lang.String,boolean,boolean);
	*** addField(org.codehaus.jackson.map.introspect.AnnotatedField,java.lang.String,boolean,boolean);
	*** addGetter(org.codehaus.jackson.map.introspect.AnnotatedMethod,java.lang.String,boolean,boolean);
	*** addSetter(org.codehaus.jackson.map.introspect.AnnotatedMethod,java.lang.String,boolean,boolean);
	*** anyDeserializeIgnorals();
	*** anyExplicitNames();
	*** anyIgnorals();
	*** anyVisible();
	*** compareTo(org.codehaus.jackson.map.introspect.POJOPropertyBuilder);
	*** findNewName();
	*** findRenamed(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node,org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** getConstructorParameter();
	*** getField();
	*** getGetter();
	*** getInternalName();
	*** getName();
	*** getSetter();
	*** hasConstructorParameter();
	*** hasField();
	*** hasGetter();
	*** hasSetter();
	*** merge(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node,org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** mergeAnnotations(boolean);
	*** removeIgnored();
	*** removeNonVisible();
	*** trimByVisibility();
	*** withName(java.lang.String);
}

-keep class org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node {
	*** explicitName;
	*** isMarkedIgnored;
	*** isVisible;
	*** next;
	*** value;
	*** access$000(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node,org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** append(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** toString();
	*** trimByVisibility();
	*** withNext(org.codehaus.jackson.map.introspect.POJOPropertyBuilder$Node);
	*** withValue(java.lang.Object);
	*** withoutIgnored();
	*** withoutNonVisible();
}

-keep class org.codehaus.jackson.map.introspect.VisibilityChecker {
	*** isCreatorVisible(org.codehaus.jackson.map.introspect.AnnotatedMember);
	*** isFieldVisible(org.codehaus.jackson.map.introspect.AnnotatedField);
	*** isGetterVisible(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** isIsGetterVisible(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** isSetterVisible(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** with(org.codehaus.jackson.annotate.JsonAutoDetect);
	*** withCreatorVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withFieldVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withGetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withIsGetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withSetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withVisibility(org.codehaus.jackson.annotate.JsonMethod,org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
}

-keep class org.codehaus.jackson.map.introspect.VisibilityChecker$1 {
	*** $SwitchMap$org$codehaus$jackson$annotate$JsonMethod;
}

-keep class org.codehaus.jackson.map.introspect.VisibilityChecker$Std {
	*** DEFAULT;
	*** _creatorMinLevel;
	*** _fieldMinLevel;
	*** _getterMinLevel;
	*** _isGetterMinLevel;
	*** _setterMinLevel;
	*** defaultInstance();
	*** hasMethod(org.codehaus.jackson.annotate.JsonMethod[],org.codehaus.jackson.annotate.JsonMethod);
	*** isCreatorVisible(java.lang.reflect.Member);
	*** isFieldVisible(java.lang.reflect.Field);
	*** isGetterVisible(java.lang.reflect.Method);
	*** isIsGetterVisible(java.lang.reflect.Method);
	*** isSetterVisible(java.lang.reflect.Method);
	*** with(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** with(org.codehaus.jackson.annotate.JsonAutoDetect);
	*** withCreatorVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withFieldVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withGetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withIsGetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withSetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
	*** withVisibility(org.codehaus.jackson.annotate.JsonMethod,org.codehaus.jackson.annotate.JsonAutoDetect$Visibility);
}

-keep class org.codehaus.jackson.map.jsontype.NamedType {
	*** getType();
	*** hasName();
}

-keep class org.codehaus.jackson.map.jsontype.SubtypeResolver {
	org.codehaus.jackson.map.jsontype.SubtypeResolver();
	*** collectAndResolveSubtypes(org.codehaus.jackson.map.introspect.AnnotatedClass,org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.AnnotationIntrospector);
	*** collectAndResolveSubtypes(org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.AnnotationIntrospector);
	*** registerSubtypes(java.lang.Class[]);
	*** registerSubtypes(org.codehaus.jackson.map.jsontype.NamedType[]);
}

-keep class org.codehaus.jackson.map.jsontype.TypeIdResolver {
	*** init(org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.jsontype.TypeResolverBuilder {
	*** buildTypeDeserializer(org.codehaus.jackson.map.DeserializationConfig,org.codehaus.jackson.type.JavaType,java.util.Collection,org.codehaus.jackson.map.BeanProperty);
	*** buildTypeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,java.util.Collection,org.codehaus.jackson.map.BeanProperty);
	*** defaultImpl(java.lang.Class);
	*** getDefaultImpl();
	*** inclusion(org.codehaus.jackson.annotate.JsonTypeInfo$As);
	*** init(org.codehaus.jackson.annotate.JsonTypeInfo$Id,org.codehaus.jackson.map.jsontype.TypeIdResolver);
	*** typeProperty(java.lang.String);
}

-keep class org.codehaus.jackson.map.jsontype.impl.StdSubtypeResolver {
	*** _registeredSubtypes;
	*** _collectAndResolve(org.codehaus.jackson.map.introspect.AnnotatedClass,org.codehaus.jackson.map.jsontype.NamedType,org.codehaus.jackson.map.MapperConfig,org.codehaus.jackson.map.AnnotationIntrospector,java.util.HashMap);
	*** registerSubtypes(org.codehaus.jackson.map.jsontype.NamedType[]);
}

-keep class org.codehaus.jackson.map.jsontype.impl.StdTypeResolverBuilder {
	*** noTypeInfoBuilder();
}

-keep class org.codehaus.jackson.map.ser.AnyGetterWriter {
	*** getAndSerialize(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** resolve(org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.BasicSerializerFactory {
	*** _arraySerializers;
	*** _concrete;
	*** _concreteLazy;
	*** optionalHandlers;
	org.codehaus.jackson.map.ser.BasicSerializerFactory();
	*** buildArraySerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.ArrayType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** buildCollectionLikeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.CollectionLikeType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** buildCollectionSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.CollectionType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** buildContainerSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean);
	*** buildEnumMapSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** buildEnumSetSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** buildIterableSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean);
	*** buildIteratorSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean);
	*** buildMapLikeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.MapLikeType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** buildMapSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.MapType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** createTypeSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** customSerializers();
	*** findContentSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.map.BeanProperty);
	*** findKeySerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.map.BeanProperty);
	*** findSerializerByAddonType(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean);
	*** findSerializerByLookup(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean);
	*** findSerializerByPrimaryType(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty,boolean);
	*** findSerializerFromAnnotation(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.map.BeanProperty);
	*** isIndexedList(java.lang.Class);
	*** modifySecondaryTypesByAnnotation(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType);
	*** modifyTypeByAnnotation(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.Annotated,org.codehaus.jackson.type.JavaType);
	*** usesStaticTyping(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.ser.BeanPropertyFilter {
	*** serializeAsField(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.ser.BeanPropertyWriter);
}

-keep class org.codehaus.jackson.map.ser.BeanPropertyWriter {
	*** _accessorMethod;
	*** _cfgSerializationType;
	*** _contextAnnotations;
	*** _declaredType;
	*** _dynamicSerializers;
	*** _field;
	*** _includeInViews;
	*** _internalSettings;
	*** _member;
	*** _name;
	*** _nonTrivialBaseType;
	*** _serializer;
	*** _suppressNulls;
	*** _suppressableValue;
	*** _typeSerializer;
	org.codehaus.jackson.map.ser.BeanPropertyWriter(org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.util.Annotations,org.codehaus.jackson.io.SerializedString,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.type.JavaType,java.lang.reflect.Method,java.lang.reflect.Field,boolean,java.lang.Object);
	org.codehaus.jackson.map.ser.BeanPropertyWriter(org.codehaus.jackson.map.ser.BeanPropertyWriter);
	org.codehaus.jackson.map.ser.BeanPropertyWriter(org.codehaus.jackson.map.ser.BeanPropertyWriter,org.codehaus.jackson.map.JsonSerializer);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,java.lang.Class,org.codehaus.jackson.map.SerializerProvider);
	*** _reportSelfReference(java.lang.Object);
	*** get(java.lang.Object);
	*** getGenericPropertyType();
	*** getName();
	*** getPropertyType();
	*** getRawSerializationType();
	*** getSerializationType();
	*** getSerializer();
	*** getViews();
	*** hasSerializer();
	*** serializeAsField(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** setNonTrivialBaseType(org.codehaus.jackson.type.JavaType);
	*** setViews(java.lang.Class[]);
	*** unwrappingWriter();
	*** withSerializer(org.codehaus.jackson.map.JsonSerializer);
}

-keep class org.codehaus.jackson.map.ser.BeanSerializer {
	*** createDummy(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ser.BeanSerializerBuilder {
	*** NO_PROPERTIES;
	*** _anyGetter;
	*** _beanDesc;
	*** _filterId;
	*** _filteredProperties;
	*** _properties;
	*** build();
	*** createDummy();
	*** getProperties();
	*** setAnyGetter(org.codehaus.jackson.map.ser.AnyGetterWriter);
	*** setFilterId(java.lang.Object);
	*** setFilteredProperties(org.codehaus.jackson.map.ser.BeanPropertyWriter[]);
	*** setProperties(java.util.List);
}

-keep class org.codehaus.jackson.map.ser.BeanSerializerFactory {
	*** _factoryConfig;
	*** instance;
	*** _constructWriter(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.type.TypeBindings,org.codehaus.jackson.map.ser.PropertyBuilder,boolean,java.lang.String,org.codehaus.jackson.map.introspect.AnnotatedMember);
	*** constructBeanSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** constructBeanSerializerBuilder(org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** constructFilteredBeanWriter(org.codehaus.jackson.map.ser.BeanPropertyWriter,java.lang.Class[]);
	*** constructPropertyBuilder(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** filterBeanProperties(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.util.List);
	*** findBeanProperties(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** findBeanSerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.BeanProperty);
	*** findFilterId(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** findPropertyContentTypeSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.BeanProperty);
	*** findPropertyTypeSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.AnnotatedMember,org.codehaus.jackson.map.BeanProperty);
	*** isPotentialBeanType(java.lang.Class);
	*** processViews(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.ser.BeanSerializerBuilder);
	*** removeIgnorableTypes(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.util.List);
	*** removeSetterlessGetters(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.util.List);
	*** sortBeanProperties(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.util.List);
}

-keep class org.codehaus.jackson.map.ser.BeanSerializerFactory$ConfigImpl {
	*** NO_MODIFIERS;
	*** NO_SERIALIZERS;
	*** _additionalKeySerializers;
	*** _additionalSerializers;
	*** _modifiers;
	org.codehaus.jackson.map.ser.BeanSerializerFactory$ConfigImpl(org.codehaus.jackson.map.Serializers[],org.codehaus.jackson.map.Serializers[],org.codehaus.jackson.map.ser.BeanSerializerModifier[]);
}

-keep class org.codehaus.jackson.map.ser.BeanSerializerModifier {
	*** changeProperties(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.util.List);
	*** modifySerializer(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.JsonSerializer);
	*** orderProperties(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,java.util.List);
	*** updateBuilder(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription,org.codehaus.jackson.map.ser.BeanSerializerBuilder);
}

-keep class org.codehaus.jackson.map.ser.FilterProvider {
	*** findFilter(java.lang.Object);
}

-keep class org.codehaus.jackson.map.ser.FilteredBeanPropertyWriter {
	*** constructViewBased(org.codehaus.jackson.map.ser.BeanPropertyWriter,java.lang.Class[]);
}

-keep class org.codehaus.jackson.map.ser.FilteredBeanPropertyWriter$MultiView {
	*** _delegate;
	*** _views;
}

-keep class org.codehaus.jackson.map.ser.FilteredBeanPropertyWriter$SingleView {
	*** _delegate;
	*** _view;
}

-keep class org.codehaus.jackson.map.ser.PropertyBuilder {
	*** _annotationIntrospector;
	*** _beanDesc;
	*** _config;
	*** _defaultBean;
	*** _outputProps;
	*** _throwWrapped(java.lang.Exception,java.lang.String,java.lang.Object);
	*** buildWriter(java.lang.String,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.introspect.AnnotatedMember,boolean);
	*** findSerializationType(org.codehaus.jackson.map.introspect.Annotated,boolean,org.codehaus.jackson.type.JavaType);
	*** getClassAnnotations();
	*** getContainerValueChecker(java.lang.String,org.codehaus.jackson.type.JavaType);
	*** getDefaultBean();
	*** getDefaultValue(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Field);
	*** getEmptyValueChecker(java.lang.String,org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.ser.PropertyBuilder$1 {
	*** $SwitchMap$org$codehaus$jackson$map$annotate$JsonSerialize$Inclusion;
}

-keep class org.codehaus.jackson.map.ser.SerializerBase {
	org.codehaus.jackson.map.ser.SerializerBase(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ser.StdSerializerProvider {
	*** DEFAULT_KEY_SERIALIZER;
	*** DEFAULT_NULL_KEY_SERIALIZER;
	*** DEFAULT_UNKNOWN_SERIALIZER;
	*** _dateFormat;
	*** _keySerializer;
	*** _knownSerializers;
	*** _nullKeySerializer;
	*** _nullValueSerializer;
	*** _rootNames;
	*** _serializerCache;
	*** _serializerFactory;
	*** _unknownTypeSerializer;
	*** _createAndCacheUntypedSerializer(java.lang.Class,org.codehaus.jackson.map.BeanProperty);
	*** _createAndCacheUntypedSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** _createUntypedSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** _findExplicitUntypedSerializer(java.lang.Class,org.codehaus.jackson.map.BeanProperty);
	*** _handleContextualResolvable(org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.BeanProperty);
	*** _reportIncompatibleRootType(java.lang.Object,org.codehaus.jackson.type.JavaType);
	*** _serializeValue(org.codehaus.jackson.JsonGenerator,java.lang.Object);
	*** _serializeValue(org.codehaus.jackson.JsonGenerator,java.lang.Object,org.codehaus.jackson.type.JavaType);
	*** createInstance(org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.SerializerFactory);
	*** findTypedValueSerializer(java.lang.Class,boolean,org.codehaus.jackson.map.BeanProperty);
	*** findTypedValueSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.BeanProperty);
	*** findValueSerializer(java.lang.Class,org.codehaus.jackson.map.BeanProperty);
	*** findValueSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** getNullValueSerializer();
	*** getUnknownTypeSerializer(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ser.StdSerializerProvider$WrappedSerializer {
	*** _serializer;
	*** _typeSerializer;
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$BooleanSerializer {
	*** _forPrimitive;
	*** serialize(java.lang.Boolean,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$DoubleSerializer {
	*** instance;
	*** serialize(java.lang.Double,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$FloatSerializer {
	*** instance;
	*** serialize(java.lang.Float,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$IntLikeSerializer {
	*** instance;
	*** serialize(java.lang.Number,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$IntegerSerializer {
	*** serialize(java.lang.Integer,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$LongSerializer {
	*** instance;
	*** serialize(java.lang.Long,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$NumberSerializer {
	*** instance;
	*** serialize(java.lang.Number,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$SqlDateSerializer {
	*** serialize(java.sql.Date,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.StdSerializers$SqlTimeSerializer {
	*** serialize(java.sql.Time,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.impl.FailingSerializer {
	*** _msg;
}

-keep class org.codehaus.jackson.map.ser.impl.JsonSerializerMap {
	*** _buckets;
	*** _size;
	*** find(org.codehaus.jackson.map.ser.impl.SerializerCache$TypeKey);
	*** findSize(int);
}

-keep class org.codehaus.jackson.map.ser.impl.JsonSerializerMap$Bucket {
	*** key;
	*** next;
	*** value;
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap {
	org.codehaus.jackson.map.ser.impl.PropertySerializerMap();
	*** emptyMap();
	*** findAndAddSerializer(java.lang.Class,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.BeanProperty);
	*** findAndAddSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.BeanProperty);
	*** newWith(java.lang.Class,org.codehaus.jackson.map.JsonSerializer);
	*** serializerFor(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap$Double {
	*** _serializer1;
	*** _serializer2;
	*** _type1;
	*** _type2;
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap$Empty {
	*** instance;
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap$Multi {
	*** _entries;
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap$SerializerAndMapResult {
	*** map;
	*** serializer;
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap$Single {
	*** _serializer;
	*** _type;
}

-keep class org.codehaus.jackson.map.ser.impl.PropertySerializerMap$TypeAndSerializer {
	*** serializer;
	*** type;
}

-keep class org.codehaus.jackson.map.ser.impl.ReadOnlyClassToSerializerMap {
	*** _cacheKey;
	*** _map;
	*** from(java.util.HashMap);
	*** instance();
	*** typedValueSerializer(java.lang.Class);
	*** typedValueSerializer(org.codehaus.jackson.type.JavaType);
	*** untypedValueSerializer(java.lang.Class);
	*** untypedValueSerializer(org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.ser.impl.SerializerCache {
	*** _readOnlyMap;
	*** _sharedMap;
	*** addAndResolveNonTypedSerializer(java.lang.Class,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.SerializerProvider);
	*** addAndResolveNonTypedSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.SerializerProvider);
	*** addTypedSerializer(java.lang.Class,org.codehaus.jackson.map.JsonSerializer);
	*** addTypedSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.JsonSerializer);
	*** flush();
	*** getReadOnlyLookupMap();
	*** size();
	*** typedValueSerializer(java.lang.Class);
	*** typedValueSerializer(org.codehaus.jackson.type.JavaType);
	*** untypedValueSerializer(java.lang.Class);
	*** untypedValueSerializer(org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.ser.impl.SerializerCache$TypeKey {
	*** _class;
	*** _hashCode;
	*** _isTyped;
	*** _type;
	*** equals(java.lang.Object);
	*** hash(java.lang.Class,boolean);
	*** hash(org.codehaus.jackson.type.JavaType,boolean);
	*** hashCode();
	*** resetTyped(java.lang.Class);
	*** resetTyped(org.codehaus.jackson.type.JavaType);
	*** resetUntyped(java.lang.Class);
	*** resetUntyped(org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.ser.impl.UnknownSerializer {
	*** failForEmpty(java.lang.Object);
}

-keep class org.codehaus.jackson.map.ser.impl.UnwrappingBeanPropertyWriter {
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,java.lang.Class,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.AsArraySerializerBase {
	*** _dynamicSerializers;
	*** _elementSerializer;
	*** _elementType;
	*** _property;
	*** _staticTyping;
	*** _valueTypeSerializer;
	org.codehaus.jackson.map.ser.std.AsArraySerializerBase(java.lang.Class,org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,java.lang.Class,org.codehaus.jackson.map.SerializerProvider);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContents(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.BeanSerializerBase {
	*** NO_PROPS;
	*** _anyGetterWriter;
	*** _filteredProps;
	*** _propertyFilterId;
	*** _props;
	org.codehaus.jackson.map.ser.std.BeanSerializerBase(java.lang.Class,org.codehaus.jackson.map.ser.BeanPropertyWriter[],org.codehaus.jackson.map.ser.BeanPropertyWriter[],org.codehaus.jackson.map.ser.AnyGetterWriter,java.lang.Object);
	org.codehaus.jackson.map.ser.std.BeanSerializerBase(org.codehaus.jackson.map.ser.std.BeanSerializerBase);
	org.codehaus.jackson.map.ser.std.BeanSerializerBase(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.ser.BeanPropertyWriter[],org.codehaus.jackson.map.ser.BeanPropertyWriter[],org.codehaus.jackson.map.ser.AnyGetterWriter,java.lang.Object);
	*** findFilter(org.codehaus.jackson.map.SerializerProvider);
	*** serializeFields(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeFieldsFiltered(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.CalendarSerializer {
	*** instance;
	*** serialize(java.util.Calendar,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.CollectionSerializer {
	*** serializeContents(java.util.Collection,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContentsUsing(java.util.Collection,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.JsonSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.ContainerSerializerBase {
	org.codehaus.jackson.map.ser.std.ContainerSerializerBase(java.lang.Class);
	org.codehaus.jackson.map.ser.std.ContainerSerializerBase(java.lang.Class,boolean);
	*** _withValueTypeSerializer(org.codehaus.jackson.map.TypeSerializer);
	*** withValueTypeSerializer(org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.DateSerializer {
	*** instance;
	*** serialize(java.util.Date,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.EnumMapSerializer {
	*** _keyEnums;
	*** _property;
	*** _staticTyping;
	*** _valueSerializer;
	*** _valueType;
	*** _valueTypeSerializer;
	org.codehaus.jackson.map.ser.std.EnumMapSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.util.EnumValues,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** serialize(java.util.EnumMap,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContents(java.util.EnumMap,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContentsUsing(java.util.EnumMap,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.JsonSerializer);
	*** serializeWithType(java.util.EnumMap,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.EnumSerializer {
	*** _values;
	*** construct(java.lang.Class,org.codehaus.jackson.map.SerializationConfig,org.codehaus.jackson.map.introspect.BasicBeanDescription);
	*** getEnumValues();
	*** serialize(java.lang.Enum,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.EnumSetSerializer {
	*** serializeContents(java.util.EnumSet,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.IndexedStringListSerializer {
	*** _serializer;
	org.codehaus.jackson.map.ser.std.IndexedStringListSerializer(org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** serialize(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContents(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeUsingCustom(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.InetAddressSerializer {
	*** instance;
	*** serialize(java.net.InetAddress,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(java.net.InetAddress,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.IterableSerializer {
	*** serializeContents(java.lang.Iterable,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.JsonValueSerializer {
	*** _accessorMethod;
	*** _forceTypeInformation;
	*** _property;
	*** _valueSerializer;
	*** isNaturalTypeWithStdHandling(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.JsonSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.MapSerializer {
	*** UNSPECIFIED_TYPE;
	*** _dynamicValueSerializers;
	*** _ignoredEntries;
	*** _keySerializer;
	*** _keyType;
	*** _property;
	*** _valueSerializer;
	*** _valueType;
	*** _valueTypeIsStatic;
	*** _valueTypeSerializer;
	org.codehaus.jackson.map.ser.std.MapSerializer(java.util.HashSet,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.BeanProperty);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,java.lang.Class,org.codehaus.jackson.map.SerializerProvider);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializerProvider);
	*** construct(java.lang.String[],org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer,org.codehaus.jackson.map.JsonSerializer);
	*** serialize(java.util.Map,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeFields(java.util.Map,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeFieldsUsing(java.util.Map,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.JsonSerializer);
	*** serializeTypedFields(java.util.Map,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(java.util.Map,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
	*** toSet(java.lang.String[]);
}

-keep class org.codehaus.jackson.map.ser.std.NonTypedScalarSerializerBase {
	org.codehaus.jackson.map.ser.std.NonTypedScalarSerializerBase(java.lang.Class);
}

-keep class org.codehaus.jackson.map.ser.std.NullSerializer {
	*** instance;
}

-keep class org.codehaus.jackson.map.ser.std.ObjectArraySerializer {
	*** _dynamicSerializers;
	*** _elementSerializer;
	*** _elementType;
	*** _staticTyping;
	org.codehaus.jackson.map.ser.std.ObjectArraySerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,java.lang.Class,org.codehaus.jackson.map.SerializerProvider);
	*** _findAndAddDynamic(org.codehaus.jackson.map.ser.impl.PropertySerializerMap,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContents(java.lang.Object[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContentsUsing(java.lang.Object[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.JsonSerializer);
	*** serializeTypedContents(java.lang.Object[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.ScalarSerializerBase {
	org.codehaus.jackson.map.ser.std.ScalarSerializerBase(java.lang.Class);
	org.codehaus.jackson.map.ser.std.ScalarSerializerBase(java.lang.Class,boolean);
}

-keep class org.codehaus.jackson.map.ser.std.SerializableSerializer {
	*** instance;
	*** serialize(org.codehaus.jackson.map.JsonSerializable,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(org.codehaus.jackson.map.JsonSerializable,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.SerializableWithTypeSerializer {
	*** instance;
	*** serialize(org.codehaus.jackson.map.JsonSerializableWithType,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(org.codehaus.jackson.map.JsonSerializableWithType,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.SerializerBase {
	*** _handledType;
	org.codehaus.jackson.map.ser.std.SerializerBase(java.lang.Class);
	org.codehaus.jackson.map.ser.std.SerializerBase(java.lang.Class,boolean);
	org.codehaus.jackson.map.ser.std.SerializerBase(org.codehaus.jackson.type.JavaType);
	*** createObjectNode();
	*** createSchemaNode(java.lang.String);
	*** createSchemaNode(java.lang.String,boolean);
	*** handledType();
	*** isDefaultSerializer(org.codehaus.jackson.map.JsonSerializer);
	*** serialize(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** wrapAndThrow(org.codehaus.jackson.map.SerializerProvider,java.lang.Throwable,java.lang.Object,int);
	*** wrapAndThrow(org.codehaus.jackson.map.SerializerProvider,java.lang.Throwable,java.lang.Object,java.lang.String);
}

-keep class org.codehaus.jackson.map.ser.std.StaticListSerializerBase {
	*** _property;
	org.codehaus.jackson.map.ser.std.StaticListSerializerBase(java.lang.Class,org.codehaus.jackson.map.BeanProperty);
	*** contentSchema();
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$ArraySerializerBase {
	*** _property;
	*** _valueTypeSerializer;
	org.codehaus.jackson.map.ser.std.StdArraySerializers$ArraySerializerBase(java.lang.Class,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty);
	*** serializeContents(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$BooleanArraySerializer {
	*** serializeContents(boolean[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$ByteArraySerializer {
	*** serialize(byte[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(byte[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$CharArraySerializer {
	*** _writeArrayContents(org.codehaus.jackson.JsonGenerator,char[]);
	*** serialize(char[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(char[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$DoubleArraySerializer {
	*** serializeContents(double[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$FloatArraySerializer {
	org.codehaus.jackson.map.ser.std.StdArraySerializers$FloatArraySerializer(org.codehaus.jackson.map.TypeSerializer);
	*** serializeContents(float[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$IntArraySerializer {
	*** serializeContents(int[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$LongArraySerializer {
	org.codehaus.jackson.map.ser.std.StdArraySerializers$LongArraySerializer(org.codehaus.jackson.map.TypeSerializer);
	*** serializeContents(long[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$ShortArraySerializer {
	org.codehaus.jackson.map.ser.std.StdArraySerializers$ShortArraySerializer(org.codehaus.jackson.map.TypeSerializer);
	*** serializeContents(short[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdArraySerializers$StringArraySerializer {
	*** _elementSerializer;
	*** serializeContents(java.lang.String[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContentsSlow(java.lang.String[],org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.JsonSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.StdContainerSerializers {
	*** collectionSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** enumSetSerializer(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.BeanProperty);
	*** indexedListSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** iterableSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty);
	*** iteratorSerializer(org.codehaus.jackson.type.JavaType,boolean,org.codehaus.jackson.map.TypeSerializer,org.codehaus.jackson.map.BeanProperty);
}

-keep class org.codehaus.jackson.map.ser.std.StdContainerSerializers$IndexedListSerializer {
	*** serializeContents(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContentsUsing(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.JsonSerializer);
	*** serializeTypedContents(java.util.List,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdContainerSerializers$IteratorSerializer {
	*** serializeContents(java.util.Iterator,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers {
	*** provide();
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers$AtomicBooleanSerializer {
	*** serialize(java.util.concurrent.atomic.AtomicBoolean,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers$AtomicIntegerSerializer {
	*** serialize(java.util.concurrent.atomic.AtomicInteger,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers$AtomicLongSerializer {
	*** serialize(java.util.concurrent.atomic.AtomicLong,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers$AtomicReferenceSerializer {
	*** serialize(java.util.concurrent.atomic.AtomicReference,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers$ClassSerializer {
	*** serialize(java.lang.Class,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdJdkSerializers$FileSerializer {
	*** serialize(java.io.File,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StdKeySerializer {
	*** instace;
}

-keep class org.codehaus.jackson.map.ser.std.StdKeySerializers {
	*** DEFAULT_KEY_SERIALIZER;
	*** DEFAULT_STRING_SERIALIZER;
	*** getStdKeySerializer(org.codehaus.jackson.type.JavaType);
}

-keep class org.codehaus.jackson.map.ser.std.StdKeySerializers$CalendarKeySerializer {
	*** instance;
}

-keep class org.codehaus.jackson.map.ser.std.StdKeySerializers$DateKeySerializer {
	*** instance;
}

-keep class org.codehaus.jackson.map.ser.std.StdKeySerializers$StringKeySerializer {
	*** serialize(java.lang.String,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.StringCollectionSerializer {
	*** _serializer;
	org.codehaus.jackson.map.ser.std.StringCollectionSerializer(org.codehaus.jackson.map.BeanProperty,org.codehaus.jackson.map.JsonSerializer);
	*** serialize(java.util.Collection,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeContents(java.util.Collection,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeUsingCustom(java.util.Collection,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(java.util.Collection,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.StringSerializer {
	*** serialize(java.lang.String,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.TimeZoneSerializer {
	*** instance;
	*** serialize(java.util.TimeZone,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(java.util.TimeZone,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.ser.std.ToStringSerializer {
	*** instance;
	*** serialize(java.lang.Object,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.map.ser.std.TokenBufferSerializer {
	*** serialize(org.codehaus.jackson.util.TokenBuffer,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** serializeWithType(org.codehaus.jackson.util.TokenBuffer,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider,org.codehaus.jackson.map.TypeSerializer);
}

-keep class org.codehaus.jackson.map.type.ArrayType {
	*** _componentType;
	*** _emptyArray;
	*** construct(org.codehaus.jackson.type.JavaType,java.lang.Object,java.lang.Object);
	*** getContentType();
	*** toString();
	*** withContentTypeHandler(java.lang.Object);
	*** withContentValueHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.map.type.ClassKey {
	*** _class;
	*** _className;
	*** _hashCode;
	*** compareTo(org.codehaus.jackson.map.type.ClassKey);
}

-keep class org.codehaus.jackson.map.type.CollectionLikeType {
	*** _elementType;
	org.codehaus.jackson.map.type.CollectionLikeType(java.lang.Class,org.codehaus.jackson.type.JavaType,java.lang.Object,java.lang.Object);
	*** construct(java.lang.Class,org.codehaus.jackson.type.JavaType);
	*** getContentType();
	*** isTrueCollectionType();
	*** withContentTypeHandler(java.lang.Object);
	*** withContentValueHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.map.type.CollectionType {
	*** construct(java.lang.Class,org.codehaus.jackson.type.JavaType);
	*** withContentTypeHandler(java.lang.Object);
	*** withContentValueHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.map.type.HierarchicType {
	*** _actualType;
	*** _genericType;
	*** _rawClass;
	*** _subType;
	*** _superType;
	*** asGeneric();
	*** deepCloneWithoutSubtype();
	*** getRawClass();
	*** getSubType();
	*** getSuperType();
	*** isGeneric();
	*** setSubType(org.codehaus.jackson.map.type.HierarchicType);
	*** setSuperType(org.codehaus.jackson.map.type.HierarchicType);
}

-keep class org.codehaus.jackson.map.type.MapLikeType {
	*** _keyType;
	*** _valueType;
	org.codehaus.jackson.map.type.MapLikeType(java.lang.Class,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.type.JavaType,java.lang.Object,java.lang.Object);
	*** construct(java.lang.Class,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.type.JavaType);
	*** getContentType();
	*** getKeyType();
	*** isTrueMapType();
	*** narrowKey(java.lang.Class);
	*** withContentTypeHandler(java.lang.Object);
	*** withContentValueHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.map.type.MapType {
	org.codehaus.jackson.map.type.MapType(java.lang.Class,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.type.JavaType,java.lang.Object,java.lang.Object);
	*** construct(java.lang.Class,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.type.JavaType);
	*** widenKey(java.lang.Class);
	*** withContentTypeHandler(java.lang.Object);
	*** withContentValueHandler(java.lang.Object);
	*** withKeyTypeHandler(java.lang.Object);
	*** withKeyValueHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.map.type.SimpleType {
	*** _typeNames;
	*** _typeParameters;
	org.codehaus.jackson.map.type.SimpleType(java.lang.Class,java.lang.String[],org.codehaus.jackson.type.JavaType[],java.lang.Object,java.lang.Object);
	*** buildCanonicalName();
	*** constructUnsafe(java.lang.Class);
	*** withContentValueHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.map.type.TypeBase {
	*** _canonicalName;
	org.codehaus.jackson.map.type.TypeBase(java.lang.Class,int,java.lang.Object,java.lang.Object);
	*** _classSignature(java.lang.Class,java.lang.StringBuilder,boolean);
	*** buildCanonicalName();
	*** serialize(org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
	*** toCanonical();
}

-keep class org.codehaus.jackson.map.type.TypeBindings {
	*** NO_TYPES;
	*** UNBOUND;
	*** _bindings;
	*** _contextClass;
	*** _contextType;
	*** _parentBindings;
	*** _placeholders;
	*** _typeFactory;
	org.codehaus.jackson.map.type.TypeBindings(org.codehaus.jackson.map.type.TypeFactory,org.codehaus.jackson.map.type.TypeBindings,java.lang.Class,org.codehaus.jackson.type.JavaType);
	*** _addPlaceholder(java.lang.String);
	*** _resolve();
	*** _resolveBindings(java.lang.reflect.Type);
	*** addBinding(java.lang.String,org.codehaus.jackson.type.JavaType);
	*** childInstance();
	*** findType(java.lang.String);
	*** resolveType(java.lang.reflect.Type);
	*** typesAsArray();
}

-keep class org.codehaus.jackson.map.type.TypeFactory {
	*** NO_TYPES;
	*** _cachedArrayListType;
	*** _cachedHashMapType;
	*** _modifiers;
	*** _parser;
	*** instance;
	*** _arrayListSuperInterfaceChain(org.codehaus.jackson.map.type.HierarchicType);
	*** _collectionType(java.lang.Class);
	*** _constructType(java.lang.reflect.Type,org.codehaus.jackson.map.type.TypeBindings);
	*** _doFindSuperInterfaceChain(org.codehaus.jackson.map.type.HierarchicType,java.lang.Class);
	*** _findSuperClassChain(java.lang.reflect.Type,java.lang.Class);
	*** _findSuperInterfaceChain(java.lang.reflect.Type,java.lang.Class);
	*** _findSuperTypeChain(java.lang.Class,java.lang.Class);
	*** _fromArrayType(java.lang.reflect.GenericArrayType,org.codehaus.jackson.map.type.TypeBindings);
	*** _fromClass(java.lang.Class,org.codehaus.jackson.map.type.TypeBindings);
	*** _fromParamType(java.lang.reflect.ParameterizedType,org.codehaus.jackson.map.type.TypeBindings);
	*** _fromParameterizedClass(java.lang.Class,java.util.List);
	*** _fromVariable(java.lang.reflect.TypeVariable,org.codehaus.jackson.map.type.TypeBindings);
	*** _fromWildcard(java.lang.reflect.WildcardType,org.codehaus.jackson.map.type.TypeBindings);
	*** _hashMapSuperInterfaceChain(org.codehaus.jackson.map.type.HierarchicType);
	*** _mapType(java.lang.Class);
	*** _resolveVariableViaSubTypes(org.codehaus.jackson.map.type.HierarchicType,java.lang.String,org.codehaus.jackson.map.type.TypeBindings);
	*** _unknownType();
	*** constructArrayType(org.codehaus.jackson.type.JavaType);
	*** constructCollectionType(java.lang.Class,org.codehaus.jackson.type.JavaType);
	*** constructFromCanonical(java.lang.String);
	*** constructMapType(java.lang.Class,org.codehaus.jackson.type.JavaType,org.codehaus.jackson.type.JavaType);
	*** constructParametricType(java.lang.Class,java.lang.Class[]);
	*** constructParametricType(java.lang.Class,org.codehaus.jackson.type.JavaType[]);
	*** constructSimpleType(java.lang.Class,org.codehaus.jackson.type.JavaType[]);
	*** constructSpecializedType(org.codehaus.jackson.type.JavaType,java.lang.Class);
	*** constructType(java.lang.reflect.Type);
	*** constructType(java.lang.reflect.Type,java.lang.Class);
	*** constructType(java.lang.reflect.Type,org.codehaus.jackson.map.type.TypeBindings);
	*** constructType(java.lang.reflect.Type,org.codehaus.jackson.type.JavaType);
	*** constructType(org.codehaus.jackson.type.TypeReference);
	*** defaultInstance();
	*** findTypeParameters(java.lang.Class,java.lang.Class);
	*** findTypeParameters(java.lang.Class,java.lang.Class,org.codehaus.jackson.map.type.TypeBindings);
	*** findTypeParameters(org.codehaus.jackson.type.JavaType,java.lang.Class);
	*** rawClass(java.lang.reflect.Type);
	*** type(java.lang.reflect.Type);
	*** uncheckedSimpleType(java.lang.Class);
	*** unknownType();
}

-keep class org.codehaus.jackson.map.type.TypeModifier {
	*** modifyType(org.codehaus.jackson.type.JavaType,java.lang.reflect.Type,org.codehaus.jackson.map.type.TypeBindings,org.codehaus.jackson.map.type.TypeFactory);
}

-keep class org.codehaus.jackson.map.type.TypeParser {
	*** _factory;
	*** _problem(org.codehaus.jackson.map.type.TypeParser$MyTokenizer,java.lang.String);
	*** findClass(java.lang.String,org.codehaus.jackson.map.type.TypeParser$MyTokenizer);
	*** parse(java.lang.String);
	*** parseType(org.codehaus.jackson.map.type.TypeParser$MyTokenizer);
	*** parseTypes(org.codehaus.jackson.map.type.TypeParser$MyTokenizer);
}

-keep class org.codehaus.jackson.map.type.TypeParser$MyTokenizer {
	*** getAllInput();
	*** getRemainingInput();
	*** hasMoreTokens();
	*** nextToken();
	*** pushBack(java.lang.String);
}

-keep class org.codehaus.jackson.map.util.Annotations {
	*** get(java.lang.Class);
}

-keep class org.codehaus.jackson.map.util.ArrayBuilders {
	*** _booleanBuilder;
	*** _byteBuilder;
	*** _doubleBuilder;
	*** _floatBuilder;
	*** _intBuilder;
	*** _longBuilder;
	*** _shortBuilder;
	*** arrayAsIterable(java.lang.Object[]);
	*** arrayToSet(java.lang.Object[]);
	*** getBooleanBuilder();
	*** getByteBuilder();
	*** getDoubleBuilder();
	*** getFloatBuilder();
	*** getIntBuilder();
	*** getLongBuilder();
	*** getShortBuilder();
	*** insertInListNoDup(java.lang.Object[],java.lang.Object);
}

-keep class org.codehaus.jackson.map.util.ArrayBuilders$ArrayIterator {
	*** _array;
	*** _index;
}

-keep class org.codehaus.jackson.map.util.BeanUtil {
	*** isCglibGetCallbacks(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** isGroovyMetaClassGetter(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** isGroovyMetaClassSetter(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** manglePropertyName(java.lang.String);
	*** okNameForGetter(org.codehaus.jackson.map.introspect.AnnotatedMethod);
	*** okNameForIsGetter(org.codehaus.jackson.map.introspect.AnnotatedMethod,java.lang.String);
	*** okNameForRegularGetter(org.codehaus.jackson.map.introspect.AnnotatedMethod,java.lang.String);
	*** okNameForSetter(org.codehaus.jackson.map.introspect.AnnotatedMethod);
}

-keep class org.codehaus.jackson.map.util.ClassUtil {
	*** _addSuperTypes(java.lang.Class,java.lang.Class,java.util.Collection,boolean);
	*** canBeABeanType(java.lang.Class);
	*** checkAndFixAccess(java.lang.reflect.Member);
	*** createInstance(java.lang.Class,boolean);
	*** findClass(java.lang.String);
	*** findConstructor(java.lang.Class,boolean);
	*** findEnumType(java.lang.Class);
	*** findEnumType(java.lang.Enum);
	*** findSuperTypes(java.lang.Class,java.lang.Class);
	*** findSuperTypes(java.lang.Class,java.lang.Class,java.util.List);
	*** getClassDescription(java.lang.Object);
	*** getOuterClass(java.lang.Class);
	*** getRootCause(java.lang.Throwable);
	*** hasGetterSignature(java.lang.reflect.Method);
	*** isCollectionMapOrArray(java.lang.Class);
	*** isConcrete(java.lang.Class);
	*** isLocalType(java.lang.Class,boolean);
	*** isProxyType(java.lang.Class);
	*** throwAsIAE(java.lang.Throwable);
	*** throwAsIAE(java.lang.Throwable,java.lang.String);
	*** unwrapAndThrowAsIAE(java.lang.Throwable);
	*** unwrapAndThrowAsIAE(java.lang.Throwable,java.lang.String);
	*** wrapperType(java.lang.Class);
}

-keep class org.codehaus.jackson.map.util.ClassUtil$EnumTypeLocator {
	*** instance;
	*** enumTypeFor(java.util.EnumMap);
	*** enumTypeFor(java.util.EnumSet);
}

-keep class org.codehaus.jackson.map.util.Comparators {
	*** getArrayComparator(java.lang.Object);
}

-keep class org.codehaus.jackson.map.util.EnumResolver {
	*** _enumClass;
	*** _enums;
	*** _enumsById;
	*** constructFor(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector);
	*** constructUnsafe(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector);
	*** constructUnsafeUsingToString(java.lang.Class);
	*** constructUsingToString(java.lang.Class);
	*** findEnum(java.lang.String);
	*** getEnum(int);
	*** getEnumClass();
	*** lastValidIndex();
}

-keep class org.codehaus.jackson.map.util.EnumValues {
	*** _values;
	*** construct(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector);
	*** constructFromName(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector);
	*** constructFromToString(java.lang.Class,org.codehaus.jackson.map.AnnotationIntrospector);
	*** serializedValueFor(java.lang.Enum);
	*** values();
}

-keep class org.codehaus.jackson.map.util.LinkedNode {
	*** contains(org.codehaus.jackson.map.util.LinkedNode,java.lang.Object);
	*** next();
	*** value();
}

-keep class org.codehaus.jackson.map.util.ObjectBuffer {
	*** appendCompletedChunk(java.lang.Object[]);
	*** completeAndClearBuffer(java.lang.Object[],int);
	*** completeAndClearBuffer(java.lang.Object[],int,java.lang.Class);
	*** completeAndClearBuffer(java.lang.Object[],int,java.util.List);
	*** initialCapacity();
	*** resetAndStart();
}

-keep class org.codehaus.jackson.map.util.PrimitiveArrayBuilder {
	*** appendCompletedChunk(java.lang.Object,int);
	*** completeAndClearBuffer(java.lang.Object,int);
	*** resetAndStart();
}

-keep class org.codehaus.jackson.map.util.Provider {
	*** provide();
}

-keep class org.codehaus.jackson.map.util.RootNameLookup {
	*** _rootNames;
	*** findRootName(java.lang.Class,org.codehaus.jackson.map.MapperConfig);
	*** findRootName(org.codehaus.jackson.type.JavaType,org.codehaus.jackson.map.MapperConfig);
}

-keep class org.codehaus.jackson.map.util.StdDateFormat {
	*** ALL_FORMATS;
	*** DATE_FORMAT_ISO8601;
	*** DATE_FORMAT_ISO8601_Z;
	*** DATE_FORMAT_PLAIN;
	*** DATE_FORMAT_RFC1123;
	*** _formatISO8601;
	*** _formatISO8601_z;
	*** _formatPlain;
	*** _formatRFC1123;
	*** instance;
	*** clone();
	*** hasTimeZone(java.lang.String);
	*** looksLikeISO8601(java.lang.String);
	*** parse(java.lang.String,java.text.ParsePosition);
	*** parseAsISO8601(java.lang.String,java.text.ParsePosition);
	*** parseAsRFC1123(java.lang.String,java.text.ParsePosition);
}

-keep class org.codehaus.jackson.node.ArrayNode {
	*** _children;
	*** _add(org.codehaus.jackson.JsonNode);
	*** _insert(int,org.codehaus.jackson.JsonNode);
	*** _sameChildren(java.util.ArrayList);
	*** _set(int,org.codehaus.jackson.JsonNode);
	*** add(java.lang.String);
	*** add(org.codehaus.jackson.JsonNode);
	*** addContentsTo(java.util.List);
	*** addNull();
	*** findParent(java.lang.String);
	*** insertNull(int);
	*** removeAll();
	*** size();
}

-keep class org.codehaus.jackson.node.BaseJsonNode {
	org.codehaus.jackson.node.BaseJsonNode();
	*** findParent(java.lang.String);
	*** findValue(java.lang.String);
	*** serialize(org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.codehaus.jackson.node.BigIntegerNode {
	*** _value;
	*** valueOf(java.math.BigInteger);
}

-keep class org.codehaus.jackson.node.BinaryNode {
	*** EMPTY_BINARY_NODE;
	*** _data;
	*** getBinaryValue();
	*** valueOf(byte[]);
	*** valueOf(byte[],int,int);
}

-keep class org.codehaus.jackson.node.BooleanNode {
	*** FALSE;
	*** TRUE;
	*** getFalse();
	*** getTrue();
}

-keep class org.codehaus.jackson.node.ContainerNode {
	*** _nodeFactory;
	org.codehaus.jackson.node.ContainerNode(org.codehaus.jackson.node.JsonNodeFactory);
	*** POJONode(java.lang.Object);
	*** arrayNode();
	*** binaryNode(byte[]);
	*** booleanNode(boolean);
	*** findParent(java.lang.String);
	*** nullNode();
	*** numberNode(double);
	*** numberNode(float);
	*** numberNode(int);
	*** numberNode(java.math.BigDecimal);
	*** numberNode(long);
	*** objectNode();
	*** textNode(java.lang.String);
}

-keep class org.codehaus.jackson.node.ContainerNode$NoNodesIterator {
	*** instance;
	*** instance();
	*** next();
}

-keep class org.codehaus.jackson.node.ContainerNode$NoStringsIterator {
	*** instance;
	*** instance();
	*** next();
}

-keep class org.codehaus.jackson.node.DecimalNode {
	*** _value;
	*** valueOf(java.math.BigDecimal);
}

-keep class org.codehaus.jackson.node.DoubleNode {
	*** _value;
	*** getDecimalValue();
	*** valueOf(double);
}

-keep class org.codehaus.jackson.node.IntNode {
	*** CANONICALS;
	*** _value;
	*** valueOf(int);
}

-keep class org.codehaus.jackson.node.JsonNodeFactory {
	*** instance;
	*** POJONode(java.lang.Object);
	*** arrayNode();
	*** binaryNode(byte[]);
	*** binaryNode(byte[],int,int);
	*** booleanNode(boolean);
	*** nullNode();
	*** numberNode(byte);
	*** numberNode(double);
	*** numberNode(float);
	*** numberNode(int);
	*** numberNode(java.math.BigDecimal);
	*** numberNode(java.math.BigInteger);
	*** numberNode(long);
	*** numberNode(short);
	*** objectNode();
	*** textNode(java.lang.String);
}

-keep class org.codehaus.jackson.node.LongNode {
	*** _value;
	*** valueOf(long);
}

-keep class org.codehaus.jackson.node.MissingNode {
	*** instance;
	*** getInstance();
}

-keep class org.codehaus.jackson.node.NodeCursor {
	*** currentHasChildren();
	*** currentNode();
	*** endToken();
	*** getCurrentName();
	*** getParent();
	*** iterateChildren();
	*** nextToken();
}

-keep class org.codehaus.jackson.node.NullNode {
	*** instance;
	*** getInstance();
}

-keep class org.codehaus.jackson.node.NumericNode {
	org.codehaus.jackson.node.NumericNode();
	*** getDoubleValue();
	*** getIntValue();
	*** getLongValue();
}

-keep class org.codehaus.jackson.node.ObjectNode {
	*** _children;
	*** _put(java.lang.String,org.codehaus.jackson.JsonNode);
	*** findParent(java.lang.String);
	*** get(java.lang.String);
	*** put(java.lang.String,boolean);
	*** put(java.lang.String,java.lang.String);
	*** put(java.lang.String,org.codehaus.jackson.JsonNode);
	*** putArray(java.lang.String);
	*** putContentsTo(java.util.Map);
	*** putNull(java.lang.String);
	*** removeAll();
	*** retain(java.util.Collection);
	*** size();
	*** with(java.lang.String);
}

-keep class org.codehaus.jackson.node.ObjectNode$NoFieldsIterator {
	*** instance;
}

-keep class org.codehaus.jackson.node.POJONode {
	*** _value;
	*** getPojo();
}

-keep class org.codehaus.jackson.node.TextNode {
	*** EMPTY_STRING_NODE;
	*** _value;
	*** _reportBase64EOF();
	*** _reportInvalidBase64(org.codehaus.jackson.Base64Variant,char,int);
	*** _reportInvalidBase64(org.codehaus.jackson.Base64Variant,char,int,java.lang.String);
	*** appendQuoted(java.lang.StringBuilder,java.lang.String);
	*** getBinaryValue(org.codehaus.jackson.Base64Variant);
	*** valueOf(java.lang.String);
}

-keep class org.codehaus.jackson.node.TreeTraversingParser {
	*** _closed;
	*** _nextToken;
	*** _nodeCursor;
	*** _objectCodec;
	*** _startContainer;
	org.codehaus.jackson.node.TreeTraversingParser(org.codehaus.jackson.JsonNode,org.codehaus.jackson.ObjectCodec);
	*** currentNode();
	*** currentNumericNode();
	*** getText();
}

-keep class org.codehaus.jackson.node.TreeTraversingParser$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.node.ValueNode {
	org.codehaus.jackson.node.ValueNode();
}

-keep class org.codehaus.jackson.schema.JsonSchema {
	*** getDefaultSchemaNode();
}

-keep class org.codehaus.jackson.schema.JsonSerializableSchema {
	*** schemaItemDefinition();
	*** schemaObjectPropertiesDefinition();
	*** schemaType();
}

-keep class org.codehaus.jackson.schema.SchemaAware {
	*** getSchema(org.codehaus.jackson.map.SerializerProvider,java.lang.reflect.Type);
}

-keep class org.codehaus.jackson.sym.BytesToNameCanonicalizer {
	*** _collCount;
	*** _collEnd;
	*** _collList;
	*** _collListShared;
	*** _count;
	*** _hashSeed;
	*** _intern;
	*** _longestCollisionList;
	*** _mainHash;
	*** _mainHashMask;
	*** _mainHashShared;
	*** _mainNames;
	*** _mainNamesShared;
	*** _needRehash;
	*** _parent;
	*** _tableInfo;
	*** _addSymbol(int,org.codehaus.jackson.sym.Name);
	*** addName(java.lang.String,int[],int);
	*** calcHash(int);
	*** calcHash(int,int);
	*** calcHash(int[],int);
	*** constructName(int,java.lang.String,int,int);
	*** constructName(int,java.lang.String,int[],int);
	*** createRoot();
	*** createRoot(int);
	*** expandCollision();
	*** findBestBucket();
	*** findName(int);
	*** findName(int,int);
	*** findName(int[],int);
	*** getEmptyName();
	*** initTableInfo(int);
	*** makeChild(boolean,boolean);
	*** maybeDirty();
	*** mergeChild(org.codehaus.jackson.sym.BytesToNameCanonicalizer$TableInfo);
	*** nukeSymbols();
	*** rehash();
	*** release();
	*** reportTooManyCollisions(int);
	*** unshareCollision();
	*** unshareMain();
	*** unshareNames();
}

-keep class org.codehaus.jackson.sym.BytesToNameCanonicalizer$Bucket {
	*** _length;
	*** _name;
	*** _next;
	*** find(int,int,int);
	*** find(int,int[],int);
	*** length();
}

-keep class org.codehaus.jackson.sym.BytesToNameCanonicalizer$TableInfo {
	*** collCount;
	*** collEnd;
	*** collList;
	*** count;
	*** longestCollisionList;
	*** mainHash;
	*** mainHashMask;
	*** mainNames;
}

-keep class org.codehaus.jackson.sym.CharsToNameCanonicalizer {
	*** _buckets;
	*** _canonicalize;
	*** _dirty;
	*** _hashSeed;
	*** _indexMask;
	*** _intern;
	*** _longestCollisionList;
	*** _parent;
	*** _size;
	*** _sizeThreshold;
	*** _symbols;
	*** sBootstrapSymbolTable;
	*** _hashToIndex(int);
	*** _thresholdSize(int);
	*** calcHash(char[],int,int);
	*** calcHash(java.lang.String);
	*** copyArrays();
	*** createRoot();
	*** createRoot(int);
	*** findSymbol(char[],int,int,int);
	*** initTables(int);
	*** makeChild(boolean,boolean);
	*** makeOrphan(int);
	*** maybeDirty();
	*** mergeChild(org.codehaus.jackson.sym.CharsToNameCanonicalizer);
	*** rehash();
	*** release();
	*** reportTooManyCollisions(int);
	*** size();
}

-keep class org.codehaus.jackson.sym.CharsToNameCanonicalizer$Bucket {
	*** _length;
	*** _next;
	*** _symbol;
	*** find(char[],int,int);
	*** getNext();
	*** getSymbol();
	*** length();
}

-keep class org.codehaus.jackson.sym.Name {
	*** _hashCode;
	*** _name;
	org.codehaus.jackson.sym.Name(java.lang.String,int);
	*** equals(int);
	*** equals(int,int);
	*** equals(int[],int);
	*** getName();
	*** hashCode();
}

-keep class org.codehaus.jackson.sym.Name1 {
	*** mQuad;
	*** sEmptyName;
	*** getEmptyName();
}

-keep class org.codehaus.jackson.sym.Name2 {
	*** mQuad1;
	*** mQuad2;
}

-keep class org.codehaus.jackson.sym.Name3 {
	*** mQuad1;
	*** mQuad2;
	*** mQuad3;
}

-keep class org.codehaus.jackson.sym.NameN {
	*** mQuadLen;
	*** mQuads;
}

-keep class org.codehaus.jackson.type.JavaType {
	*** _class;
	*** _hashCode;
	*** _typeHandler;
	*** _valueHandler;
	org.codehaus.jackson.type.JavaType(java.lang.Class,int);
	*** _assertSubclass(java.lang.Class,java.lang.Class);
	*** _narrow(java.lang.Class);
	*** _widen(java.lang.Class);
	*** containedType(int);
	*** containedTypeCount();
	*** containedTypeName(int);
	*** equals(java.lang.Object);
	*** getContentType();
	*** getErasedSignature(java.lang.StringBuilder);
	*** getGenericSignature(java.lang.StringBuilder);
	*** getKeyType();
	*** getRawClass();
	*** getTypeHandler();
	*** getValueHandler();
	*** hasGenericTypes();
	*** hashCode();
	*** isAbstract();
	*** isArrayType();
	*** isCollectionLikeType();
	*** isConcrete();
	*** isContainerType();
	*** isEnumType();
	*** isFinal();
	*** isInterface();
	*** isMapLikeType();
	*** isPrimitive();
	*** isThrowable();
	*** narrowBy(java.lang.Class);
	*** narrowContentsBy(java.lang.Class);
	*** setValueHandler(java.lang.Object);
	*** toCanonical();
	*** toString();
	*** widenBy(java.lang.Class);
	*** widenContentsBy(java.lang.Class);
	*** withContentTypeHandler(java.lang.Object);
	*** withTypeHandler(java.lang.Object);
	*** withValueHandler(java.lang.Object);
}

-keep class org.codehaus.jackson.type.TypeReference {
	*** getType();
}

-keep class org.codehaus.jackson.util.BufferRecycler {
	*** _byteBuffers;
	*** _charBuffers;
	*** allocByteBuffer(org.codehaus.jackson.util.BufferRecycler$ByteBufferType);
	*** allocCharBuffer(org.codehaus.jackson.util.BufferRecycler$CharBufferType);
	*** allocCharBuffer(org.codehaus.jackson.util.BufferRecycler$CharBufferType,int);
	*** balloc(int);
	*** calloc(int);
	*** releaseByteBuffer(org.codehaus.jackson.util.BufferRecycler$ByteBufferType,byte[]);
	*** releaseCharBuffer(org.codehaus.jackson.util.BufferRecycler$CharBufferType,char[]);
}

-keep class org.codehaus.jackson.util.BufferRecycler$ByteBufferType {
	*** $VALUES;
	*** READ_IO_BUFFER;
	*** WRITE_CONCAT_BUFFER;
	*** WRITE_ENCODING_BUFFER;
	*** size;
	*** access$000(org.codehaus.jackson.util.BufferRecycler$ByteBufferType);
	*** values();
}

-keep class org.codehaus.jackson.util.BufferRecycler$CharBufferType {
	*** $VALUES;
	*** CONCAT_BUFFER;
	*** NAME_COPY_BUFFER;
	*** TEXT_BUFFER;
	*** TOKEN_BUFFER;
	*** size;
	*** access$100(org.codehaus.jackson.util.BufferRecycler$CharBufferType);
	*** values();
}

-keep class org.codehaus.jackson.util.ByteArrayBuilder {
	*** NO_BYTES;
	*** _bufferRecycler;
	*** _currBlock;
	*** _currBlockPtr;
	*** _pastBlocks;
	*** _pastLen;
	org.codehaus.jackson.util.ByteArrayBuilder(org.codehaus.jackson.util.BufferRecycler);
	org.codehaus.jackson.util.ByteArrayBuilder(org.codehaus.jackson.util.BufferRecycler,int);
	*** _allocMore();
	*** append(int);
	*** appendThreeBytes(int);
	*** appendTwoBytes(int);
	*** completeAndCoalesce(int);
	*** finishCurrentSegment();
	*** getCurrentSegment();
	*** getCurrentSegmentLength();
	*** release();
	*** reset();
	*** resetAndGetFirstSegment();
	*** setCurrentSegmentLength(int);
	*** toByteArray();
	*** write(byte[],int,int);
}

-keep class org.codehaus.jackson.util.CharTypes {
	*** HEX_BYTES;
	*** HEX_CHARS;
	*** sHexValues;
	*** sInputCodes;
	*** sInputCodesComment;
	*** sInputCodesJsNames;
	*** sInputCodesUtf8;
	*** sInputCodesUtf8JsNames;
	*** sOutputEscapes128;
	*** appendQuoted(java.lang.StringBuilder,java.lang.String);
	*** charToHex(int);
	*** copyHexBytes();
	*** copyHexChars();
	*** get7BitOutputEscapes();
	*** getInputCodeComment();
	*** getInputCodeLatin1();
	*** getInputCodeLatin1JsNames();
	*** getInputCodeUtf8();
	*** getInputCodeUtf8JsNames();
}

-keep class org.codehaus.jackson.util.DefaultPrettyPrinter {
	*** _arrayIndenter;
	*** _nesting;
	*** _objectIndenter;
	*** _spacesInObjectEntries;
}

-keep class org.codehaus.jackson.util.DefaultPrettyPrinter$Lf2SpacesIndenter {
	*** SPACES;
	*** SYSTEM_LINE_SEPARATOR;
}

-keep class org.codehaus.jackson.util.InternCache {
	*** instance;
	*** intern(java.lang.String);
}

-keep class org.codehaus.jackson.util.MinimalPrettyPrinter {
	*** _rootValueSeparator;
	org.codehaus.jackson.util.MinimalPrettyPrinter(java.lang.String);
}

-keep class org.codehaus.jackson.util.TextBuffer {
	*** NO_CHARS;
	*** _allocator;
	*** _currentSegment;
	*** _currentSize;
	*** _hasSegments;
	*** _inputBuffer;
	*** _inputLen;
	*** _inputStart;
	*** _resultArray;
	*** _resultString;
	*** _segmentSize;
	*** _segments;
	*** _charArray(int);
	*** append(char);
	*** append(char[],int,int);
	*** append(java.lang.String,int,int);
	*** buildResultArray();
	*** clearSegments();
	*** contentsAsArray();
	*** contentsAsDecimal();
	*** contentsAsDouble();
	*** contentsAsString();
	*** emptyAndGetCurrentSegment();
	*** expand(int);
	*** expandCurrentSegment();
	*** findBuffer(int);
	*** finishCurrentSegment();
	*** getCurrentSegment();
	*** getCurrentSegmentSize();
	*** getTextBuffer();
	*** getTextOffset();
	*** releaseBuffers();
	*** resetWithCopy(char[],int,int);
	*** resetWithEmpty();
	*** resetWithShared(char[],int,int);
	*** resetWithString(java.lang.String);
	*** setCurrentLength(int);
	*** size();
	*** unshare(int);
}

-keep class org.codehaus.jackson.util.TokenBuffer {
	*** DEFAULT_PARSER_FEATURES;
	*** _appendOffset;
	*** _closed;
	*** _first;
	*** _generatorFeatures;
	*** _last;
	*** _objectCodec;
	*** _writeContext;
	*** _append(org.codehaus.jackson.JsonToken);
	*** _append(org.codehaus.jackson.JsonToken,java.lang.Object);
	*** _reportUnsupportedOperation();
	*** asParser();
	*** asParser(org.codehaus.jackson.ObjectCodec);
	*** copyCurrentEvent(org.codehaus.jackson.JsonParser);
	*** copyCurrentStructure(org.codehaus.jackson.JsonParser);
	*** getOutputContext();
	*** serialize(org.codehaus.jackson.JsonGenerator);
	*** writeBoolean(boolean);
	*** writeEndArray();
	*** writeEndObject();
	*** writeFieldName(java.lang.String);
	*** writeNull();
	*** writeNumber(double);
	*** writeNumber(float);
	*** writeNumber(int);
	*** writeNumber(java.math.BigDecimal);
	*** writeNumber(java.math.BigInteger);
	*** writeNumber(long);
	*** writeObject(java.lang.Object);
	*** writeStartArray();
	*** writeStartObject();
	*** writeString(char[],int,int);
	*** writeString(java.lang.String);
}

-keep class org.codehaus.jackson.util.TokenBuffer$1 {
	*** $SwitchMap$org$codehaus$jackson$JsonParser$NumberType;
	*** $SwitchMap$org$codehaus$jackson$JsonToken;
}

-keep class org.codehaus.jackson.util.TokenBuffer$Parser {
	*** setLocation(org.codehaus.jackson.JsonLocation);
}

-keep class org.codehaus.jackson.util.TokenBuffer$Segment {
	*** append(int,org.codehaus.jackson.JsonToken);
	*** append(int,org.codehaus.jackson.JsonToken,java.lang.Object);
	*** get(int);
	*** next();
	*** type(int);
}

-keep class org.codehaus.jackson.util.VersionUtil {
	*** versionFor(java.lang.Class);
}

-keep class org.cometd.annotation.AnnotationProcessor {
	*** logger;
	org.cometd.annotation.AnnotationProcessor();
	*** findGetterMethod(java.lang.Class,java.lang.reflect.Method);
	*** getField(java.lang.Object,java.lang.reflect.Field);
	*** invokeMethod(java.lang.Object,java.lang.reflect.Method,java.lang.Object[]);
	*** processInjectable(java.lang.Object,java.lang.Object);
	*** processInjectables(java.lang.Object,java.util.List);
	*** processPostConstruct(java.lang.Object);
	*** processPreDestroy(java.lang.Object);
	*** setField(java.lang.Object,java.lang.reflect.Field,java.lang.Object);
	*** signaturesMatch(java.lang.Class[],java.lang.Class[]);
}

-keep class org.cometd.annotation.Configure {
	*** configureIfExists();
	*** errorIfExists();
	*** value();
}

-keep class org.cometd.annotation.Listener {
	*** receiveOwnPublishes();
	*** value();
}

-keep class org.cometd.annotation.ServerAnnotationProcessor {
	*** bayeuxServer;
	*** injectables;
	*** listeners;
	*** sessions;
	*** subscribers;
	org.cometd.annotation.ServerAnnotationProcessor(org.cometd.bayeux.server.BayeuxServer,java.lang.Object[]);
	*** deprocessCallbacks(java.lang.Object);
	*** deprocessListener(java.lang.Object);
	*** deprocessSubscription(java.lang.Object);
	*** findOrCreateLocalSession(java.lang.Object,java.lang.String);
	*** process(java.lang.Object);
	*** processCallbacks(java.lang.Object);
	*** processConfigurations(java.lang.Object);
	*** processDependencies(java.lang.Object);
	*** processListener(java.lang.Object,org.cometd.bayeux.server.LocalSession);
	*** processPostConstruct(java.lang.Object);
	*** processPreDestroy(java.lang.Object);
	*** processSession(java.lang.Object,org.cometd.bayeux.server.LocalSession);
	*** processSubscription(java.lang.Object,org.cometd.bayeux.server.LocalSession);
}

-keep class org.cometd.annotation.ServerAnnotationProcessor$1 {
	*** this$0;
	*** val$bean;
	*** val$method;
}

-keep class org.cometd.annotation.ServerAnnotationProcessor$ListenerCallback {
	*** channel;
	*** localSession;
	*** method;
	*** receiveOwnPublishes;
	*** signature;
	*** target;
	org.cometd.annotation.ServerAnnotationProcessor$ListenerCallback(org.cometd.bayeux.server.LocalSession,java.lang.Object,java.lang.reflect.Method,java.lang.String,boolean);
	*** access$100(org.cometd.annotation.ServerAnnotationProcessor$ListenerCallback);
}

-keep class org.cometd.annotation.ServerAnnotationProcessor$SubscriptionCallback {
	*** access$200(org.cometd.annotation.ServerAnnotationProcessor$SubscriptionCallback);
	*** access$300(org.cometd.annotation.ServerAnnotationProcessor$SubscriptionCallback);
}

-keep class org.cometd.annotation.Service {
	*** value();
}

-keep class org.cometd.annotation.Subscription {
	*** value();
}

-keep class org.cometd.bayeux.Channel {
	*** getChannelId();
	*** getId();
	*** isMeta();
}

-keep class org.cometd.bayeux.ChannelId {
	*** _id;
	*** _parent;
	*** _segments;
	*** _wild;
	*** _wilds;
	*** depth();
	*** equals(java.lang.Object);
	*** getParent();
	*** getWilds();
	*** isBroadcast(java.lang.String);
	*** isDeepWild();
	*** isMeta();
	*** isMeta(java.lang.String);
	*** isService();
	*** isService(java.lang.String);
	*** isWild();
	*** resolve();
	*** toString();
}

-keep class org.cometd.bayeux.Message {
	*** getAdvice();
	*** getChannel();
	*** getClientId();
	*** getData();
	*** getId();
	*** getJSON();
	*** isMeta();
	*** isPublishReply();
	*** isSuccessful();
}

-keep class org.cometd.bayeux.Message$Mutable {
	*** getAdvice(boolean);
	*** setChannel(java.lang.String);
	*** setClientId(java.lang.String);
	*** setData(java.lang.Object);
	*** setId(java.lang.String);
	*** setSuccessful(boolean);
}

-keep class org.cometd.bayeux.Session {
	*** getId();
	*** isHandshook();
}

-keep class org.cometd.bayeux.Transport {
	*** getName();
}

-keep class org.cometd.bayeux.client.ClientSession {
	*** getChannel(java.lang.String);
	*** handshake();
}

-keep class org.cometd.bayeux.client.ClientSession$Extension {
	*** rcv(org.cometd.bayeux.client.ClientSession,org.cometd.bayeux.Message$Mutable);
	*** rcvMeta(org.cometd.bayeux.client.ClientSession,org.cometd.bayeux.Message$Mutable);
	*** send(org.cometd.bayeux.client.ClientSession,org.cometd.bayeux.Message$Mutable);
	*** sendMeta(org.cometd.bayeux.client.ClientSession,org.cometd.bayeux.Message$Mutable);
}

-keep class org.cometd.bayeux.client.ClientSessionChannel {
	*** addListener(org.cometd.bayeux.client.ClientSessionChannel$ClientSessionChannelListener);
	*** publish(java.lang.Object);
	*** publish(java.lang.Object,org.cometd.bayeux.client.ClientSessionChannel$MessageListener);
	*** subscribe(org.cometd.bayeux.client.ClientSessionChannel$MessageListener);
	*** unsubscribe(org.cometd.bayeux.client.ClientSessionChannel$MessageListener);
}

-keep class org.cometd.bayeux.client.ClientSessionChannel$MessageListener {
	*** onMessage(org.cometd.bayeux.client.ClientSessionChannel,org.cometd.bayeux.Message);
}

-keep class org.cometd.bayeux.server.Authorizer {
	*** authorize(org.cometd.bayeux.server.Authorizer$Operation,org.cometd.bayeux.ChannelId,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
}

-keep class org.cometd.bayeux.server.Authorizer$Operation {
	*** $VALUES;
	*** CREATE;
	*** PUBLISH;
	*** SUBSCRIBE;
}

-keep class org.cometd.bayeux.server.Authorizer$Result {
	org.cometd.bayeux.server.Authorizer$Result();
	*** deny(java.lang.String);
	*** grant();
	*** ignore();
	*** toString();
}

-keep class org.cometd.bayeux.server.Authorizer$Result$Denied {
	*** reason;
	org.cometd.bayeux.server.Authorizer$Result$Denied(java.lang.String);
	*** getReason();
}

-keep class org.cometd.bayeux.server.Authorizer$Result$Granted {
	*** GRANTED;
	*** access$100();
}

-keep class org.cometd.bayeux.server.Authorizer$Result$Ignored {
	*** IGNORED;
	*** access$200();
}

-keep class org.cometd.bayeux.server.BayeuxServer {
	*** createIfAbsent(java.lang.String,org.cometd.bayeux.server.ConfigurableServerChannel$Initializer[]);
	*** getChannel(java.lang.String);
	*** newLocalSession(java.lang.String);
}

-keep class org.cometd.bayeux.server.BayeuxServer$ChannelListener {
	*** channelAdded(org.cometd.bayeux.server.ServerChannel);
	*** channelRemoved(java.lang.String);
}

-keep class org.cometd.bayeux.server.BayeuxServer$Extension {
	*** rcv(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** rcvMeta(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** send(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** sendMeta(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
}

-keep class org.cometd.bayeux.server.BayeuxServer$SessionListener {
	*** sessionAdded(org.cometd.bayeux.server.ServerSession);
	*** sessionRemoved(org.cometd.bayeux.server.ServerSession,boolean);
}

-keep class org.cometd.bayeux.server.BayeuxServer$SubscriptionListener {
	*** subscribed(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
	*** unsubscribed(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
}

-keep class org.cometd.bayeux.server.ConfigurableServerChannel {
	*** addListener(org.cometd.bayeux.server.ServerChannel$ServerChannelListener);
	*** getAuthorizers();
	*** removeListener(org.cometd.bayeux.server.ServerChannel$ServerChannelListener);
	*** setPersistent(boolean);
}

-keep class org.cometd.bayeux.server.ConfigurableServerChannel$Initializer {
	*** configureChannel(org.cometd.bayeux.server.ConfigurableServerChannel);
}

-keep class org.cometd.bayeux.server.LocalSession {
	*** getServerSession();
}

-keep class org.cometd.bayeux.server.SecurityPolicy {
	*** canCreate(org.cometd.bayeux.server.BayeuxServer,org.cometd.bayeux.server.ServerSession,java.lang.String,org.cometd.bayeux.server.ServerMessage);
	*** canHandshake(org.cometd.bayeux.server.BayeuxServer,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** canPublish(org.cometd.bayeux.server.BayeuxServer,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerMessage);
	*** canSubscribe(org.cometd.bayeux.server.BayeuxServer,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerMessage);
}

-keep class org.cometd.bayeux.server.ServerChannel {
	*** publish(org.cometd.bayeux.Session,org.cometd.bayeux.server.ServerMessage$Mutable);
}

-keep class org.cometd.bayeux.server.ServerChannel$MessageListener {
	*** onMessage(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerMessage$Mutable);
}

-keep class org.cometd.bayeux.server.ServerChannel$SubscriptionListener {
	*** subscribed(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
	*** unsubscribed(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
}

-keep class org.cometd.bayeux.server.ServerMessage {
	*** getAssociated();
	*** isLazy();
}

-keep class org.cometd.bayeux.server.ServerMessage$Mutable {
	*** setAssociated(org.cometd.bayeux.server.ServerMessage$Mutable);
	*** setLazy(boolean);
}

-keep class org.cometd.bayeux.server.ServerSession {
	*** getLocalSession();
	*** isLocalSession();
}

-keep class org.cometd.bayeux.server.ServerSession$DeQueueListener {
	*** deQueue(org.cometd.bayeux.server.ServerSession,java.util.Queue);
}

-keep class org.cometd.bayeux.server.ServerSession$Extension {
	*** rcv(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** rcvMeta(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** send(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** sendMeta(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
}

-keep class org.cometd.bayeux.server.ServerSession$MaxQueueListener {
	*** queueMaxed(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.Session,org.cometd.bayeux.Message);
}

-keep class org.cometd.bayeux.server.ServerSession$MessageListener {
	*** onMessage(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
}

-keep class org.cometd.bayeux.server.ServerSession$RemoveListener {
	*** removed(org.cometd.bayeux.server.ServerSession,boolean);
}

-keep class org.cometd.bayeux.server.ServerTransport {
	*** getContext();
	*** getInterval();
	*** getTimeout();
}

-keep class org.cometd.client.transport.ClientTransport {
	*** debug;
	*** jsonContext;
	*** logger;
	org.cometd.client.transport.ClientTransport(java.lang.String,java.util.Map);
	*** generateJSON(org.cometd.bayeux.Message$Mutable[]);
	*** init();
	*** isDebugEnabled();
}

-keep class org.cometd.client.transport.HttpClientTransport {
	*** cookieProvider;
	*** url;
	org.cometd.client.transport.HttpClientTransport(java.lang.String,java.util.Map);
	*** getCookieProvider();
	*** getURL();
}

-keep class org.cometd.client.transport.HttpClientTransport$Cookie {
	*** asString();
}

-keep class org.cometd.client.transport.HttpClientTransport$CookieProvider {
	*** getCookie(java.lang.String);
	*** getCookies();
	*** setCookie(org.cometd.client.transport.HttpClientTransport$Cookie);
}

-keep class org.cometd.client.transport.LongPollingTransport {
	*** _aborted;
	*** _advice;
	*** _appendMessageType;
	*** _exchanges;
	*** _httpClient;
	*** _maxNetworkDelay;
	*** create(java.util.Map,org.eclipse.jetty.client.HttpClient);
	*** customize(org.eclipse.jetty.client.ContentExchange);
}

-keep class org.cometd.client.transport.LongPollingTransport$TransportExchange {
	*** access$000(org.cometd.client.transport.LongPollingTransport$TransportExchange);
	*** access$100(org.cometd.client.transport.LongPollingTransport$TransportExchange);
}

-keep class org.cometd.client.transport.TransportListener {
	*** onException(java.lang.Throwable,org.cometd.bayeux.Message[]);
}

-keep class org.cometd.common.AbstractClientSession {
	*** _attributes;
	*** _batch;
	*** _channels;
	*** _extensions;
	*** _idGen;
	*** logger;
	org.cometd.common.AbstractClientSession();
	*** access$100(org.cometd.common.AbstractClientSession);
	*** dump(java.lang.StringBuilder,java.lang.String);
	*** endBatch();
	*** extendRcv(org.cometd.bayeux.Message$Mutable);
	*** extendSend(org.cometd.bayeux.Message$Mutable);
	*** getChannel(java.lang.String);
	*** getChannels();
	*** getReleasableChannel(java.lang.String);
	*** isBatching();
	*** newChannel(org.cometd.bayeux.ChannelId);
	*** newChannelId(java.lang.String);
	*** newMessageId();
	*** notifyListener(org.cometd.bayeux.client.ClientSessionChannel$MessageListener,org.cometd.bayeux.Message$Mutable);
	*** notifyListeners(org.cometd.bayeux.Message$Mutable);
	*** receive(org.cometd.bayeux.Message$Mutable);
	*** sendBatch();
	*** startBatch();
}

-keep class org.cometd.common.AbstractClientSession$AbstractSessionChannel {
	*** _attributes;
	*** _id;
	*** _listeners;
	*** _released;
	*** _subscriptionCount;
	*** _subscriptions;
	*** this$0;
	org.cometd.common.AbstractClientSession$AbstractSessionChannel(org.cometd.common.AbstractClientSession,org.cometd.bayeux.ChannelId);
	*** dump(java.lang.StringBuilder,java.lang.String);
	*** getAttribute(java.lang.String);
	*** getChannelId();
	*** getId();
	*** isMeta();
	*** isReleased();
	*** isService();
	*** notifyMessageListeners(org.cometd.bayeux.Message);
	*** notifyOnMessage(org.cometd.bayeux.client.ClientSessionChannel$MessageListener,org.cometd.bayeux.Message);
	*** release();
	*** resetSubscriptions();
	*** sendSubscribe();
	*** sendUnSubscribe();
	*** throwIfReleased();
	*** toString();
	*** unsubscribe(org.cometd.bayeux.client.ClientSessionChannel$MessageListener);
}

-keep class org.cometd.common.AbstractClientSession$MarkableReference {
	*** mark;
	*** reference;
	org.cometd.common.AbstractClientSession$MarkableReference(java.lang.Object,boolean);
	*** getReference();
	*** isMarked();
}

-keep class org.cometd.common.AbstractTransport {
	*** _name;
	*** _optionPrefix;
	*** _options;
	*** _prefix;
	org.cometd.common.AbstractTransport(java.lang.String,java.util.Map);
	*** getOption(java.lang.String);
	*** getOption(java.lang.String,boolean);
	*** getOption(java.lang.String,int);
	*** getOption(java.lang.String,java.lang.String);
	*** getOption(java.lang.String,long);
	*** getOptionPrefix();
	*** setOptionPrefix(java.lang.String);
}

-keep class org.cometd.common.HashMapMessage {
	*** _jsonContext;
	org.cometd.common.HashMapMessage();
	*** getAdvice();
	*** getChannel();
	*** getData();
	*** getDataAsMap();
	*** getExt();
	*** isMeta();
}

-keep class org.cometd.common.JSONParserGenerator {
	*** generate(org.cometd.bayeux.Message$Mutable);
	*** generate(org.cometd.bayeux.Message$Mutable[]);
	*** parse(java.io.Reader);
	*** parse(java.lang.String);
}

-keep class org.cometd.common.JacksonJSONContext {
	*** objectMapper;
	*** rootArrayType;
	org.cometd.common.JacksonJSONContext();
	*** getObjectMapper();
	*** rootArrayClass();
}

-keep class org.cometd.common.JettyJSONContext {
	*** _jsonParser;
	*** _messageParser;
	*** _messagesParser;
	org.cometd.common.JettyJSONContext();
	*** access$300(org.cometd.common.JettyJSONContext);
	*** access$400(org.cometd.common.JettyJSONContext);
	*** adapt(java.lang.Object);
	*** getJSON();
	*** newRoot();
	*** newRootArray(int);
	*** parse(java.io.Reader);
}

-keep class org.cometd.common.JettyJSONContext$FieldJSON {
	*** this$0;
	org.cometd.common.JettyJSONContext$FieldJSON(org.cometd.common.JettyJSONContext);
	org.cometd.common.JettyJSONContext$FieldJSON(org.cometd.common.JettyJSONContext,org.cometd.common.JettyJSONContext$1);
	*** getConvertor(java.lang.Class);
}

-keep class org.cometd.common.JettyJSONContext$MessageJSON {
	*** this$0;
	org.cometd.common.JettyJSONContext$MessageJSON(org.cometd.common.JettyJSONContext);
}

-keep class org.cometd.common.JettyJSONContext$MessagesJSON {
	*** this$0;
	org.cometd.common.JettyJSONContext$MessagesJSON(org.cometd.common.JettyJSONContext);
}

-keep class org.cometd.server.AbstractServerTransport {
	*** _advice;
	*** _bayeux;
	*** _interval;
	*** _logger;
	*** _maxInterval;
	*** _maxLazyTimeout;
	*** _metaConnectDeliveryOnly;
	*** _timeout;
	*** jsonContext;
	org.cometd.server.AbstractServerTransport(org.cometd.server.BayeuxServerImpl,java.lang.String);
	*** destroy();
	*** getBayeux();
	*** getInterval();
	*** getMaxInterval();
	*** getMaxLazyTimeout();
	*** getTimeout();
	*** init();
	*** isMetaConnectDeliveryOnly();
	*** parseMessages(java.io.BufferedReader,boolean);
	*** parseMessages(java.lang.String);
	*** setMetaConnectDeliveryOnly(boolean);
	*** sweep();
}

-keep class org.cometd.server.AbstractServerTransport$Scheduler {
	*** cancel();
	*** schedule();
}

-keep class org.cometd.server.BayeuxServerImpl {
	*** $assertionsDisabled;
	*** _allowedTransports;
	*** _channels;
	*** _currentTransport;
	*** _extensions;
	*** _handshakeAdvice;
	*** _jsonContext;
	*** _listeners;
	*** _logLevel;
	*** _logger;
	*** _options;
	*** _policy;
	*** _random;
	*** _sessions;
	*** _timeout;
	*** _timer;
	*** _transports;
	*** access$000(org.cometd.server.BayeuxServerImpl);
	*** access$600(org.cometd.server.BayeuxServerImpl);
	*** access$700(org.cometd.server.BayeuxServerImpl,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage,java.lang.String);
	*** access$800(org.cometd.server.BayeuxServerImpl,java.lang.String,org.cometd.bayeux.server.ConfigurableServerChannel$Initializer[]);
	*** access$900(org.cometd.server.BayeuxServerImpl,org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** addServerSession(org.cometd.server.ServerSessionImpl);
	*** addTransport(org.cometd.bayeux.server.ServerTransport);
	*** cancelTimeout(org.eclipse.jetty.util.thread.Timeout$Task);
	*** createChannelIfAbsent(java.lang.String,org.cometd.bayeux.server.ConfigurableServerChannel$Initializer[]);
	*** createReply(org.cometd.bayeux.server.ServerMessage$Mutable);
	*** debug(java.lang.String,java.lang.Object[]);
	*** doPublish(org.cometd.server.ServerSessionImpl,org.cometd.server.ServerChannelImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** error(org.cometd.bayeux.server.ServerMessage$Mutable,java.lang.String);
	*** extendRecv(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** extendReply(org.cometd.server.ServerSessionImpl,org.cometd.server.ServerSessionImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** extendSend(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** freeze(org.cometd.bayeux.server.ServerMessage$Mutable);
	*** getAllowedTransports();
	*** getChannel(java.lang.String);
	*** getCurrentTransport();
	*** getListeners();
	*** getLogLevel();
	*** getOption(java.lang.String);
	*** getOption(java.lang.String,long);
	*** getOptions();
	*** getSession(java.lang.String);
	*** getSessions();
	*** getTransport(java.lang.String);
	*** handle(org.cometd.server.ServerSessionImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** initializeDefaultTransports();
	*** initializeJSONContext();
	*** initializeMetaChannels();
	*** isCreationAuthorized(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage,java.lang.String);
	*** isOperationAuthorized(org.cometd.bayeux.server.Authorizer$Operation,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage,org.cometd.bayeux.ChannelId);
	*** isPublishAuthorized(org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** isSubscribeAuthorized(org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** newChannelId(java.lang.String);
	*** newMessage();
	*** newMessage(org.cometd.bayeux.server.ServerMessage);
	*** newServerSession();
	*** notifyChannelAdded(org.cometd.bayeux.server.BayeuxServer$ChannelListener,org.cometd.bayeux.server.ServerChannel);
	*** notifyChannelRemoved(org.cometd.bayeux.server.BayeuxServer$ChannelListener,org.cometd.server.ServerChannelImpl);
	*** notifyConfigureChannel(org.cometd.bayeux.server.ConfigurableServerChannel$Initializer,org.cometd.bayeux.server.ServerChannel);
	*** notifyOnMessage(org.cometd.bayeux.server.ServerChannel$MessageListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifyRcv(org.cometd.bayeux.server.BayeuxServer$Extension,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifyRcvMeta(org.cometd.bayeux.server.BayeuxServer$Extension,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifySend(org.cometd.bayeux.server.BayeuxServer$Extension,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifySendMeta(org.cometd.bayeux.server.BayeuxServer$Extension,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifySessionAdded(org.cometd.bayeux.server.BayeuxServer$SessionListener,org.cometd.bayeux.server.ServerSession);
	*** notifySessionRemoved(org.cometd.bayeux.server.BayeuxServer$SessionListener,org.cometd.bayeux.server.ServerSession,boolean);
	*** randomLong();
	*** removeServerChannel(org.cometd.server.ServerChannelImpl);
	*** removeServerSession(org.cometd.bayeux.server.ServerSession,boolean);
	*** setAllowedTransports(java.lang.String[]);
	*** setAllowedTransports(java.util.List);
	*** setCurrentTransport(org.cometd.server.AbstractServerTransport);
	*** setOption(java.lang.String,java.lang.Object);
	*** setTransports(java.util.List);
	*** startTimeout(org.eclipse.jetty.util.thread.Timeout$Task,long);
	*** sweep();
	*** unknownSession(org.cometd.bayeux.server.ServerMessage$Mutable);
}

-keep class org.cometd.server.BayeuxServerImpl$1 {
	*** this$0;
}

-keep class org.cometd.server.BayeuxServerImpl$2 {
	*** this$0;
}

-keep class org.cometd.server.BayeuxServerImpl$ConnectHandler {
	*** this$0;
	org.cometd.server.BayeuxServerImpl$ConnectHandler(org.cometd.server.BayeuxServerImpl);
}

-keep class org.cometd.server.BayeuxServerImpl$DisconnectHandler {
	*** this$0;
	org.cometd.server.BayeuxServerImpl$DisconnectHandler(org.cometd.server.BayeuxServerImpl);
}

-keep class org.cometd.server.BayeuxServerImpl$HandlerListener {
	*** this$0;
	org.cometd.server.BayeuxServerImpl$HandlerListener(org.cometd.server.BayeuxServerImpl);
	*** isSessionUnknown(org.cometd.bayeux.server.ServerSession);
	*** onMessage(org.cometd.server.ServerSessionImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** toChannelList(java.lang.Object);
}

-keep class org.cometd.server.BayeuxServerImpl$HandshakeHandler {
	*** this$0;
	org.cometd.server.BayeuxServerImpl$HandshakeHandler(org.cometd.server.BayeuxServerImpl);
}

-keep class org.cometd.server.BayeuxServerImpl$SubscribeHandler {
	*** this$0;
	org.cometd.server.BayeuxServerImpl$SubscribeHandler(org.cometd.server.BayeuxServerImpl);
}

-keep class org.cometd.server.BayeuxServerImpl$UnsubscribeHandler {
	*** this$0;
	org.cometd.server.BayeuxServerImpl$UnsubscribeHandler(org.cometd.server.BayeuxServerImpl);
}

-keep class org.cometd.server.CometdServlet {
	*** _bayeux;
	*** _logger;
	org.cometd.server.CometdServlet();
	*** newBayeuxServer();
	*** service(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** serviceOptions(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class org.cometd.server.JacksonJSONContextServer {
	org.cometd.server.JacksonJSONContextServer();
}

-keep class org.cometd.server.JettyJSONContextServer {
	*** newRoot();
	*** newRootArray(int);
}

-keep class org.cometd.server.LocalSessionImpl {
	*** _bayeux;
	*** _idHint;
	*** _queue;
	*** _session;
	*** publishCallbacks;
	*** access$000(org.cometd.server.LocalSessionImpl);
	*** access$100(org.cometd.server.LocalSessionImpl);
	*** doSend(org.cometd.server.ServerSessionImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** getId();
	*** handshake(java.util.Map);
	*** receive(org.cometd.bayeux.Message$Mutable);
	*** send(org.cometd.server.ServerSessionImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** toString();
}

-keep class org.cometd.server.LocalSessionImpl$LocalChannel {
	*** this$0;
}

-keep class org.cometd.server.ServerChannelImpl {
	*** _attributes;
	*** _authorizers;
	*** _bayeux;
	*** _children;
	*** _id;
	*** _initialized;
	*** _lazy;
	*** _listeners;
	*** _logger;
	*** _parent;
	*** _persistent;
	*** _subscribers;
	*** _sweeperPasses;
	*** addChild(org.cometd.server.ServerChannelImpl);
	*** addListener(org.cometd.bayeux.server.ServerChannel$ServerChannelListener);
	*** dump(java.lang.StringBuilder,java.lang.String);
	*** getAttribute(java.lang.String);
	*** getChannelId();
	*** getId();
	*** getListeners();
	*** getSubscribers();
	*** initialized();
	*** isBroadcast();
	*** isLazy();
	*** isMeta();
	*** isPersistent();
	*** isService();
	*** isWild();
	*** notifySubscribed(org.cometd.bayeux.server.BayeuxServer$SubscriptionListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
	*** notifySubscribed(org.cometd.bayeux.server.ServerChannel$SubscriptionListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
	*** notifyUnsubscribed(org.cometd.bayeux.server.BayeuxServer$SubscriptionListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
	*** notifyUnsubscribed(org.cometd.bayeux.server.ServerChannel$SubscriptionListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerChannel);
	*** publish(org.cometd.bayeux.Session,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** remove();
	*** removeChild(org.cometd.server.ServerChannelImpl);
	*** resetSweeperPasses();
	*** setPersistent(boolean);
	*** subscribe(org.cometd.bayeux.server.ServerSession);
	*** subscribe(org.cometd.server.ServerSessionImpl);
	*** sweep();
	*** toString();
	*** unsubscribe(org.cometd.bayeux.server.ServerSession);
	*** unsubscribe(org.cometd.server.ServerSessionImpl);
	*** waitForInitialized();
}

-keep class org.cometd.server.ServerMessageImpl {
	*** $assertionsDisabled;
	*** _associated;
	*** _json;
	*** _jsonContext;
	*** _lazy;
	*** freeze(java.lang.String);
	*** isFrozen();
	*** put(java.lang.String,java.lang.Object);
}

-keep class org.cometd.server.ServerSessionImpl {
	*** _advisedTransport;
	*** _attributes;
	*** _batch;
	*** _bayeux;
	*** _connectTimestamp;
	*** _connected;
	*** _extensions;
	*** _handshook;
	*** _id;
	*** _idCount;
	*** _interval;
	*** _intervalTimestamp;
	*** _lastConnect;
	*** _lazyDispatch;
	*** _lazyTask;
	*** _listeners;
	*** _localSession;
	*** _logger;
	*** _maxInterval;
	*** _maxLazy;
	*** _maxQueue;
	*** _maxServerInterval;
	*** _metaConnectDelivery;
	*** _queue;
	*** _scheduler;
	*** _subscribedTo;
	*** _timeout;
	*** _transientInterval;
	*** _transientTimeout;
	*** _userAgent;
	org.cometd.server.ServerSessionImpl(org.cometd.server.BayeuxServerImpl,org.cometd.server.LocalSessionImpl,java.lang.String);
	*** calculateInterval(long);
	*** calculateTimeout(long);
	*** cancelIntervalTimeout();
	*** cancelSchedule();
	*** connect();
	*** deliver(org.cometd.bayeux.Session,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** doDeliver(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** dump(java.lang.StringBuilder,java.lang.String);
	*** endBatch();
	*** extendRecv(org.cometd.bayeux.server.ServerMessage$Mutable);
	*** extendSendMessage(org.cometd.bayeux.server.ServerMessage);
	*** extendSendMeta(org.cometd.bayeux.server.ServerMessage$Mutable);
	*** flush();
	*** flushLazy();
	*** getAttribute(java.lang.String);
	*** getId();
	*** getTimeout();
	*** handshake();
	*** isConnected();
	*** isHandshook();
	*** isLocalSession();
	*** isMetaConnectDeliveryOnly();
	*** isQueueEmpty();
	*** notifyDeQueue(org.cometd.bayeux.server.ServerSession$DeQueueListener,org.cometd.bayeux.server.ServerSession,java.util.Queue);
	*** notifyOnMessage(org.cometd.bayeux.server.ServerSession$MessageListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** notifyQueueMaxed(org.cometd.bayeux.server.ServerSession$MaxQueueListener,org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.server.ServerMessage);
	*** notifyRcv(org.cometd.bayeux.server.ServerSession$Extension,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifyRcvMeta(org.cometd.bayeux.server.ServerSession$Extension,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** notifyRemoved(org.cometd.bayeux.server.ServerSession$RemoveListener,org.cometd.bayeux.server.ServerSession,boolean);
	*** notifySend(org.cometd.bayeux.server.ServerSession$Extension,org.cometd.bayeux.server.ServerMessage);
	*** notifySendMeta(org.cometd.bayeux.server.ServerSession$Extension,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** reAdvise();
	*** removed(boolean);
	*** setScheduler(org.cometd.server.AbstractServerTransport$Scheduler);
	*** setUserAgent(java.lang.String);
	*** startBatch();
	*** startIntervalTimeout(long);
	*** subscribedTo(org.cometd.server.ServerChannelImpl);
	*** sweep(long);
	*** takeAdvice();
	*** takeQueue();
	*** toString();
	*** unsubscribedFrom(org.cometd.server.ServerChannelImpl);
	*** updateTransientInterval(long);
	*** updateTransientTimeout(long);
}

-keep class org.cometd.server.ServerSessionImpl$1 {
	*** this$0;
}

-keep class org.cometd.server.transport.HttpTransport {
	*** _currentRequest;
	org.cometd.server.transport.HttpTransport(org.cometd.server.BayeuxServerImpl,java.lang.String);
	*** accept(javax.servlet.http.HttpServletRequest);
	*** getCurrentRequest();
	*** handle(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** setCurrentRequest(javax.servlet.http.HttpServletRequest);
}

-keep class org.cometd.server.transport.JSONPTransport {
	*** _callbackParam;
	*** _mimeType;
	*** getCallbackParameter();
}

-keep class org.cometd.server.transport.JSONTransport {
	*** _jsonDebug;
	*** _mimeType;
}

-keep class org.cometd.server.transport.LongPollingTransport {
	*** _allowMultiSessionsNoBrowser;
	*** _autoBatch;
	*** _browserId;
	*** _browserMap;
	*** _browserSweep;
	*** _lastSweep;
	*** _logger;
	*** _maxSessionsPerBrowser;
	*** _multiSessionInterval;
	org.cometd.server.transport.LongPollingTransport(org.cometd.server.BayeuxServerImpl,java.lang.String);
	*** bayeuxServerHandle(org.cometd.server.ServerSessionImpl,org.cometd.bayeux.server.ServerMessage$Mutable);
	*** complete(java.io.PrintWriter);
	*** decBrowserId(java.lang.String);
	*** findBrowserId(javax.servlet.http.HttpServletRequest);
	*** handleJSONParseException(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,java.lang.String,java.lang.Throwable);
	*** incBrowserId(java.lang.String);
	*** init();
	*** isAlwaysFlushingAfterHandle();
	*** metaConnectResumed(javax.servlet.http.HttpServletRequest,org.cometd.bayeux.server.ServerSession);
	*** metaConnectSuspended(javax.servlet.http.HttpServletRequest,org.cometd.bayeux.server.ServerSession,long);
	*** parseMessages(java.lang.String[]);
	*** parseMessages(javax.servlet.http.HttpServletRequest);
	*** send(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,java.io.PrintWriter,org.cometd.bayeux.server.ServerMessage);
	*** sendQueue(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,org.cometd.server.ServerSessionImpl,java.io.PrintWriter);
	*** setBrowserId(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class org.cometd.server.transport.LongPollingTransport$LongPollScheduler {
	*** getReply();
	*** getSession();
}

-keep class org.eclipse.jdt.internal.junit.runner.AbstractTestLoader {
	*** fClassLoader;
}

-keep class org.eclipse.jdt.internal.junit.runner.CustomHashtable {
	*** comparer;
	*** elementCount;
	*** elementData;
	*** emptyEnumerator;
	*** firstSlot;
	*** lastSlot;
	*** loadFactor;
	*** threshold;
	org.eclipse.jdt.internal.junit.runner.CustomHashtable(int);
	org.eclipse.jdt.internal.junit.runner.CustomHashtable(int,org.eclipse.jdt.internal.junit.runner.IElementComparer);
	*** computeMaxSize();
	*** getEntry(java.lang.Object);
	*** hashCode(java.lang.Object);
	*** keyEquals(java.lang.Object,java.lang.Object);
	*** put(java.lang.Object,java.lang.Object);
	*** rehash();
	*** size();
}

-keep class org.eclipse.jdt.internal.junit.runner.CustomHashtable$EmptyEnumerator {
	org.eclipse.jdt.internal.junit.runner.CustomHashtable$EmptyEnumerator();
}

-keep class org.eclipse.jdt.internal.junit.runner.CustomHashtable$HashEnumerator {
	*** entry;
	*** key;
	*** start;
	*** this$0;
	*** hasMoreElements();
}

-keep class org.eclipse.jdt.internal.junit.runner.CustomHashtable$HashMapEntry {
	*** key;
	*** next;
	*** value;
	*** access$0(org.eclipse.jdt.internal.junit.runner.CustomHashtable$HashMapEntry,java.lang.StringBuffer);
	*** appendToStringWithCommaNL(java.lang.StringBuffer);
}

-keep class org.eclipse.jdt.internal.junit.runner.DefaultClassifier {
	*** fVersion;
}

-keep class org.eclipse.jdt.internal.junit.runner.FailedComparison {
	*** fActual;
	*** fExpected;
	*** getActual();
	*** getExpected();
	*** sendMessages(org.eclipse.jdt.internal.junit.runner.MessageSender);
}

-keep class org.eclipse.jdt.internal.junit.runner.FailuresFirstPrioritizer {
	*** fPriorities;
	*** doPrioritize(junit.framework.Test,java.util.List);
	*** doReorder(junit.framework.Test,java.util.List,int);
	*** getField(java.lang.Object,java.lang.String);
	*** getFieldInClass(java.lang.Object,java.lang.String,java.lang.Class);
	*** hasPriority(junit.framework.TestCase);
	*** loopTests(java.util.List,junit.framework.TestSuite);
	*** moveTestToFront(junit.framework.TestSuite,junit.framework.Test);
	*** reorder(junit.framework.Test,java.util.List);
}

-keep class org.eclipse.jdt.internal.junit.runner.FirstRunExecutionListener {
	*** fIds;
	*** fSender;
	org.eclipse.jdt.internal.junit.runner.FirstRunExecutionListener(org.eclipse.jdt.internal.junit.runner.MessageSender,org.eclipse.jdt.internal.junit.runner.TestIdMap);
	*** getTestId(org.eclipse.jdt.internal.junit.runner.ITestIdentifier);
	*** sendFailure(org.eclipse.jdt.internal.junit.runner.TestReferenceFailure,java.lang.String,java.lang.String);
	*** sendMessage(org.eclipse.jdt.internal.junit.runner.ITestIdentifier,java.lang.String);
}

-keep class org.eclipse.jdt.internal.junit.runner.IClassifiesThrowables {
	*** getTrace(java.lang.Throwable);
	*** isComparisonFailure(java.lang.Throwable);
}

-keep class org.eclipse.jdt.internal.junit.runner.IElementComparer {
	*** equals(java.lang.Object,java.lang.Object);
	*** hashCode(java.lang.Object);
}

-keep class org.eclipse.jdt.internal.junit.runner.IListensToTestExecutions {
	*** notifyTestEnded(org.eclipse.jdt.internal.junit.runner.ITestIdentifier);
	*** notifyTestFailed(org.eclipse.jdt.internal.junit.runner.TestReferenceFailure);
	*** notifyTestStarted(org.eclipse.jdt.internal.junit.runner.ITestIdentifier);
}

-keep class org.eclipse.jdt.internal.junit.runner.IStopListener {
	*** stop();
}

-keep class org.eclipse.jdt.internal.junit.runner.ITestIdentifier {
	*** getName();
}

-keep class org.eclipse.jdt.internal.junit.runner.ITestLoader {
	*** loadTests(java.lang.Class[],java.lang.String,java.lang.String[],org.eclipse.jdt.internal.junit.runner.RemoteTestRunner);
}

-keep class org.eclipse.jdt.internal.junit.runner.ITestPrioritizer {
	*** prioritize(junit.framework.Test);
}

-keep class org.eclipse.jdt.internal.junit.runner.ITestReference {
	*** countTestCases();
	*** getIdentifier();
	*** run(org.eclipse.jdt.internal.junit.runner.TestExecution);
	*** sendTree(org.eclipse.jdt.internal.junit.runner.IVisitsTestTrees);
}

-keep class org.eclipse.jdt.internal.junit.runner.IVisitsTestTrees {
	*** visitTreeEntry(org.eclipse.jdt.internal.junit.runner.ITestIdentifier,boolean,int);
}

-keep class org.eclipse.jdt.internal.junit.runner.JUnitMessages {
	*** RESOURCE_BUNDLE;
	*** getFormattedString(java.lang.String,java.lang.Object);
	*** getFormattedString(java.lang.String,java.lang.Object[]);
	*** getString(java.lang.String);
}

-keep class org.eclipse.jdt.internal.junit.runner.MessageSender {
	*** flush();
	*** sendMessage(java.lang.String);
}

-keep class org.eclipse.jdt.internal.junit.runner.RemoteTestRunner {
	*** class$0;
	*** fClientSocket;
	*** fConsoleMode;
	*** fDebugMode;
	*** fExecution;
	*** fFailureNames;
	*** fHost;
	*** fIds;
	*** fKeepAlive;
	*** fLoader;
	*** fPort;
	*** fReader;
	*** fReaderThread;
	*** fRerunRequests;
	*** fRerunTest;
	*** fSender;
	*** fStopped;
	*** fTestClassNames;
	*** fTestName;
	*** fVersion;
	*** fWriter;
	*** access$0(org.eclipse.jdt.internal.junit.runner.RemoteTestRunner);
	*** access$1(org.eclipse.jdt.internal.junit.runner.RemoteTestRunner,boolean);
	*** access$2(org.eclipse.jdt.internal.junit.runner.RemoteTestRunner);
	*** connect();
	*** countTests(org.eclipse.jdt.internal.junit.runner.ITestReference[]);
	*** createLoader(java.lang.String);
	*** createRawTestLoader(java.lang.String);
	*** defaultInit(java.lang.String[]);
	*** escapeComma(java.lang.String);
	*** firstRunExecutionListener();
	*** getClassifier();
	*** getTestClassLoader();
	*** getTestId(org.eclipse.jdt.internal.junit.runner.ITestIdentifier);
	*** getTestLoader();
	*** init(java.lang.String[]);
	*** initDefaultLoader();
	*** loadClass(java.lang.String,org.eclipse.jdt.internal.junit.runner.RemoteTestRunner);
	*** loadClasses(java.lang.String[]);
	*** loadTestLoaderClass(java.lang.String);
	*** notifyListenersOfTestEnd(org.eclipse.jdt.internal.junit.runner.TestExecution,long);
	*** notifyRerunComplete(org.eclipse.jdt.internal.junit.runner.RemoteTestRunner$RerunRequest,java.lang.String);
	*** notifyTestRunEnded(long);
	*** notifyTestRunStarted(int);
	*** notifyTestRunStopped(long);
	*** notifyTestTreeEntry(java.lang.String);
	*** readFailureNames(java.lang.String);
	*** readTestNames(java.lang.String);
	*** rerunExecutionListener();
	*** rerunTest(org.eclipse.jdt.internal.junit.runner.RemoteTestRunner$RerunRequest);
	*** run();
	*** runFailed(java.lang.String,java.lang.Exception);
	*** runTests(java.lang.String[],java.lang.String,org.eclipse.jdt.internal.junit.runner.TestExecution);
	*** runTests(org.eclipse.jdt.internal.junit.runner.TestExecution);
	*** sendTrees(org.eclipse.jdt.internal.junit.runner.ITestReference[]);
	*** setLoader(org.eclipse.jdt.internal.junit.runner.ITestLoader);
	*** setMessageSender(org.eclipse.jdt.internal.junit.runner.MessageSender);
	*** shutDown();
	*** stop();
	*** waitForReruns();
}

-keep class org.eclipse.jdt.internal.junit.runner.RemoteTestRunner$ReaderThread {
	*** this$0;
}

-keep class org.eclipse.jdt.internal.junit.runner.RemoteTestRunner$RerunRequest {
	*** fRerunClassName;
	*** fRerunTestId;
	*** fRerunTestName;
}

-keep class org.eclipse.jdt.internal.junit.runner.RerunExecutionListener {
	*** fStatus;
	*** getStatus();
}

-keep class org.eclipse.jdt.internal.junit.runner.TestExecution {
	*** fClassifier;
	*** fExecutionListener;
	*** fShouldStop;
	*** fStopListeners;
	*** addStopListener(org.eclipse.jdt.internal.junit.runner.IStopListener);
	*** getClassifier();
	*** getListener();
	*** run(org.eclipse.jdt.internal.junit.runner.ITestReference[]);
	*** shouldStop();
	*** stop();
}

-keep class org.eclipse.jdt.internal.junit.runner.TestIdMap {
	*** fIdMap;
	*** fNextId;
	*** getTestId(org.eclipse.jdt.internal.junit.runner.ITestIdentifier);
}

-keep class org.eclipse.jdt.internal.junit.runner.TestReferenceFailure {
	*** fComparison;
	*** fStatus;
	*** fTest;
	*** fTrace;
	org.eclipse.jdt.internal.junit.runner.TestReferenceFailure(org.eclipse.jdt.internal.junit.runner.ITestIdentifier,java.lang.String,java.lang.String);
	org.eclipse.jdt.internal.junit.runner.TestReferenceFailure(org.eclipse.jdt.internal.junit.runner.ITestIdentifier,java.lang.String,java.lang.String,org.eclipse.jdt.internal.junit.runner.FailedComparison);
	*** getComparison();
	*** getStatus();
	*** getTest();
	*** getTrace();
	*** setComparison(org.eclipse.jdt.internal.junit.runner.FailedComparison);
}

-keep class org.eclipse.jdt.internal.junit.runner.junit3.JUnit3Identifier {
	*** ref;
}

-keep class org.eclipse.jdt.internal.junit.runner.junit3.JUnit3Listener {
	*** fClassifier;
	*** fNotified;
	*** id(junit.framework.Test);
	*** newReference(junit.framework.Test);
}

-keep class org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestLoader {
	*** class$0;
	*** class$1;
	*** createTest(java.lang.String,java.lang.Class);
	*** error(java.lang.String,java.lang.String);
	*** getTest(java.lang.Class,java.lang.String,org.eclipse.jdt.internal.junit.runner.RemoteTestRunner);
	*** setupTest(java.lang.Class,junit.framework.Test,java.lang.String);
}

-keep class org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestLoader$1 {
	*** this$0;
	*** val$message;
}

-keep class org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference {
	*** fTest;
	*** callJUnit4GetterMethod(junit.framework.Test,java.lang.String);
	*** equals(java.lang.Object);
	*** getField(java.lang.Object,java.lang.String);
	*** getIdentifier();
	*** getName();
	*** hashCode();
	*** isJUnit4TestCaseAdapter(junit.framework.Test);
	*** isJUnit4TestSuiteAdapter(junit.framework.Test);
	*** sendFailure(java.lang.Throwable,org.eclipse.jdt.internal.junit.runner.IClassifiesThrowables,java.lang.String,org.eclipse.jdt.internal.junit.runner.IListensToTestExecutions);
	*** sendTree(org.eclipse.jdt.internal.junit.runner.IVisitsTestTrees);
	*** sendTreeOfChild(junit.framework.Test,org.eclipse.jdt.internal.junit.runner.IVisitsTestTrees);
}

-keep class org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference$1 {
	*** this$0;
	*** val$testResult;
}

-keep class org.eclipse.jdt.internal.junit4.runner.FailuresFirstSorter {
	*** failuresList;
	*** compare(org.junit.runner.Description,org.junit.runner.Description);
	*** hasFailures(org.junit.runner.Description);
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4Identifier {
	*** fPlan;
	org.eclipse.jdt.internal.junit4.runner.JUnit4Identifier(org.junit.runner.Description);
	*** getName();
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4TestClassReference {
	*** fClass;
	*** getIdentifier();
	*** sendDescriptionTree(org.eclipse.jdt.internal.junit.runner.IVisitsTestTrees,org.junit.runner.Description);
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4TestListener {
	*** fNotified;
	*** getIdentifier(org.junit.runner.Description,boolean,boolean);
	*** testFailure(org.junit.runner.notification.Failure,boolean);
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader {
	*** createTest(java.lang.Class,java.lang.String,java.lang.String[],org.eclipse.jdt.internal.junit.runner.RemoteTestRunner);
	*** isJUnit3SetUpTest(java.lang.Class,java.lang.String);
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4TestMethodReference {
	*** fDescription;
	*** createRequest(java.lang.Class,java.lang.String);
	*** getIdentifier();
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference {
	*** fRunner;
	org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference(org.junit.runner.Request,java.lang.String[]);
}

-keep class org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference$1 {
	*** this$0;
	*** val$notifier;
}

-keep class org.eclipse.jetty.client.HttpClient {
	*** getTimeout();
	*** send(org.eclipse.jetty.client.HttpExchange);
	*** setConnectorType(int);
	*** setIdleTimeout(long);
	*** setMaxConnectionsPerAddress(int);
}

-keep class org.eclipse.jetty.client.HttpExchange {
	*** cancel();
	*** setMethod(java.lang.String);
	*** setRequestContent(org.eclipse.jetty.io.Buffer);
	*** setRequestContentType(java.lang.String);
	*** setRequestHeader(java.lang.String,java.lang.String);
	*** setTimeout(long);
	*** setURL(java.lang.String);
}

-keep class org.eclipse.jetty.continuation.Continuation {
	*** setTimeout(long);
	*** suspend(javax.servlet.ServletResponse);
}

-keep class org.eclipse.jetty.continuation.ContinuationListener {
	*** onComplete(org.eclipse.jetty.continuation.Continuation);
	*** onTimeout(org.eclipse.jetty.continuation.Continuation);
}

-keep class org.eclipse.jetty.continuation.ContinuationSupport {
	*** getContinuation(javax.servlet.ServletRequest);
}

-keep class org.eclipse.jetty.http.AbstractGenerator {
	*** LOG;
	*** NO_BYTES;
	*** _buffer;
	*** _buffers;
	*** _content;
	*** _contentLength;
	*** _contentWritten;
	*** _date;
	*** _endp;
	*** _head;
	*** _header;
	*** _last;
	*** _method;
	*** _noContent;
	*** _persistent;
	*** _reason;
	*** _sendServerVersion;
	*** _state;
	*** _status;
	*** _uri;
	*** _version;
	org.eclipse.jetty.http.AbstractGenerator(org.eclipse.jetty.io.Buffers,org.eclipse.jetty.io.EndPoint);
	*** blockForOutput(long);
	*** complete();
	*** completeHeader(org.eclipse.jetty.http.HttpFields,boolean);
	*** completeUncheckedAddContent();
	*** flush(long);
	*** flushBuffer();
	*** getContentWritten();
	*** getSendServerVersion();
	*** getUncheckedBuffer();
	*** isAllContentWritten();
	*** isBufferFull();
	*** isCommitted();
	*** isOpen();
	*** isRequest();
	*** isWritten();
	*** prepareUncheckedAddContent();
	*** reset();
	*** setResponse(int,java.lang.String);
}

-keep class org.eclipse.jetty.http.EncodedHttpURI {
	*** _encoding;
	*** toString();
}

-keep class org.eclipse.jetty.http.Generator {
	*** addContent(org.eclipse.jetty.io.Buffer,boolean);
	*** complete();
	*** completeHeader(org.eclipse.jetty.http.HttpFields,boolean);
	*** flushBuffer();
	*** getContentBufferSize();
	*** getContentWritten();
	*** increaseContentBufferSize(int);
	*** isAllContentWritten();
	*** isCommitted();
	*** isComplete();
	*** isIdle();
	*** isPersistent();
	*** isWritten();
	*** reset();
	*** resetBuffer();
	*** returnBuffers();
	*** sendError(int,java.lang.String,java.lang.String,boolean);
	*** setContentLength(long);
	*** setDate(org.eclipse.jetty.io.Buffer);
	*** setHead(boolean);
	*** setPersistent(boolean);
	*** setResponse(int,java.lang.String);
	*** setSendServerVersion(boolean);
	*** setVersion(int);
}

-keep class org.eclipse.jetty.http.HttpBuffers {
	*** getRequestBuffers();
	*** getResponseBuffers();
}

-keep class org.eclipse.jetty.http.HttpBuffersImpl {
	*** _maxBuffers;
	*** _requestBufferSize;
	*** _requestBufferType;
	*** _requestBuffers;
	*** _requestHeaderSize;
	*** _requestHeaderType;
	*** _responseBufferSize;
	*** _responseBufferType;
	*** _responseBuffers;
	*** _responseHeaderSize;
	*** _responseHeaderType;
	*** getMaxBuffers();
	*** getRequestBufferSize();
	*** getRequestBufferType();
	*** getRequestBuffers();
	*** getRequestHeaderSize();
	*** getRequestHeaderType();
	*** getResponseBufferSize();
	*** getResponseBufferType();
	*** getResponseBuffers();
	*** getResponseHeaderSize();
	*** getResponseHeaderType();
	*** setMaxBuffers(int);
	*** setRequestBufferSize(int);
	*** setRequestBufferType(org.eclipse.jetty.io.Buffers$Type);
	*** setRequestBuffers(org.eclipse.jetty.io.Buffers);
	*** setRequestHeaderSize(int);
	*** setRequestHeaderType(org.eclipse.jetty.io.Buffers$Type);
	*** setResponseBufferSize(int);
	*** setResponseBufferType(org.eclipse.jetty.io.Buffers$Type);
	*** setResponseBuffers(org.eclipse.jetty.io.Buffers);
	*** setResponseHeaderSize(int);
	*** setResponseHeaderType(org.eclipse.jetty.io.Buffers$Type);
}

-keep class org.eclipse.jetty.http.HttpContent {
	*** getContentLength();
	*** getContentType();
	*** getDirectBuffer();
	*** getIndirectBuffer();
	*** getInputStream();
	*** getLastModified();
	*** getResource();
	*** release();
}

-keep class org.eclipse.jetty.http.HttpCookie {
	*** getComment();
	*** getDomain();
	*** getMaxAge();
	*** getName();
	*** getPath();
	*** getValue();
	*** getVersion();
	*** isHttpOnly();
	*** isSecure();
}

-keep class org.eclipse.jetty.http.HttpException {
	*** _reason;
	*** _status;
	*** getReason();
	*** getStatus();
}

-keep class org.eclipse.jetty.http.HttpFields {
	*** DAYS;
	*** LOG;
	*** MONTHS;
	*** __01Jan1970;
	*** __01Jan1970_BUFFER;
	*** __01Jan1970_COOKIE;
	*** __GMT;
	*** __cache;
	*** __cacheSize;
	*** __dateCache;
	*** __dateGenerator;
	*** __dateParser;
	*** __dateReceiveFmt;
	*** __one;
	*** __qualities;
	*** __zero;
	*** _fields;
	*** _names;
	*** access$000();
	*** access$100();
	*** add(java.lang.String,java.lang.String);
	*** add(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** addDateField(java.lang.String,long);
	*** addLongField(java.lang.String,long);
	*** addSetCookie(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long,java.lang.String,boolean,boolean,int);
	*** addSetCookie(org.eclipse.jetty.http.HttpCookie);
	*** clear();
	*** containsKey(java.lang.String);
	*** containsKey(org.eclipse.jetty.io.Buffer);
	*** convertValue(java.lang.String);
	*** formatCookieDate(java.lang.StringBuilder,long);
	*** formatCookieDate(long);
	*** formatDate(long);
	*** get(org.eclipse.jetty.io.Buffer);
	*** getDateField(java.lang.String);
	*** getField(int);
	*** getField(java.lang.String);
	*** getField(org.eclipse.jetty.io.Buffer);
	*** getFieldNames();
	*** getLongField(java.lang.String);
	*** getLongField(org.eclipse.jetty.io.Buffer);
	*** getQuality(java.lang.String);
	*** getStringField(java.lang.String);
	*** getStringField(org.eclipse.jetty.io.Buffer);
	*** getValues(java.lang.String);
	*** getValues(java.lang.String,java.lang.String);
	*** getValues(org.eclipse.jetty.io.Buffer);
	*** put(java.lang.String,java.lang.String);
	*** put(org.eclipse.jetty.io.Buffer,java.lang.String);
	*** put(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** putDateField(java.lang.String,long);
	*** putDateField(org.eclipse.jetty.io.Buffer,long);
	*** putLongField(java.lang.String,long);
	*** putLongField(org.eclipse.jetty.io.Buffer,long);
	*** qualityList(java.util.Enumeration);
	*** remove(java.lang.String);
	*** remove(org.eclipse.jetty.io.Buffer);
	*** size();
	*** toString();
	*** valueParameters(java.lang.String,java.util.Map);
}

-keep class org.eclipse.jetty.http.HttpFields$1 {
	*** initialValue();
}

-keep class org.eclipse.jetty.http.HttpFields$2 {
	*** initialValue();
}

-keep class org.eclipse.jetty.http.HttpFields$DateGenerator {
	*** buf;
	*** gc;
	org.eclipse.jetty.http.HttpFields$DateGenerator();
	*** formatCookieDate(java.lang.StringBuilder,long);
	*** formatDate(long);
}

-keep class org.eclipse.jetty.http.HttpFields$DateParser {
	*** parse(java.lang.String);
}

-keep class org.eclipse.jetty.http.HttpFields$Field {
	*** _name;
	*** _next;
	*** _value;
	org.eclipse.jetty.http.HttpFields$Field(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** access$500(org.eclipse.jetty.http.HttpFields$Field);
	*** access$600(org.eclipse.jetty.http.HttpFields$Field);
	*** access$602(org.eclipse.jetty.http.HttpFields$Field,org.eclipse.jetty.http.HttpFields$Field);
	*** getLongValue();
	*** getName();
	*** getNameOrdinal();
	*** getValue();
	*** getValueBuffer();
	*** getValueOrdinal();
	*** putTo(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.http.HttpGenerator {
	*** CONNECTION_;
	*** CONNECTION_CLOSE;
	*** CONNECTION_KEEP_ALIVE;
	*** CONTENT_LENGTH_0;
	*** CRLF;
	*** LAST_CHUNK;
	*** LOG;
	*** SERVER;
	*** TRANSFER_ENCODING_CHUNKED;
	*** __status;
	*** _bufferChunked;
	*** _bypass;
	*** _needCRLF;
	*** _needEOC;
	*** flushBuffer();
	*** flushMask();
	*** isRequest();
	*** isResponse();
	*** prepareBuffers();
	*** send1xx(int);
	*** sendResponse(org.eclipse.jetty.io.Buffer);
	*** setServerVersion(java.lang.String);
}

-keep class org.eclipse.jetty.http.HttpGenerator$Status {
	*** _reason;
	*** _responseLine;
	*** _schemeCode;
	org.eclipse.jetty.http.HttpGenerator$Status();
}

-keep class org.eclipse.jetty.http.HttpHeaderValues {
	*** BYTES_BUFFER;
	*** CACHE;
	*** CHUNKED_BUFFER;
	*** CLOSE_BUFFER;
	*** CONTINUE_BUFFER;
	*** GZIP_BUFFER;
	*** IDENTITY_BUFFER;
	*** KEEP_ALIVE_BUFFER;
	*** NO_CACHE_BUFFER;
	*** PROCESSING_BUFFER;
	*** TE_BUFFER;
	*** UPGRADE_BUFFER;
	*** hasKnownValues(int);
}

-keep class org.eclipse.jetty.http.HttpHeaders {
	*** ACCEPT_BUFFER;
	*** ACCEPT_CHARSET_BUFFER;
	*** ACCEPT_ENCODING_BUFFER;
	*** ACCEPT_LANGUAGE_BUFFER;
	*** ACCEPT_RANGES_BUFFER;
	*** AGE_BUFFER;
	*** ALLOW_BUFFER;
	*** AUTHORIZATION_BUFFER;
	*** CACHE;
	*** CACHE_CONTROL_BUFFER;
	*** CONNECTION_BUFFER;
	*** CONTENT_ENCODING_BUFFER;
	*** CONTENT_LANGUAGE_BUFFER;
	*** CONTENT_LENGTH_BUFFER;
	*** CONTENT_LOCATION_BUFFER;
	*** CONTENT_MD5_BUFFER;
	*** CONTENT_RANGE_BUFFER;
	*** CONTENT_TYPE_BUFFER;
	*** COOKIE_BUFFER;
	*** DATE_BUFFER;
	*** ETAG_BUFFER;
	*** EXPECT_BUFFER;
	*** EXPIRES_BUFFER;
	*** FORWARDED_BUFFER;
	*** FROM_BUFFER;
	*** HOST_BUFFER;
	*** IDENTITY_BUFFER;
	*** IF_MATCH_BUFFER;
	*** IF_MODIFIED_SINCE_BUFFER;
	*** IF_NONE_MATCH_BUFFER;
	*** IF_RANGE_BUFFER;
	*** IF_UNMODIFIED_SINCE_BUFFER;
	*** KEEP_ALIVE_BUFFER;
	*** LAST_MODIFIED_BUFFER;
	*** LOCATION_BUFFER;
	*** MAX_FORWARDS_BUFFER;
	*** MIME_VERSION_BUFFER;
	*** PRAGMA_BUFFER;
	*** PROXY_AUTHENTICATE_BUFFER;
	*** PROXY_AUTHORIZATION_BUFFER;
	*** PROXY_CONNECTION_BUFFER;
	*** RANGE_BUFFER;
	*** REFERER_BUFFER;
	*** REQUEST_RANGE_BUFFER;
	*** RETRY_AFTER_BUFFER;
	*** SERVER_BUFFER;
	*** SERVLET_ENGINE_BUFFER;
	*** SET_COOKIE2_BUFFER;
	*** SET_COOKIE_BUFFER;
	*** TE_BUFFER;
	*** TRAILER_BUFFER;
	*** TRANSFER_ENCODING_BUFFER;
	*** UPGRADE_BUFFER;
	*** USER_AGENT_BUFFER;
	*** VARY_BUFFER;
	*** VIA_BUFFER;
	*** WARNING_BUFFER;
	*** WWW_AUTHENTICATE_BUFFER;
	*** X_FORWARDED_FOR_BUFFER;
	*** X_FORWARDED_HOST_BUFFER;
	*** X_FORWARDED_PROTO_BUFFER;
	*** X_FORWARDED_SERVER_BUFFER;
}

-keep class org.eclipse.jetty.http.HttpMethods {
	*** CACHE;
	*** CONNECT_BUFFER;
	*** DELETE_BUFFER;
	*** GET_BUFFER;
	*** HEAD_BUFFER;
	*** MOVE_BUFFER;
	*** OPTIONS_BUFFER;
	*** POST_BUFFER;
	*** PUT_BUFFER;
	*** TRACE_BUFFER;
}

-keep class org.eclipse.jetty.http.HttpParser {
	*** LOG;
	*** _body;
	*** _buffer;
	*** _buffers;
	*** _cached;
	*** _chunkLength;
	*** _chunkPosition;
	*** _contentLength;
	*** _contentPosition;
	*** _contentView;
	*** _endp;
	*** _eol;
	*** _forceContentBuffer;
	*** _handler;
	*** _headResponse;
	*** _header;
	*** _length;
	*** _multiLineValue;
	*** _persistent;
	*** _responseStatus;
	*** _state;
	*** _tok0;
	*** _tok1;
	*** available();
	*** blockForContent(long);
	*** fill();
	*** getContentLength();
	*** getContentRead();
	*** getHeaderBuffer();
	*** getState();
	*** isChunking();
	*** isComplete();
	*** isIdle();
	*** isState(int);
	*** parseNext();
	*** reset();
	*** returnBuffers();
	*** toString();
}

-keep class org.eclipse.jetty.http.HttpParser$EventHandler {
	org.eclipse.jetty.http.HttpParser$EventHandler();
	*** content(org.eclipse.jetty.io.Buffer);
	*** earlyEOF();
	*** headerComplete();
	*** messageComplete(long);
	*** parsedHeader(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** startRequest(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** startResponse(org.eclipse.jetty.io.Buffer,int,org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.http.HttpStatus {
	*** codeMap;
	*** getCode(int);
	*** getMessage(int);
	*** isClientError(int);
	*** isInformational(int);
	*** isRedirection(int);
	*** isServerError(int);
	*** isSuccess(int);
}

-keep class org.eclipse.jetty.http.HttpStatus$Code {
	*** $VALUES;
	*** ACCEPTED;
	*** BAD_GATEWAY;
	*** BAD_REQUEST;
	*** CONFLICT;
	*** CONTINUE;
	*** CREATED;
	*** EXPECTATION_FAILED;
	*** FAILED_DEPENDENCY;
	*** FORBIDDEN;
	*** FOUND;
	*** GATEWAY_TIMEOUT;
	*** GONE;
	*** HTTP_VERSION_NOT_SUPPORTED;
	*** INSUFFICIENT_STORAGE;
	*** INTERNAL_SERVER_ERROR;
	*** LENGTH_REQUIRED;
	*** LOCKED;
	*** METHOD_NOT_ALLOWED;
	*** MOVED_PERMANENTLY;
	*** MOVED_TEMPORARILY;
	*** MULTIPLE_CHOICES;
	*** MULTI_STATUS;
	*** NON_AUTHORITATIVE_INFORMATION;
	*** NOT_ACCEPTABLE;
	*** NOT_FOUND;
	*** NOT_IMPLEMENTED;
	*** NOT_MODIFIED;
	*** NO_CONTENT;
	*** OK;
	*** PARTIAL_CONTENT;
	*** PAYMENT_REQUIRED;
	*** PRECONDITION_FAILED;
	*** PROCESSING;
	*** PROXY_AUTHENTICATION_REQUIRED;
	*** REQUESTED_RANGE_NOT_SATISFIABLE;
	*** REQUEST_ENTITY_TOO_LARGE;
	*** REQUEST_TIMEOUT;
	*** REQUEST_URI_TOO_LONG;
	*** RESET_CONTENT;
	*** SEE_OTHER;
	*** SERVICE_UNAVAILABLE;
	*** SWITCHING_PROTOCOLS;
	*** TEMPORARY_REDIRECT;
	*** UNAUTHORIZED;
	*** UNPROCESSABLE_ENTITY;
	*** UNSUPPORTED_MEDIA_TYPE;
	*** USE_PROXY;
	*** _code;
	*** _message;
	*** access$000(org.eclipse.jetty.http.HttpStatus$Code);
	*** getMessage();
	*** values();
}

-keep class org.eclipse.jetty.http.HttpTokens {
	*** CRLF;
}

-keep class org.eclipse.jetty.http.HttpURI {
	*** __empty;
	*** _authority;
	*** _encoded;
	*** _end;
	*** _fragment;
	*** _host;
	*** _param;
	*** _partial;
	*** _path;
	*** _port;
	*** _portValue;
	*** _query;
	*** _raw;
	*** _rawString;
	*** _scheme;
	*** _utf8b;
	org.eclipse.jetty.http.HttpURI();
	*** clear();
	*** decodeQueryTo(org.eclipse.jetty.util.MultiMap);
	*** decodeQueryTo(org.eclipse.jetty.util.MultiMap,java.lang.String);
	*** getDecodedPath();
	*** getDecodedPath(java.lang.String);
	*** getFragment();
	*** getHost();
	*** getPath();
	*** getPathAndParam();
	*** getPort();
	*** getQuery();
	*** getQuery(java.lang.String);
	*** getScheme();
	*** hasQuery();
	*** parse(byte[],int,int);
	*** parse(java.lang.String);
	*** parse2(byte[],int,int);
	*** parseConnect(byte[],int,int);
	*** toUtf8String(int,int);
}

-keep class org.eclipse.jetty.http.HttpVersions {
	*** CACHE;
	*** HTTP_0_9_BUFFER;
	*** HTTP_1_0_BUFFER;
	*** HTTP_1_1_BUFFER;
}

-keep class org.eclipse.jetty.http.MimeTypes {
	*** CACHE;
	*** FORM_ENCODED_BUFFER;
	*** LOG;
	*** MESSAGE_HTTP_BUFFER;
	*** MULTIPART_BYTERANGES_BUFFER;
	*** TEXT_HTML_8859_1_BUFFER;
	*** TEXT_HTML_BUFFER;
	*** TEXT_HTML_UTF_8_BUFFER;
	*** TEXT_HTML__8859_1_BUFFER;
	*** TEXT_HTML__UTF_8_BUFFER;
	*** TEXT_JSON_BUFFER;
	*** TEXT_JSON_UTF_8_BUFFER;
	*** TEXT_JSON__UTF_8_BUFFER;
	*** TEXT_PLAIN_8859_1_BUFFER;
	*** TEXT_PLAIN_BUFFER;
	*** TEXT_PLAIN_UTF_8_BUFFER;
	*** TEXT_PLAIN__8859_1_BUFFER;
	*** TEXT_PLAIN__UTF_8_BUFFER;
	*** TEXT_XML_8859_1_BUFFER;
	*** TEXT_XML_BUFFER;
	*** TEXT_XML_UTF_8_BUFFER;
	*** TEXT_XML__8859_1_BUFFER;
	*** TEXT_XML__UTF_8_BUFFER;
	*** __dftMimeMap;
	*** __encodings;
	*** __index;
	*** _mimeMap;
	*** getCharsetFromContentType(org.eclipse.jetty.io.Buffer);
	*** getMimeByExtension(java.lang.String);
	*** normalizeMimeType(java.lang.String);
}

-keep class org.eclipse.jetty.http.Parser {
	*** isComplete();
	*** isIdle();
	*** isPersistent();
	*** parseAvailable();
	*** reset();
	*** returnBuffers();
	*** setPersistent(boolean);
}

-keep class org.eclipse.jetty.http.PathMap {
	*** __pathSpecSeparators;
	*** _default;
	*** _defaultSingletonList;
	*** _entrySet;
	*** _exactMap;
	*** _nodefault;
	*** _prefixDefault;
	*** _prefixMap;
	*** _suffixMap;
	*** clear();
	*** getLazyMatches(java.lang.String);
	*** getMatch(java.lang.String);
	*** isPathWildcardMatch(java.lang.String,java.lang.String);
	*** match(java.lang.String);
	*** match(java.lang.String,java.lang.String,boolean);
	*** pathInfo(java.lang.String,java.lang.String);
	*** pathMatch(java.lang.String,java.lang.String);
	*** put(java.lang.Object,java.lang.Object);
}

-keep class org.eclipse.jetty.http.PathMap$Entry {
	*** key;
	*** mapped;
	*** string;
	*** value;
	*** getKey();
	*** getMapped();
	*** getValue();
	*** setMapped(java.lang.String);
}

-keep class org.eclipse.jetty.io.AbstractBuffer {
	*** $assertionsDisabled;
	*** LOG;
	*** __boundsChecking;
	*** _access;
	*** _get;
	*** _hash;
	*** _hashGet;
	*** _hashPut;
	*** _mark;
	*** _put;
	*** _string;
	*** _view;
	*** _volatile;
	org.eclipse.jetty.io.AbstractBuffer(int,boolean);
	*** asArray();
	*** buffer();
	*** clear();
	*** duplicate(int);
	*** equals(java.lang.Object);
	*** equalsIgnoreCase(org.eclipse.jetty.io.Buffer);
	*** getIndex();
	*** hasContent();
	*** isImmutable();
	*** isReadOnly();
	*** isVolatile();
	*** length();
	*** markIndex();
	*** peek(int,int);
	*** poke(int,byte[],int,int);
	*** poke(int,org.eclipse.jetty.io.Buffer);
	*** put(byte);
	*** put(byte[],int,int);
	*** putIndex();
	*** setGetIndex(int);
	*** setMarkIndex(int);
	*** setPutIndex(int);
	*** skip(int);
	*** sliceFromMark(int);
	*** space();
	*** toString();
	*** toString(java.lang.String);
}

-keep class org.eclipse.jetty.io.AbstractBuffers {
	*** _bufferSize;
	*** _bufferType;
	*** _headerSize;
	*** _headerType;
	*** _otherType;
	org.eclipse.jetty.io.AbstractBuffers(org.eclipse.jetty.io.Buffers$Type,int,org.eclipse.jetty.io.Buffers$Type,int,org.eclipse.jetty.io.Buffers$Type);
	*** getBufferSize();
	*** getHeaderSize();
	*** isBuffer(org.eclipse.jetty.io.Buffer);
	*** isHeader(org.eclipse.jetty.io.Buffer);
	*** newBuffer();
	*** newBuffer(int);
	*** newHeader();
}

-keep class org.eclipse.jetty.io.AbstractBuffers$1 {
	*** $SwitchMap$org$eclipse$jetty$io$Buffers$Type;
}

-keep class org.eclipse.jetty.io.AbstractConnection {
	*** LOG;
	*** _endp;
	*** _timeStamp;
	org.eclipse.jetty.io.AbstractConnection(org.eclipse.jetty.io.EndPoint);
	*** getEndPoint();
	*** toString();
}

-keep class org.eclipse.jetty.io.AsyncEndPoint {
	*** asyncDispatch();
	*** cancelTimeout(org.eclipse.jetty.util.thread.Timeout$Task);
	*** hasProgressed();
	*** scheduleTimeout(org.eclipse.jetty.util.thread.Timeout$Task,long);
	*** setCheckForIdle(boolean);
}

-keep class org.eclipse.jetty.io.Buffer {
	*** array();
	*** asArray();
	*** asImmutableBuffer();
	*** buffer();
	*** capacity();
	*** clear();
	*** compact();
	*** equalsIgnoreCase(org.eclipse.jetty.io.Buffer);
	*** get();
	*** get(byte[],int,int);
	*** get(int);
	*** getIndex();
	*** hasContent();
	*** isImmutable();
	*** isReadOnly();
	*** isVolatile();
	*** length();
	*** mark();
	*** markIndex();
	*** peek();
	*** peek(int);
	*** peek(int,byte[],int,int);
	*** peek(int,int);
	*** poke(int,byte);
	*** poke(int,byte[],int,int);
	*** poke(int,org.eclipse.jetty.io.Buffer);
	*** put(byte);
	*** put(byte[]);
	*** put(org.eclipse.jetty.io.Buffer);
	*** putIndex();
	*** readFrom(java.io.InputStream,int);
	*** setGetIndex(int);
	*** setMarkIndex(int);
	*** setPutIndex(int);
	*** skip(int);
	*** sliceFromMark();
	*** space();
	*** toString(java.lang.String);
	*** writeTo(java.io.OutputStream);
}

-keep class org.eclipse.jetty.io.BufferCache {
	*** _bufferMap;
	*** _index;
	*** _stringMap;
	org.eclipse.jetty.io.BufferCache();
	*** add(java.lang.String,int);
	*** get(java.lang.String);
	*** get(org.eclipse.jetty.io.Buffer);
	*** getBest(byte[],int,int);
	*** getOrdinal(java.lang.String);
	*** getOrdinal(org.eclipse.jetty.io.Buffer);
	*** lookup(java.lang.String);
	*** lookup(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.io.BufferCache$CachedBuffer {
	*** _associateMap;
	*** _ordinal;
	*** getAssociate(java.lang.Object);
	*** getOrdinal();
	*** setAssociate(java.lang.Object,org.eclipse.jetty.io.BufferCache$CachedBuffer);
}

-keep class org.eclipse.jetty.io.BufferDateCache {
	*** _buffer;
	*** _last;
	*** formatBuffer(long);
}

-keep class org.eclipse.jetty.io.BufferUtil {
	*** DIGIT;
	*** decDivisors;
	*** decDivisorsL;
	*** hexDivisors;
	*** isPrefix(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** prependHexInt(org.eclipse.jetty.io.Buffer,int);
	*** putCRLF(org.eclipse.jetty.io.Buffer);
	*** putDecLong(org.eclipse.jetty.io.Buffer,long);
	*** putHexInt(org.eclipse.jetty.io.Buffer,int);
	*** to8859_1_String(org.eclipse.jetty.io.Buffer);
	*** toBuffer(long);
	*** toInt(org.eclipse.jetty.io.Buffer);
	*** toLong(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.io.Buffers {
	*** getBuffer();
	*** getBuffer(int);
	*** getHeader();
	*** returnBuffer(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.io.Buffers$Type {
	*** $VALUES;
	*** BYTE_ARRAY;
	*** DIRECT;
	*** INDIRECT;
	*** values();
}

-keep class org.eclipse.jetty.io.BuffersFactory {
	*** newBuffers(org.eclipse.jetty.io.Buffers$Type,int,org.eclipse.jetty.io.Buffers$Type,int,org.eclipse.jetty.io.Buffers$Type,int);
}

-keep class org.eclipse.jetty.io.ByteArrayBuffer {
	*** _bytes;
	org.eclipse.jetty.io.ByteArrayBuffer(byte[],int,int,int);
	org.eclipse.jetty.io.ByteArrayBuffer(byte[],int,int,int,boolean);
	org.eclipse.jetty.io.ByteArrayBuffer(int,int,boolean);
	org.eclipse.jetty.io.ByteArrayBuffer(java.lang.String);
	*** capacity();
	*** equalsIgnoreCase(org.eclipse.jetty.io.Buffer);
	*** space();
}

-keep class org.eclipse.jetty.io.ByteArrayBuffer$CaseInsensitive {
	org.eclipse.jetty.io.ByteArrayBuffer$CaseInsensitive(java.lang.String);
}

-keep class org.eclipse.jetty.io.ConnectedEndPoint {
	*** getConnection();
}

-keep class org.eclipse.jetty.io.Connection {
	*** getTimeStamp();
	*** handle();
	*** isSuspended();
	*** onClose();
	*** onIdleExpired(long);
}

-keep class org.eclipse.jetty.io.EndPoint {
	*** blockReadable(long);
	*** blockWritable(long);
	*** close();
	*** fill(org.eclipse.jetty.io.Buffer);
	*** flush();
	*** flush(org.eclipse.jetty.io.Buffer);
	*** flush(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** getLocalAddr();
	*** getLocalHost();
	*** getLocalPort();
	*** getMaxIdleTime();
	*** getRemoteAddr();
	*** getRemoteHost();
	*** getRemotePort();
	*** isBlocking();
	*** isInputShutdown();
	*** isOpen();
	*** isOutputShutdown();
	*** setMaxIdleTime(int);
	*** shutdownOutput();
}

-keep class org.eclipse.jetty.io.PooledBuffers {
	*** _buffers;
	*** _headers;
	*** _maxSize;
	*** _otherBuffers;
	*** _otherHeaders;
	*** _others;
	*** _size;
	*** getBuffer();
	*** getHeader();
}

-keep class org.eclipse.jetty.io.UncheckedPrintWriter {
	*** LOG;
	*** _autoFlush;
	*** _ioException;
	*** _isClosed;
	*** _lineSeparator;
	org.eclipse.jetty.io.UncheckedPrintWriter(java.io.OutputStream,boolean);
	org.eclipse.jetty.io.UncheckedPrintWriter(java.io.Writer,boolean);
	*** isOpen();
	*** newLine();
	*** print(boolean);
	*** print(char);
	*** print(char[]);
	*** print(double);
	*** print(float);
	*** print(int);
	*** print(java.lang.Object);
	*** print(java.lang.String);
	*** print(long);
	*** println();
	*** setError(java.lang.Throwable);
	*** write(char[]);
	*** write(char[],int,int);
	*** write(int);
	*** write(java.lang.String);
	*** write(java.lang.String,int,int);
}

-keep class org.eclipse.jetty.io.View {
	*** _buffer;
	org.eclipse.jetty.io.View();
	org.eclipse.jetty.io.View(org.eclipse.jetty.io.Buffer);
	org.eclipse.jetty.io.View(org.eclipse.jetty.io.Buffer,int,int,int,int);
	*** equals(java.lang.Object);
	*** update(int,int);
	*** update(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.io.WriterOutputStream {
	*** _buf;
	*** _encoding;
	*** _writer;
	*** write(byte[]);
}

-keep class org.eclipse.jetty.io.bio.StreamEndPoint {
	*** getInputStream();
}

-keep class org.eclipse.jetty.io.nio.AsyncConnection {
	*** onInputShutdown();
}

-keep class org.eclipse.jetty.io.nio.ChannelEndPoint {
	*** LOG;
	*** _channel;
	*** _gather2;
	*** _ishut;
	*** _local;
	*** _maxIdleTime;
	*** _oshut;
	*** _remote;
	*** _socket;
	org.eclipse.jetty.io.nio.ChannelEndPoint(java.nio.channels.ByteChannel,int);
	*** close();
	*** fill(org.eclipse.jetty.io.Buffer);
	*** flush(org.eclipse.jetty.io.Buffer);
	*** flush(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** gatheringFlush(org.eclipse.jetty.io.Buffer,java.nio.ByteBuffer,org.eclipse.jetty.io.Buffer,java.nio.ByteBuffer);
	*** getChannel();
	*** isInputShutdown();
	*** isOpen();
	*** isOutputShutdown();
	*** shutdownChannelInput();
	*** shutdownChannelOutput();
	*** shutdownInput();
}

-keep class org.eclipse.jetty.io.nio.DirectNIOBuffer {
	*** _buf;
	*** _in;
	*** _inStream;
	*** _out;
	*** _outStream;
	*** capacity();
	*** poke(int,byte[],int,int);
}

-keep class org.eclipse.jetty.io.nio.IndirectNIOBuffer {
	*** _buf;
}

-keep class org.eclipse.jetty.io.nio.NIOBuffer {
	*** getByteBuffer();
}

-keep class org.eclipse.jetty.io.nio.RandomAccessFileBuffer {
	*** writeTo(java.nio.channels.WritableByteChannel,int,int);
}

-keep class org.eclipse.jetty.io.nio.SelectChannelEndPoint {
	*** LOG;
	*** WORK_AROUND_JVM_BUG_6346658;
	*** _asyncDispatch;
	*** _connection;
	*** _dispatched;
	*** _handler;
	*** _idleTimestamp;
	*** _interestOps;
	*** _ishut;
	*** _key;
	*** _manager;
	*** _open;
	*** _readBlocked;
	*** _selectSet;
	*** _writable;
	*** _writeBlocked;
	*** checkIdleTimestamp(long);
	*** close();
	*** dispatch();
	*** doUpdateKey();
	*** getConnection();
	*** getSelectSet();
	*** handle();
	*** isCheckForIdle();
	*** notIdle();
	*** onIdleExpired(long);
	*** schedule();
	*** setCheckForIdle(boolean);
	*** setConnection(org.eclipse.jetty.io.Connection);
	*** undispatch();
	*** updateKey();
}

-keep class org.eclipse.jetty.io.nio.SelectChannelEndPoint$1 {
	*** this$0;
}

-keep class org.eclipse.jetty.io.nio.SelectChannelEndPoint$2 {
	*** this$0;
	*** val$idleForMs;
}

-keep class org.eclipse.jetty.io.nio.SelectorManager {
	*** LOG;
	*** __BUSY_PAUSE;
	*** __IDLE_TICK;
	*** __MAX_SELECTS;
	*** __MONITOR_PERIOD;
	*** _deferringInterestedOps0;
	*** _lowResourcesConnections;
	*** _lowResourcesMaxIdleTime;
	*** _maxIdleTime;
	*** _selectSet;
	*** _selectSets;
	*** _selectorPriorityDelta;
	*** _set;
	org.eclipse.jetty.io.nio.SelectorManager();
	*** access$000(org.eclipse.jetty.io.nio.SelectorManager);
	*** access$100();
	*** access$200();
	*** access$300();
	*** access$400();
	*** access$500(org.eclipse.jetty.io.nio.SelectorManager);
	*** access$600(org.eclipse.jetty.io.nio.SelectorManager);
	*** access$700(org.eclipse.jetty.io.nio.SelectorManager);
	*** connectionFailed(java.nio.channels.SocketChannel,java.lang.Throwable,java.lang.Object);
	*** dispatch(java.lang.Runnable);
	*** endPointClosed(org.eclipse.jetty.io.nio.SelectChannelEndPoint);
	*** endPointOpened(org.eclipse.jetty.io.nio.SelectChannelEndPoint);
	*** endPointUpgraded(org.eclipse.jetty.io.ConnectedEndPoint,org.eclipse.jetty.io.Connection);
	*** getSelectSets();
	*** getSelectorPriorityDelta();
	*** isDeferringInterestedOps0();
	*** newConnection(java.nio.channels.SocketChannel,org.eclipse.jetty.io.AsyncEndPoint,java.lang.Object);
	*** newEndPoint(java.nio.channels.SocketChannel,org.eclipse.jetty.io.nio.SelectorManager$SelectSet,java.nio.channels.SelectionKey);
	*** register(java.nio.channels.SocketChannel);
	*** setLowResourcesConnections(long);
	*** setLowResourcesMaxIdleTime(long);
	*** setMaxIdleTime(long);
	*** setSelectSets(int);
}

-keep class org.eclipse.jetty.io.nio.SelectorManager$1 {
	*** this$0;
	*** val$id;
}

-keep class org.eclipse.jetty.io.nio.SelectorManager$ChannelAndAttachment {
	*** _attachment;
	*** _channel;
}

-keep class org.eclipse.jetty.io.nio.SelectorManager$SelectSet {
	*** _busySelects;
	*** _changes;
	*** _endPoints;
	*** _idleTick;
	*** _monitorNext;
	*** _paused;
	*** _pausing;
	*** _selecting;
	*** _selector;
	*** _setID;
	*** _timeout;
	*** this$0;
	*** access$800(org.eclipse.jetty.io.nio.SelectorManager$SelectSet);
	*** addChange(java.lang.Object);
	*** addChange(java.nio.channels.SelectableChannel,java.lang.Object);
	*** cancelTimeout(org.eclipse.jetty.util.thread.Timeout$Task);
	*** createEndPoint(java.nio.channels.SocketChannel,java.nio.channels.SelectionKey);
	*** destroyEndPoint(org.eclipse.jetty.io.nio.SelectChannelEndPoint);
	*** doSelect();
	*** getManager();
	*** getNow();
	*** getSelector();
	*** renewSelector();
	*** scheduleTimeout(org.eclipse.jetty.util.thread.Timeout$Task,long);
	*** stop();
	*** wakeup();
}

-keep class org.eclipse.jetty.io.nio.SelectorManager$SelectSet$1 {
	*** this$1;
	*** val$idle_now;
}

-keep class org.eclipse.jetty.security.Authenticator {
	*** getAuthMethod();
	*** secureResponse(javax.servlet.ServletRequest,javax.servlet.ServletResponse,boolean,org.eclipse.jetty.server.Authentication$User);
	*** setConfiguration(org.eclipse.jetty.security.Authenticator$AuthConfiguration);
	*** validateRequest(javax.servlet.ServletRequest,javax.servlet.ServletResponse,boolean);
}

-keep class org.eclipse.jetty.security.Authenticator$Factory {
	*** getAuthenticator(org.eclipse.jetty.server.Server,javax.servlet.ServletContext,org.eclipse.jetty.security.Authenticator$AuthConfiguration,org.eclipse.jetty.security.IdentityService,org.eclipse.jetty.security.LoginService);
}

-keep class org.eclipse.jetty.security.ConstraintAware {
	*** getRoles();
}

-keep class org.eclipse.jetty.security.ConstraintMapping {
	*** getConstraint();
	*** getMethod();
	*** getPathSpec();
}

-keep class org.eclipse.jetty.security.ConstraintSecurityHandler {
	*** _constraintMap;
	*** _constraintMappings;
	*** _roles;
	*** _strict;
	*** addRole(java.lang.String);
	*** processConstraintMapping(org.eclipse.jetty.security.ConstraintMapping);
	*** setConstraintMappings(java.util.List,java.util.Set);
	*** setRoles(java.util.Set);
}

-keep class org.eclipse.jetty.security.IdentityService {
	*** associate(org.eclipse.jetty.server.UserIdentity);
	*** disassociate(java.lang.Object);
	*** getSystemUserIdentity();
	*** newRunAsToken(java.lang.String);
	*** setRunAs(org.eclipse.jetty.server.UserIdentity,org.eclipse.jetty.security.RunAsToken);
	*** unsetRunAs(java.lang.Object);
}

-keep class org.eclipse.jetty.security.LoginService {
	*** getIdentityService();
	*** getName();
	*** logout(org.eclipse.jetty.server.UserIdentity);
	*** setIdentityService(org.eclipse.jetty.security.IdentityService);
}

-keep class org.eclipse.jetty.security.RoleInfo {
	*** addRole(java.lang.String);
	*** combine(org.eclipse.jetty.security.RoleInfo);
	*** getRoles();
	*** getUserDataConstraint();
	*** isAnyRole();
	*** isChecked();
	*** isForbidden();
	*** setAnyRole(boolean);
	*** setChecked(boolean);
	*** setForbidden(boolean);
	*** setUserDataConstraint(org.eclipse.jetty.security.UserDataConstraint);
}

-keep class org.eclipse.jetty.security.SecurityHandler {
	*** LOG;
	*** __NOBODY;
	*** __NO_USER;
	*** _authMethod;
	*** _authenticator;
	*** _authenticatorFactory;
	*** _checkWelcomeFiles;
	*** _identityService;
	*** _initParameters;
	*** _loginService;
	*** _loginServiceShared;
	*** _realmName;
	*** _renewSession;
	org.eclipse.jetty.security.SecurityHandler();
	*** checkSecurity(org.eclipse.jetty.server.Request);
	*** checkUserDataPermissions(java.lang.String,org.eclipse.jetty.server.Request,org.eclipse.jetty.server.Response,java.lang.Object);
	*** checkWebResourcePermissions(java.lang.String,org.eclipse.jetty.server.Request,org.eclipse.jetty.server.Response,java.lang.Object,org.eclipse.jetty.server.UserIdentity);
	*** doStart();
	*** doStop();
	*** findIdentityService();
	*** findLoginService();
	*** getAuthenticator();
	*** getIdentityService();
	*** getInitParameter(java.lang.String);
	*** getLoginService();
	*** getRealmName();
	*** isAuthMandatory(org.eclipse.jetty.server.Request,org.eclipse.jetty.server.Response,java.lang.Object);
	*** prepareConstraintInfo(java.lang.String,org.eclipse.jetty.server.Request);
	*** setInitParameter(java.lang.String,java.lang.String);
}

-keep class org.eclipse.jetty.security.SecurityHandler$4 {
	*** $SwitchMap$javax$servlet$DispatcherType;
}

-keep class org.eclipse.jetty.security.UserDataConstraint {
	*** Confidential;
	*** Integral;
	*** None;
	*** get(int);
}

-keep class org.eclipse.jetty.security.authentication.DeferredAuthentication {
	*** getPreviousAssociation();
	*** setIdentityService(org.eclipse.jetty.security.IdentityService);
	*** setLoginService(org.eclipse.jetty.security.LoginService);
}

-keep class org.eclipse.jetty.server.AbstractConnector {
	*** LOG;
	*** _acceptQueueSize;
	*** _acceptorPriorityOffset;
	*** _acceptorThreads;
	*** _acceptors;
	*** _buffers;
	*** _confidentialPort;
	*** _confidentialScheme;
	*** _connectionDurationStats;
	*** _connectionStats;
	*** _forwarded;
	*** _forwardedCipherSuiteHeader;
	*** _forwardedForHeader;
	*** _forwardedHostHeader;
	*** _forwardedProtoHeader;
	*** _forwardedServerHeader;
	*** _forwardedSslSessionIdHeader;
	*** _host;
	*** _hostHeader;
	*** _integralPort;
	*** _integralScheme;
	*** _lowResourceMaxIdleTime;
	*** _maxIdleTime;
	*** _name;
	*** _port;
	*** _requestStats;
	*** _reuseAddress;
	*** _server;
	*** _soLingerTime;
	*** _statsStartedAt;
	*** _threadPool;
	*** _useDNS;
	org.eclipse.jetty.server.AbstractConnector();
	*** accept(int);
	*** access$000(org.eclipse.jetty.server.AbstractConnector);
	*** access$100(org.eclipse.jetty.server.AbstractConnector);
	*** access$200();
	*** checkForwardedHeaders(org.eclipse.jetty.io.EndPoint,org.eclipse.jetty.server.Request);
	*** configure(java.net.Socket);
	*** connectionClosed(org.eclipse.jetty.io.Connection);
	*** connectionOpened(org.eclipse.jetty.io.Connection);
	*** connectionUpgraded(org.eclipse.jetty.io.Connection,org.eclipse.jetty.io.Connection);
	*** customize(org.eclipse.jetty.io.EndPoint,org.eclipse.jetty.server.Request);
	*** doStart();
	*** getAcceptQueueSize();
	*** getAcceptors();
	*** getForwardedCipherSuiteHeader();
	*** getForwardedForHeader();
	*** getForwardedHostHeader();
	*** getForwardedProtoHeader();
	*** getForwardedServerHeader();
	*** getForwardedSslSessionIdHeader();
	*** getHost();
	*** getLeftMostFieldValue(org.eclipse.jetty.http.HttpFields,java.lang.String);
	*** getLowResourcesMaxIdleTime();
	*** getMaxIdleTime();
	*** getPort();
	*** getRequestBufferType();
	*** getReuseAddress();
	*** getServer();
	*** getThreadPool();
	*** isForwarded();
	*** persist(org.eclipse.jetty.io.EndPoint);
	*** setAcceptQueueSize(int);
	*** setAcceptors(int);
	*** setHost(java.lang.String);
	*** setLowResourcesMaxIdleTime(int);
	*** setMaxIdleTime(int);
	*** setName(java.lang.String);
	*** setPort(int);
	*** setThreadPool(org.eclipse.jetty.util.thread.ThreadPool);
	*** statsReset();
	*** updateNotEqual(java.util.concurrent.atomic.AtomicLong,long,long);
}

-keep class org.eclipse.jetty.server.AbstractConnector$Acceptor {
	*** _acceptor;
	*** this$0;
}

-keep class org.eclipse.jetty.server.AbstractHttpConnection {
	*** LOG;
	*** __currentConnection;
	*** _associatedObject;
	*** _charset;
	*** _connector;
	*** _delayedHandling;
	*** _earlyEOF;
	*** _expect;
	*** _expect100Continue;
	*** _expect102Processing;
	*** _generator;
	*** _head;
	*** _host;
	*** _in;
	*** _include;
	*** _out;
	*** _parser;
	*** _printWriter;
	*** _request;
	*** _requestFields;
	*** _requests;
	*** _response;
	*** _responseFields;
	*** _server;
	*** _uri;
	*** _version;
	*** _writer;
	org.eclipse.jetty.server.AbstractHttpConnection(org.eclipse.jetty.server.Connector,org.eclipse.jetty.io.EndPoint,org.eclipse.jetty.server.Server);
	*** access$100();
	*** commitResponse(boolean);
	*** completeResponse();
	*** content(org.eclipse.jetty.io.Buffer);
	*** earlyEOF();
	*** flushResponse();
	*** getConnector();
	*** getCurrentConnection();
	*** getGenerator();
	*** getInputStream();
	*** getMaxIdleTime();
	*** getOutputStream();
	*** getParser();
	*** getPrintWriter(java.lang.String);
	*** getRequest();
	*** getRequestFields();
	*** getRequests();
	*** getResolveNames();
	*** getResponse();
	*** getResponseFields();
	*** getServer();
	*** handleRequest();
	*** headerComplete();
	*** isConfidential(org.eclipse.jetty.server.Request);
	*** isEarlyEOF();
	*** isExpecting102Processing();
	*** isIncluding();
	*** isResponseCommitted();
	*** isSuspended();
	*** messageComplete(long);
	*** newHttpGenerator(org.eclipse.jetty.io.Buffers,org.eclipse.jetty.io.EndPoint);
	*** newHttpParser(org.eclipse.jetty.io.Buffers,org.eclipse.jetty.io.EndPoint,org.eclipse.jetty.http.HttpParser$EventHandler);
	*** parsedHeader(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
	*** reset();
	*** setCurrentConnection(org.eclipse.jetty.server.AbstractHttpConnection);
	*** startRequest(org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer,org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.server.AbstractHttpConnection$1 {
	*** this$0;
}

-keep class org.eclipse.jetty.server.AbstractHttpConnection$Output {
	*** this$0;
	*** flush();
	*** sendContent(java.lang.Object);
	*** sendResponse(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.server.AbstractHttpConnection$OutputWriter {
	*** this$0;
}

-keep class org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler {
	*** this$0;
	org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler(org.eclipse.jetty.server.AbstractHttpConnection);
}

-keep class org.eclipse.jetty.server.AsyncContinuation {
	*** LOG;
	*** __exception;
	*** _asyncListeners;
	*** _connection;
	*** _continuation;
	*** _continuationListeners;
	*** _event;
	*** _expireAt;
	*** _expired;
	*** _initial;
	*** _lastAsyncListeners;
	*** _responseWrapped;
	*** _resumed;
	*** _state;
	*** _timeoutMs;
	*** cancelTimeout();
	*** complete();
	*** dispatch();
	*** doComplete(java.lang.Throwable);
	*** doSuspend(javax.servlet.ServletContext,javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	*** expired();
	*** getAsyncEventState();
	*** getContextHandler();
	*** getRequest();
	*** getResponse();
	*** getStatusString();
	*** handling();
	*** isAsync();
	*** isAsyncStarted();
	*** isDispatchable();
	*** isInitial();
	*** isSuspended();
	*** isUncompleted();
	*** recycle();
	*** scheduleDispatch();
	*** scheduleTimeout();
	*** setConnection(org.eclipse.jetty.server.AbstractHttpConnection);
	*** suspend();
	*** suspend(javax.servlet.ServletContext,javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	*** unhandle();
}

-keep class org.eclipse.jetty.server.AsyncContinuation$AsyncEventState {
	*** _dispatchContext;
	*** _pathInContext;
	*** _suspendedContext;
	*** _timeout;
	*** this$0;
	*** access$002(org.eclipse.jetty.server.AsyncContinuation$AsyncEventState,javax.servlet.ServletContext);
	*** access$102(org.eclipse.jetty.server.AsyncContinuation$AsyncEventState,java.lang.String);
	*** access$200(org.eclipse.jetty.server.AsyncContinuation$AsyncEventState);
	*** getPath();
	*** getServletContext();
}

-keep class org.eclipse.jetty.server.AsyncHttpConnection {
	*** LOG;
	*** NO_PROGRESS_CLOSE;
	*** NO_PROGRESS_INFO;
	*** _asyncEndp;
	*** _readInterested;
	*** _total_no_progress;
	*** reset();
}

-keep class org.eclipse.jetty.server.Authentication {
	*** NOT_CHECKED;
	*** UNAUTHENTICATED;
}

-keep class org.eclipse.jetty.server.Authentication$Deferred {
	*** authenticate(javax.servlet.ServletRequest);
	*** authenticate(javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	*** login(java.lang.String,java.lang.String);
}

-keep class org.eclipse.jetty.server.Authentication$User {
	*** getAuthMethod();
	*** getUserIdentity();
	*** isUserInRole(org.eclipse.jetty.server.UserIdentity$Scope,java.lang.String);
	*** logout();
}

-keep class org.eclipse.jetty.server.Authentication$Wrapped {
	*** getHttpServletRequest();
	*** getHttpServletResponse();
}

-keep class org.eclipse.jetty.server.Connector {
	*** close();
	*** customize(org.eclipse.jetty.io.EndPoint,org.eclipse.jetty.server.Request);
	*** getConfidentialPort();
	*** getConfidentialScheme();
	*** getConnection();
	*** getIntegralPort();
	*** getIntegralScheme();
	*** getLocalPort();
	*** getLowResourceMaxIdleTime();
	*** getMaxIdleTime();
	*** getName();
	*** getResolveNames();
	*** getServer();
	*** isConfidential(org.eclipse.jetty.server.Request);
	*** isIntegral(org.eclipse.jetty.server.Request);
	*** isLowResources();
	*** open();
	*** persist(org.eclipse.jetty.io.EndPoint);
	*** setHost(java.lang.String);
	*** setPort(int);
	*** setServer(org.eclipse.jetty.server.Server);
}

-keep class org.eclipse.jetty.server.CookieCutter {
	*** LOG;
	*** _cookies;
	*** _fields;
	*** _lastCookies;
	*** _lazyFields;
	*** addCookieField(java.lang.String);
	*** getCookies();
	*** parseFields();
	*** reset();
	*** setCookies(javax.servlet.http.Cookie[]);
}

-keep class org.eclipse.jetty.server.Handler {
	*** destroy();
	*** getServer();
	*** handle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** setServer(org.eclipse.jetty.server.Server);
}

-keep class org.eclipse.jetty.server.HandlerContainer {
	*** getChildHandlers();
	*** getChildHandlersByClass(java.lang.Class);
	*** getHandlers();
}

-keep class org.eclipse.jetty.server.HttpInput {
	*** _connection;
	*** _parser;
	*** read(byte[],int,int);
}

-keep class org.eclipse.jetty.server.HttpOutput {
	*** _bytes;
	*** _characterEncoding;
	*** _chars;
	*** _closed;
	*** _connection;
	*** _converter;
	*** _generator;
	*** _onebyte;
	org.eclipse.jetty.server.HttpOutput(org.eclipse.jetty.server.AbstractHttpConnection);
	*** close();
	*** flush();
	*** getMaxIdleTime();
	*** isClosed();
	*** isWritten();
	*** reopen();
	*** write(byte[]);
	*** write(org.eclipse.jetty.io.Buffer);
}

-keep class org.eclipse.jetty.server.HttpWriter {
	*** _generator;
	*** _out;
	*** _surrogate;
	*** _writeMode;
	org.eclipse.jetty.server.HttpWriter(org.eclipse.jetty.server.HttpOutput);
	*** getConverter();
	*** setCharacterEncoding(java.lang.String);
	*** write(char[],int,int);
	*** write(java.lang.String,int,int);
}

-keep class org.eclipse.jetty.server.InclusiveByteRange {
	*** getFirst(long);
	*** getLast(long);
	*** getSize(long);
	*** satisfiableRanges(java.util.Enumeration,long);
	*** to416HeaderRangeString(long);
	*** toHeaderRangeString(long);
}

-keep class org.eclipse.jetty.server.Request {
	*** LOG;
	*** __defaultLocale;
	*** _async;
	*** _asyncSupported;
	*** _attributes;
	*** _authentication;
	*** _baseParameters;
	*** _characterEncoding;
	*** _connection;
	*** _context;
	*** _contextPath;
	*** _cookies;
	*** _cookiesExtracted;
	*** _dispatchTime;
	*** _dispatcherType;
	*** _dns;
	*** _endp;
	*** _handled;
	*** _inputState;
	*** _method;
	*** _multiPartInputStream;
	*** _newContext;
	*** _parameters;
	*** _paramsExtracted;
	*** _pathInfo;
	*** _port;
	*** _protocol;
	*** _queryEncoding;
	*** _queryString;
	*** _reader;
	*** _readerEncoding;
	*** _remoteAddr;
	*** _remoteHost;
	*** _requestAttributeListeners;
	*** _requestURI;
	*** _requestedSessionId;
	*** _requestedSessionIdFromCookie;
	*** _savedNewSessions;
	*** _scheme;
	*** _scope;
	*** _serverName;
	*** _servletPath;
	*** _session;
	*** _sessionManager;
	*** _timeStamp;
	*** _timeStampBuffer;
	*** _uri;
	*** addEventListener(java.util.EventListener);
	*** extractParameters();
	*** getAsyncContinuation();
	*** getAttribute(java.lang.String);
	*** getAuthType();
	*** getAuthentication();
	*** getCharacterEncoding();
	*** getConnection();
	*** getContentLength();
	*** getContentType();
	*** getContext();
	*** getContextPath();
	*** getDispatcherType();
	*** getInputStream();
	*** getLocalName();
	*** getLocalPort();
	*** getMethod();
	*** getParameter(java.lang.String);
	*** getParameters();
	*** getPathInfo();
	*** getProtocol();
	*** getQueryString();
	*** getRemoteAddr();
	*** getRequestURI();
	*** getResolvedUserIdentity();
	*** getResponse();
	*** getRootURL();
	*** getScheme();
	*** getServerName();
	*** getServerPort();
	*** getServletContext();
	*** getServletName();
	*** getServletPath();
	*** getServletResponse();
	*** getSession(boolean);
	*** getSessionManager();
	*** getTimeStamp();
	*** getTimeStampBuffer();
	*** getUserIdentityScope();
	*** getUserPrincipal();
	*** isAsyncSupported();
	*** isHandled();
	*** isRequestedSessionIdFromCookie();
	*** isSecure();
	*** mergeQueryString(java.lang.String);
	*** recoverNewSession(java.lang.Object);
	*** recycle();
	*** removeAttribute(java.lang.String);
	*** removeEventListener(java.util.EventListener);
	*** setAsyncSupported(boolean);
	*** setAttribute(java.lang.String,java.lang.Object);
	*** setAuthentication(org.eclipse.jetty.server.Authentication);
	*** setCharacterEncodingUnchecked(java.lang.String);
	*** setConnection(org.eclipse.jetty.server.AbstractHttpConnection);
	*** setContext(org.eclipse.jetty.server.handler.ContextHandler$Context);
	*** setContextPath(java.lang.String);
	*** setDispatcherType(javax.servlet.DispatcherType);
	*** setHandled(boolean);
	*** setMethod(java.lang.String);
	*** setParameters(org.eclipse.jetty.util.MultiMap);
	*** setPathInfo(java.lang.String);
	*** setProtocol(java.lang.String);
	*** setQueryEncoding(java.lang.String);
	*** setQueryString(java.lang.String);
	*** setRemoteAddr(java.lang.String);
	*** setRemoteHost(java.lang.String);
	*** setRequestURI(java.lang.String);
	*** setRequestedSessionId(java.lang.String);
	*** setRequestedSessionIdFromCookie(boolean);
	*** setScheme(java.lang.String);
	*** setServerName(java.lang.String);
	*** setServerPort(int);
	*** setServletPath(java.lang.String);
	*** setSession(javax.servlet.http.HttpSession);
	*** setSessionManager(org.eclipse.jetty.server.SessionManager);
	*** setTimeStamp(long);
	*** setUri(org.eclipse.jetty.http.HttpURI);
	*** setUserIdentityScope(org.eclipse.jetty.server.UserIdentity$Scope);
	*** takeNewContext();
}

-keep class org.eclipse.jetty.server.Request$1 {
	*** this$0;
	*** val$in;
}

-keep class org.eclipse.jetty.server.ResourceCache {
	*** flushCache();
	*** lookup(java.lang.String);
	*** setMaxCacheSize(int);
	*** setMaxCachedFileSize(int);
	*** setMaxCachedFiles(int);
}

-keep class org.eclipse.jetty.server.Response {
	*** LOG;
	*** _cachedMimeType;
	*** _characterEncoding;
	*** _connection;
	*** _contentType;
	*** _explicitEncoding;
	*** _locale;
	*** _mimeType;
	*** _outputState;
	*** _reason;
	*** _status;
	*** _writer;
	*** addCookie(org.eclipse.jetty.http.HttpCookie);
	*** complete();
	*** encodeRedirectURL(java.lang.String);
	*** encodeURL(java.lang.String);
	*** flushBuffer();
	*** fwdReset();
	*** getContentCount();
	*** getContentType();
	*** getHttpFields();
	*** getOutputStream();
	*** getReason();
	*** getResponse(javax.servlet.http.HttpServletResponse);
	*** getSetCharacterEncoding();
	*** getStatus();
	*** isCommitted();
	*** recycle();
	*** reset();
	*** reset(boolean);
	*** resetBuffer();
	*** sendError(int);
	*** sendError(int,java.lang.String);
	*** sendProcessing();
	*** sendRedirect(java.lang.String);
	*** setCharacterEncoding(java.lang.String);
	*** setContentLength(int);
	*** setContentType(java.lang.String);
	*** setHeader(java.lang.String,java.lang.String);
	*** setLongContentLength(long);
	*** setStatus(int);
	*** setStatus(int,java.lang.String);
}

-keep class org.eclipse.jetty.server.Server {
	*** LOG;
	*** __version;
	*** _attributes;
	*** _connectors;
	*** _container;
	*** _dumpAfterStart;
	*** _dumpBeforeStop;
	*** _graceful;
	*** _sendDateHeader;
	*** _sendServerVersion;
	*** _sessionIdManager;
	*** _stopAtShutdown;
	*** _threadPool;
	*** _uncheckedPrintWriter;
	*** addBean(java.lang.Object);
	*** getAttribute(java.lang.String);
	*** getConnectors();
	*** getContainer();
	*** getSendDateHeader();
	*** getSendServerVersion();
	*** getSessionIdManager();
	*** getStopAtShutdown();
	*** getThreadPool();
	*** getVersion();
	*** handle(org.eclipse.jetty.server.AbstractHttpConnection);
	*** handleAsync(org.eclipse.jetty.server.AbstractHttpConnection);
	*** isDumpAfterStart();
	*** isDumpBeforeStop();
	*** isUncheckedPrintWriter();
	*** join();
	*** removeBean(java.lang.Object);
	*** setConnectors(org.eclipse.jetty.server.Connector[]);
	*** setSessionIdManager(org.eclipse.jetty.server.SessionIdManager);
	*** setStopAtShutdown(boolean);
	*** setThreadPool(org.eclipse.jetty.util.thread.ThreadPool);
}

-keep class org.eclipse.jetty.server.Server$Graceful {
	*** setShutdown(boolean);
}

-keep class org.eclipse.jetty.server.SessionIdManager {
	*** addSession(javax.servlet.http.HttpSession);
	*** getClusterId(java.lang.String);
	*** getNodeId(java.lang.String,javax.servlet.http.HttpServletRequest);
	*** idInUse(java.lang.String);
	*** invalidateAll(java.lang.String);
	*** newSessionId(javax.servlet.http.HttpServletRequest,long);
	*** removeSession(javax.servlet.http.HttpSession);
}

-keep class org.eclipse.jetty.server.SessionManager {
	*** access(javax.servlet.http.HttpSession,boolean);
	*** addEventListener(java.util.EventListener);
	*** clearEventListeners();
	*** complete(javax.servlet.http.HttpSession);
	*** getClusterId(javax.servlet.http.HttpSession);
	*** getDefaultSessionTrackingModes();
	*** getEffectiveSessionTrackingModes();
	*** getHttpSession(java.lang.String);
	*** getNodeId(javax.servlet.http.HttpSession);
	*** getSessionCookie(javax.servlet.http.HttpSession,java.lang.String,boolean);
	*** getSessionCookieConfig();
	*** getSessionIdManager();
	*** getSessionIdPathParameterNamePrefix();
	*** isCheckingRemoteSessionIdEncoding();
	*** isUsingCookies();
	*** isValid(javax.servlet.http.HttpSession);
	*** newHttpSession(javax.servlet.http.HttpServletRequest);
	*** setSessionHandler(org.eclipse.jetty.server.session.SessionHandler);
	*** setSessionTrackingModes(java.util.Set);
}

-keep class org.eclipse.jetty.server.UserIdentity {
	*** getUserPrincipal();
	*** isUserInRole(java.lang.String,org.eclipse.jetty.server.UserIdentity$Scope);
}

-keep class org.eclipse.jetty.server.UserIdentity$Scope {
	*** getName();
}

-keep class org.eclipse.jetty.server.handler.AbstractHandler {
	*** LOG;
	*** _server;
	org.eclipse.jetty.server.handler.AbstractHandler();
	*** destroy();
	*** doStart();
	*** doStop();
	*** dumpThis(java.lang.Appendable);
	*** getServer();
	*** setServer(org.eclipse.jetty.server.Server);
}

-keep class org.eclipse.jetty.server.handler.AbstractHandlerContainer {
	org.eclipse.jetty.server.handler.AbstractHandlerContainer();
	*** expandChildren(java.lang.Object,java.lang.Class);
	*** expandHandler(org.eclipse.jetty.server.Handler,java.lang.Object,java.lang.Class);
	*** getChildHandlerByClass(java.lang.Class);
	*** getChildHandlers();
	*** getChildHandlersByClass(java.lang.Class);
}

-keep class org.eclipse.jetty.server.handler.ContextHandler {
	*** LOG;
	*** __context;
	*** _aliases;
	*** _allowNullPathInfo;
	*** _attributes;
	*** _availability;
	*** _available;
	*** _baseResource;
	*** _classLoader;
	*** _compactPath;
	*** _connectors;
	*** _contextAttributeListeners;
	*** _contextAttributes;
	*** _contextListeners;
	*** _contextPath;
	*** _displayName;
	*** _errorHandler;
	*** _eventListeners;
	*** _initParams;
	*** _localeEncodingMap;
	*** _logger;
	*** _managedAttributes;
	*** _maxFormContentSize;
	*** _maxFormKeys;
	*** _mimeTypes;
	*** _protectedTargets;
	*** _requestAttributeListeners;
	*** _requestListeners;
	*** _scontext;
	*** _shutdown;
	*** _vhosts;
	*** _welcomeFiles;
	org.eclipse.jetty.server.handler.ContextHandler();
	org.eclipse.jetty.server.handler.ContextHandler(org.eclipse.jetty.server.handler.ContextHandler$Context);
	*** access$000(org.eclipse.jetty.server.handler.ContextHandler);
	*** access$100();
	*** access$200(org.eclipse.jetty.server.handler.ContextHandler);
	*** access$300(org.eclipse.jetty.server.handler.ContextHandler);
	*** access$400(org.eclipse.jetty.server.handler.ContextHandler);
	*** access$500(org.eclipse.jetty.server.handler.ContextHandler);
	*** access$600(org.eclipse.jetty.server.handler.ContextHandler);
	*** access$700(org.eclipse.jetty.server.handler.ContextHandler);
	*** addEventListener(java.util.EventListener);
	*** callContextDestroyed(javax.servlet.ServletContextListener,javax.servlet.ServletContextEvent);
	*** callContextInitialized(javax.servlet.ServletContextListener,javax.servlet.ServletContextEvent);
	*** checkContext(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletResponse);
	*** checkManagedAttribute(java.lang.String,java.lang.Object);
	*** doHandle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doStop();
	*** getAttribute(java.lang.String);
	*** getBaseResource();
	*** getClassLoader();
	*** getClassPath();
	*** getContextPath();
	*** getCurrentContext();
	*** getDisplayName();
	*** getErrorHandler();
	*** getEventListeners();
	*** getInitParameter(java.lang.String);
	*** getInitParameterNames();
	*** getInitParams();
	*** getLocaleEncoding(java.util.Locale);
	*** getMaxFormContentSize();
	*** getMaxFormKeys();
	*** getMimeTypes();
	*** getResource(java.lang.String);
	*** getResourcePaths(java.lang.String);
	*** getServletContext();
	*** getVirtualHosts();
	*** getWelcomeFiles();
	*** isAliases();
	*** isProtectedTarget(java.lang.String);
	*** newResource(java.lang.String);
	*** newResource(java.net.URL);
	*** normalizeHostname(java.lang.String);
	*** restrictEventListener(java.util.EventListener);
	*** setAliases(boolean);
	*** setAttribute(java.lang.String,java.lang.Object);
	*** setBaseResource(org.eclipse.jetty.util.resource.Resource);
	*** setConnectorNames(java.lang.String[]);
	*** setContextPath(java.lang.String);
	*** setErrorHandler(org.eclipse.jetty.server.handler.ErrorHandler);
	*** setEventListeners(java.util.EventListener[]);
	*** setManagedAttribute(java.lang.String,java.lang.Object);
	*** setResourceBase(java.lang.String);
	*** startContext();
	*** toString();
}

-keep class org.eclipse.jetty.server.handler.ContextHandler$Context {
	*** _enabled;
	*** _majorVersion;
	*** _minorVersion;
	*** this$0;
	org.eclipse.jetty.server.handler.ContextHandler$Context(org.eclipse.jetty.server.handler.ContextHandler);
	*** addListener(java.lang.Class);
	*** addListener(java.lang.String);
	*** addListener(java.util.EventListener);
	*** createListener(java.lang.Class);
	*** getAttribute(java.lang.String);
	*** getAttributeNames();
	*** getContextHandler();
	*** getContextPath();
	*** getInitParameter(java.lang.String);
	*** getInitParameterNames();
	*** getRealPath(java.lang.String);
	*** getRequestDispatcher(java.lang.String);
	*** getResource(java.lang.String);
	*** setEnabled(boolean);
	*** setInitParameter(java.lang.String,java.lang.String);
}

-keep class org.eclipse.jetty.server.handler.ContextHandlerCollection {
	*** LOG;
	*** _contextClass;
	*** _contextMap;
	*** mapContexts();
	*** normalizeHostname(java.lang.String);
}

-keep class org.eclipse.jetty.server.handler.ErrorHandler {
	*** handle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class org.eclipse.jetty.server.handler.HandlerCollection {
	*** _handlers;
	*** _mutableWhenRunning;
	*** _parallelStart;
	org.eclipse.jetty.server.handler.HandlerCollection(boolean);
	*** addHandler(org.eclipse.jetty.server.Handler);
	*** doStart();
	*** getHandlers();
	*** setHandlers(org.eclipse.jetty.server.Handler[]);
}

-keep class org.eclipse.jetty.server.handler.HandlerWrapper {
	*** _handler;
	org.eclipse.jetty.server.handler.HandlerWrapper();
	*** doStart();
	*** doStop();
	*** getHandler();
	*** getHandlers();
	*** handle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** setHandler(org.eclipse.jetty.server.Handler);
	*** setServer(org.eclipse.jetty.server.Server);
}

-keep class org.eclipse.jetty.server.handler.ScopedHandler {
	*** __outerScope;
	*** _nextScope;
	*** _outerScope;
	org.eclipse.jetty.server.handler.ScopedHandler();
	*** doHandle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doScope(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** doStart();
	*** handle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** never();
	*** nextHandle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** nextScope(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class org.eclipse.jetty.server.nio.AbstractNIOConnector {
	org.eclipse.jetty.server.nio.AbstractNIOConnector();
}

-keep class org.eclipse.jetty.server.nio.NIOConnector {
	*** getUseDirectBuffers();
}

-keep class org.eclipse.jetty.server.nio.SelectChannelConnector {
	*** _acceptChannel;
	*** _localPort;
	*** _lowResourcesConnections;
	*** _lowResourcesMaxIdleTime;
	*** _manager;
	*** access$100(org.eclipse.jetty.server.nio.SelectChannelConnector,org.eclipse.jetty.io.Connection);
	*** access$200(org.eclipse.jetty.server.nio.SelectChannelConnector,org.eclipse.jetty.io.Connection,org.eclipse.jetty.io.Connection);
	*** endPointClosed(org.eclipse.jetty.io.nio.SelectChannelEndPoint);
	*** getLowResourcesConnections();
	*** getLowResourcesMaxIdleTime();
	*** newConnection(java.nio.channels.SocketChannel,org.eclipse.jetty.io.AsyncEndPoint);
	*** newEndPoint(java.nio.channels.SocketChannel,org.eclipse.jetty.io.nio.SelectorManager$SelectSet,java.nio.channels.SelectionKey);
	*** setLowResourcesConnections(int);
	*** setLowResourcesMaxIdleTime(int);
	*** setMaxIdleTime(int);
}

-keep class org.eclipse.jetty.server.nio.SelectChannelConnector$ConnectorSelectorManager {
	*** this$0;
	org.eclipse.jetty.server.nio.SelectChannelConnector$ConnectorSelectorManager(org.eclipse.jetty.server.nio.SelectChannelConnector);
}

-keep class org.eclipse.jetty.server.session.AbstractSession {
	*** LOG;
	*** _accessed;
	*** _attributes;
	*** _clusterId;
	*** _cookieSet;
	*** _created;
	*** _doInvalidate;
	*** _idChanged;
	*** _invalid;
	*** _jdbcAttributes;
	*** _lastAccessed;
	*** _manager;
	*** _maxIdleMs;
	*** _newSession;
	*** _nodeId;
	*** _requests;
	org.eclipse.jetty.server.session.AbstractSession(org.eclipse.jetty.server.session.AbstractSessionManager,javax.servlet.http.HttpServletRequest);
	org.eclipse.jetty.server.session.AbstractSession(org.eclipse.jetty.server.session.AbstractSessionManager,long,long,java.lang.String);
	*** access(long);
	*** bindValue(java.lang.String,java.lang.Object);
	*** checkValid();
	*** clearAttributes();
	*** complete();
	*** cookieSet();
	*** didActivate();
	*** doGet(java.lang.String);
	*** doInvalidate();
	*** doPutOrRemove(java.lang.String,java.lang.Object);
	*** getAccessed();
	*** getAttribute(java.lang.String);
	*** getAttributeNames();
	*** getAttributes();
	*** getClusterId();
	*** getCookieSetTime();
	*** getCreationTime();
	*** getId();
	*** getMaxInactiveInterval();
	*** getNodeId();
	*** getRequests();
	*** invalidate();
	*** isIdChanged();
	*** isValid();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
	*** setIdChanged(boolean);
	*** setMaxInactiveInterval(int);
	*** setRequests(int);
	*** timeout();
	*** unbindValue(java.lang.String,java.lang.Object);
	*** willPassivate();
}

-keep class org.eclipse.jetty.server.session.AbstractSessionIdManager {
	*** LOG;
	*** _random;
	*** _weakRandom;
	*** _workerName;
	org.eclipse.jetty.server.session.AbstractSessionIdManager();
	org.eclipse.jetty.server.session.AbstractSessionIdManager(java.util.Random);
	*** doStart();
	*** doStop();
	*** initRandom();
}

-keep class org.eclipse.jetty.server.session.AbstractSessionManager {
	*** __defaultSessionTrackingModes;
	*** __log;
	*** __nullSessionContext;
	*** _checkingRemoteSessionIdEncoding;
	*** _context;
	*** _cookieConfig;
	*** _dftMaxIdleSecs;
	*** _httpOnly;
	*** _loader;
	*** _maxCookieAge;
	*** _nodeIdInSessionId;
	*** _refreshCookieAge;
	*** _secureCookies;
	*** _secureRequestOnly;
	*** _sessionAttributeListeners;
	*** _sessionComment;
	*** _sessionCookie;
	*** _sessionDomain;
	*** _sessionHandler;
	*** _sessionIdManager;
	*** _sessionIdPathParameterName;
	*** _sessionIdPathParameterNamePrefix;
	*** _sessionListeners;
	*** _sessionPath;
	*** _sessionTimeStats;
	*** _sessionTrackingModes;
	*** _sessionsStats;
	*** _usingCookies;
	*** _usingURLs;
	org.eclipse.jetty.server.session.AbstractSessionManager();
	*** addSession(org.eclipse.jetty.server.session.AbstractSession);
	*** addSession(org.eclipse.jetty.server.session.AbstractSession,boolean);
	*** doSessionAttributeListeners(org.eclipse.jetty.server.session.AbstractSession,java.lang.String,java.lang.Object,java.lang.Object);
	*** doStart();
	*** doStop();
	*** getNodeId(javax.servlet.http.HttpSession);
	*** getRefreshCookieAge();
	*** getSession(java.lang.String);
	*** getSessionCookie(javax.servlet.http.HttpSession,java.lang.String,boolean);
	*** getSessionCookieConfig();
	*** getSessionHandler();
	*** getSessionIdManager();
	*** getSessions();
	*** getSessionsMax();
	*** invalidateSessions();
	*** isSecureRequestOnly();
	*** isUsingCookies();
	*** newSession(javax.servlet.http.HttpServletRequest);
	*** removeSession(java.lang.String);
	*** removeSession(org.eclipse.jetty.server.session.AbstractSession,boolean);
	*** setMaxInactiveInterval(int);
	*** setSessionIdManager(org.eclipse.jetty.server.SessionIdManager);
	*** setSessionIdPathParameterName(java.lang.String);
	*** setSessionTrackingModes(java.util.Set);
	*** statsReset();
}

-keep class org.eclipse.jetty.server.session.AbstractSessionManager$2 {
	*** this$0;
}

-keep class org.eclipse.jetty.server.session.AbstractSessionManager$SessionIf {
	*** getSession();
}

-keep class org.eclipse.jetty.server.session.HashSessionIdManager {
	*** _sessions;
	*** getClusterId(java.lang.String);
}

-keep class org.eclipse.jetty.server.session.HashSessionManager {
	*** __id;
	*** __log;
	*** _deleteUnrestorableSessions;
	*** _idleSavePeriodMs;
	*** _lazyLoad;
	*** _savePeriodMs;
	*** _saveTask;
	*** _scavengePeriodMs;
	*** _sessions;
	*** _sessionsLoaded;
	*** _storeDir;
	*** _task;
	*** _timer;
	*** _timerStop;
	*** getSavePeriod();
	*** getScavengePeriod();
	*** isDeleteUnrestorableSessions();
	*** newSession(long,long,java.lang.String);
	*** restoreSession(java.io.InputStream,org.eclipse.jetty.server.session.HashedSession);
	*** restoreSession(java.lang.String);
	*** restoreSessions();
	*** saveSessions(boolean);
	*** scavenge();
	*** setSavePeriod(int);
	*** setScavengePeriod(int);
}

-keep class org.eclipse.jetty.server.session.HashSessionManager$1 {
	*** this$0;
}

-keep class org.eclipse.jetty.server.session.HashSessionManager$2 {
	*** this$0;
}

-keep class org.eclipse.jetty.server.session.HashedSession {
	*** LOG;
	*** _hashSessionManager;
	*** _idled;
	*** _saveFailed;
	*** deIdle();
	*** idle();
	*** isIdled();
	*** save(boolean);
	*** save(java.io.OutputStream);
	*** saveFailed();
}

-keep class org.eclipse.jetty.server.session.SessionHandler {
	*** DEFAULT_TRACKING;
	*** LOG;
	*** _sessionManager;
	org.eclipse.jetty.server.session.SessionHandler(org.eclipse.jetty.server.SessionManager);
	*** checkRequestedSessionId(org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest);
	*** doHandle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** getSessionManager();
	*** setSessionManager(org.eclipse.jetty.server.SessionManager);
}

-keep class org.eclipse.jetty.servlet.DefaultServlet {
	*** LOG;
	*** _acceptRanges;
	*** _cache;
	*** _cacheControl;
	*** _contextHandler;
	*** _defaultHolder;
	*** _dirAllowed;
	*** _gzip;
	*** _mimeTypes;
	*** _pathInfoOnly;
	*** _redirectWelcome;
	*** _relativeResourceBase;
	*** _resourceBase;
	*** _servletContext;
	*** _servletHandler;
	*** _stylesheet;
	*** _useFileMappedBuffer;
	*** _welcomeExactServlets;
	*** _welcomeServlets;
	*** _welcomes;
	org.eclipse.jetty.servlet.DefaultServlet();
	*** doGet(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** getInitBoolean(java.lang.String,boolean);
	*** getInitInt(java.lang.String,int);
	*** getInitParameter(java.lang.String);
	*** getResource(java.lang.String);
	*** getWelcomeFile(java.lang.String);
	*** hasDefinedRange(java.util.Enumeration);
	*** initContextHandler(javax.servlet.ServletContext);
	*** passConditionalHeaders(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,org.eclipse.jetty.util.resource.Resource,org.eclipse.jetty.http.HttpContent);
	*** sendData(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,boolean,org.eclipse.jetty.util.resource.Resource,org.eclipse.jetty.http.HttpContent,java.util.Enumeration);
	*** sendDirectory(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,org.eclipse.jetty.util.resource.Resource,java.lang.String);
	*** writeHeaders(javax.servlet.http.HttpServletResponse,org.eclipse.jetty.http.HttpContent,long);
	*** writeOptionHeaders(javax.servlet.http.HttpServletResponse);
	*** writeOptionHeaders(org.eclipse.jetty.http.HttpFields);
}

-keep class org.eclipse.jetty.servlet.FilterHolder {
	*** LOG;
	*** _config;
	*** _filter;
	*** _registration;
	*** destroyInstance(java.lang.Object);
	*** getRegistration();
	*** setFilter(javax.servlet.Filter);
}

-keep class org.eclipse.jetty.servlet.FilterMapping {
	*** appliesTo(int);
	*** appliesTo(java.lang.String,int);
	*** dispatch(javax.servlet.DispatcherType);
	*** getFilterHolder();
	*** getFilterName();
	*** getPathSpecs();
	*** getServletNames();
	*** setDispatcherTypes(java.util.EnumSet);
	*** setDispatches(int);
	*** setFilterHolder(org.eclipse.jetty.servlet.FilterHolder);
	*** setFilterName(java.lang.String);
	*** setPathSpec(java.lang.String);
}

-keep class org.eclipse.jetty.servlet.Holder {
	*** LOG;
	*** _asyncSupported;
	*** _class;
	*** _className;
	*** _displayName;
	*** _extInstance;
	*** _initParams;
	*** _name;
	*** _servletHandler;
	*** _source;
	org.eclipse.jetty.servlet.Holder(org.eclipse.jetty.servlet.Holder$Source);
	*** access$000();
	*** doStart();
	*** doStop();
	*** getClassName();
	*** getHeldClass();
	*** getInitParameter(java.lang.String);
	*** getInitParameterNames();
	*** getInitParameters();
	*** getName();
	*** getServletHandler();
	*** illegalStateIfContextStarted();
	*** isAsyncSupported();
	*** setAsyncSupported(boolean);
	*** setClassName(java.lang.String);
	*** setHeldClass(java.lang.Class);
	*** setInitParameter(java.lang.String,java.lang.String);
	*** setName(java.lang.String);
	*** setServletHandler(org.eclipse.jetty.servlet.ServletHandler);
	*** toString();
}

-keep class org.eclipse.jetty.servlet.Holder$HolderConfig {
	*** this$0;
	org.eclipse.jetty.servlet.Holder$HolderConfig(org.eclipse.jetty.servlet.Holder);
	*** getServletContext();
}

-keep class org.eclipse.jetty.servlet.Holder$HolderRegistration {
	*** this$0;
	org.eclipse.jetty.servlet.Holder$HolderRegistration(org.eclipse.jetty.servlet.Holder);
	*** getClassName();
	*** getInitParameter(java.lang.String);
	*** getInitParameters();
	*** getName();
	*** setAsyncSupported(boolean);
	*** setDescription(java.lang.String);
	*** setInitParameter(java.lang.String,java.lang.String);
	*** setInitParameters(java.util.Map);
}

-keep class org.eclipse.jetty.servlet.Holder$Source {
	*** $VALUES;
	*** ANNOTATION;
	*** DESCRIPTOR;
	*** EMBEDDED;
	*** JAVAX_API;
}

-keep class org.eclipse.jetty.servlet.ServletContextHandler {
	*** _decorators;
	*** _defaultSecurityHandlerClass;
	*** _jspConfig;
	*** _options;
	*** _restrictListeners;
	*** _restrictedContextListeners;
	*** _securityHandler;
	*** _servletHandler;
	*** _sessionHandler;
	*** _wrapper;
	org.eclipse.jetty.servlet.ServletContextHandler(org.eclipse.jetty.server.HandlerContainer,java.lang.String,int);
	org.eclipse.jetty.servlet.ServletContextHandler(org.eclipse.jetty.server.HandlerContainer,java.lang.String,org.eclipse.jetty.server.session.SessionHandler,org.eclipse.jetty.security.SecurityHandler,org.eclipse.jetty.servlet.ServletHandler,org.eclipse.jetty.server.handler.ErrorHandler);
	org.eclipse.jetty.servlet.ServletContextHandler(org.eclipse.jetty.server.HandlerContainer,org.eclipse.jetty.server.session.SessionHandler,org.eclipse.jetty.security.SecurityHandler,org.eclipse.jetty.servlet.ServletHandler,org.eclipse.jetty.server.handler.ErrorHandler);
	*** addRoles(java.lang.String[]);
	*** addServlet(org.eclipse.jetty.servlet.ServletHolder,java.lang.String);
	*** destroyFilter(javax.servlet.Filter);
	*** destroyServlet(javax.servlet.Servlet);
	*** dynamicHolderAdded(org.eclipse.jetty.servlet.ServletHolder);
	*** getSecurityHandler();
	*** getServletHandler();
	*** getSessionHandler();
	*** newSecurityHandler();
	*** newServletHandler();
	*** newSessionHandler();
	*** setServletSecurity(javax.servlet.ServletRegistration$Dynamic,javax.servlet.ServletSecurityElement);
}

-keep class org.eclipse.jetty.servlet.ServletContextHandler$Context {
	*** this$0;
	*** createFilter(java.lang.Class);
	*** createServlet(java.lang.Class);
}

-keep class org.eclipse.jetty.servlet.ServletContextHandler$Decorator {
	*** decorateFilterHolder(org.eclipse.jetty.servlet.FilterHolder);
	*** decorateFilterInstance(javax.servlet.Filter);
	*** decorateListenerInstance(java.util.EventListener);
	*** decorateServletHolder(org.eclipse.jetty.servlet.ServletHolder);
	*** decorateServletInstance(javax.servlet.Servlet);
	*** destroyFilterInstance(javax.servlet.Filter);
	*** destroyServletInstance(javax.servlet.Servlet);
}

-keep class org.eclipse.jetty.servlet.ServletHandler {
	*** LOG;
	*** _chainCache;
	*** _chainLRU;
	*** _contextHandler;
	*** _filterChainsCached;
	*** _filterMappings;
	*** _filterNameMap;
	*** _filterNameMappings;
	*** _filterPathMappings;
	*** _filters;
	*** _identityService;
	*** _maxFilterChainsCacheSize;
	*** _servletContext;
	*** _servletMappings;
	*** _servletNameMap;
	*** _servletPathMap;
	*** _servlets;
	*** _startWithUnavailable;
	*** addFilter(org.eclipse.jetty.servlet.FilterHolder);
	*** addFilterWithMapping(java.lang.Class,java.lang.String,java.util.EnumSet);
	*** addFilterWithMapping(java.lang.String,java.lang.String,java.util.EnumSet);
	*** addFilterWithMapping(org.eclipse.jetty.servlet.FilterHolder,java.lang.String,int);
	*** addFilterWithMapping(org.eclipse.jetty.servlet.FilterHolder,java.lang.String,java.util.EnumSet);
	*** addServlet(org.eclipse.jetty.servlet.ServletHolder);
	*** addServletMapping(org.eclipse.jetty.servlet.ServletMapping);
	*** addServletWithMapping(java.lang.String,java.lang.String);
	*** addServletWithMapping(org.eclipse.jetty.servlet.ServletHolder,java.lang.String);
	*** destroyFilter(javax.servlet.Filter);
	*** destroyServlet(javax.servlet.Servlet);
	*** doHandle(java.lang.String,org.eclipse.jetty.server.Request,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** getFilter(java.lang.String);
	*** getFilterChain(org.eclipse.jetty.server.Request,java.lang.String,org.eclipse.jetty.servlet.ServletHolder);
	*** getFilterMappings();
	*** getFilters();
	*** getHolderEntry(java.lang.String);
	*** getIdentityService();
	*** getServlet(java.lang.String);
	*** getServletContext();
	*** getServletMapping(java.lang.String);
	*** getServletMappings();
	*** getServlets();
	*** initialize();
	*** invalidateChainsCache();
	*** isStartWithUnavailable();
	*** newFilterHolder(org.eclipse.jetty.servlet.Holder$Source);
	*** newServletHolder(org.eclipse.jetty.servlet.Holder$Source);
	*** notFound(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** setFilterMappings(org.eclipse.jetty.servlet.FilterMapping[]);
	*** setFilters(org.eclipse.jetty.servlet.FilterHolder[]);
	*** setServletMappings(org.eclipse.jetty.servlet.ServletMapping[]);
	*** setServletSecurity(javax.servlet.ServletRegistration$Dynamic,javax.servlet.ServletSecurityElement);
	*** setServlets(org.eclipse.jetty.servlet.ServletHolder[]);
	*** updateMappings();
	*** updateNameMappings();
}

-keep class org.eclipse.jetty.servlet.ServletHolder {
	*** LOG;
	*** NO_MAPPED_ROLES;
	*** _config;
	*** _enabled;
	*** _forcedPath;
	*** _identityService;
	*** _initOnStartup;
	*** _initOrder;
	*** _registration;
	*** _roleMap;
	*** _runAsRole;
	*** _runAsToken;
	*** _servlet;
	*** _unavailable;
	*** _unavailableEx;
	*** access$100(org.eclipse.jetty.servlet.ServletHolder);
	*** access$102(org.eclipse.jetty.servlet.ServletHolder,java.lang.String);
	*** checkServletType();
	*** compareTo(java.lang.Object);
	*** destroyInstance(java.lang.Object);
	*** getForcedPath();
	*** getInitOrder();
	*** getRegistration();
	*** getServlet();
	*** getServletInstance();
	*** handle(org.eclipse.jetty.server.Request,javax.servlet.ServletRequest,javax.servlet.ServletResponse);
	*** hashCode();
	*** initJspServlet();
	*** initServlet();
	*** isAvailable();
	*** isEnabled();
	*** isJspServlet();
	*** isJspServlet(java.lang.String);
	*** makeUnavailable(java.lang.Throwable);
	*** makeUnavailable(javax.servlet.UnavailableException);
	*** newInstance();
	*** setInitOrder(int);
	*** setServlet(javax.servlet.Servlet);
}

-keep class org.eclipse.jetty.servlet.ServletHolder$1 {
	*** this$0;
	*** val$e;
}

-keep class org.eclipse.jetty.servlet.ServletHolder$Config {
	*** this$0;
}

-keep class org.eclipse.jetty.servlet.ServletHolder$Registration {
	*** _multipartConfig;
	*** this$0;
	*** getMultipartConfig();
	*** getName();
}

-keep class org.eclipse.jetty.servlet.ServletMapping {
	*** _default;
	*** _pathSpecs;
	*** _servletName;
	*** getPathSpecs();
	*** getServletName();
	*** isDefault();
	*** setPathSpec(java.lang.String);
	*** setPathSpecs(java.lang.String[]);
	*** setServletName(java.lang.String);
}

-keep class org.eclipse.jetty.util.ArrayQueue {
	*** _elements;
	*** _growCapacity;
	*** _lock;
	*** _nextE;
	*** _nextSlot;
	*** _size;
	org.eclipse.jetty.util.ArrayQueue(int,int);
	org.eclipse.jetty.util.ArrayQueue(int,int,java.lang.Object);
	*** add(java.lang.Object);
	*** at(int);
	*** clear();
	*** dequeue();
	*** enqueue(java.lang.Object);
	*** getUnsafe(int);
	*** grow();
	*** isEmpty();
	*** offer(java.lang.Object);
	*** size();
}

-keep class org.eclipse.jetty.util.Atomics {
	*** updateMax(java.util.concurrent.atomic.AtomicLong,long);
}

-keep class org.eclipse.jetty.util.Attributes {
	*** clearAttributes();
	*** getAttribute(java.lang.String);
	*** getAttributeNames();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
}

-keep class org.eclipse.jetty.util.AttributesMap {
	*** _map;
	*** addAll(org.eclipse.jetty.util.Attributes);
	*** clearAttributes();
	*** getAttribute(java.lang.String);
	*** getAttributeEntrySet();
	*** getAttributeNameSet();
	*** getAttributeNames();
	*** getAttributeNamesCopy(org.eclipse.jetty.util.Attributes);
	*** keySet();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
}

-keep class org.eclipse.jetty.util.BlockingArrayQueue {
	*** DEFAULT_CAPACITY;
	*** DEFAULT_GROWTH;
	*** _capacity;
	*** _elements;
	*** _growCapacity;
	*** _head;
	*** _headLock;
	*** _limit;
	*** _notEmpty;
	*** _size;
	*** _space0;
	*** _space1;
	*** _space2;
	*** _space3;
	*** _space4;
	*** _space5;
	*** _space6;
	*** _space7;
	*** _tail;
	*** _tailLock;
	*** add(java.lang.Object);
	*** getCapacity();
	*** grow();
	*** offer(java.lang.Object);
	*** peek();
	*** poll();
	*** size();
}

-keep class org.eclipse.jetty.util.ByteArrayISO8859Writer {
	*** destroy();
	*** flush();
	*** size();
	*** write(char);
	*** write(java.lang.String);
	*** writeTo(java.io.OutputStream);
}

-keep class org.eclipse.jetty.util.ByteArrayOutputStream2 {
	*** getBuf();
	*** getCount();
	*** setCount(int);
}

-keep class org.eclipse.jetty.util.ConcurrentHashSet {
	*** _keys;
	*** _map;
}

-keep class org.eclipse.jetty.util.DateCache {
	*** DEFAULT_FORMAT;
	*** __hitWindow;
	*** _dfs;
	*** _formatString;
	*** _lastMinutes;
	*** _lastMs;
	*** _lastResult;
	*** _lastSeconds;
	*** _locale;
	*** _minFormat;
	*** _minFormatString;
	*** _secFormatString;
	*** _secFormatString0;
	*** _secFormatString1;
	*** _tzFormat;
	*** _tzFormatString;
	org.eclipse.jetty.util.DateCache();
	org.eclipse.jetty.util.DateCache(java.lang.String);
	org.eclipse.jetty.util.DateCache(java.lang.String,java.text.DateFormatSymbols);
	org.eclipse.jetty.util.DateCache(java.lang.String,java.util.Locale);
	*** format(long);
	*** getFormat();
	*** setMinFormatString();
	*** setTimeZone(java.util.TimeZone);
	*** setTzFormatString(java.util.TimeZone);
}

-keep class org.eclipse.jetty.util.IO {
	*** close(java.io.InputStream);
	*** close(java.io.OutputStream);
	*** copy(java.io.File,java.io.File);
	*** copy(java.io.InputStream,java.io.OutputStream);
	*** copy(java.io.InputStream,java.io.OutputStream,long);
	*** copyDir(java.io.File,java.io.File);
	*** getClosedStream();
	*** toString(java.io.InputStream);
	*** toString(java.io.Reader);
}

-keep class org.eclipse.jetty.util.LazyList {
	*** __EMTPY_STRING_ARRAY;
	*** add(java.lang.Object,int,java.lang.Object);
	*** add(java.lang.Object,java.lang.Object);
	*** addArray(java.lang.Object,java.lang.Object[]);
	*** addToArray(java.lang.Object[],java.lang.Object,java.lang.Class);
	*** contains(java.lang.Object,java.lang.Object);
	*** ensureSize(java.lang.Object,int);
	*** get(java.lang.Object,int);
	*** getList(java.lang.Object);
	*** getList(java.lang.Object,boolean);
	*** remove(java.lang.Object,int);
	*** remove(java.lang.Object,java.lang.Object);
	*** removeFromArray(java.lang.Object[],java.lang.Object);
	*** size(java.lang.Object);
	*** toArray(java.lang.Object,java.lang.Class);
}

-keep class org.eclipse.jetty.util.Loader {
	*** getClassPath(java.lang.ClassLoader);
	*** getResource(java.lang.Class,java.lang.String,boolean);
	*** loadClass(java.lang.Class,java.lang.String);
	*** loadClass(java.lang.Class,java.lang.String,boolean);
}

-keep class org.eclipse.jetty.util.MultiException {
	*** nested;
	*** add(java.lang.Throwable);
	*** getThrowable(int);
	*** ifExceptionThrow();
	*** ifExceptionThrowRuntime();
	*** size();
}

-keep class org.eclipse.jetty.util.MultiMap {
	*** add(java.lang.Object,java.lang.Object);
	*** clear();
	*** containsKey(java.lang.Object);
	*** entrySet();
	*** get(java.lang.Object);
	*** getValue(java.lang.Object,int);
	*** getValues(java.lang.Object);
	*** keySet();
	*** size();
	*** toStringArrayMap();
}

-keep class org.eclipse.jetty.util.MultiPartOutputStream {
	*** MULTIPART_MIXED;
	*** MULTIPART_X_MIXED_REPLACE;
	*** __CRLF;
	*** __DASHDASH;
	*** boundary;
	*** boundaryBytes;
	*** inPart;
	*** close();
	*** getBoundary();
	*** startPart(java.lang.String,java.lang.String[]);
}

-keep class org.eclipse.jetty.util.QuotedStringTokenizer {
	*** _delim;
	*** _double;
	*** _hasToken;
	*** _i;
	*** _lastStart;
	*** _returnDelimiters;
	*** _returnQuotes;
	*** _single;
	*** _string;
	*** _token;
	*** escapes;
	org.eclipse.jetty.util.QuotedStringTokenizer(java.lang.String,java.lang.String,boolean,boolean);
	*** hasMoreTokens();
	*** nextToken();
	*** quote(java.lang.Appendable,java.lang.String);
	*** quoteIfNeeded(java.lang.Appendable,java.lang.String,java.lang.String);
	*** quoteIfNeeded(java.lang.String,java.lang.String);
	*** unquote(java.lang.String);
}

-keep class org.eclipse.jetty.util.StringMap {
	*** _entrySet;
	*** _ignoreCase;
	*** _nullEntry;
	*** _nullValue;
	*** _root;
	*** _umEntrySet;
	*** _width;
	org.eclipse.jetty.util.StringMap();
	*** clear();
	*** get(java.lang.String);
	*** getBestEntry(byte[],int,int);
	*** getEntry(java.lang.String,int,int);
	*** put(java.lang.String,java.lang.Object);
	*** remove(java.lang.String);
	*** setIgnoreCase(boolean);
}

-keep class org.eclipse.jetty.util.StringMap$Node {
	*** _char;
	*** _children;
	*** _key;
	*** _next;
	*** _ochar;
	*** _value;
	*** split(org.eclipse.jetty.util.StringMap,int);
	*** toString(java.lang.StringBuilder);
}

-keep class org.eclipse.jetty.util.StringMap$NullEntry {
	*** this$0;
	org.eclipse.jetty.util.StringMap$NullEntry(org.eclipse.jetty.util.StringMap);
}

-keep class org.eclipse.jetty.util.StringUtil {
	*** LOG;
	*** __ISO_8859_1_CHARSET;
	*** __LINE_SEPARATOR;
	*** __UTF8_CHARSET;
	*** lowercases;
	*** append(java.lang.StringBuilder,byte,int);
	*** append2digits(java.lang.StringBuilder,int);
	*** asciiToLowerCase(java.lang.String);
	*** getBytes(java.lang.String);
	*** isUTF8(java.lang.String);
	*** replace(java.lang.String,java.lang.String,java.lang.String);
	*** startsWithIgnoreCase(java.lang.String,java.lang.String);
	*** toString(byte[],int,int,java.lang.String);
}

-keep class org.eclipse.jetty.util.TypeUtil {
	*** asList(java.lang.Object[]);
	*** convertHexDigit(byte);
	*** parseInt(byte[],int,int,int);
	*** parseInt(java.lang.String,int,int,int);
	*** toHex(byte,java.lang.Appendable);
	*** toHexString(byte);
}

-keep class org.eclipse.jetty.util.URIUtil {
	*** __CHARSET;
	*** addPaths(java.lang.String,java.lang.String);
	*** canonicalPath(java.lang.String);
	*** compactPath(java.lang.String);
	*** decodePath(byte[],int,int);
	*** decodePath(java.lang.String);
	*** encodePath(java.lang.String);
	*** encodePath(java.lang.StringBuilder,java.lang.String);
	*** hasScheme(java.lang.String);
	*** parentPath(java.lang.String);
}

-keep class org.eclipse.jetty.util.UrlEncoded {
	*** decodeTo(java.io.InputStream,org.eclipse.jetty.util.MultiMap,java.lang.String,int,int);
	*** decodeTo(java.lang.String,org.eclipse.jetty.util.MultiMap,java.lang.String);
	*** decodeUtf8To(byte[],int,int,org.eclipse.jetty.util.MultiMap);
	*** decodeUtf8To(byte[],int,int,org.eclipse.jetty.util.MultiMap,org.eclipse.jetty.util.Utf8StringBuilder);
}

-keep class org.eclipse.jetty.util.Utf8Appendable {
	*** BYTE_TABLE;
	*** TRANS_TABLE;
	*** _appendable;
	*** _codep;
	*** _state;
	org.eclipse.jetty.util.Utf8Appendable(java.lang.Appendable);
	*** append(byte[],int,int);
	*** appendByte(byte);
	*** isUtf8SequenceComplete();
	*** length();
	*** reset();
}

-keep class org.eclipse.jetty.util.Utf8StringBuffer {
	*** getStringBuffer();
}

-keep class org.eclipse.jetty.util.Utf8StringBuilder {
	*** _buffer;
	*** checkState();
	*** reset();
	*** toString();
}

-keep class org.eclipse.jetty.util.ajax.JSON {
	*** DEFAULT;
	*** LOG;
	*** _convertors;
	*** _stringBufferSize;
	org.eclipse.jetty.util.ajax.JSON();
	*** addConvertor(java.lang.Class,org.eclipse.jetty.util.ajax.JSON$Convertor);
	*** append(java.lang.Appendable,java.lang.Object);
	*** appendArray(java.lang.Appendable,java.lang.Object);
	*** appendArray(java.lang.Appendable,java.util.Collection);
	*** appendBoolean(java.lang.Appendable,java.lang.Boolean);
	*** appendJSON(java.lang.Appendable,org.eclipse.jetty.util.ajax.JSON$Convertible);
	*** appendJSON(java.lang.Appendable,org.eclipse.jetty.util.ajax.JSON$Convertor,java.lang.Object);
	*** appendJSON(java.lang.Appendable,org.eclipse.jetty.util.ajax.JSON$Generator);
	*** appendMap(java.lang.Appendable,java.util.Map);
	*** appendNull(java.lang.Appendable);
	*** appendNumber(java.lang.Appendable,java.lang.Number);
	*** appendString(java.lang.Appendable,java.lang.String);
	*** complete(java.lang.String,org.eclipse.jetty.util.ajax.JSON$Source);
	*** contextFor(java.lang.String);
	*** contextForArray();
	*** convertTo(java.lang.Class,java.util.Map);
	*** getConvertor(java.lang.Class);
	*** getConvertorFor(java.lang.String);
	*** getStringBufferSize();
	*** handleUnknown(org.eclipse.jetty.util.ajax.JSON$Source,char);
	*** newArray(int);
	*** newMap();
	*** parse(org.eclipse.jetty.util.ajax.JSON$Source);
	*** parse(org.eclipse.jetty.util.ajax.JSON$Source,boolean);
	*** parseArray(org.eclipse.jetty.util.ajax.JSON$Source);
	*** parseNumber(org.eclipse.jetty.util.ajax.JSON$Source);
	*** parseObject(org.eclipse.jetty.util.ajax.JSON$Source);
	*** parseString(org.eclipse.jetty.util.ajax.JSON$Source);
	*** seekTo(char,org.eclipse.jetty.util.ajax.JSON$Source);
	*** seekTo(java.lang.String,org.eclipse.jetty.util.ajax.JSON$Source);
	*** toJSON(java.lang.Object);
	*** toString(char[],int,int);
}

-keep class org.eclipse.jetty.util.ajax.JSON$ConvertableOutput {
	*** complete();
}

-keep class org.eclipse.jetty.util.ajax.JSON$Convertible {
	*** fromJSON(java.util.Map);
	*** toJSON(org.eclipse.jetty.util.ajax.JSON$Output);
}

-keep class org.eclipse.jetty.util.ajax.JSON$Convertor {
	*** fromJSON(java.util.Map);
}

-keep class org.eclipse.jetty.util.ajax.JSON$Generator {
	*** addJSON(java.lang.Appendable);
}

-keep class org.eclipse.jetty.util.ajax.JSON$Source {
	*** hasNext();
	*** next();
	*** peek();
	*** scratchBuffer();
}

-keep class org.eclipse.jetty.util.component.AbstractLifeCycle {
	*** LOG;
	*** __FAILED;
	*** __STARTED;
	*** __STARTING;
	*** __STOPPED;
	*** __STOPPING;
	*** _listeners;
	*** _lock;
	*** _state;
	org.eclipse.jetty.util.component.AbstractLifeCycle();
	*** doStart();
	*** doStop();
	*** getState();
	*** getState(org.eclipse.jetty.util.component.LifeCycle);
	*** isRunning();
	*** isStarted();
	*** isStarting();
	*** isStopped();
	*** isStopping();
	*** setFailed(java.lang.Throwable);
	*** setStarted();
	*** setStarting();
	*** setStopped();
	*** setStopping();
	*** start();
	*** stop();
}

-keep class org.eclipse.jetty.util.component.AggregateLifeCycle {
	*** LOG;
	*** _beans;
	*** _started;
	org.eclipse.jetty.util.component.AggregateLifeCycle();
	*** addBean(java.lang.Object);
	*** addBean(java.lang.Object,boolean);
	*** contains(java.lang.Object);
	*** destroy();
	*** doStart();
	*** doStop();
	*** dump(java.lang.Appendable,java.lang.String);
	*** dump(java.lang.Appendable,java.lang.String,java.util.Collection[]);
	*** dump(org.eclipse.jetty.util.component.Dumpable);
	*** dumpObject(java.lang.Appendable,java.lang.Object);
	*** dumpStdErr();
	*** dumpThis(java.lang.Appendable);
	*** getBean(java.lang.Class);
	*** getBeans();
	*** getBeans(java.lang.Class);
	*** removeBean(java.lang.Object);
}

-keep class org.eclipse.jetty.util.component.AggregateLifeCycle$Bean {
	*** _bean;
	*** _managed;
	*** this$0;
}

-keep class org.eclipse.jetty.util.component.Container {
	*** LOG;
	*** _listeners;
	*** add(java.lang.Object,java.lang.Object,java.lang.String);
	*** addBean(java.lang.Object);
	*** remove(java.lang.Object,java.lang.Object,java.lang.String);
	*** removeBean(java.lang.Object);
	*** update(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.String);
	*** update(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.String,boolean);
	*** update(java.lang.Object,java.lang.Object[],java.lang.Object[],java.lang.String);
	*** update(java.lang.Object,java.lang.Object[],java.lang.Object[],java.lang.String,boolean);
}

-keep class org.eclipse.jetty.util.component.Container$Listener {
	*** add(org.eclipse.jetty.util.component.Container$Relationship);
	*** addBean(java.lang.Object);
	*** remove(org.eclipse.jetty.util.component.Container$Relationship);
	*** removeBean(java.lang.Object);
}

-keep class org.eclipse.jetty.util.component.Container$Relationship {
	*** _child;
	*** _container;
	*** _parent;
	*** _relationship;
	org.eclipse.jetty.util.component.Container$Relationship(org.eclipse.jetty.util.component.Container,java.lang.Object,java.lang.Object,java.lang.String);
}

-keep class org.eclipse.jetty.util.component.Destroyable {
	*** destroy();
}

-keep class org.eclipse.jetty.util.component.Dumpable {
	*** dump(java.lang.Appendable,java.lang.String);
}

-keep class org.eclipse.jetty.util.component.LifeCycle {
	*** isRunning();
	*** isStarted();
	*** isStarting();
	*** isStopped();
	*** isStopping();
	*** start();
	*** stop();
}

-keep class org.eclipse.jetty.util.component.LifeCycle$Listener {
	*** lifeCycleFailure(org.eclipse.jetty.util.component.LifeCycle,java.lang.Throwable);
	*** lifeCycleStarted(org.eclipse.jetty.util.component.LifeCycle);
	*** lifeCycleStarting(org.eclipse.jetty.util.component.LifeCycle);
	*** lifeCycleStopped(org.eclipse.jetty.util.component.LifeCycle);
	*** lifeCycleStopping(org.eclipse.jetty.util.component.LifeCycle);
}

-keep class org.eclipse.jetty.util.log.AbstractLogger {
	org.eclipse.jetty.util.log.AbstractLogger();
	*** isBlank(java.lang.String);
	*** newLogger(java.lang.String);
}

-keep class org.eclipse.jetty.util.log.JettyAwareLogger {
	*** FQCN;
	*** _logger;
	*** log(org.slf4j.Marker,int,java.lang.String,java.lang.Object[],java.lang.Throwable);
}

-keep class org.eclipse.jetty.util.log.Log {
	*** LOG;
	*** __ignored;
	*** __initialized;
	*** __logClass;
	*** __loggers;
	*** __props;
	*** getLogger(java.lang.Class);
	*** getLogger(java.lang.String);
	*** getLoggers();
	*** getMutableLoggers();
	*** getRootLogger();
	*** initStandardLogging(java.lang.Throwable);
	*** initialized();
	*** isDebugEnabled();
	*** isIgnored();
	*** setLog(org.eclipse.jetty.util.log.Logger);
}

-keep class org.eclipse.jetty.util.log.Logger {
	*** debug(java.lang.String,java.lang.Object[]);
	*** debug(java.lang.String,java.lang.Throwable);
	*** debug(java.lang.Throwable);
	*** getLogger(java.lang.String);
	*** getName();
	*** ignore(java.lang.Throwable);
	*** info(java.lang.String,java.lang.Object[]);
	*** info(java.lang.String,java.lang.Throwable);
	*** isDebugEnabled();
	*** warn(java.lang.String,java.lang.Object[]);
	*** warn(java.lang.String,java.lang.Throwable);
	*** warn(java.lang.Throwable);
}

-keep class org.eclipse.jetty.util.log.Slf4jLog {
	*** _logger;
	org.eclipse.jetty.util.log.Slf4jLog(java.lang.String);
	*** debug(java.lang.String,java.lang.Throwable);
	*** info(java.lang.String,java.lang.Throwable);
	*** warn(java.lang.String,java.lang.Object[]);
	*** warn(java.lang.String,java.lang.Throwable);
}

-keep class org.eclipse.jetty.util.resource.BadResource {
	*** _message;
}

-keep class org.eclipse.jetty.util.resource.FileResource {
	*** LOG;
	*** __checkAliases;
	*** _alias;
	*** _aliasChecked;
	*** _file;
	*** getCheckAliases();
	*** getFile();
	*** isDirectory();
}

-keep class org.eclipse.jetty.util.resource.JarFileResource {
	*** LOG;
	*** _directory;
	*** _entry;
	*** _exists;
	*** _file;
	*** _jarFile;
	*** _jarUrl;
	*** _list;
	*** _path;
	*** checkConnection();
	*** exists();
	*** isDirectory();
	*** listEntries();
	*** release();
}

-keep class org.eclipse.jetty.util.resource.JarResource {
	*** LOG;
	*** _jarConnection;
	org.eclipse.jetty.util.resource.JarResource(java.net.URL);
	org.eclipse.jetty.util.resource.JarResource(java.net.URL,boolean);
	*** checkConnection();
	*** exists();
	*** newConnection();
	*** release();
}

-keep class org.eclipse.jetty.util.resource.JarResource$1 {
	*** this$0;
}

-keep class org.eclipse.jetty.util.resource.Resource {
	*** LOG;
	*** __defaultUseCaches;
	*** _associate;
	org.eclipse.jetty.util.resource.Resource();
	*** addPath(java.lang.String);
	*** deTag(java.lang.String);
	*** exists();
	*** getAlias();
	*** getFile();
	*** getInputStream();
	*** getListHTML(java.lang.String,boolean);
	*** getURL();
	*** hrefEncodeURI(java.lang.String);
	*** isContainedIn(org.eclipse.jetty.util.resource.Resource);
	*** isDirectory();
	*** lastModified();
	*** length();
	*** list();
	*** newClassPathResource(java.lang.String,boolean,boolean);
	*** newResource(java.lang.String);
	*** newResource(java.lang.String,boolean);
	*** newResource(java.net.URL);
	*** newResource(java.net.URL,boolean);
	*** release();
	*** toURL(java.io.File);
	*** writeTo(java.io.OutputStream,long,long);
}

-keep class org.eclipse.jetty.util.resource.URLResource {
	*** LOG;
	*** _connection;
	*** _in;
	*** _url;
	*** _urlString;
	*** _useCaches;
	org.eclipse.jetty.util.resource.URLResource(java.net.URL,java.net.URLConnection);
	org.eclipse.jetty.util.resource.URLResource(java.net.URL,java.net.URLConnection,boolean);
	*** addPath(java.lang.String);
	*** checkConnection();
	*** exists();
	*** getInputStream();
	*** getURL();
	*** getUseCaches();
	*** hashCode();
	*** isDirectory();
	*** release();
	*** toString();
}

-keep class org.eclipse.jetty.util.security.Constraint {
	*** getAuthenticate();
	*** getDataConstraint();
	*** getRoles();
	*** isAnyRole();
	*** isForbidden();
}

-keep class org.eclipse.jetty.util.statistic.CounterStatistic {
	*** _curr;
	*** _max;
	*** _total;
	*** add(long);
	*** decrement();
	*** getCurrent();
	*** getMax();
	*** getTotal();
	*** increment();
	*** reset();
	*** reset(long);
}

-keep class org.eclipse.jetty.util.statistic.SampleStatistic {
	*** _count;
	*** _max;
	*** _total;
	*** _totalVariance100;
	*** getMax();
	*** getMean();
	*** getStdDev();
	*** getTotal();
	*** getVariance();
	*** reset();
	*** set(long);
}

-keep class org.eclipse.jetty.util.thread.QueuedThreadPool {
	*** LOG;
	*** _daemon;
	*** _detailedDump;
	*** _jobs;
	*** _joinLock;
	*** _lastShrink;
	*** _maxIdleTimeMs;
	*** _maxQueued;
	*** _maxStopTime;
	*** _maxThreads;
	*** _minThreads;
	*** _name;
	*** _priority;
	*** _runnable;
	*** _threads;
	*** _threadsIdle;
	*** _threadsStarted;
	org.eclipse.jetty.util.thread.QueuedThreadPool();
	*** access$000(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$100(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$200(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$300(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$400(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$500(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$600(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** access$700();
	*** access$800(org.eclipse.jetty.util.thread.QueuedThreadPool);
	*** dispatch(java.lang.Runnable);
	*** getIdleThreads();
	*** getMaxThreads();
	*** getMinThreads();
	*** getThreads();
	*** idleJobPoll();
	*** newThread(java.lang.Runnable);
	*** runJob(java.lang.Runnable);
	*** setDaemon(boolean);
	*** setMaxThreads(int);
	*** setMinThreads(int);
	*** setName(java.lang.String);
	*** startThread(int);
}

-keep class org.eclipse.jetty.util.thread.QueuedThreadPool$3 {
	*** this$0;
}

-keep class org.eclipse.jetty.util.thread.ShutdownThread {
	*** LOG;
	*** _hooked;
	*** _lifeCycles;
	*** _thread;
	*** deregister(org.eclipse.jetty.util.component.LifeCycle);
	*** hook();
	*** register(org.eclipse.jetty.util.component.LifeCycle[]);
	*** unhook();
}

-keep class org.eclipse.jetty.util.thread.ThreadPool {
	*** dispatch(java.lang.Runnable);
	*** isLowOnThreads();
	*** join();
}

-keep class org.eclipse.jetty.util.thread.Timeout {
	*** LOG;
	*** _duration;
	*** _head;
	*** _lock;
	*** _now;
	*** access$200(org.eclipse.jetty.util.thread.Timeout);
	*** access$300(org.eclipse.jetty.util.thread.Timeout);
	*** cancelAll();
	*** expired();
	*** getNow();
	*** getTimeToNext();
	*** schedule(org.eclipse.jetty.util.thread.Timeout$Task);
	*** schedule(org.eclipse.jetty.util.thread.Timeout$Task,long);
	*** setDuration(long);
	*** setNow(long);
	*** tick();
	*** tick(long);
}

-keep class org.eclipse.jetty.util.thread.Timeout$Task {
	*** _delay;
	*** _expired;
	*** _next;
	*** _prev;
	*** _timeout;
	*** _timestamp;
	org.eclipse.jetty.util.thread.Timeout$Task();
	*** access$000(org.eclipse.jetty.util.thread.Timeout$Task);
	*** access$100(org.eclipse.jetty.util.thread.Timeout$Task,org.eclipse.jetty.util.thread.Timeout$Task);
	*** cancel();
	*** expire();
	*** expired();
	*** link(org.eclipse.jetty.util.thread.Timeout$Task);
	*** unlink();
}

-keep class org.freedesktop.Secret.Collection {
	*** CreateItem(java.util.Map,org.freedesktop.Secret.Secret,boolean);
}

-keep class org.freedesktop.Secret.Collection$ItemChanged {
	*** item;
}

-keep class org.freedesktop.Secret.Collection$ItemCreated {
	*** item;
}

-keep class org.freedesktop.Secret.Collection$ItemDeleted {
	*** item;
}

-keep class org.freedesktop.Secret.Item {
	*** GetSecret(org.freedesktop.dbus.Path);
}

-keep class org.freedesktop.Secret.Pair {
	*** a;
	*** b;
}

-keep class org.freedesktop.Secret.Prompt {
	*** Prompt(java.lang.String);
}

-keep class org.freedesktop.Secret.Prompt$Completed {
	*** dismissed;
	*** result;
}

-keep class org.freedesktop.Secret.Secret {
	*** content_type;
	*** parameters;
	*** session;
	*** value;
}

-keep class org.freedesktop.Secret.Service {
	*** OpenSession(java.lang.String,org.freedesktop.dbus.Variant);
	*** SearchItems(java.util.Map);
	*** Unlock(java.util.List);
}

-keep class org.freedesktop.Secret.Service$CollectionChanged {
	*** collection;
}

-keep class org.freedesktop.Secret.Service$CollectionCreated {
	*** collection;
}

-keep class org.freedesktop.Secret.Service$CollectionDeleted {
	*** collection;
}

-keep class org.freedesktop.Secret.Session {
	*** Close();
}

-keep class org.freedesktop.dbus.AbstractConnection {
	*** EXCEPTION_DEBUG;
	*** dollar_pattern;
	*** addSigHandler(java.lang.Class,org.freedesktop.dbus.DBusInterface,org.freedesktop.dbus.DBusSigHandler);
	*** removeSigHandler(java.lang.Class,org.freedesktop.dbus.DBusInterface,org.freedesktop.dbus.DBusSigHandler);
}

-keep class org.freedesktop.dbus.ArrayFrob {
	*** listify(java.lang.Object);
}

-keep class org.freedesktop.dbus.Container {
	*** parameters;
	*** typecache;
	org.freedesktop.dbus.Container();
	*** getParameters();
	*** setup();
}

-keep class org.freedesktop.dbus.DBusConnection {
	*** disconnect();
	*** getConnection(int);
	*** getRemoteObject(java.lang.String,java.lang.String,java.lang.Class);
}

-keep class org.freedesktop.dbus.DBusInterfaceName {
	*** value();
}

-keep class org.freedesktop.dbus.DBusMatchRule {
	*** getCachedSignalType(java.lang.String);
}

-keep class org.freedesktop.dbus.DBusMemberName {
	*** value();
}

-keep class org.freedesktop.dbus.DBusSignal {
	*** blen;
	*** bodydone;
	*** c;
	*** classCache;
	*** conCache;
	*** intnames;
	*** signames;
	*** typeCache;
	org.freedesktop.dbus.DBusSignal(java.lang.String,java.lang.Object[]);
	org.freedesktop.dbus.DBusSignal(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[]);
	*** createSignalClass(java.lang.String,java.lang.String);
}

-keep class org.freedesktop.dbus.Gettext {
	*** _(java.lang.String);
}

-keep class org.freedesktop.dbus.Marshalling {
	*** convertParameters(java.lang.Object[],java.lang.reflect.Type[],org.freedesktop.dbus.AbstractConnection);
	*** deSerializeParameters(java.lang.Object[],java.lang.reflect.Type[],org.freedesktop.dbus.AbstractConnection);
	*** getDBusType(java.lang.reflect.Type);
	*** getDBusType(java.lang.reflect.Type[]);
	*** getJavaType(java.lang.String,java.util.List,int);
}

-keep class org.freedesktop.dbus.Message {
	*** args;
	*** big;
	*** body;
	*** bodylen;
	*** bufferuse;
	*** bytecounter;
	*** flags;
	*** globalserial;
	*** headers;
	*** pabuf;
	*** padding;
	*** paofs;
	*** preallocated;
	*** protover;
	*** serial;
	*** type;
	*** wiredata;
	org.freedesktop.dbus.Message();
	org.freedesktop.dbus.Message(byte,byte,byte);
	*** align(int,byte);
	*** append(java.lang.String,java.lang.Object[]);
	*** appendByte(byte);
	*** appendBytes(byte[]);
	*** appendint(long,int);
	*** appendone(byte[],int,java.lang.Object);
	*** demarshallint(byte[],int,int);
	*** demarshallintBig(byte[],int,int);
	*** demarshallintLittle(byte[],int,int);
	*** ensureBuffers(int);
	*** extract(java.lang.String,byte[],int);
	*** extract(java.lang.String,byte[],int[]);
	*** extractone(byte[],byte[],int[],boolean);
	*** getAlignment(byte);
	*** getHeaderFieldName(byte);
	*** getInterface();
	*** getName();
	*** getParameters();
	*** getPath();
	*** getSig();
	*** getSource();
	*** marshallint(long,byte[],int,int);
	*** marshallintBig(long,byte[],int,int);
	*** marshallintLittle(long,byte[],int,int);
	*** pad(byte);
	*** preallocate(int);
	*** setArgs(java.lang.Object[]);
}

-keep class org.freedesktop.dbus.Path {
	*** getPath();
}

-keep class org.freedesktop.dbus.Position {
	*** value();
}

-keep class org.freedesktop.dbus.Struct {
	org.freedesktop.dbus.Struct();
}

-keep class org.freedesktop.dbus.Tuple {
	org.freedesktop.dbus.Tuple();
}

-keep class org.freedesktop.dbus.UInt64 {
	*** bottom();
	*** top();
}

-keep class org.freedesktop.dbus.Variant {
	*** getSig();
	*** getValue();
}

-keep class org.freedesktop.dbus.exceptions.DBusException {
	org.freedesktop.dbus.exceptions.DBusException(java.lang.String);
}

-keep class org.hamcrest.BaseMatcher {
	org.hamcrest.BaseMatcher();
}

-keep class org.hamcrest.Description {
	*** appendDescriptionOf(org.hamcrest.SelfDescribing);
	*** appendText(java.lang.String);
	*** appendValue(java.lang.Object);
}

-keep class org.hamcrest.Matcher {
	*** matches(java.lang.Object);
}

-keep class org.hamcrest.SelfDescribing {
	*** describeTo(org.hamcrest.Description);
}

-keep class org.hamcrest.StringDescription {
	*** asString(org.hamcrest.SelfDescribing);
	*** toString(org.hamcrest.SelfDescribing);
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap {
	*** entrySet;
	*** keySet;
	*** segmentMask;
	*** segmentShift;
	*** segments;
	*** values;
	org.jboss.netty.util.internal.ConcurrentHashMap(int,float,int);
	*** clear();
	*** containsValue(java.lang.Object);
	*** get(java.lang.Object);
	*** hash(int);
	*** hashOf(java.lang.Object);
	*** isEmpty();
	*** put(java.lang.Object,java.lang.Object);
	*** putAll(java.util.Map);
	*** remove(java.lang.Object);
	*** remove(java.lang.Object,java.lang.Object);
	*** segmentFor(int);
	*** size();
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$EntryIterator {
	*** this$0;
	*** next();
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$EntrySet {
	*** this$0;
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$HashEntry {
	*** hash;
	*** key;
	*** next;
	*** value;
	*** key();
	*** newArray(int);
	*** setValue(java.lang.Object);
	*** value();
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$HashIterator {
	*** currentKey;
	*** currentTable;
	*** lastReturned;
	*** nextEntry;
	*** nextSegmentIndex;
	*** nextTableIndex;
	*** this$0;
	org.jboss.netty.util.internal.ConcurrentHashMap$HashIterator(org.jboss.netty.util.internal.ConcurrentHashMap);
	*** advance();
	*** hasNext();
	*** nextEntry();
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$Segment {
	*** count;
	*** loadFactor;
	*** modCount;
	*** table;
	*** threshold;
	*** clear();
	*** containsKey(java.lang.Object,int);
	*** containsValue(java.lang.Object);
	*** get(java.lang.Object,int);
	*** getFirst(int);
	*** keyEq(java.lang.Object,java.lang.Object);
	*** newArray(int);
	*** newHashEntry(java.lang.Object,int,org.jboss.netty.util.internal.ConcurrentHashMap$HashEntry,java.lang.Object);
	*** put(java.lang.Object,int,java.lang.Object,boolean);
	*** readValueUnderLock(org.jboss.netty.util.internal.ConcurrentHashMap$HashEntry);
	*** rehash();
	*** remove(java.lang.Object,int,java.lang.Object,boolean);
	*** replace(java.lang.Object,int,java.lang.Object);
	*** replace(java.lang.Object,int,java.lang.Object,java.lang.Object);
	*** setTable(org.jboss.netty.util.internal.ConcurrentHashMap$HashEntry[]);
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$SimpleEntry {
	*** key;
	*** value;
	org.jboss.netty.util.internal.ConcurrentHashMap$SimpleEntry(java.lang.Object,java.lang.Object);
	*** eq(java.lang.Object,java.lang.Object);
	*** getKey();
	*** setValue(java.lang.Object);
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$ValueIterator {
	*** this$0;
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$Values {
	*** this$0;
}

-keep class org.jboss.netty.util.internal.ConcurrentHashMap$WriteThroughEntry {
	*** this$0;
}

-keep class org.jcp.xml.dsig.internal.dom.XMLDSigRI$1 {
	*** this$0;
	*** val$map;
}

-keep class org.jivesoftware.smack.AbstractConnectionListener {
	org.jivesoftware.smack.AbstractConnectionListener();
}

-keep class org.jivesoftware.smack.AccountManager {
	*** setSupportsAccountCreation(boolean);
}

-keep class org.jivesoftware.smack.ChatManager {
	*** createChat(java.lang.String,org.jivesoftware.smack.MessageListener);
}

-keep class org.jivesoftware.smack.Connection {
	*** DEBUG_ENABLED;
	*** accountManager;
	*** chatManager;
	*** collectors;
	*** config;
	*** connectionCounter;
	*** connectionCounterValue;
	*** connectionEstablishedListeners;
	*** connectionListeners;
	*** debugger;
	*** interceptors;
	*** reader;
	*** recvListeners;
	*** saslAuthentication;
	*** sendListeners;
	*** writer;
	org.jivesoftware.smack.Connection(org.jivesoftware.smack.ConnectionConfiguration);
	*** addConnectionCreationListener(org.jivesoftware.smack.ConnectionCreationListener);
	*** addConnectionListener(org.jivesoftware.smack.ConnectionListener);
	*** addPacketInterceptor(org.jivesoftware.smack.PacketInterceptor,org.jivesoftware.smack.filter.PacketFilter);
	*** addPacketListener(org.jivesoftware.smack.PacketListener,org.jivesoftware.smack.filter.PacketFilter);
	*** addPacketSendingListener(org.jivesoftware.smack.PacketListener,org.jivesoftware.smack.filter.PacketFilter);
	*** connect();
	*** createPacketCollector(org.jivesoftware.smack.filter.PacketFilter);
	*** disconnect();
	*** disconnect(org.jivesoftware.smack.packet.Presence);
	*** firePacketInterceptors(org.jivesoftware.smack.packet.Packet);
	*** firePacketSendingListeners(org.jivesoftware.smack.packet.Packet);
	*** getAccountManager();
	*** getChatManager();
	*** getConfiguration();
	*** getConnectionCreationListeners();
	*** getConnectionListeners();
	*** getHost();
	*** getPacketCollectors();
	*** getSASLAuthentication();
	*** getServiceName();
	*** getUser();
	*** initDebugger();
	*** isAnonymous();
	*** isAuthenticated();
	*** isConnected();
	*** isReconnectionAllowed();
	*** login(java.lang.String,java.lang.String,java.lang.String);
	*** removePacketCollector(org.jivesoftware.smack.PacketCollector);
	*** removePacketInterceptor(org.jivesoftware.smack.PacketInterceptor);
	*** removePacketListener(org.jivesoftware.smack.PacketListener);
	*** removePacketSendingListener(org.jivesoftware.smack.PacketListener);
	*** sendPacket(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.Connection$InterceptorWrapper {
	*** notifyListener(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.Connection$ListenerWrapper {
	*** packetFilter;
	*** packetListener;
	*** notifyListener(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.ConnectionConfiguration {
	*** callbackHandler;
	*** cipherSuites;
	*** compressionEnabled;
	*** debuggerEnabled;
	*** expiredCertificatesCheckEnabled;
	*** host;
	*** keystorePath;
	*** keystoreType;
	*** notMatchingDomainCheckEnabled;
	*** password;
	*** pkcs11Library;
	*** port;
	*** proxy;
	*** reconnectionAllowed;
	*** resource;
	*** rosterLoadedAtLogin;
	*** saslAuthenticationEnabled;
	*** securityMode;
	*** selfSignedCertificateEnabled;
	*** sendPresence;
	*** serviceName;
	*** socketFactory;
	*** truststorePassword;
	*** truststorePath;
	*** truststoreType;
	*** username;
	*** verifyChainEnabled;
	*** verifyRootCAEnabled;
	*** getCallbackHandler();
	*** getCipherSuites();
	*** getHost();
	*** getKeystorePath();
	*** getKeystoreType();
	*** getPKCS11Library();
	*** getPassword();
	*** getPort();
	*** getProxy();
	*** getResource();
	*** getSecurityMode();
	*** getServiceName();
	*** getSocketFactory();
	*** getUsername();
	*** init(java.lang.String,int,java.lang.String,org.jivesoftware.smack.proxy.ProxyInfo);
	*** isCompressionEnabled();
	*** isDebuggerEnabled();
	*** isReconnectionAllowed();
	*** isRosterLoadedAtLogin();
	*** isSASLAuthenticationEnabled();
	*** isSendPresence();
	*** setCallbackHandler(javax.security.auth.callback.CallbackHandler);
	*** setCipherSuites(java.lang.String[]);
	*** setCompressionEnabled(boolean);
	*** setDebuggerEnabled(boolean);
	*** setExpiredCertificatesCheckEnabled(boolean);
	*** setLoginInfo(java.lang.String,java.lang.String,java.lang.String);
	*** setNotMatchingDomainCheckEnabled(boolean);
	*** setReconnectionAllowed(boolean);
	*** setRosterLoadedAtLogin(boolean);
	*** setSASLAuthenticationEnabled(boolean);
	*** setSecurityMode(org.jivesoftware.smack.ConnectionConfiguration$SecurityMode);
	*** setSelfSignedCertificateEnabled(boolean);
	*** setSendPresence(boolean);
	*** setServiceName(java.lang.String);
	*** setSocketFactory(javax.net.SocketFactory);
	*** setVerifyChainEnabled(boolean);
	*** setVerifyRootCAEnabled(boolean);
}

-keep class org.jivesoftware.smack.ConnectionConfiguration$SecurityMode {
	*** $VALUES;
	*** disabled;
	*** enabled;
	*** required;
}

-keep class org.jivesoftware.smack.ConnectionCreationListener {
	*** connectionCreated(org.jivesoftware.smack.Connection);
}

-keep class org.jivesoftware.smack.ConnectionListener {
	*** connectionClosed();
	*** connectionClosedOnError(java.lang.Exception);
	*** reconnectingIn(int);
	*** reconnectionFailed(java.lang.Exception);
	*** reconnectionSuccessful();
}

-keep class org.jivesoftware.smack.MessageListener {
	*** processMessage(org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message);
}

-keep class org.jivesoftware.smack.NonSASLAuthentication {
	*** authenticate(java.lang.String,java.lang.String,java.lang.String);
	*** authenticateAnonymously();
}

-keep class org.jivesoftware.smack.PacketCollector {
	*** cancelled;
	*** conection;
	*** maxPackets;
	*** packetFilter;
	*** resultQueue;
	org.jivesoftware.smack.PacketCollector(org.jivesoftware.smack.Connection,org.jivesoftware.smack.filter.PacketFilter);
	*** cancel();
	*** nextResult(long);
	*** processPacket(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.PacketInterceptor {
	*** interceptPacket(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.PacketListener {
	*** processPacket(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.PacketReader {
	*** connection;
	*** connectionID;
	*** connectionSemaphore;
	*** done;
	*** listenerExecutor;
	*** parser;
	*** readerThread;
	*** access$000(org.jivesoftware.smack.PacketReader,java.lang.Thread);
	*** access$100(org.jivesoftware.smack.PacketReader);
	*** cleanup();
	*** init();
	*** notifyConnectionError(java.lang.Exception);
	*** notifyReconnection();
	*** parseFeatures(org.xmlpull.v1.XmlPullParser);
	*** parsePackets(java.lang.Thread);
	*** processPacket(org.jivesoftware.smack.packet.Packet);
	*** releaseConnectionIDLock();
	*** resetParser();
	*** shutdown();
	*** startup();
}

-keep class org.jivesoftware.smack.PacketReader$1 {
	*** this$0;
}

-keep class org.jivesoftware.smack.PacketReader$2 {
	*** this$0;
}

-keep class org.jivesoftware.smack.PacketReader$ListenerNotification {
	*** packet;
	*** this$0;
}

-keep class org.jivesoftware.smack.PacketWriter {
	*** connection;
	*** done;
	*** keepAliveThread;
	*** lastActive;
	*** queue;
	*** writer;
	*** writerThread;
	*** access$000(org.jivesoftware.smack.PacketWriter,java.lang.Thread);
	*** access$100(org.jivesoftware.smack.PacketWriter);
	*** access$200(org.jivesoftware.smack.PacketWriter);
	*** access$300(org.jivesoftware.smack.PacketWriter);
	*** access$400(org.jivesoftware.smack.PacketWriter);
	*** cleanup();
	*** init();
	*** nextPacket();
	*** openStream();
	*** sendPacket(org.jivesoftware.smack.packet.Packet);
	*** setWriter(java.io.Writer);
	*** shutdown();
	*** startKeepAliveProcess();
	*** startup();
	*** writePackets(java.lang.Thread);
}

-keep class org.jivesoftware.smack.PacketWriter$1 {
	*** this$0;
}

-keep class org.jivesoftware.smack.PacketWriter$KeepAliveTask {
	*** delay;
	*** this$0;
	*** thread;
	*** setThread(java.lang.Thread);
}

-keep class org.jivesoftware.smack.PrivacyListListener {
	*** setPrivacyList(java.lang.String,java.util.List);
	*** updatedPrivacyList(java.lang.String);
}

-keep class org.jivesoftware.smack.PrivacyListManager {
	*** connection;
	*** instances;
	*** listeners;
	*** packetFilter;
	org.jivesoftware.smack.PrivacyListManager(org.jivesoftware.smack.Connection);
	*** access$100(org.jivesoftware.smack.PrivacyListManager);
	*** access$200();
	*** access$300(org.jivesoftware.smack.PrivacyListManager);
	*** getPrivacyListItems(java.lang.String);
	*** getPrivacyWithListNames();
	*** getRequest(org.jivesoftware.smack.packet.Privacy);
	*** getUser();
	*** init();
	*** setRequest(org.jivesoftware.smack.packet.Privacy);
	*** updatePrivacyList(java.lang.String,java.util.List);
}

-keep class org.jivesoftware.smack.PrivacyListManager$2 {
	*** this$0;
}

-keep class org.jivesoftware.smack.PrivacyListManager$3 {
	*** this$0;
}

-keep class org.jivesoftware.smack.PrivacyListManager$3$1 {
	*** this$1;
}

-keep class org.jivesoftware.smack.ReconnectionManager {
	*** connection;
	*** done;
	*** randomBase;
	*** reconnectionThread;
	org.jivesoftware.smack.ReconnectionManager(org.jivesoftware.smack.Connection);
	*** access$100(org.jivesoftware.smack.ReconnectionManager);
	*** access$200(org.jivesoftware.smack.ReconnectionManager);
	*** access$300(org.jivesoftware.smack.ReconnectionManager);
	*** isReconnectionAllowed();
	*** notifyAttemptToReconnectIn(int);
	*** notifyReconnectionFailed(java.lang.Exception);
	*** reconnect();
}

-keep class org.jivesoftware.smack.ReconnectionManager$2 {
	*** attempts;
	*** this$0;
	*** timeDelay();
}

-keep class org.jivesoftware.smack.Roster {
	*** connection;
	*** defaultSubscriptionMode;
	*** entries;
	*** groups;
	*** presenceMap;
	*** presencePacketListener;
	*** rosterInitialized;
	*** rosterListeners;
	*** subscriptionMode;
	*** unfiledEntries;
	*** access$100(org.jivesoftware.smack.Roster);
	*** access$1000(org.jivesoftware.smack.Roster,java.util.Collection,java.util.Collection,java.util.Collection);
	*** access$200(org.jivesoftware.smack.Roster);
	*** access$300(org.jivesoftware.smack.Roster,java.lang.String);
	*** access$400(org.jivesoftware.smack.Roster);
	*** access$500(org.jivesoftware.smack.Roster);
	*** access$600(org.jivesoftware.smack.Roster,org.jivesoftware.smack.packet.Presence);
	*** access$700(org.jivesoftware.smack.Roster);
	*** access$800(org.jivesoftware.smack.Roster);
	*** access$900(org.jivesoftware.smack.Roster);
	*** addRosterListener(org.jivesoftware.smack.RosterListener);
	*** cleanup();
	*** contains(java.lang.String);
	*** createEntry(java.lang.String,java.lang.String,java.lang.String[]);
	*** createGroup(java.lang.String);
	*** fireRosterChangedEvent(java.util.Collection,java.util.Collection,java.util.Collection);
	*** fireRosterPresenceEvent(org.jivesoftware.smack.packet.Presence);
	*** getDefaultSubscriptionMode();
	*** getEntries();
	*** getEntry(java.lang.String);
	*** getGroup(java.lang.String);
	*** getGroups();
	*** getPresence(java.lang.String);
	*** getPresenceMapKey(java.lang.String);
	*** getPresences(java.lang.String);
	*** reload();
	*** removeEntry(org.jivesoftware.smack.RosterEntry);
	*** setOfflinePresences();
	*** setSubscriptionMode(org.jivesoftware.smack.Roster$SubscriptionMode);
}

-keep class org.jivesoftware.smack.Roster$1 {
	*** this$0;
}

-keep class org.jivesoftware.smack.Roster$2 {
	*** this$0;
	*** val$connectionListener;
}

-keep class org.jivesoftware.smack.Roster$PresencePacketListener {
	*** this$0;
	org.jivesoftware.smack.Roster$PresencePacketListener(org.jivesoftware.smack.Roster);
	*** processPacket(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.Roster$RosterPacketListener {
	*** this$0;
}

-keep class org.jivesoftware.smack.Roster$SubscriptionMode {
	*** $VALUES;
	*** accept_all;
	*** manual;
	*** reject_all;
}

-keep class org.jivesoftware.smack.RosterEntry {
	*** aliasFor;
	*** autosub;
	*** connection;
	*** emc;
	*** inv;
	*** mc;
	*** name;
	*** rejected;
	*** roster;
	*** status;
	*** t;
	*** type;
	*** user;
	*** w;
	*** equalsDeep(java.lang.Object);
	*** getAliasFor();
	*** getEmc();
	*** getGroups();
	*** getInv();
	*** getMc();
	*** getName();
	*** getStatus();
	*** getT();
	*** getType();
	*** getUser();
	*** getW();
	*** isAutosub();
	*** isRejected();
	*** toRosterItem(org.jivesoftware.smack.RosterEntry);
}

-keep class org.jivesoftware.smack.RosterGroup {
	*** connection;
	*** entries;
	*** name;
	*** addEntryLocal(org.jivesoftware.smack.RosterEntry);
	*** contains(org.jivesoftware.smack.RosterEntry);
	*** getEntries();
	*** getEntry(java.lang.String);
	*** getEntryCount();
	*** getName();
	*** removeEntryLocal(org.jivesoftware.smack.RosterEntry);
}

-keep class org.jivesoftware.smack.RosterListener {
	*** entriesAdded(java.util.Collection);
	*** entriesDeleted(java.util.Collection);
	*** entriesUpdated(java.util.Collection);
	*** presenceChanged(org.jivesoftware.smack.packet.Presence);
}

-keep class org.jivesoftware.smack.SASLAuthentication {
	*** connection;
	*** currentMechanism;
	*** errorCondition;
	*** implementedMechanisms;
	*** mechanismsPreferences;
	*** resourceBinded;
	*** saslFailed;
	*** saslNegotiated;
	*** serverMechanisms;
	*** sessionSupported;
	*** authenticate(java.lang.String,java.lang.String,java.lang.String);
	*** authenticate(java.lang.String,java.lang.String,org.jivesoftware.smack.ConnectionConfiguration);
	*** authenticateAnonymously();
	*** authenticated();
	*** authenticationFailed(java.lang.String);
	*** bindResourceAndEstablishSession(java.lang.String);
	*** bindingRequired();
	*** challengeReceived(java.lang.String);
	*** hasAnonymousAuthentication();
	*** hasNonAnonymousAuthentication();
	*** init();
	*** registerSASLMechanism(java.lang.String,java.lang.Class);
	*** send(org.jivesoftware.smack.packet.Packet);
	*** sessionsSupported();
	*** setAvailableSASLMethods(java.util.Collection);
	*** supportSASLMechanism(java.lang.String);
	*** supportSASLMechanism(java.lang.String,int);
}

-keep class org.jivesoftware.smack.SmackConfiguration {
	*** defaultMechs;
	*** dnsSecEnabled;
	*** keepAliveInterval;
	*** localSocks5ProxyEnabled;
	*** localSocks5ProxyPort;
	*** packetCollectorSize;
	*** packetReplyTimeout;
	*** addSaslMech(java.lang.String);
	*** getClassLoaders();
	*** getKeepAliveInterval();
	*** getPacketCollectorSize();
	*** getPacketReplyTimeout();
	*** getVersion();
	*** isDnsSecEnabled();
	*** parseClassToLoad(org.xmlpull.v1.XmlPullParser);
	*** parseIntProperty(org.xmlpull.v1.XmlPullParser,int);
	*** removeSaslMech(java.lang.String);
	*** setPacketReplyTimeout(int);
}

-keep class org.jivesoftware.smack.XMPPConnection {
	*** anonymous;
	*** authenticated;
	*** compressionMethods;
	*** connected;
	*** connectionID;
	*** packetReader;
	*** packetWriter;
	*** roster;
	*** socket;
	*** user;
	*** usingCompression;
	*** usingTLS;
	*** wasAuthenticated;
	*** connect();
	*** connectUsingConfiguration(org.jivesoftware.smack.ConnectionConfiguration);
	*** getConnectionID();
	*** getRoster();
	*** getUser();
	*** hasAvailableCompressionMethod(java.lang.String);
	*** initConnection();
	*** initReaderAndWriter();
	*** isAnonymous();
	*** isAuthenticated();
	*** isConnected();
	*** isSecureConnection();
	*** isUsingTLS();
	*** login(java.lang.String,java.lang.String,java.lang.String);
	*** loginAnonymously();
	*** proceedTLSReceived();
	*** requestStreamCompression();
	*** sendPacket(org.jivesoftware.smack.packet.Packet);
	*** setAvailableCompressionMethods(java.util.Collection);
	*** setWasAuthenticated(boolean);
	*** shutdown(org.jivesoftware.smack.packet.Presence);
	*** startStreamCompression();
	*** startTLSReceived(boolean);
	*** streamCompressionDenied();
	*** useCompression();
}

-keep class org.jivesoftware.smack.XMPPException {
	*** error;
	*** streamError;
	*** wrappedThrowable;
	*** getMessage();
	*** getStreamError();
	*** getXMPPError();
	*** printStackTrace();
	*** printStackTrace(java.io.PrintStream);
}

-keep class org.jivesoftware.smack.debugger.SmackDebugger {
	*** getReader();
	*** getReaderListener();
	*** getWriter();
	*** getWriterListener();
	*** newConnectionReader(java.io.Reader);
	*** newConnectionWriter(java.io.Writer);
	*** userHasLogged(java.lang.String);
}

-keep class org.jivesoftware.smack.filter.AndFilter {
	*** filters;
}

-keep class org.jivesoftware.smack.filter.IQTypeFilter {
	*** type;
}

-keep class org.jivesoftware.smack.filter.PacketExtensionFilter {
	*** elementName;
	*** namespace;
	org.jivesoftware.smack.filter.PacketExtensionFilter(java.lang.String,java.lang.String);
}

-keep class org.jivesoftware.smack.filter.PacketFilter {
	*** accept(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smack.filter.PacketIDFilter {
	*** packetID;
}

-keep class org.jivesoftware.smack.filter.PacketTypeFilter {
	*** packetType;
}

-keep class org.jivesoftware.smack.packet.Authentication {
	*** digest;
	*** password;
	*** resource;
	*** username;
	*** setDigest(java.lang.String);
	*** setPassword(java.lang.String);
	*** setResource(java.lang.String);
	*** setUsername(java.lang.String);
}

-keep class org.jivesoftware.smack.packet.Bind {
	*** jid;
	*** resource;
	*** getJid();
	*** setJid(java.lang.String);
	*** setResource(java.lang.String);
}

-keep class org.jivesoftware.smack.packet.DefaultPacketExtension {
	*** elementName;
	*** map;
	*** namespace;
	*** getNames();
	*** getValue(java.lang.String);
	*** setValue(java.lang.String,java.lang.String);
}

-keep class org.jivesoftware.smack.packet.IQ {
	*** type;
	org.jivesoftware.smack.packet.IQ();
	*** getChildElementXML();
	*** getType();
	*** setType(org.jivesoftware.smack.packet.IQ$Type);
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.IQ$2 {
	*** val$request;
}

-keep class org.jivesoftware.smack.packet.IQ$Type {
	*** ERROR;
	*** GET;
	*** RESULT;
	*** SET;
	*** value;
	*** fromString(java.lang.String);
	*** toString();
}

-keep class org.jivesoftware.smack.packet.Message {
	*** bodies;
	*** language;
	*** subjects;
	*** thread;
	*** type;
	*** addBody(java.lang.String,java.lang.String);
	*** addSubject(java.lang.String,java.lang.String);
	*** determineLanguage(java.lang.String);
	*** getBodies();
	*** getBody();
	*** getBody(java.lang.String);
	*** getLanguage();
	*** getMessageBody(java.lang.String);
	*** getMessageSubject(java.lang.String);
	*** getSubject();
	*** getSubject(java.lang.String);
	*** getSubjects();
	*** getType();
	*** removeBody(java.lang.String);
	*** removeSubject(java.lang.String);
	*** setBody(java.lang.String);
	*** setLanguage(java.lang.String);
	*** setSubject(java.lang.String);
	*** setThread(java.lang.String);
	*** setType(org.jivesoftware.smack.packet.Message$Type);
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.Message$Body {
	*** language;
	*** message;
	org.jivesoftware.smack.packet.Message$Body(java.lang.String,java.lang.String);
	*** access$300(org.jivesoftware.smack.packet.Message$Body);
	*** access$400(org.jivesoftware.smack.packet.Message$Body);
	*** equals(java.lang.Object);
	*** getLanguage();
	*** getMessage();
}

-keep class org.jivesoftware.smack.packet.Message$Subject {
	*** access$000(org.jivesoftware.smack.packet.Message$Subject);
	*** access$100(org.jivesoftware.smack.packet.Message$Subject);
	*** equals(java.lang.Object);
}

-keep class org.jivesoftware.smack.packet.Message$Type {
	*** $VALUES;
	*** chat;
	*** error;
	*** groupchat;
	*** headline;
	*** normal;
	*** fromString(java.lang.String);
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smack.packet.Packet {
	*** DEFAULT_LANGUAGE;
	*** DEFAULT_XML_NS;
	*** error;
	*** from;
	*** id;
	*** packetExtensions;
	*** packetID;
	*** prefix;
	*** properties;
	*** to;
	*** xmlns;
	org.jivesoftware.smack.packet.Packet();
	*** addExtension(org.jivesoftware.smack.packet.PacketExtension);
	*** equals(java.lang.Object);
	*** getDefaultLanguage();
	*** getError();
	*** getExtension(java.lang.String,java.lang.String);
	*** getExtensions();
	*** getExtensionsXML();
	*** getFrom();
	*** getPacketID();
	*** getProperty(java.lang.String);
	*** getPropertyNames();
	*** getTo();
	*** getXmlns();
	*** nextID();
	*** setError(org.jivesoftware.smack.packet.XMPPError);
	*** setFrom(java.lang.String);
	*** setPacketID(java.lang.String);
	*** setProperty(java.lang.String,java.lang.Object);
	*** setTo(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.PacketExtension {
	*** getElementName();
	*** getNamespace();
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.Presence {
	*** language;
	*** mode;
	*** priority;
	*** status;
	*** type;
	*** getLanguage();
	*** getMode();
	*** getPriority();
	*** getStatus();
	*** getType();
	*** isAvailable();
	*** setLanguage(java.lang.String);
	*** setMode(org.jivesoftware.smack.packet.Presence$Mode);
	*** setPriority(int);
	*** setStatus(java.lang.String);
	*** setType(org.jivesoftware.smack.packet.Presence$Type);
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.Presence$Mode {
	*** $VALUES;
	*** available;
	*** away;
	*** chat;
	*** dnd;
	*** xa;
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smack.packet.Presence$Type {
	*** $VALUES;
	*** available;
	*** error;
	*** subscribe;
	*** subscribed;
	*** unavailable;
	*** unsubscribe;
	*** unsubscribed;
	*** valueOf(java.lang.String);
	*** values();
}

-keep class org.jivesoftware.smack.packet.Privacy {
	*** activeName;
	*** declineActiveList;
	*** declineDefaultList;
	*** defaultName;
	*** itemLists;
	*** getActiveName();
	*** getDefaultName();
	*** getItemLists();
	*** getPrivacyList(java.lang.String);
	*** getPrivacyListNames();
	*** isDeclineActiveList();
	*** isDeclineDefaultList();
	*** setActiveName(java.lang.String);
	*** setDeclineActiveList(boolean);
	*** setDeclineDefaultList(boolean);
	*** setDefaultName(java.lang.String);
	*** setPrivacyList(java.lang.String,java.util.List);
}

-keep class org.jivesoftware.smack.packet.PrivacyItem {
	*** getOrder();
	*** setFilterIQ(boolean);
	*** setFilterMessage(boolean);
	*** setFilterPresence_in(boolean);
	*** setFilterPresence_out(boolean);
	*** setValue(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.Registration {
	*** attributes;
	*** instructions;
	*** setAttributes(java.util.Map);
	*** setInstructions(java.lang.String);
}

-keep class org.jivesoftware.smack.packet.RosterPacket {
	*** rosterItems;
	*** addRosterItem(org.jivesoftware.smack.packet.RosterPacket$Item);
	*** getRosterItems();
}

-keep class org.jivesoftware.smack.packet.RosterPacket$Item {
	*** aliasFor;
	*** autosub;
	*** emc;
	*** groupNames;
	*** inv;
	*** itemStatus;
	*** itemType;
	*** mc;
	*** name;
	*** rejected;
	*** t;
	*** user;
	*** w;
	org.jivesoftware.smack.packet.RosterPacket$Item(java.lang.String,java.lang.String,org.jivesoftware.smack.packet.RosterPacket$ItemType,org.jivesoftware.smack.packet.RosterPacket$ItemStatus,int,int,int,boolean,java.lang.String,boolean,java.lang.String,java.lang.String);
	*** addGroupName(java.lang.String);
	*** getAliasFor();
	*** getEmc();
	*** getGroupNames();
	*** getInv();
	*** getItemStatus();
	*** getItemType();
	*** getMc();
	*** getName();
	*** getT();
	*** getUser();
	*** getW();
	*** isAutosub();
	*** isRejected();
	*** removeGroupName(java.lang.String);
	*** setItemType(org.jivesoftware.smack.packet.RosterPacket$ItemType);
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.RosterPacket$ItemStatus {
	*** SUBSCRIPTION_PENDING;
	*** UNSUBSCRIPTION_PENDING;
	*** value;
	*** fromString(java.lang.String);
	*** toString();
}

-keep class org.jivesoftware.smack.packet.RosterPacket$ItemType {
	*** $VALUES;
	*** both;
	*** from;
	*** none;
	*** remove;
	*** to;
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smack.packet.StreamError {
	*** getCode();
	*** toString();
}

-keep class org.jivesoftware.smack.packet.XMPPError {
	*** applicationExtensions;
	*** code;
	*** condition;
	*** message;
	*** type;
	*** addExtension(org.jivesoftware.smack.packet.PacketExtension);
	*** getCode();
	*** getCondition();
	*** getExtensions();
	*** getMessage();
	*** getType();
	*** init(org.jivesoftware.smack.packet.XMPPError$Condition);
	*** toString();
	*** toXML();
}

-keep class org.jivesoftware.smack.packet.XMPPError$Condition {
	*** bad_request;
	*** feature_not_implemented;
	*** forbidden;
	*** interna_server_error;
	*** item_not_found;
	*** no_acceptable;
	*** not_allowed;
	*** remote_server_error;
	*** remote_server_timeout;
	*** request_timeout;
	*** access$000(org.jivesoftware.smack.packet.XMPPError$Condition);
}

-keep class org.jivesoftware.smack.packet.XMPPError$ErrorSpecification {
	*** getCode();
	*** getType();
	*** specFor(org.jivesoftware.smack.packet.XMPPError$Condition);
}

-keep class org.jivesoftware.smack.packet.XMPPError$Type {
	*** $VALUES;
	*** AUTH;
	*** CANCEL;
	*** CONTINUE;
	*** MODIFY;
	*** WAIT;
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smack.provider.IQProvider {
	*** parseIQ(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smack.provider.PacketExtensionProvider {
	*** parseExtension(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smack.provider.PrivacyProvider {
	*** parseItem(org.xmlpull.v1.XmlPullParser);
	*** parseList(org.xmlpull.v1.XmlPullParser,org.jivesoftware.smack.packet.Privacy);
}

-keep class org.jivesoftware.smack.provider.ProviderManager {
	*** extensionProviders;
	*** instance;
	*** iqProviders;
	*** addIQProvider(java.lang.String,java.lang.String,java.lang.Object);
	*** getClassLoaders();
	*** getExtensionProvider(java.lang.String,java.lang.String);
	*** getIQProvider(java.lang.String,java.lang.String);
	*** getInstance();
	*** getProviderKey(java.lang.String,java.lang.String);
	*** initialize();
}

-keep class org.jivesoftware.smack.proxy.HTTPProxySocketFactory {
	*** RESPONSE_PATTERN;
	*** proxy;
	*** httpProxifiedSocket(java.lang.String,int);
}

-keep class org.jivesoftware.smack.proxy.ProxyInfo {
	*** proxyAddress;
	*** proxyPassword;
	*** proxyPort;
	*** proxyType;
	*** proxyUsername;
	*** forDefaultProxy();
	*** getProxyAddress();
	*** getProxyPassword();
	*** getProxyPort();
	*** getProxyType();
	*** getProxyUsername();
	*** getSocketFactory();
}

-keep class org.jivesoftware.smack.proxy.ProxyInfo$ProxyType {
	*** $VALUES;
	*** HTTP;
	*** NONE;
	*** SOCKS4;
	*** SOCKS5;
}

-keep class org.jivesoftware.smack.proxy.Socks4ProxySocketFactory {
	*** proxy;
	*** socks4ProxifiedSocket(java.lang.String,int);
}

-keep class org.jivesoftware.smack.proxy.Socks5ProxySocketFactory {
	*** proxy;
	*** fill(java.io.InputStream,byte[],int);
	*** socks5ProxifiedSocket(java.lang.String,int);
}

-keep class org.jivesoftware.smack.sasl.SASLAnonymous {
	*** authenticate();
	*** getName();
}

-keep class org.jivesoftware.smack.sasl.SASLGSSAPIMechanism {
	*** getName();
}

-keep class org.jivesoftware.smack.sasl.SASLMechanism {
	*** authenticationId;
	*** hostname;
	*** password;
	*** saslAuthentication;
	*** sc;
	org.jivesoftware.smack.sasl.SASLMechanism(org.jivesoftware.smack.SASLAuthentication);
	*** authenticate();
	*** authenticate(java.lang.String,java.lang.String,java.lang.String);
	*** authenticate(java.lang.String,java.lang.String,javax.security.auth.callback.CallbackHandler);
	*** authenticate(java.lang.String,java.lang.String,org.jivesoftware.smack.ConnectionConfiguration);
	*** challengeReceived(java.lang.String);
	*** getName();
	*** getSASLAuthentication();
}

-keep class org.jivesoftware.smack.sasl.SASLMechanism$AuthMechanism {
	*** authenticationText;
	*** name;
	*** this$0;
}

-keep class org.jivesoftware.smack.sasl.SASLMechanism$Challenge {
	*** data;
}

-keep class org.jivesoftware.smack.sasl.SASLMechanism$Failure {
	*** condition;
	*** getCondition();
}

-keep class org.jivesoftware.smack.sasl.SASLMechanism$Response {
	*** authenticationText;
	*** this$0;
}

-keep class org.jivesoftware.smack.sasl.SASLMechanism$Success {
	*** data;
}

-keep class org.jivesoftware.smack.util.Base64 {
	*** _ORDERED_ALPHABET;
	*** _ORDERED_DECODABET;
	*** _STANDARD_ALPHABET;
	*** _STANDARD_DECODABET;
	*** _URL_SAFE_ALPHABET;
	*** _URL_SAFE_DECODABET;
	*** access$000(int);
	*** access$100(int);
	*** access$300(byte[],int,byte[],int,int);
	*** access$400(byte[],byte[],int,int);
	*** decode(byte[],int,int,int);
	*** decode(java.lang.String);
	*** decode(java.lang.String,int);
	*** decode4to3(byte[],int,byte[],int,int);
	*** decodeFileToFile(java.lang.String,java.lang.String);
	*** decodeFromFile(java.lang.String);
	*** encode3to4(byte[],byte[],int,int);
	*** encode3to4(byte[],int,int,byte[],int,int);
	*** encodeBytes(byte[]);
	*** encodeBytes(byte[],int);
	*** encodeBytes(byte[],int,int,int);
	*** encodeFileToFile(java.lang.String,java.lang.String);
	*** encodeFromFile(java.lang.String);
	*** encodeObject(java.io.Serializable,int);
	*** getAlphabet(int);
	*** getDecodabet(int);
	*** usage(java.lang.String);
}

-keep class org.jivesoftware.smack.util.Base64$InputStream {
	*** read(byte[],int,int);
}

-keep class org.jivesoftware.smack.util.Base64$OutputStream {
	*** alphabet;
	*** b4;
	*** breakLines;
	*** buffer;
	*** bufferLength;
	*** decodabet;
	*** encode;
	*** lineLength;
	*** options;
	*** position;
	*** suspendEncoding;
	org.jivesoftware.smack.util.Base64$OutputStream(java.io.OutputStream,int);
	*** close();
	*** flushBase64();
	*** write(int);
}

-keep class org.jivesoftware.smack.util.DNSUtil {
	*** resolveXMPPDomain(java.lang.String);
}

-keep class org.jivesoftware.smack.util.DNSUtil$HostAddress {
	*** getHost();
	*** getPort();
}

-keep class org.jivesoftware.smack.util.PacketParserUtils {
	*** assign(org.xmlpull.v1.XmlPullParser,java.lang.String,java.lang.String);
	*** decode(java.lang.Class,java.lang.String);
	*** getLanguageAttribute(org.xmlpull.v1.XmlPullParser);
	*** parseAuthentication(org.xmlpull.v1.XmlPullParser);
	*** parseBoolean(java.lang.String);
	*** parseCompressionMethods(org.xmlpull.v1.XmlPullParser);
	*** parseContent(org.xmlpull.v1.XmlPullParser);
	*** parseError(org.xmlpull.v1.XmlPullParser);
	*** parseIQ(org.xmlpull.v1.XmlPullParser,org.jivesoftware.smack.Connection);
	*** parseInt(java.lang.String);
	*** parseMechanisms(org.xmlpull.v1.XmlPullParser);
	*** parseMessage(org.xmlpull.v1.XmlPullParser);
	*** parsePacketExtension(java.lang.String,java.lang.String,org.xmlpull.v1.XmlPullParser);
	*** parsePresence(org.xmlpull.v1.XmlPullParser);
	*** parseProperties(org.xmlpull.v1.XmlPullParser);
	*** parseRegistration(org.xmlpull.v1.XmlPullParser);
	*** parseResourceBinding(org.xmlpull.v1.XmlPullParser);
	*** parseRoster(org.xmlpull.v1.XmlPullParser);
	*** parseSASLFailure(org.xmlpull.v1.XmlPullParser);
	*** parseStreamError(org.xmlpull.v1.XmlPullParser);
	*** parseWithIntrospection(java.lang.String,java.lang.Class,org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smack.util.StringUtils {
	*** AMP_ENCODE;
	*** APOS_ENCODE;
	*** GT_ENCODE;
	*** LT_ENCODE;
	*** QUOTE_ENCODE;
	*** XEP_0082_UTC_FORMAT;
	*** digest;
	*** numbersAndLetters;
	*** randGen;
	*** decodeBase64(java.lang.String);
	*** encodeBase64(byte[]);
	*** encodeBase64(byte[],boolean);
	*** encodeBase64(byte[],int,int,boolean);
	*** encodeHex(byte[]);
	*** escapeForXML(java.lang.String);
	*** hash(java.lang.String);
	*** parseBareAddress(java.lang.String);
	*** parseName(java.lang.String);
	*** parseResource(java.lang.String);
	*** parseServer(java.lang.String);
	*** parseXEP0082Date(java.lang.String);
	*** randomString(int);
}

-keep class org.jivesoftware.smackx.ChatState {
	*** active;
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smackx.Form {
	*** getDataFormToSend();
	*** getFields();
	*** getFormFrom(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smackx.FormField {
	*** addOption(org.jivesoftware.smackx.FormField$Option);
	*** addValue(java.lang.String);
	*** getValues();
	*** getVariable();
	*** setDescription(java.lang.String);
	*** setLabel(java.lang.String);
	*** setRequired(boolean);
	*** setType(java.lang.String);
}

-keep class org.jivesoftware.smackx.LastActivityManager {
	*** connection;
	*** lastMessageSent;
	org.jivesoftware.smackx.LastActivityManager(org.jivesoftware.smack.Connection);
	*** access$100(org.jivesoftware.smackx.LastActivityManager);
	*** access$200(org.jivesoftware.smackx.LastActivityManager);
	*** access$300(org.jivesoftware.smackx.LastActivityManager);
	*** getIdleTime();
	*** resetIdleTime();
}

-keep class org.jivesoftware.smackx.LastActivityManager$2 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.LastActivityManager$3 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.NodeInformationProvider {
	*** getNodeFeatures();
	*** getNodeIdentities();
	*** getNodeItems();
}

-keep class org.jivesoftware.smackx.PrivateDataManager {
	*** getPrivateDataProvider(java.lang.String,java.lang.String);
}

-keep class org.jivesoftware.smackx.PrivateDataManager$PrivateDataResult {
	*** privateData;
}

-keep class org.jivesoftware.smackx.ReportedData {
	*** addColumn(org.jivesoftware.smackx.ReportedData$Column);
	*** addRow(org.jivesoftware.smackx.ReportedData$Row);
	*** getColumns();
	*** getReportedDataFrom(org.jivesoftware.smack.packet.Packet);
}

-keep class org.jivesoftware.smackx.ReportedData$Column {
	*** getVariable();
}

-keep class org.jivesoftware.smackx.ServiceDiscoveryManager {
	*** connection;
	*** extendedInfo;
	*** features;
	*** identityName;
	*** identityType;
	*** instances;
	*** nodeInformationProviders;
	*** access$000(org.jivesoftware.smackx.ServiceDiscoveryManager);
	*** access$100();
	*** access$200(org.jivesoftware.smackx.ServiceDiscoveryManager,java.lang.String);
	*** access$300(org.jivesoftware.smackx.ServiceDiscoveryManager);
	*** access$400(org.jivesoftware.smackx.ServiceDiscoveryManager);
	*** addFeature(java.lang.String);
	*** discoverInfo(java.lang.String);
	*** discoverInfo(java.lang.String,java.lang.String);
	*** discoverItems(java.lang.String);
	*** discoverItems(java.lang.String,java.lang.String);
	*** getFeatures();
	*** getIdentityName();
	*** getIdentityType();
	*** getInstanceFor(org.jivesoftware.smack.Connection);
	*** getNodeInformationProvider(java.lang.String);
	*** includesFeature(java.lang.String);
	*** init();
	*** publishItems(java.lang.String,java.lang.String,org.jivesoftware.smackx.packet.DiscoverItems);
	*** removeFeature(java.lang.String);
	*** setNodeInformationProvider(java.lang.String,org.jivesoftware.smackx.NodeInformationProvider);
}

-keep class org.jivesoftware.smackx.ServiceDiscoveryManager$2 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.ServiceDiscoveryManager$3 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.ServiceDiscoveryManager$4 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.XHTMLManager {
	*** isServiceEnabled(org.jivesoftware.smack.Connection);
	*** setServiceEnabled(org.jivesoftware.smack.Connection,boolean);
}

-keep class org.jivesoftware.smackx.commands.AdHocCommand {
	*** cancel();
	*** complete(org.jivesoftware.smackx.Form);
	*** execute();
	*** getExecuteAction();
	*** isValidAction(org.jivesoftware.smackx.commands.AdHocCommand$Action);
	*** next(org.jivesoftware.smackx.Form);
	*** prev();
	*** setName(java.lang.String);
	*** setNode(java.lang.String);
}

-keep class org.jivesoftware.smackx.commands.AdHocCommand$Action {
	*** cancel;
	*** complete;
	*** execute;
	*** next;
	*** prev;
	*** unknown;
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smackx.commands.AdHocCommand$SpecificErrorCondition {
	*** badAction;
	*** badLocale;
	*** badPayload;
	*** badSessionid;
	*** malformedAction;
	*** sessionExpired;
}

-keep class org.jivesoftware.smackx.commands.AdHocCommand$Status {
	*** canceled;
	*** completed;
	*** executing;
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandManager {
	*** commands;
	*** connection;
	*** executingCommands;
	*** instances;
	*** sessionsSweeper;
	org.jivesoftware.smackx.commands.AdHocCommandManager(org.jivesoftware.smack.Connection);
	*** access$100(org.jivesoftware.smackx.commands.AdHocCommandManager);
	*** access$200();
	*** access$300(org.jivesoftware.smackx.commands.AdHocCommandManager);
	*** access$400(org.jivesoftware.smackx.commands.AdHocCommandManager,org.jivesoftware.smackx.packet.AdHocCommandData);
	*** access$500(org.jivesoftware.smackx.commands.AdHocCommandManager);
	*** getRegisteredCommands();
	*** init();
	*** newInstanceOfCmd(java.lang.String,java.lang.String);
	*** processAdHocCommand(org.jivesoftware.smackx.packet.AdHocCommandData);
	*** registerCommand(java.lang.String,java.lang.String,org.jivesoftware.smackx.commands.LocalCommandFactory);
	*** respondError(org.jivesoftware.smackx.packet.AdHocCommandData,org.jivesoftware.smack.packet.XMPPError$Condition);
	*** respondError(org.jivesoftware.smackx.packet.AdHocCommandData,org.jivesoftware.smack.packet.XMPPError$Condition,org.jivesoftware.smackx.commands.AdHocCommand$SpecificErrorCondition);
	*** respondError(org.jivesoftware.smackx.packet.AdHocCommandData,org.jivesoftware.smack.packet.XMPPError);
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandManager$4 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandManager$5 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandManager$6 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandManager$7 {
	*** this$0;
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandManager$AdHocCommandInfo {
	*** getCommandInstance();
	*** getName();
	*** getNode();
	*** getOwnerJID();
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandNote {
	*** getType();
	*** getValue();
}

-keep class org.jivesoftware.smackx.commands.AdHocCommandNote$Type {
	*** valueOf(java.lang.String);
}

-keep class org.jivesoftware.smackx.commands.LocalCommand {
	*** decrementStage();
	*** getCreationDate();
	*** hasPermission(java.lang.String);
	*** incrementStage();
	*** isLastStage();
	*** setData(org.jivesoftware.smackx.packet.AdHocCommandData);
	*** setSessionID(java.lang.String);
}

-keep class org.jivesoftware.smackx.filetransfer.FileTransfer {
	*** setFileInfo(java.lang.String,long);
}

-keep class org.jivesoftware.smackx.filetransfer.FileTransferListener {
	*** fileTransferRequest(org.jivesoftware.smackx.filetransfer.FileTransferRequest);
}

-keep class org.jivesoftware.smackx.filetransfer.FileTransferManager {
	*** connection;
	*** fileTransferNegotiator;
	*** listeners;
	*** initListeners();
}

-keep class org.jivesoftware.smackx.filetransfer.FileTransferNegotiator {
	*** createIQ(java.lang.String,java.lang.String,java.lang.String,org.jivesoftware.smack.packet.IQ$Type);
	*** getInstanceFor(org.jivesoftware.smack.Connection);
	*** getNextStreamID();
}

-keep class org.jivesoftware.smackx.filetransfer.FileTransferRequest {
	*** getFileName();
	*** getFileSize();
	*** getStreamInitiation();
}

-keep class org.jivesoftware.smackx.muc.ConnectionDetachedPacketCollector {
	*** nextResult();
	*** nextResult(long);
	*** pollResult();
}

-keep class org.jivesoftware.smackx.muc.DiscussionHistory {
	*** getMUCHistory();
}

-keep class org.jivesoftware.smackx.muc.InvitationRejectionListener {
	*** invitationDeclined(java.lang.String,java.lang.String);
}

-keep class org.jivesoftware.smackx.muc.MultiUserChat {
	*** connection;
	*** connectionListeners;
	*** invitationRejectionListeners;
	*** joined;
	*** joinedRooms;
	*** messageCollector;
	*** messageFilter;
	*** nickname;
	*** occupantsMap;
	*** participantStatusListeners;
	*** presenceFilter;
	*** presenceInterceptors;
	*** room;
	*** roomListenerMultiplexor;
	*** subject;
	*** subjectUpdatedListeners;
	*** userStatusListeners;
	*** access$000(org.jivesoftware.smack.Connection);
	*** changeAffiliationByAdmin(java.lang.String,java.lang.String,java.lang.String);
	*** changeAffiliationByAdmin(java.util.Collection,java.lang.String);
	*** changeAffiliationByOwner(java.lang.String,java.lang.String);
	*** changeAffiliationByOwner(java.util.Collection,java.lang.String);
	*** changeRole(java.lang.String,java.lang.String,java.lang.String);
	*** changeRole(java.util.Collection,java.lang.String);
	*** checkAffiliationModifications(java.lang.String,java.lang.String,boolean,java.lang.String);
	*** checkPresenceCode(java.lang.String,boolean,org.jivesoftware.smackx.packet.MUCUser,java.lang.String);
	*** checkRoleModifications(java.lang.String,java.lang.String,boolean,java.lang.String);
	*** fireInvitationRejectionListeners(java.lang.String,java.lang.String);
	*** fireParticipantStatusListeners(java.lang.String,java.util.List);
	*** fireSubjectUpdatedListeners(java.lang.String,java.lang.String);
	*** fireUserStatusListeners(java.lang.String,java.lang.Object[]);
	*** getAffiliatesByAdmin(java.lang.String);
	*** getAffiliatesByOwner(java.lang.String);
	*** getJoinedRooms(org.jivesoftware.smack.Connection);
	*** getMUCUserExtension(org.jivesoftware.smack.packet.Packet);
	*** getOccupants(java.lang.String);
	*** init();
	*** invite(org.jivesoftware.smack.packet.Message,java.lang.String,java.lang.String);
	*** join(java.lang.String,java.lang.String,org.jivesoftware.smackx.muc.DiscussionHistory,long);
	*** leave();
	*** userHasJoined();
	*** userHasLeft();
}

-keep class org.jivesoftware.smackx.muc.MultiUserChat$1$1 {
	*** this$0;
	*** val$connection;
}

-keep class org.jivesoftware.smackx.muc.MultiUserChat$InvitationsMonitor {
	*** addInvitationListener(org.jivesoftware.smackx.muc.InvitationListener);
	*** getInvitationsMonitor(org.jivesoftware.smack.Connection);
	*** removeInvitationListener(org.jivesoftware.smackx.muc.InvitationListener);
}

-keep class org.jivesoftware.smackx.muc.RoomListenerMultiplexor {
	*** addRoom(java.lang.String,org.jivesoftware.smackx.muc.PacketMultiplexListener);
	*** getRoomMultiplexor(org.jivesoftware.smack.Connection);
	*** removeRoom(java.lang.String);
}

-keep class org.jivesoftware.smackx.muc.SubjectUpdatedListener {
	*** subjectUpdated(java.lang.String,java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.AdHocCommandData {
	*** action;
	*** actions;
	*** executeAction;
	*** form;
	*** id;
	*** lang;
	*** name;
	*** node;
	*** notes;
	*** sessionID;
	*** status;
	*** addAction(org.jivesoftware.smackx.commands.AdHocCommand$Action);
	*** addNote(org.jivesoftware.smackx.commands.AdHocCommandNote);
	*** getAction();
	*** getForm();
	*** getNode();
	*** getSessionID();
	*** setAction(org.jivesoftware.smackx.commands.AdHocCommand$Action);
	*** setExecuteAction(org.jivesoftware.smackx.commands.AdHocCommand$Action);
	*** setForm(org.jivesoftware.smackx.packet.DataForm);
	*** setId(java.lang.String);
	*** setNode(java.lang.String);
	*** setSessionID(java.lang.String);
	*** setStatus(org.jivesoftware.smackx.commands.AdHocCommand$Status);
}

-keep class org.jivesoftware.smackx.packet.Bytestream {
	*** mode;
	*** sessionID;
	*** streamHosts;
	*** toActivate;
	*** usedHost;
	*** addStreamHost(java.lang.String,java.lang.String);
	*** addStreamHost(java.lang.String,java.lang.String,int);
	*** addStreamHost(org.jivesoftware.smackx.packet.Bytestream$StreamHost);
	*** countStreamHosts();
	*** getMode();
	*** getSessionID();
	*** getStreamHosts();
	*** getToActivate();
	*** getUsedHost();
	*** setMode(org.jivesoftware.smackx.packet.Bytestream$Mode);
	*** setSessionID(java.lang.String);
	*** setToActivate(java.lang.String);
	*** setUsedHost(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.Bytestream$Activate {
	*** ELEMENTNAME;
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.Bytestream$Mode {
	*** tcp;
	*** fromName(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.Bytestream$StreamHost {
	*** ELEMENTNAME;
	*** getJID();
	*** setPort(int);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.Bytestream$StreamHostUsed {
	*** ELEMENTNAME;
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.DataForm {
	*** addField(org.jivesoftware.smackx.FormField);
	*** addInstruction(java.lang.String);
	*** addItem(org.jivesoftware.smackx.packet.DataForm$Item);
	*** getElementName();
	*** setReportedData(org.jivesoftware.smackx.packet.DataForm$ReportedData);
	*** setTitle(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.DefaultPrivateData {
	*** setValue(java.lang.String,java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.DelayInformation {
	*** XEP_0091_UTC_FORMAT;
	*** from;
	*** reason;
	*** stamp;
	*** getElementName();
	*** getNamespace();
	*** setFrom(java.lang.String);
	*** setReason(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.DiscoverInfo {
	*** features;
	*** identities;
	*** node;
	*** addFeature(java.lang.String);
	*** addFeature(org.jivesoftware.smackx.packet.DiscoverInfo$Feature);
	*** addIdentity(org.jivesoftware.smackx.packet.DiscoverInfo$Identity);
	*** containsFeature(java.lang.String);
	*** getFeatures();
	*** getIdentities();
	*** getNode();
	*** setNode(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.DiscoverInfo$Feature {
	*** getVar();
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.DiscoverInfo$Identity {
	*** getName();
	*** setType(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.DiscoverItems {
	*** items;
	*** node;
	*** addItem(org.jivesoftware.smackx.packet.DiscoverItems$Item);
	*** getItems();
	*** getNode();
	*** setNode(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.DiscoverItems$Item {
	*** getEntityID();
	*** setAction(java.lang.String);
	*** setName(java.lang.String);
	*** setNode(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.IBBExtensions$Close {
	*** getElementName();
	*** getNamespace();
	*** getSessionID();
}

-keep class org.jivesoftware.smackx.packet.IBBExtensions$IBB {
	*** sid;
	org.jivesoftware.smackx.packet.IBBExtensions$IBB(java.lang.String);
	org.jivesoftware.smackx.packet.IBBExtensions$IBB(java.lang.String,org.jivesoftware.smackx.packet.IBBExtensions$1);
	*** getNamespace();
	*** getSessionID();
}

-keep class org.jivesoftware.smackx.packet.IBBExtensions$Open {
	*** blockSize;
	*** getBlockSize();
	*** getElementName();
	*** getNamespace();
	*** getSessionID();
}

-keep class org.jivesoftware.smackx.packet.LastActivity {
	*** lastActivity;
	*** message;
	*** access$000(org.jivesoftware.smackx.packet.LastActivity,java.lang.String);
	*** setLastActivity(long);
	*** setMessage(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MUCAdmin {
	*** items;
	*** addItem(org.jivesoftware.smackx.packet.MUCAdmin$Item);
	*** getItems();
}

-keep class org.jivesoftware.smackx.packet.MUCAdmin$Item {
	*** setActor(java.lang.String);
	*** setJid(java.lang.String);
	*** setNick(java.lang.String);
	*** setReason(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.MUCInitialPresence {
	*** setHistory(org.jivesoftware.smackx.packet.MUCInitialPresence$History);
	*** setPassword(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MUCOwner {
	*** destroy;
	*** items;
	*** addItem(org.jivesoftware.smackx.packet.MUCOwner$Item);
	*** getDestroy();
	*** getItems();
	*** setDestroy(org.jivesoftware.smackx.packet.MUCOwner$Destroy);
}

-keep class org.jivesoftware.smackx.packet.MUCOwner$Destroy {
	*** setJid(java.lang.String);
	*** setReason(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.MUCOwner$Item {
	*** setActor(java.lang.String);
	*** setJid(java.lang.String);
	*** setNick(java.lang.String);
	*** setReason(java.lang.String);
	*** setRole(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.MUCUser {
	*** getItem();
	*** getStatus();
	*** setDecline(org.jivesoftware.smackx.packet.MUCUser$Decline);
	*** setDestroy(org.jivesoftware.smackx.packet.MUCUser$Destroy);
	*** setInvite(org.jivesoftware.smackx.packet.MUCUser$Invite);
	*** setItem(org.jivesoftware.smackx.packet.MUCUser$Item);
	*** setPassword(java.lang.String);
	*** setStatus(org.jivesoftware.smackx.packet.MUCUser$Status);
}

-keep class org.jivesoftware.smackx.packet.MUCUser$Decline {
	*** setFrom(java.lang.String);
	*** setReason(java.lang.String);
	*** setTo(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MUCUser$Destroy {
	*** setJid(java.lang.String);
	*** setReason(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MUCUser$Invite {
	*** setFrom(java.lang.String);
	*** setReason(java.lang.String);
	*** setTo(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MUCUser$Item {
	*** getActor();
	*** getNick();
	*** getReason();
	*** setActor(java.lang.String);
	*** setJid(java.lang.String);
	*** setNick(java.lang.String);
	*** setReason(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MUCUser$Status {
	*** getCode();
}

-keep class org.jivesoftware.smackx.packet.MessageEvent {
	*** setComposing(boolean);
	*** setDelivered(boolean);
	*** setDisplayed(boolean);
	*** setOffline(boolean);
	*** setPacketID(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.MultipleAddresses {
	*** addAddress(java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String);
	*** getElementName();
}

-keep class org.jivesoftware.smackx.packet.OfflineMessageInfo {
	*** setNode(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.OfflineMessageRequest {
	*** fetch;
	*** items;
	*** purge;
	*** addItem(org.jivesoftware.smackx.packet.OfflineMessageRequest$Item);
	*** setFetch(boolean);
	*** setPurge(boolean);
}

-keep class org.jivesoftware.smackx.packet.OfflineMessageRequest$Item {
	*** setAction(java.lang.String);
	*** setJid(java.lang.String);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.OfflineMessageRequest$Provider {
	*** parseItem(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smackx.packet.PrivateData {
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.RosterExchange {
	*** addRosterEntry(org.jivesoftware.smackx.RemoteRosterEntry);
}

-keep class org.jivesoftware.smackx.packet.SharedGroupsInfo {
	*** groups;
	*** getGroups();
}

-keep class org.jivesoftware.smackx.packet.StreamInitiation {
	*** featureNegotiation;
	*** file;
	*** id;
	*** mimeType;
	*** getMimeType();
	*** getSessionID();
	*** setFeatureNegotiationForm(org.jivesoftware.smackx.packet.DataForm);
	*** setFile(org.jivesoftware.smackx.packet.StreamInitiation$File);
	*** setMimeType(java.lang.String);
	*** setSesssionID(java.lang.String);
}

-keep class org.jivesoftware.smackx.packet.StreamInitiation$Feature {
	*** getData();
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.StreamInitiation$File {
	*** setDate(java.util.Date);
	*** setDesc(java.lang.String);
	*** setHash(java.lang.String);
	*** setRanged(boolean);
	*** toXML();
}

-keep class org.jivesoftware.smackx.packet.Time {
	*** display;
	*** displayFormat;
	*** tz;
	*** utc;
	*** utcFormat;
}

-keep class org.jivesoftware.smackx.packet.VCard {
	*** avatar;
	*** emailHome;
	*** emailWork;
	*** firstName;
	*** homeAddr;
	*** homePhones;
	*** lastName;
	*** middleName;
	*** organization;
	*** organizationUnit;
	*** otherSimpleFields;
	*** otherUnescapableFields;
	*** workAddr;
	*** workPhones;
	*** access$000(org.jivesoftware.smackx.packet.VCard);
	*** access$1100(org.jivesoftware.smackx.packet.VCard);
	*** access$1200(org.jivesoftware.smackx.packet.VCard);
	*** access$1300(org.jivesoftware.smackx.packet.VCard);
	*** access$200(org.jivesoftware.smackx.packet.VCard);
	*** access$300(org.jivesoftware.smackx.packet.VCard);
	*** access$400(org.jivesoftware.smackx.packet.VCard);
	*** access$500(org.jivesoftware.smackx.packet.VCard);
	*** access$600(org.jivesoftware.smackx.packet.VCard);
	*** access$700(org.jivesoftware.smackx.packet.VCard);
	*** access$800(org.jivesoftware.smackx.packet.VCard);
	*** checkAuthenticated(org.jivesoftware.smack.Connection,boolean);
	*** copyFieldsFrom(org.jivesoftware.smackx.packet.VCard);
	*** doLoad(org.jivesoftware.smack.Connection,java.lang.String);
	*** getAvatar();
	*** getBytes(java.net.URL);
	*** getChildElementXML();
	*** getField(java.lang.String);
	*** getFileBytes(java.io.File);
	*** hasContent();
	*** hasNameField();
	*** hasOrganizationFields();
	*** load(org.jivesoftware.smack.Connection,java.lang.String);
	*** setAddressFieldHome(java.lang.String,java.lang.String);
	*** setAddressFieldWork(java.lang.String,java.lang.String);
	*** setAvatar(byte[]);
	*** setEmailHome(java.lang.String);
	*** setEmailWork(java.lang.String);
	*** setEncodedImage(java.lang.String);
	*** setField(java.lang.String,java.lang.String);
	*** setField(java.lang.String,java.lang.String,boolean);
	*** setFirstName(java.lang.String);
	*** setLastName(java.lang.String);
	*** setMiddleName(java.lang.String);
	*** setOrganization(java.lang.String);
	*** setOrganizationUnit(java.lang.String);
	*** setPhoneHome(java.lang.String,java.lang.String);
	*** setPhoneWork(java.lang.String,java.lang.String);
	*** updateFN();
}

-keep class org.jivesoftware.smackx.packet.VCard$ContentBuilder {
	*** addTagContent();
}

-keep class org.jivesoftware.smackx.packet.VCard$VCardWriter {
	*** sb;
	*** this$0;
	*** access$100(org.jivesoftware.smackx.packet.VCard$VCardWriter);
	*** appendAddress(java.util.Map,java.lang.String);
	*** appendEmail(java.lang.String,java.lang.String);
	*** appendEmptyTag(java.lang.Object);
	*** appendGenericFields();
	*** appendN();
	*** appendOrganization();
	*** appendPhones(java.util.Map,java.lang.String);
	*** appendTag(java.lang.String,boolean,org.jivesoftware.smackx.packet.VCard$ContentBuilder);
	*** appendTag(java.lang.String,java.lang.String);
	*** appendTag(java.lang.String,java.lang.String,java.lang.String,boolean,org.jivesoftware.smackx.packet.VCard$ContentBuilder);
	*** buildActualContent();
	*** write();
}

-keep class org.jivesoftware.smackx.packet.VCard$VCardWriter$1 {
	*** this$1;
}

-keep class org.jivesoftware.smackx.packet.Version {
	*** name;
	*** os;
	*** version;
}

-keep class org.jivesoftware.smackx.packet.XHTMLExtension {
	*** addBody(java.lang.String);
	*** getBodies();
	*** getElementName();
}

-keep class org.jivesoftware.smackx.provider.DataFormProvider {
	*** parseExtension(org.xmlpull.v1.XmlPullParser);
	*** parseField(org.xmlpull.v1.XmlPullParser);
	*** parseItem(org.xmlpull.v1.XmlPullParser);
	*** parseOption(org.xmlpull.v1.XmlPullParser);
	*** parseReported(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smackx.provider.DelayInformationProvider {
	*** XEP_0082_UTC_FORMAT_WITHOUT_MILLIS;
	*** XEP_0091_UTC_FALLBACK_FORMAT;
	*** formats;
	*** determineNearestDate(java.util.Calendar,java.util.List);
	*** filterDatesBefore(java.util.Calendar,java.util.Calendar[]);
	*** handleDateWithMissingLeadingZeros(java.lang.String);
	*** parseXEP91Date(java.lang.String,java.text.DateFormat);
}

-keep class org.jivesoftware.smackx.provider.MUCAdminProvider {
	*** parseItem(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smackx.provider.MUCOwnerProvider {
	*** parseDestroy(org.xmlpull.v1.XmlPullParser);
	*** parseItem(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smackx.provider.MUCUserProvider {
	*** parseDecline(org.xmlpull.v1.XmlPullParser);
	*** parseDestroy(org.xmlpull.v1.XmlPullParser);
	*** parseInvite(org.xmlpull.v1.XmlPullParser);
	*** parseItem(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smackx.provider.PrivateDataProvider {
	*** parsePrivateData(org.xmlpull.v1.XmlPullParser);
}

-keep class org.jivesoftware.smackx.provider.VCardProvider {
	*** createVCardFromXML(java.lang.String);
}

-keep class org.jivesoftware.smackx.provider.VCardProvider$VCardReader {
	*** document;
	*** vCard;
	*** appendText(java.lang.StringBuilder,org.w3c.dom.Node);
	*** getTagContents(java.lang.String);
	*** getTextContent(org.w3c.dom.Node);
	*** initializeFields();
	*** isWorkHome(java.lang.String);
	*** setupAddresses();
	*** setupEmails();
	*** setupPhones();
	*** setupSimpleFields();
}

-keep class org.jivesoftware.smackx.search.SimpleUserSearch {
	*** data;
	*** form;
	*** getItemsToSearch();
	*** getReportedData();
	*** getSingleValue(org.jivesoftware.smackx.FormField);
	*** parseItems(org.xmlpull.v1.XmlPullParser);
	*** setForm(org.jivesoftware.smackx.Form);
}

-keep class org.jivesoftware.smackx.search.UserSearch {
	*** access$000(org.jivesoftware.smackx.search.SimpleUserSearch,java.lang.String,org.xmlpull.v1.XmlPullParser);
	*** buildDataForm(org.jivesoftware.smackx.search.SimpleUserSearch,java.lang.String,org.xmlpull.v1.XmlPullParser);
	*** sendSimpleSearchForm(org.jivesoftware.smack.Connection,org.jivesoftware.smackx.Form,java.lang.String);
}

-keep class org.json.simple.JSONArray {
	*** toJSONString(java.util.List);
	*** writeJSONString(java.util.List,java.io.Writer);
}

-keep class org.json.simple.JSONAware {
	*** toJSONString();
}

-keep class org.json.simple.JSONObject {
	*** escape(java.lang.String);
	*** toJSONString();
	*** toJSONString(java.lang.String,java.lang.Object,java.lang.StringBuffer);
	*** toJSONString(java.util.Map);
	*** writeJSONString(java.util.Map,java.io.Writer);
}

-keep class org.json.simple.JSONStreamAware {
	*** writeJSONString(java.io.Writer);
}

-keep class org.json.simple.JSONValue {
	*** escape(java.lang.String);
	*** escape(java.lang.String,java.lang.StringBuffer);
	*** parse(java.io.Reader);
	*** parse(java.lang.String);
	*** toJSONString(java.lang.Object);
	*** writeJSONString(java.lang.Object,java.io.Writer);
}

-keep class org.json.simple.parser.ContainerFactory {
	*** creatArrayContainer();
	*** createObjectContainer();
}

-keep class org.json.simple.parser.ContentHandler {
	*** endArray();
	*** endJSON();
	*** endObject();
	*** endObjectEntry();
	*** primitive(java.lang.Object);
	*** startArray();
	*** startJSON();
	*** startObject();
	*** startObjectEntry(java.lang.String);
}

-keep class org.json.simple.parser.JSONParser {
	*** handlerStatusStack;
	*** lexer;
	*** status;
	*** token;
	*** createArrayContainer(org.json.simple.parser.ContainerFactory);
	*** createObjectContainer(org.json.simple.parser.ContainerFactory);
	*** getPosition();
	*** nextToken();
	*** parse(java.io.Reader);
	*** parse(java.io.Reader,org.json.simple.parser.ContainerFactory);
	*** parse(java.io.Reader,org.json.simple.parser.ContentHandler,boolean);
	*** parse(java.lang.String);
	*** parse(java.lang.String,org.json.simple.parser.ContainerFactory);
	*** parse(java.lang.String,org.json.simple.parser.ContentHandler,boolean);
	*** peekStatus(java.util.LinkedList);
	*** reset();
	*** reset(java.io.Reader);
}

-keep class org.json.simple.parser.ParseException {
	*** errorType;
	*** position;
	*** unexpectedObject;
	org.json.simple.parser.ParseException(int,int,java.lang.Object);
}

-keep class org.json.simple.parser.Yylex {
	*** ZZ_ACTION;
	*** ZZ_ATTRIBUTE;
	*** ZZ_CMAP;
	*** ZZ_ERROR_MSG;
	*** ZZ_LEXSTATE;
	*** ZZ_ROWMAP;
	*** ZZ_TRANS;
	*** sb;
	*** yychar;
	*** yycolumn;
	*** yyline;
	*** zzAtBOL;
	*** zzAtEOF;
	*** zzBuffer;
	*** zzCurrentPos;
	*** zzEndRead;
	*** zzLexicalState;
	*** zzMarkedPos;
	*** zzReader;
	*** zzStartRead;
	*** zzState;
	org.json.simple.parser.Yylex(java.io.Reader);
	*** getPosition();
	*** yybegin(int);
	*** yycharat(int);
	*** yylength();
	*** yylex();
	*** yyreset(java.io.Reader);
	*** yytext();
	*** zzRefill();
	*** zzScanError(int);
	*** zzUnpackAction();
	*** zzUnpackAction(java.lang.String,int,int[]);
	*** zzUnpackAttribute();
	*** zzUnpackAttribute(java.lang.String,int,int[]);
	*** zzUnpackCMap(java.lang.String);
	*** zzUnpackRowMap();
	*** zzUnpackRowMap(java.lang.String,int,int[]);
}

-keep class org.json.simple.parser.Yytoken {
	*** type;
	*** value;
}

-keep class org.junit.Assert {
	*** assertArrayEquals(java.lang.Object[],java.lang.Object[]);
	*** assertArrayEquals(java.lang.String,byte[],byte[]);
	*** assertArrayEquals(java.lang.String,char[],char[]);
	*** assertArrayEquals(java.lang.String,double[],double[],double);
	*** assertArrayEquals(java.lang.String,float[],float[],float);
	*** assertArrayEquals(java.lang.String,int[],int[]);
	*** assertArrayEquals(java.lang.String,java.lang.Object[],java.lang.Object[]);
	*** assertArrayEquals(java.lang.String,long[],long[]);
	*** assertArrayEquals(java.lang.String,short[],short[]);
	*** assertEquals(java.lang.Object,java.lang.Object);
	*** assertEquals(java.lang.String,double,double);
	*** assertEquals(java.lang.String,double,double,double);
	*** assertEquals(java.lang.String,float,float,float);
	*** assertEquals(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertEquals(java.lang.String,long,long);
	*** assertEquals(long,long);
	*** assertFalse(boolean);
	*** assertFalse(java.lang.String,boolean);
	*** assertNotEquals(java.lang.String,double,double,double);
	*** assertNotEquals(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertNotEquals(java.lang.String,long,long);
	*** assertNotNull(java.lang.Object);
	*** assertNotNull(java.lang.String,java.lang.Object);
	*** assertNotSame(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertNull(java.lang.Object);
	*** assertNull(java.lang.String,java.lang.Object);
	*** assertSame(java.lang.String,java.lang.Object,java.lang.Object);
	*** assertThat(java.lang.String,java.lang.Object,org.hamcrest.Matcher);
	*** assertTrue(boolean);
	*** assertTrue(java.lang.String,boolean);
	*** doubleIsDifferent(double,double,double);
	*** equalsRegardingNull(java.lang.Object,java.lang.Object);
	*** fail(java.lang.String);
	*** failEquals(java.lang.String,java.lang.Object);
	*** failNotEquals(java.lang.String,java.lang.Object,java.lang.Object);
	*** failNotNull(java.lang.String,java.lang.Object);
	*** failNotSame(java.lang.String,java.lang.Object,java.lang.Object);
	*** failSame(java.lang.String);
	*** format(java.lang.String,java.lang.Object,java.lang.Object);
	*** formatClassAndValue(java.lang.Object,java.lang.String);
	*** internalArrayEquals(java.lang.String,java.lang.Object,java.lang.Object);
	*** isEquals(java.lang.Object,java.lang.Object);
}

-keep class org.junit.ComparisonFailure {
	*** fActual;
	*** fExpected;
	*** getActual();
	*** getExpected();
}

-keep class org.junit.ComparisonFailure$ComparisonCompactor {
	*** access$000(org.junit.ComparisonFailure$ComparisonCompactor,java.lang.String);
}

-keep class org.junit.FixMethodOrder {
	*** value();
}

-keep class org.junit.Test {
	*** expected();
	*** timeout();
}

-keep class org.junit.experimental.categories.Categories {
	*** assertNoCategorizedDescendentsOfUncategorizeableParents(org.junit.runner.Description);
	*** assertNoDescendantsHaveCategoryAnnotations(org.junit.runner.Description);
	*** canHaveCategorizedChildren(org.junit.runner.Description);
	*** getExcludedCategory(java.lang.Class);
	*** getIncludedCategory(java.lang.Class);
}

-keep class org.junit.experimental.categories.Categories$ExcludeCategory {
	*** value();
}

-keep class org.junit.experimental.categories.Categories$IncludeCategory {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClassTester {
	*** acceptClass(java.lang.Class);
	*** acceptClassName(java.lang.String);
	*** acceptInnerClass();
	*** searchInJars();
}

-keep class org.junit.extensions.cpsuite.ClassesFinder {
	*** find();
}

-keep class org.junit.extensions.cpsuite.ClassesFinderFactory {
	*** create(boolean,java.lang.String[],org.junit.extensions.cpsuite.SuiteType[],java.lang.Class[],java.lang.Class[],java.lang.String);
}

-keep class org.junit.extensions.cpsuite.ClasspathClassesFinder {
	*** CLASS_SUFFIX_LENGTH;
	*** classpathProperty;
	*** tester;
	*** classNameFromFile(java.lang.String);
	*** cutOffExtension(java.lang.String);
	*** findClassesInClasspath(java.lang.String);
	*** findClassesInRoots(java.util.List);
	*** gatherClasses(java.util.List,java.lang.Iterable);
	*** gatherClassesInRoot(java.io.File,java.util.List);
	*** getClasspath();
	*** getClasspathProperty();
	*** isClassFile(java.lang.String);
	*** isInnerClass(java.lang.String);
	*** isJarFile(java.io.File);
	*** replaceFileSeparators(java.lang.String);
	*** splitClassPath(java.lang.String);
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite {
	*** DEFAULT_BASE_TYPES;
	*** DEFAULT_CLASSNAME_FILTERS;
	*** DEFAULT_EXCLUDED_BASES_TYPES;
	*** DEFAULT_SUITE_TYPES;
	*** suiteClass;
	org.junit.extensions.cpsuite.ClasspathSuite(java.lang.Class,org.junit.runners.model.RunnerBuilder,org.junit.extensions.cpsuite.ClassesFinderFactory);
	*** createFinder(java.lang.Class,org.junit.extensions.cpsuite.ClassesFinderFactory);
	*** getBaseTypes(java.lang.Class);
	*** getClassComparator();
	*** getClassnameFilters(java.lang.Class);
	*** getClasspathProperty(java.lang.Class);
	*** getExcludedBaseTypes(java.lang.Class);
	*** getSearchInJars(java.lang.Class);
	*** getSortedTestclasses(org.junit.extensions.cpsuite.ClassesFinder);
	*** getSuiteTypes(java.lang.Class);
	*** isPublicStaticVoid(java.lang.reflect.Method);
	*** runBeforeMethods();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$1 {
	*** compare(java.lang.Class,java.lang.Class);
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$BaseTypeFilter {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$ClassnameFilters {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$ClasspathProperty {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$ExcludeBaseTypeFilter {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$IncludeJars {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuite$SuiteTypes {
	*** value();
}

-keep class org.junit.extensions.cpsuite.ClasspathSuiteTester {
	*** baseTypes;
	*** excludedBaseTypes;
	*** negationFilters;
	*** positiveFilters;
	*** searchInJars;
	*** suiteTypes;
	*** acceptInNegationFilters(java.lang.String);
	*** acceptInPositiveFilers(java.lang.String);
	*** acceptJUnit38Test(java.lang.Class);
	*** acceptRunWithClass(java.lang.Class);
	*** acceptTestClass(java.lang.Class);
	*** findNegationFilters(java.lang.String[]);
	*** findPositiveFilters(java.lang.String[]);
	*** hasCorrectBaseType(java.lang.Class);
	*** hasExcludedBaseType(java.lang.Class);
	*** isAbstractClass(java.lang.Class);
	*** isInSuiteTypes(org.junit.extensions.cpsuite.SuiteType);
}

-keep class org.junit.extensions.cpsuite.JarFilenameIterator {
	*** entries;
	*** next;
	*** next();
	*** retrieveNextElement();
}

-keep class org.junit.extensions.cpsuite.RecursiveFilenameIterator {
	*** alreadyUsed;
	*** index;
	*** innerIterators;
	*** prefixLength;
	*** root;
	org.junit.extensions.cpsuite.RecursiveFilenameIterator(java.io.File,int);
	*** currentIterator();
	*** getInnerIterators(java.io.File);
	*** hasNext();
	*** isRootFile();
	*** next();
}

-keep class org.junit.extensions.cpsuite.SuiteType {
	*** $VALUES;
	*** JUNIT38_TEST_CLASSES;
	*** RUN_WITH_CLASSES;
	*** TEST_CLASSES;
}

-keep class org.junit.internal.AssumptionViolatedException {
	*** fAssumption;
	*** fMatcher;
	*** fValue;
	*** fValueMatcher;
	org.junit.internal.AssumptionViolatedException(java.lang.String,boolean,java.lang.Object,org.hamcrest.Matcher);
}

-keep class org.junit.internal.ComparisonCriteria {
	*** arrayEquals(java.lang.String,java.lang.Object,java.lang.Object);
}

-keep class org.junit.internal.MethodSorter {
	*** DEFAULT;
	*** NAME_ASCENDING;
	*** getDeclaredMethods(java.lang.Class);
	*** getSorter(org.junit.FixMethodOrder);
}

-keep class org.junit.internal.MethodSorter$1 {
	*** compare(java.lang.reflect.Method,java.lang.reflect.Method);
}

-keep class org.junit.internal.MethodSorter$2 {
	*** compare(java.lang.reflect.Method,java.lang.reflect.Method);
}

-keep class org.junit.internal.builders.AllDefaultPossibilitiesBuilder {
	*** fCanUseSuiteMethod;
	*** annotatedBuilder();
	*** ignoredBuilder();
	*** junit3Builder();
	*** junit4Builder();
	*** suiteMethodBuilder();
}

-keep class org.junit.internal.builders.AnnotatedBuilder {
	*** fSuiteBuilder;
	*** buildRunner(java.lang.Class,java.lang.Class);
}

-keep class org.junit.internal.builders.IgnoredClassRunner {
	*** fTestClass;
	*** getDescription();
}

-keep class org.junit.internal.builders.JUnit3Builder {
	*** isPre4Test(java.lang.Class);
}

-keep class org.junit.internal.builders.SuiteMethodBuilder {
	*** hasSuiteMethod(java.lang.Class);
}

-keep class org.junit.internal.requests.ClassRequest {
	*** fCanUseSuiteMethod;
	*** fRunner;
	*** fRunnerLock;
	*** fTestClass;
	org.junit.internal.requests.ClassRequest(java.lang.Class,boolean);
}

-keep class org.junit.internal.requests.FilterRequest {
	*** fFilter;
	*** fRequest;
}

-keep class org.junit.internal.requests.SortingRequest {
	*** fComparator;
	*** fRequest;
}

-keep class org.junit.internal.runners.ErrorReportingRunner {
	*** fCauses;
	*** fTestClass;
	*** describeCause(java.lang.Throwable);
	*** getCauses(java.lang.Throwable);
	*** runCause(java.lang.Throwable,org.junit.runner.notification.RunNotifier);
}

-keep class org.junit.internal.runners.InitializationError {
	*** getCauses();
}

-keep class org.junit.internal.runners.JUnit38ClassRunner {
	*** fTest;
	org.junit.internal.runners.JUnit38ClassRunner(junit.framework.Test);
	*** createAdaptingListener(org.junit.runner.notification.RunNotifier);
	*** createSuiteDescription(junit.framework.TestSuite);
	*** getTest();
	*** makeDescription(junit.framework.Test);
	*** setTest(junit.framework.Test);
}

-keep class org.junit.internal.runners.SuiteMethod {
	*** testFromSuiteMethod(java.lang.Class);
}

-keep class org.junit.internal.runners.model.EachTestNotifier {
	*** fDescription;
	*** fNotifier;
	*** addFailedAssumption(org.junit.internal.AssumptionViolatedException);
	*** addFailure(java.lang.Throwable);
	*** addMultipleFailureException(org.junit.runners.model.MultipleFailureException);
	*** fireTestFinished();
	*** fireTestIgnored();
	*** fireTestStarted();
}

-keep class org.junit.internal.runners.model.ReflectiveCallable {
	org.junit.internal.runners.model.ReflectiveCallable();
	*** run();
	*** runReflectiveCall();
}

-keep class org.junit.internal.runners.rules.RuleFieldValidator {
	*** $VALUES;
	*** CLASS_RULE_METHOD_VALIDATOR;
	*** CLASS_RULE_VALIDATOR;
	*** RULE_METHOD_VALIDATOR;
	*** RULE_VALIDATOR;
	*** fAnnotation;
	*** fMethods;
	*** fStaticMembers;
	*** addError(java.util.List,org.junit.runners.model.FrameworkMember,java.lang.String);
	*** isMethodRule(org.junit.runners.model.FrameworkMember);
	*** isTestRule(org.junit.runners.model.FrameworkMember);
	*** validate(org.junit.runners.model.TestClass,java.util.List);
	*** validateMember(org.junit.runners.model.FrameworkMember,java.util.List);
	*** validatePublic(org.junit.runners.model.FrameworkMember,java.util.List);
	*** validateStatic(org.junit.runners.model.FrameworkMember,java.util.List);
	*** validateTestRuleOrMethodRule(org.junit.runners.model.FrameworkMember,java.util.List);
}

-keep class org.junit.internal.runners.statements.ExpectException {
	*** fExpected;
	*** fNext;
}

-keep class org.junit.internal.runners.statements.Fail {
	*** fError;
}

-keep class org.junit.internal.runners.statements.FailOnTimeout {
	*** fOriginalStatement;
	*** fTimeout;
	*** evaluateStatement();
	*** throwExceptionForUnfinishedThread(org.junit.internal.runners.statements.FailOnTimeout$StatementThread);
	*** throwTimeoutException(org.junit.internal.runners.statements.FailOnTimeout$StatementThread);
}

-keep class org.junit.internal.runners.statements.FailOnTimeout$StatementThread {
	*** access$000(org.junit.internal.runners.statements.FailOnTimeout$StatementThread);
	*** access$100(org.junit.internal.runners.statements.FailOnTimeout$StatementThread);
	*** getRecordedStackTrace();
	*** recordStackTrace();
}

-keep class org.junit.internal.runners.statements.InvokeMethod {
	*** fTarget;
	*** fTestMethod;
}

-keep class org.junit.internal.runners.statements.RunAfters {
	*** fAfters;
	*** fNext;
	*** fTarget;
}

-keep class org.junit.internal.runners.statements.RunBefores {
	*** fBefores;
	*** fNext;
	*** fTarget;
}

-keep class org.junit.rules.MethodRule {
	*** apply(org.junit.runners.model.Statement,org.junit.runners.model.FrameworkMethod,java.lang.Object);
}

-keep class org.junit.rules.RunRules {
	*** statement;
	*** applyAll(org.junit.runners.model.Statement,java.lang.Iterable,org.junit.runner.Description);
}

-keep class org.junit.rules.TestRule {
	*** apply(org.junit.runners.model.Statement,org.junit.runner.Description);
}

-keep class org.junit.runner.Computer {
	*** getSuite(org.junit.runners.model.RunnerBuilder,java.lang.Class[]);
}

-keep class org.junit.runner.Describable {
	*** getDescription();
}

-keep class org.junit.runner.Description {
	*** EMPTY;
	*** METHOD_AND_CLASS_NAME_PATTERN;
	*** TEST_MECHANISM;
	*** fAnnotations;
	*** fChildren;
	*** fDisplayName;
	*** fTestClass;
	*** fUniqueId;
	org.junit.runner.Description(java.lang.Class,java.lang.String,java.io.Serializable,java.lang.annotation.Annotation[]);
	*** addChild(org.junit.runner.Description);
	*** createSuiteDescription(java.lang.Class);
	*** createSuiteDescription(java.lang.String,java.lang.annotation.Annotation[]);
	*** createTestDescription(java.lang.Class,java.lang.String);
	*** createTestDescription(java.lang.Class,java.lang.String,java.lang.annotation.Annotation[]);
	*** equals(java.lang.Object);
	*** formatDisplayName(java.lang.String,java.lang.String);
	*** getAnnotation(java.lang.Class);
	*** getChildren();
	*** getClassName();
	*** getDisplayName();
	*** getTestClass();
	*** hashCode();
	*** isTest();
	*** methodAndClassNamePatternGroupOrDefault(int,java.lang.String);
	*** testCount();
	*** toString();
}

-keep class org.junit.runner.JUnitCore {
	*** defaultComputer();
}

-keep class org.junit.runner.Request {
	org.junit.runner.Request();
	*** aClass(java.lang.Class);
	*** classWithoutSuiteMethod(java.lang.Class);
	*** classes(org.junit.runner.Computer,java.lang.Class[]);
	*** filterWith(org.junit.runner.Description);
	*** filterWith(org.junit.runner.manipulation.Filter);
	*** getRunner();
	*** runner(org.junit.runner.Runner);
	*** sortWith(java.util.Comparator);
}

-keep class org.junit.runner.Request$1 {
	*** val$runner;
}

-keep class org.junit.runner.Result {
	*** fCount;
	*** fFailures;
	*** fIgnoreCount;
	*** fRunTime;
	*** fStartTime;
	*** access$000(org.junit.runner.Result);
	*** access$002(org.junit.runner.Result,long);
	*** access$114(org.junit.runner.Result,long);
	*** access$200(org.junit.runner.Result);
	*** access$300(org.junit.runner.Result);
	*** access$400(org.junit.runner.Result);
	*** createListener();
	*** getFailureCount();
}

-keep class org.junit.runner.Result$Listener {
	*** this$0;
	org.junit.runner.Result$Listener(org.junit.runner.Result);
}

-keep class org.junit.runner.RunWith {
	*** value();
}

-keep class org.junit.runner.Runner {
	org.junit.runner.Runner();
	*** getDescription();
	*** run(org.junit.runner.notification.RunNotifier);
	*** testCount();
}

-keep class org.junit.runner.manipulation.Filter {
	*** apply(java.lang.Object);
	*** describe();
	*** matchMethodDescription(org.junit.runner.Description);
	*** shouldRun(org.junit.runner.Description);
}

-keep class org.junit.runner.manipulation.Filterable {
	*** filter(org.junit.runner.manipulation.Filter);
}

-keep class org.junit.runner.manipulation.Sortable {
	*** sort(org.junit.runner.manipulation.Sorter);
}

-keep class org.junit.runner.manipulation.Sorter {
	*** NULL;
	*** fComparator;
	*** apply(java.lang.Object);
	*** compare(org.junit.runner.Description,org.junit.runner.Description);
}

-keep class org.junit.runner.manipulation.Sorter$1 {
	*** compare(org.junit.runner.Description,org.junit.runner.Description);
}

-keep class org.junit.runner.notification.Failure {
	*** fDescription;
	*** fThrownException;
	*** getDescription();
	*** getException();
	*** getTestHeader();
	*** getTrace();
}

-keep class org.junit.runner.notification.RunListener {
	org.junit.runner.notification.RunListener();
	*** testFailure(org.junit.runner.notification.Failure);
	*** testFinished(org.junit.runner.Description);
	*** testIgnored(org.junit.runner.Description);
	*** testRunFinished(org.junit.runner.Result);
	*** testRunStarted(org.junit.runner.Description);
	*** testStarted(org.junit.runner.Description);
}

-keep class org.junit.runner.notification.RunNotifier {
	*** fListeners;
	*** fPleaseStop;
	*** access$000(org.junit.runner.notification.RunNotifier);
	*** access$100(org.junit.runner.notification.RunNotifier,java.util.List,java.util.List);
	*** addListener(org.junit.runner.notification.RunListener);
	*** fireTestAssumptionFailed(org.junit.runner.notification.Failure);
	*** fireTestFailure(org.junit.runner.notification.Failure);
	*** fireTestFailures(java.util.List,java.util.List);
	*** fireTestFinished(org.junit.runner.Description);
	*** fireTestIgnored(org.junit.runner.Description);
	*** fireTestRunFinished(org.junit.runner.Result);
	*** fireTestRunStarted(org.junit.runner.Description);
	*** fireTestStarted(org.junit.runner.Description);
	*** pleaseStop();
	*** removeListener(org.junit.runner.notification.RunListener);
}

-keep class org.junit.runner.notification.RunNotifier$1 {
	*** this$0;
	*** val$description;
}

-keep class org.junit.runner.notification.RunNotifier$2 {
	*** this$0;
	*** val$result;
}

-keep class org.junit.runner.notification.RunNotifier$3 {
	*** this$0;
	*** val$description;
}

-keep class org.junit.runner.notification.RunNotifier$4 {
	*** this$0;
	*** val$failures;
}

-keep class org.junit.runner.notification.RunNotifier$6 {
	*** this$0;
	*** val$description;
}

-keep class org.junit.runner.notification.RunNotifier$7 {
	*** this$0;
	*** val$description;
}

-keep class org.junit.runner.notification.RunNotifier$SafeNotifier {
	*** fCurrentListeners;
	*** this$0;
	org.junit.runner.notification.RunNotifier$SafeNotifier(org.junit.runner.notification.RunNotifier);
	org.junit.runner.notification.RunNotifier$SafeNotifier(org.junit.runner.notification.RunNotifier,java.util.List);
	*** notifyListener(org.junit.runner.notification.RunListener);
	*** run();
}

-keep class org.junit.runners.BlockJUnit4ClassRunner {
	*** computeTestMethods();
	*** createTest();
	*** describeChild(org.junit.runners.model.FrameworkMethod);
	*** expectsException(org.junit.Test);
	*** getExpectedException(org.junit.Test);
	*** getMethodRules(java.lang.Object);
	*** getTestRules(java.lang.Object);
	*** getTimeout(org.junit.Test);
	*** hasOneConstructor();
	*** methodBlock(org.junit.runners.model.FrameworkMethod);
	*** methodInvoker(org.junit.runners.model.FrameworkMethod,java.lang.Object);
	*** possiblyExpectingExceptions(org.junit.runners.model.FrameworkMethod,java.lang.Object,org.junit.runners.model.Statement);
	*** rules(java.lang.Object);
	*** runChild(org.junit.runners.model.FrameworkMethod,org.junit.runner.notification.RunNotifier);
	*** testName(org.junit.runners.model.FrameworkMethod);
	*** validateConstructor(java.util.List);
	*** validateFields(java.util.List);
	*** validateInstanceMethods(java.util.List);
	*** validateMethods(java.util.List);
	*** validateNoNonStaticInnerClass(java.util.List);
	*** validateOnlyOneConstructor(java.util.List);
	*** validateTestMethods(java.util.List);
	*** validateZeroArgConstructor(java.util.List);
	*** withAfters(org.junit.runners.model.FrameworkMethod,java.lang.Object,org.junit.runners.model.Statement);
	*** withBefores(org.junit.runners.model.FrameworkMethod,java.lang.Object,org.junit.runners.model.Statement);
	*** withMethodRules(org.junit.runners.model.FrameworkMethod,java.util.List,java.lang.Object,org.junit.runners.model.Statement);
	*** withPotentialTimeout(org.junit.runners.model.FrameworkMethod,java.lang.Object,org.junit.runners.model.Statement);
	*** withRules(org.junit.runners.model.FrameworkMethod,java.lang.Object,org.junit.runners.model.Statement);
	*** withTestRules(org.junit.runners.model.FrameworkMethod,java.util.List,org.junit.runners.model.Statement);
}

-keep class org.junit.runners.BlockJUnit4ClassRunner$1 {
	*** this$0;
}

-keep class org.junit.runners.MethodSorters {
	*** getComparator();
}

-keep class org.junit.runners.ParentRunner {
	*** fFilteredChildren;
	*** fScheduler;
	*** fSorter;
	*** fTestClass;
	org.junit.runners.ParentRunner(java.lang.Class);
	*** access$000(org.junit.runners.ParentRunner,org.junit.runner.notification.RunNotifier);
	*** childrenInvoker(org.junit.runner.notification.RunNotifier);
	*** classBlock(org.junit.runner.notification.RunNotifier);
	*** classRules();
	*** collectInitializationErrors(java.util.List);
	*** comparator();
	*** describeChild(java.lang.Object);
	*** filter(org.junit.runner.manipulation.Filter);
	*** getChildren();
	*** getDescription();
	*** getFilteredChildren();
	*** getName();
	*** getRunnerAnnotations();
	*** getTestClass();
	*** run(org.junit.runner.notification.RunNotifier);
	*** runChild(java.lang.Object,org.junit.runner.notification.RunNotifier);
	*** runChildren(org.junit.runner.notification.RunNotifier);
	*** runLeaf(org.junit.runners.model.Statement,org.junit.runner.Description,org.junit.runner.notification.RunNotifier);
	*** shouldRun(org.junit.runner.manipulation.Filter,java.lang.Object);
	*** sortChild(java.lang.Object);
	*** validate();
	*** validateClassRules(java.util.List);
	*** validatePublicVoidNoArgMethods(java.lang.Class,boolean,java.util.List);
	*** withAfterClasses(org.junit.runners.model.Statement);
	*** withBeforeClasses(org.junit.runners.model.Statement);
	*** withClassRules(org.junit.runners.model.Statement);
}

-keep class org.junit.runners.ParentRunner$1 {
	*** this$0;
}

-keep class org.junit.runners.ParentRunner$2 {
	*** this$0;
	*** val$notifier;
}

-keep class org.junit.runners.ParentRunner$3 {
	*** this$0;
	*** val$each;
	*** val$notifier;
}

-keep class org.junit.runners.Suite {
	*** fRunners;
	org.junit.runners.Suite(java.lang.Class,java.util.List);
	org.junit.runners.Suite(java.lang.Class,org.junit.runners.model.RunnerBuilder);
	org.junit.runners.Suite(org.junit.runners.model.RunnerBuilder,java.lang.Class,java.lang.Class[]);
	*** describeChild(org.junit.runner.Runner);
	*** getAnnotatedClasses(java.lang.Class);
	*** runChild(org.junit.runner.Runner,org.junit.runner.notification.RunNotifier);
}

-keep class org.junit.runners.Suite$SuiteClasses {
	*** value();
}

-keep class org.junit.runners.model.FrameworkField {
	*** fField;
	*** get(java.lang.Object);
	*** getField();
	*** getName();
	*** isShadowedBy(org.junit.runners.model.FrameworkField);
}

-keep class org.junit.runners.model.FrameworkMember {
	org.junit.runners.model.FrameworkMember();
	*** getAnnotations();
	*** getName();
	*** getType();
	*** isPublic();
	*** isShadowedBy(java.util.List);
	*** isShadowedBy(org.junit.runners.model.FrameworkMember);
	*** isStatic();
}

-keep class org.junit.runners.model.FrameworkMethod {
	*** fMethod;
	*** getAnnotation(java.lang.Class);
	*** getAnnotations();
	*** getName();
	*** getParameterTypes();
	*** getReturnType();
	*** invokeExplosively(java.lang.Object,java.lang.Object[]);
	*** isShadowedBy(org.junit.runners.model.FrameworkMethod);
	*** validatePublicVoid(boolean,java.util.List);
	*** validatePublicVoidNoArg(boolean,java.util.List);
}

-keep class org.junit.runners.model.FrameworkMethod$1 {
	*** this$0;
	*** val$params;
	*** val$target;
}

-keep class org.junit.runners.model.InitializationError {
	*** fErrors;
	org.junit.runners.model.InitializationError(java.lang.Throwable);
	org.junit.runners.model.InitializationError(java.util.List);
	*** getCauses();
}

-keep class org.junit.runners.model.MultipleFailureException {
	*** fErrors;
	org.junit.runners.model.MultipleFailureException(java.util.List);
	*** assertEmpty(java.util.List);
	*** getFailures();
}

-keep class org.junit.runners.model.NoGenericTypeParametersValidator {
	*** validate(java.util.List);
}

-keep class org.junit.runners.model.RunnerBuilder {
	*** parents;
	org.junit.runners.model.RunnerBuilder();
	*** addParent(java.lang.Class);
	*** removeParent(java.lang.Class);
	*** runnerForClass(java.lang.Class);
	*** runners(java.lang.Class,java.lang.Class[]);
	*** runners(java.lang.Class[]);
	*** safeRunnerForClass(java.lang.Class);
}

-keep class org.junit.runners.model.RunnerScheduler {
	*** finished();
	*** schedule(java.lang.Runnable);
}

-keep class org.junit.runners.model.Statement {
	org.junit.runners.model.Statement();
	*** evaluate();
}

-keep class org.junit.runners.model.TestClass {
	*** fClass;
	*** fFieldsForAnnotations;
	*** fMethodsForAnnotations;
	*** addToAnnotationLists(org.junit.runners.model.FrameworkMember,java.util.Map);
	*** getAnnotatedFieldValues(java.lang.Object,java.lang.Class,java.lang.Class);
	*** getAnnotatedFields(java.lang.Class);
	*** getAnnotatedMembers(java.util.Map,java.lang.Class);
	*** getAnnotatedMethodValues(java.lang.Object,java.lang.Class,java.lang.Class);
	*** getAnnotatedMethods(java.lang.Class);
	*** getAnnotations();
	*** getJavaClass();
	*** getName();
	*** getOnlyConstructor();
	*** getSuperClasses(java.lang.Class);
	*** isANonStaticInnerClass();
	*** runsTopToBottom(java.lang.Class);
}

-keep class org.kaleidoscope.BasicRandomRoutingTable {
	*** $assertionsDisabled;
	*** orderedNeighbors;
	*** rng;
	*** routingTable;
	org.kaleidoscope.BasicRandomRoutingTable();
	org.kaleidoscope.BasicRandomRoutingTable(java.security.SecureRandom);
	org.kaleidoscope.BasicRandomRoutingTable(org.kaleidoscope.RandomRoutingTable$Snapshot,java.security.SecureRandom);
	*** addNeighbor(org.kaleidoscope.TrustGraphNodeId);
	*** addNeighborToOrdering(org.kaleidoscope.TrustGraphNodeId);
	*** addNeighbors(java.util.Collection);
	*** addNeighborsToOrdering(java.util.List);
	*** clear();
	*** contains(org.kaleidoscope.TrustGraphNodeId);
	*** getNextHop(org.kaleidoscope.TrustGraphAdvertisement);
	*** getNextHop(org.kaleidoscope.TrustGraphNodeId);
	*** getOrderedNeighbors();
	*** isEmpty();
	*** isValidSnapshot(org.kaleidoscope.RandomRoutingTable$Snapshot);
	*** randomRoute();
	*** removeNeighbor(org.kaleidoscope.TrustGraphNodeId);
	*** removeNeighborFromOrdering(org.kaleidoscope.TrustGraphNodeId);
	*** removeNeighborFromRoutingTable(org.kaleidoscope.TrustGraphNodeId);
	*** removeNeighbors(java.util.Collection);
	*** removeNeighborsFromOrdering(java.util.Collection);
	*** size();
	*** snapshot();
	*** toString();
	*** validateSnapshot(org.kaleidoscope.RandomRoutingTable$Snapshot);
}

-keep class org.kaleidoscope.RandomRoutingTable {
	*** addNeighbor(org.kaleidoscope.TrustGraphNodeId);
	*** clear();
	*** getNextHop(org.kaleidoscope.TrustGraphAdvertisement);
	*** getNextHop(org.kaleidoscope.TrustGraphNodeId);
	*** getOrderedNeighbors();
}

-keep class org.kaleidoscope.RandomRoutingTable$Snapshot {
	*** getOrderedNeighbors();
	*** getRoutes();
}

-keep class org.kaleidoscope.TrustGraphAdvertisement {
	*** getInboundTTL();
	*** getPayload();
	*** getSender();
}

-keep class org.kaleidoscope.TrustGraphNode {
	*** routingTable;
	org.kaleidoscope.TrustGraphNode();
	org.kaleidoscope.TrustGraphNode(org.kaleidoscope.RandomRoutingTable);
	*** advertiseSelf(org.kaleidoscope.TrustGraphAdvertisement);
	*** forwardAdvertisement(org.kaleidoscope.TrustGraphAdvertisement);
	*** getIdealReach();
	*** getMaxRouteLength();
	*** getMinRouteLength();
	*** getRoutingTable();
	*** sendAdvertisement(org.kaleidoscope.TrustGraphAdvertisement,org.kaleidoscope.TrustGraphNodeId,int);
	*** shouldForward(org.kaleidoscope.TrustGraphAdvertisement);
}

-keep class org.kaleidoscope.TrustGraphNodeId {
	*** getNeighborId();
}

-keep class org.lantern.AppIndicatorTray {
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus;
	*** $SWITCH_TABLE$org$lantern$GoogleTalkState;
	*** LOG;
	*** active;
	*** appIndicator;
	*** browserService;
	*** connectionStatusItem;
	*** dashboardItem;
	*** dashboardItemCallback;
	*** failureCallback;
	*** libappindicator;
	*** libglib;
	*** libgobject;
	*** libgtk;
	*** menu;
	*** model;
	*** quitItem;
	*** quitItemCallback;
	*** updateData;
	*** updateItem;
	*** updateItemCallback;
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus();
	*** $SWITCH_TABLE$org$lantern$GoogleTalkState();
	*** access$0();
	*** access$1(org.lantern.AppIndicatorTray);
	*** access$2(org.lantern.AppIndicatorTray);
	*** addUpdate(java.util.Map);
	*** changeIcon(java.lang.String,java.lang.String);
	*** createTray();
	*** fallback();
	*** iconPath(java.lang.String);
	*** isActive();
	*** isSupported();
	*** onConnectivityStateChanged(org.lantern.event.ProxyConnectionEvent);
	*** onConnectivityStatus(org.lantern.ConnectivityStatus);
	*** onGoogleTalkState(org.lantern.event.GoogleTalkStateEvent);
	*** openDashboard();
	*** quit();
	*** setFailureCallback(org.lantern.AppIndicatorTray$FailureCallback);
	*** start();
	*** stop();
}

-keep class org.lantern.AppIndicatorTray$1 {
	*** this$0;
}

-keep class org.lantern.AppIndicatorTray$2 {
	*** this$0;
}

-keep class org.lantern.AppIndicatorTray$3 {
	*** this$0;
}

-keep class org.lantern.AppIndicatorTray$4 {
	*** this$0;
	*** val$data;
}

-keep class org.lantern.AppIndicatorTray$FailureCallback {
	*** createTrayFailed();
}

-keep class org.lantern.BayeuxInitializer {
	*** syncer;
}

-keep class org.lantern.BrowserService {
	*** openBrowserWhenPortReady();
	*** reopenBrowser();
}

-keep class org.lantern.Censored {
	*** isCensored();
	*** isCountryCodeCensored(java.lang.String);
	*** isExportRestricted(java.lang.String);
}

-keep class org.lantern.ChromeBrowserService {
	*** chrome;
	*** log;
	*** messageService;
	*** access$0(org.lantern.ChromeBrowserService,int,java.lang.String);
	*** launchChrome(int,java.lang.String);
	*** openBrowser();
	*** openBrowser(int,java.lang.String);
	*** openBrowserWhenPortReady();
	*** openBrowserWhenPortReady(int,java.lang.String);
	*** reopenBrowser();
	*** start();
	*** stop();
}

-keep class org.lantern.ChromeBrowserService$1 {
	*** this$0;
}

-keep class org.lantern.ChromeBrowserService$2 {
	*** this$0;
	*** val$port;
	*** val$prefix;
}

-keep class org.lantern.ChromeRunner {
	*** location;
	*** log;
	*** process;
	*** screenHeight;
	*** screenWidth;
	*** access$0(org.lantern.ChromeRunner);
	*** close();
	*** determineExecutable();
	*** determineExecutablePath();
	*** findWindowsExe();
	*** open(int,java.lang.String);
}

-keep class org.lantern.ChromeRunner$Analyzer {
	*** is;
	*** this$0;
}

-keep class org.lantern.Cli {
	*** cmd;
	*** buildOptions();
	*** getParsedCommandLine();
	*** printHelp(org.apache.commons.cli.Options,java.lang.String);
	*** printVersion();
}

-keep class org.lantern.ClientMessage$Type {
	*** ENUM$VALUES;
	*** friendSync;
}

-keep class org.lantern.ClientStats {
	*** addBytesProxied(long,java.net.InetSocketAddress);
	*** addDirectBytes(long);
	*** addDownBytesForPeers(long);
	*** addDownBytesFromPeers(long);
	*** addDownBytesViaProxies(long);
	*** addProxiedClientAddress(java.net.InetAddress);
	*** addUpBytesForPeers(long);
	*** addUpBytesToPeers(long);
	*** addUpBytesViaProxies(long);
	*** getCountOfDistinctProxiedClientAddresses();
	*** incrementProxiedRequests();
	*** resetCumulativeStats();
	*** setNatpmp(boolean);
	*** setUpnp(boolean);
}

-keep class org.lantern.ClientStats$$EnhancerByMockitoWithCGLIB$$7a32121 {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$addBytesProxied$16$Method;
	*** CGLIB$addBytesProxied$16$Proxy;
	*** CGLIB$addDirectBytes$15$Method;
	*** CGLIB$addDirectBytes$15$Proxy;
	*** CGLIB$addDownBytesForPeers$14$Method;
	*** CGLIB$addDownBytesForPeers$14$Proxy;
	*** CGLIB$addDownBytesFromPeers$12$Method;
	*** CGLIB$addDownBytesFromPeers$12$Proxy;
	*** CGLIB$addDownBytesViaProxies$8$Method;
	*** CGLIB$addDownBytesViaProxies$8$Proxy;
	*** CGLIB$addProxiedClientAddress$17$Method;
	*** CGLIB$addProxiedClientAddress$17$Proxy;
	*** CGLIB$addUpBytesForPeers$13$Method;
	*** CGLIB$addUpBytesForPeers$13$Proxy;
	*** CGLIB$addUpBytesToPeers$11$Method;
	*** CGLIB$addUpBytesToPeers$11$Proxy;
	*** CGLIB$addUpBytesViaProxies$9$Method;
	*** CGLIB$addUpBytesViaProxies$9$Proxy;
	*** CGLIB$clone$4$Method;
	*** CGLIB$clone$4$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$1$Method;
	*** CGLIB$equals$1$Proxy;
	*** CGLIB$finalize$0$Method;
	*** CGLIB$finalize$0$Proxy;
	*** CGLIB$getCountOfDistinctProxiedClientAddresses$18$Method;
	*** CGLIB$getCountOfDistinctProxiedClientAddresses$18$Proxy;
	*** CGLIB$getCountryCode$45$Method;
	*** CGLIB$getCountryCode$45$Proxy;
	*** CGLIB$getDirectBytes$38$Method;
	*** CGLIB$getDirectBytes$38$Proxy;
	*** CGLIB$getDirectRequests$40$Method;
	*** CGLIB$getDirectRequests$40$Proxy;
	*** CGLIB$getDownBytesPerSecond$30$Method;
	*** CGLIB$getDownBytesPerSecond$30$Proxy;
	*** CGLIB$getDownBytesPerSecondForPeers$33$Method;
	*** CGLIB$getDownBytesPerSecondForPeers$33$Proxy;
	*** CGLIB$getDownBytesPerSecondFromPeers$35$Method;
	*** CGLIB$getDownBytesPerSecondFromPeers$35$Proxy;
	*** CGLIB$getDownBytesPerSecondViaProxies$34$Method;
	*** CGLIB$getDownBytesPerSecondViaProxies$34$Proxy;
	*** CGLIB$getDownBytesThisRun$22$Method;
	*** CGLIB$getDownBytesThisRun$22$Proxy;
	*** CGLIB$getDownBytesThisRunForPeers$26$Method;
	*** CGLIB$getDownBytesThisRunForPeers$26$Proxy;
	*** CGLIB$getDownBytesThisRunFromPeers$28$Method;
	*** CGLIB$getDownBytesThisRunFromPeers$28$Proxy;
	*** CGLIB$getDownBytesThisRunViaProxies$27$Method;
	*** CGLIB$getDownBytesThisRunViaProxies$27$Proxy;
	*** CGLIB$getPeerCount$43$Method;
	*** CGLIB$getPeerCount$43$Proxy;
	*** CGLIB$getPeerCountThisRun$44$Method;
	*** CGLIB$getPeerCountThisRun$44$Proxy;
	*** CGLIB$getTotalBytesProxied$37$Method;
	*** CGLIB$getTotalBytesProxied$37$Proxy;
	*** CGLIB$getTotalProxiedRequests$39$Method;
	*** CGLIB$getTotalProxiedRequests$39$Proxy;
	*** CGLIB$getUpBytesPerSecond$29$Method;
	*** CGLIB$getUpBytesPerSecond$29$Proxy;
	*** CGLIB$getUpBytesPerSecondForPeers$31$Method;
	*** CGLIB$getUpBytesPerSecondForPeers$31$Proxy;
	*** CGLIB$getUpBytesPerSecondToPeers$36$Method;
	*** CGLIB$getUpBytesPerSecondToPeers$36$Proxy;
	*** CGLIB$getUpBytesPerSecondViaProxies$32$Method;
	*** CGLIB$getUpBytesPerSecondViaProxies$32$Proxy;
	*** CGLIB$getUpBytesThisRun$21$Method;
	*** CGLIB$getUpBytesThisRun$21$Proxy;
	*** CGLIB$getUpBytesThisRunForPeers$23$Method;
	*** CGLIB$getUpBytesThisRunForPeers$23$Proxy;
	*** CGLIB$getUpBytesThisRunToPeers$25$Method;
	*** CGLIB$getUpBytesThisRunToPeers$25$Proxy;
	*** CGLIB$getUpBytesThisRunViaProxies$24$Method;
	*** CGLIB$getUpBytesThisRunViaProxies$24$Proxy;
	*** CGLIB$getUptime$20$Method;
	*** CGLIB$getUptime$20$Proxy;
	*** CGLIB$getVersion$19$Method;
	*** CGLIB$getVersion$19$Proxy;
	*** CGLIB$hashCode$3$Method;
	*** CGLIB$hashCode$3$Proxy;
	*** CGLIB$incrementProxiedRequests$10$Method;
	*** CGLIB$incrementProxiedRequests$10$Proxy;
	*** CGLIB$isNatpmp$42$Method;
	*** CGLIB$isNatpmp$42$Proxy;
	*** CGLIB$isUpnp$41$Method;
	*** CGLIB$isUpnp$41$Proxy;
	*** CGLIB$resetCumulativeStats$7$Method;
	*** CGLIB$resetCumulativeStats$7$Proxy;
	*** CGLIB$setNatpmp$5$Method;
	*** CGLIB$setNatpmp$5$Proxy;
	*** CGLIB$setUpnp$6$Method;
	*** CGLIB$setUpnp$6$Proxy;
	*** CGLIB$toString$2$Method;
	*** CGLIB$toString$2$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK3();
}

-keep class org.lantern.CometDTest {
	*** log;
	*** access$0(org.lantern.CometDTest);
	*** startJetty(org.lantern.http.JettyLauncher,int);
	*** subscribe(org.cometd.bayeux.client.ClientSession,org.cometd.bayeux.client.ClientSessionChannel$MessageListener);
	*** waitForBoolean(java.util.concurrent.atomic.AtomicBoolean);
}

-keep class org.lantern.CometDTest$1 {
	*** this$0;
	*** val$handshake;
}

-keep class org.lantern.CometDTest$2 {
	*** this$0;
	*** val$hasMessage;
	*** val$messagePath;
}

-keep class org.lantern.CometDTest$3 {
	*** this$0;
	*** val$jl;
	*** val$port;
}

-keep class org.lantern.CommandLine {
	*** JDK6_CAN_EXECUTE;
	*** allInput;
	*** cleanup;
	*** commandAndArgs;
	*** drainTo;
	*** drainer;
	*** drainerThread;
	*** env;
	*** executed;
	*** exitCode;
	*** log;
	*** proc;
	*** access$0(org.lantern.CommandLine);
	*** access$1(org.lantern.CommandLine);
	*** access$2(org.lantern.CommandLine);
	*** access$3(org.lantern.CommandLine);
	*** canExecute(java.io.File);
	*** createProcess();
	*** execute();
	*** findExecutable(java.lang.String);
	*** findJdk6CanExecuteMethod();
	*** getExitCode();
	*** getStdOut();
	*** isSuccessful();
	*** postRunCleanup();
	*** setEnvironmentVariable(java.lang.String,java.lang.String);
	*** setupDrainer();
	*** waitFor();
}

-keep class org.lantern.CommandLine$1 {
	*** this$0;
}

-keep class org.lantern.CommandLine$2 {
	*** this$0;
}

-keep class org.lantern.CommandLine$StreamDrainer {
	*** drainTo;
	*** inputOut;
	*** toWatch;
	*** getStdOut();
}

-keep class org.lantern.ConnectivityChangedEvent {
	*** ipChanged;
	*** isConnected;
	*** newIp;
	*** getNewIp();
	*** isConnected();
	*** isIpChanged();
}

-keep class org.lantern.ConnectivityChecker {
	*** LOG;
	*** TEST_SITES;
	*** model;
	*** wasConnected;
	*** areAnyTestSitesReachable();
	*** determineCurrentIpAddress();
	*** isReachable(java.lang.String);
	*** notifyConnected(java.net.InetAddress);
	*** notifyDisconnected();
}

-keep class org.lantern.ConnectivityStatus {
	*** CONNECTED;
	*** CONNECTING;
	*** DISCONNECTED;
	*** ENUM$VALUES;
	*** values();
}

-keep class org.lantern.Country {
	*** bps;
	*** bytesEver;
	*** censors;
	*** code;
	*** name;
	*** npeers;
	*** nusers;
	*** getCode();
	*** getName();
	*** isCensors();
}

-keep class org.lantern.CountryService {
	*** allCountries;
	*** censored;
	*** countryTable;
	*** allCountries();
	*** getCountryByCode(java.lang.String);
	*** initCountries();
}

-keep class org.lantern.Dashboard {
	*** browser;
	*** completed;
	*** log;
	*** model;
	*** pendingCalls;
	*** shell;
	*** access$0(org.lantern.Dashboard);
	*** access$1(org.lantern.Dashboard);
	*** access$2(org.lantern.Dashboard);
	*** buildBrowser();
	*** evaluate(java.lang.String);
	*** newImage(java.lang.String);
	*** openBrowser();
	*** openBrowser(int,java.lang.String);
	*** openBrowserWhenPortReady(int,java.lang.String);
	*** windowsBugWorkaround();
}

-keep class org.lantern.Dashboard$1 {
	*** this$0;
}

-keep class org.lantern.Dashboard$2 {
	*** this$0;
	*** val$display;
}

-keep class org.lantern.Dashboard$3 {
	*** this$0;
}

-keep class org.lantern.Dashboard$4 {
	*** this$0;
	*** val$call;
}

-keep class org.lantern.DefaultCensored {
	*** CENSORED;
	*** EXPORT_RESTRICTED;
	*** LOG;
	*** lookupService;
	org.lantern.DefaultCensored(org.lantern.geoip.GeoIpLookupService);
	*** countryCode(java.net.InetAddress);
	*** isCensored();
	*** isCensored(java.net.InetAddress);
	*** isCensored(org.lantern.Country);
	*** isCountryCodeCensored(java.lang.String);
	*** isExportRestricted();
	*** isExportRestricted(java.lang.String);
	*** isExportRestricted(java.net.InetAddress);
	*** isMatch(java.net.InetAddress,java.util.Collection);
}

-keep class org.lantern.DefaultCensoredTest {
	*** lookupService;
	*** isCensored(java.lang.String);
}

-keep class org.lantern.DefaultPeerFactory {
	*** certsToPeers;
	*** geoIpLookupService;
	*** log;
	*** model;
	*** roster;
	*** addPeer(java.net.URI,org.lantern.state.Peer$Type);
	*** onCert(org.lantern.event.PeerCertEvent);
	*** onKscopeAd(org.lantern.event.KscopeAdEvent);
	*** onOutgoingConnection(java.net.URI,java.net.InetSocketAddress,org.lantern.state.Peer$Type);
	*** onUpdatePresenceEvent(org.lantern.event.UpdatePresenceEvent);
	*** peerForJid(java.net.URI);
	*** peerForSession(javax.net.ssl.SSLSession);
	*** peerSentRequest(java.net.InetSocketAddress,javax.net.ssl.SSLSession);
	*** rosterEntry(java.net.URI);
	*** updateGeoData(org.lantern.state.Peer,java.lang.String);
	*** updateGeoData(org.lantern.state.Peer,java.net.InetAddress);
	*** updatePeer(java.net.URI,java.net.InetSocketAddress,org.lantern.state.Peer$Type);
	*** updatePeer(org.lantern.state.Peer,java.net.InetSocketAddress,org.lantern.state.Peer$Type);
}

-keep class org.lantern.DefaultProxyTracker {
	*** EMPTY_UDP_TUPLE;
	*** LOG;
	*** PROXY_PRIORITIZER;
	*** fallbackServerHost;
	*** fallbackServerPort;
	*** lanternTrustStore;
	*** model;
	*** noProxies;
	*** p2pSocketThreadPool;
	*** peerFactory;
	*** proxies;
	*** proxiesPopulated;
	*** proxyCheckThreadPool;
	*** proxyRetryService;
	*** tcpProxyLock;
	*** xmppHandler;
	*** access$0(org.lantern.DefaultProxyTracker);
	*** access$1(org.lantern.DefaultProxyTracker);
	*** access$2(org.lantern.DefaultProxyTracker);
	*** access$3(org.lantern.DefaultProxyTracker,org.lantern.ProxyHolder);
	*** access$4();
	*** access$5(org.lantern.DefaultProxyTracker);
	*** access$6(org.lantern.DefaultProxyTracker);
	*** access$7(org.lantern.DefaultProxyTracker);
	*** access$8(org.lantern.DefaultProxyTracker);
	*** addFallbackProxies();
	*** addProxy(java.net.URI);
	*** addProxy(java.net.URI,java.net.InetSocketAddress);
	*** addProxy(java.net.URI,java.net.InetSocketAddress,org.lantern.state.Peer$Type);
	*** addSingleFallbackProxy(java.lang.String,int);
	*** addressForConfiguredFallbackProxy();
	*** checkConnectivityToNattedProxy(org.lantern.ProxyHolder);
	*** checkConnectivityToProxy(org.lantern.ProxyHolder);
	*** checkConnectivityToTcpProxy(org.lantern.ProxyHolder);
	*** clear();
	*** clearPeerProxySet();
	*** copyFallback();
	*** doAddProxy(java.net.URI,org.lantern.ProxyHolder);
	*** firstConnectedTcpProxy();
	*** firstConnectedTcpProxyBlocking();
	*** getConnectedProxiesInOrderOfFallbackPreference();
	*** hasProxy();
	*** notifyProxiesSize();
	*** notifyTcpProxyAvailable();
	*** onConnectivityChanged(org.lantern.ConnectivityChangedEvent);
	*** onCouldNotConnect(org.lantern.ProxyHolder);
	*** onError(java.net.URI);
	*** onModeChanged(org.lantern.event.ModeChangedEvent);
	*** onReset(org.lantern.event.ResetEvent);
	*** parseFallbackProxy();
	*** prepopulateProxies();
	*** removeNattedProxy(java.net.URI);
	*** restoreDeceasedProxies();
	*** restoreTimedInProxies();
	*** start();
	*** stop();
	*** successfullyConnectedToProxy(org.lantern.ProxyHolder);
}

-keep class org.lantern.DefaultProxyTracker$1 {
	*** this$0;
}

-keep class org.lantern.DefaultProxyTracker$2 {
	*** this$0;
	*** val$proxy;
}

-keep class org.lantern.DefaultProxyTracker$3 {
	*** this$0;
	*** val$proxy;
}

-keep class org.lantern.DefaultProxyTracker$ProxyPrioritizer {
	*** this$0;
	org.lantern.DefaultProxyTracker$ProxyPrioritizer(org.lantern.DefaultProxyTracker);
	*** compare(org.lantern.ProxyHolder,org.lantern.ProxyHolder);
}

-keep class org.lantern.DefaultProxyTrackerTest {
	*** getProxyPort(org.lantern.ProxyHolder);
	*** waitForProxy(org.lantern.DefaultProxyTracker);
}

-keep class org.lantern.DefaultProxyTrackerTest$Miniproxy {
	*** done;
	*** paused;
	*** port;
	*** access$0(org.lantern.DefaultProxyTrackerTest$Miniproxy);
}

-keep class org.lantern.DefaultXmppHandler {
	*** $SWITCH_TABLE$org$lantern$GoogleTalkState;
	*** LOG;
	*** client;
	*** closedBetaEvent;
	*** closedBetaLock;
	*** friendsHandler;
	*** keyStoreManager;
	*** kscopeAdHandler;
	*** lastInfoMessageScheduled;
	*** lastJson;
	*** mappedServer;
	*** model;
	*** modelUtils;
	*** msgs;
	*** natPmpService;
	*** networkTracker;
	*** pingTimeout;
	*** previousConnection;
	*** proxyTracker;
	*** reconnectIfNoPong;
	*** roster;
	*** socketsUtil;
	*** started;
	*** state;
	*** stats;
	*** timer;
	*** typedListener;
	*** udtFiveTupleListener;
	*** upnpService;
	*** waitingForPong;
	*** xmppProcessors;
	*** xmppUtil;
	org.lantern.DefaultXmppHandler(org.lantern.state.Model,java.util.Timer,org.lantern.ClientStats,org.lantern.LanternKeyStoreManager,org.lantern.LanternSocketsUtil,org.lantern.LanternXmppUtil,org.lantern.state.ModelUtils,org.lantern.Roster,org.lantern.ProxyTracker,org.lantern.kscope.KscopeAdHandler,org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,org.lantern.proxy.UdtServerFiveTupleListener,org.lantern.state.FriendsHandler,org.lantern.network.NetworkTracker,org.lantern.Messages);
	*** $SWITCH_TABLE$org$lantern$GoogleTalkState();
	*** access$0();
	*** access$1(org.lantern.DefaultXmppHandler,org.jivesoftware.smack.packet.Message);
	*** access$10(org.lantern.DefaultXmppHandler);
	*** access$11(org.lantern.DefaultXmppHandler,java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** access$13(org.lantern.DefaultXmppHandler);
	*** access$2(org.lantern.DefaultXmppHandler,org.jivesoftware.smack.packet.Message,java.lang.Integer);
	*** access$3(org.lantern.DefaultXmppHandler);
	*** access$4(org.lantern.DefaultXmppHandler);
	*** access$5(org.lantern.DefaultXmppHandler);
	*** access$6(org.lantern.DefaultXmppHandler);
	*** access$7(org.lantern.DefaultXmppHandler);
	*** access$8(org.lantern.DefaultXmppHandler,java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** access$9(org.lantern.DefaultXmppHandler);
	*** addOrRemovePeer(org.jivesoftware.smack.packet.Presence,java.lang.String);
	*** addToRoster(java.lang.String);
	*** addressToHostAndPort(java.net.InetSocketAddress);
	*** connect();
	*** connect(java.lang.String,java.lang.String);
	*** connect(org.littleshoot.commom.xmpp.XmppCredentials);
	*** connectViaOAuth2();
	*** disconnect();
	*** gTalkSharedStatus();
	*** getJid();
	*** getMappedServer();
	*** getP2PClient();
	*** getPingTimeout();
	*** getProxyTracker();
	*** getResource();
	*** getStunServers(org.jivesoftware.smack.XMPPConnection);
	*** handleConnectionFailure();
	*** handleSetDelay(org.json.simple.JSONObject);
	*** handleUpdate(org.json.simple.JSONObject);
	*** hasConnection();
	*** instanceOfflineOrUntrusted(org.lantern.network.InstanceInfo);
	*** instanceOnlineAndTrusted(org.lantern.network.InstanceInfo);
	*** isLoggedIn();
	*** login(org.littleshoot.commom.xmpp.XmppCredentials);
	*** makeClient(java.net.InetSocketAddress);
	*** makeXmppP2PHttpClient(java.net.InetSocketAddress,org.littleshoot.util.SessionSocketListener);
	*** notInClosedBeta(java.lang.String);
	*** onAuthStatus(org.lantern.event.GoogleTalkStateEvent);
	*** onClosedBetaEvent(org.lantern.event.ClosedBetaEvent);
	*** onConnectivityChanged(org.lantern.ConnectivityChangedEvent);
	*** onReset(org.lantern.event.ResetEvent);
	*** onUpdatePresenceEvent(org.lantern.event.UpdatePresenceEvent);
	*** peerAvailable(java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** peerUnavailable(java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** ping();
	*** processInfoData(org.jivesoftware.smack.packet.Message);
	*** processKscopePayload(java.lang.String,java.lang.String);
	*** processLanternHubMessage(org.jivesoftware.smack.packet.Message);
	*** processTypedMessage(org.jivesoftware.smack.packet.Message,java.lang.Integer);
	*** reconnect();
	*** removeFromRoster(java.lang.String);
	*** sendAndRequestCert(java.lang.String);
	*** sendFallbackHostAndPort(org.jivesoftware.smack.packet.Presence);
	*** sendHostAndPort(org.jivesoftware.smack.packet.Presence);
	*** sendInfoResponse(java.lang.String);
	*** sendInvite(org.lantern.state.Friend,boolean,boolean);
	*** sendOnDemandValuesToControllerIfNecessary(org.json.simple.JSONObject);
	*** sendPacket(org.jivesoftware.smack.packet.Packet);
	*** sendPresence(org.jivesoftware.smack.packet.Presence,java.lang.String);
	*** sendToken(org.jivesoftware.smack.packet.Presence);
	*** sendTypedPacket(java.lang.String,org.jivesoftware.smack.packet.Presence$Type);
	*** setPingTimeout(long);
	*** start();
	*** stop();
	*** subscribe(java.lang.String);
	*** subscribed(java.lang.String);
	*** toStringServers(java.util.Collection);
	*** unsubscribe(java.lang.String);
	*** unsubscribed(java.lang.String);
	*** updatePresence();
	*** waitForClosedBetaStatus(java.lang.String);
}

-keep class org.lantern.DefaultXmppHandler$$EnhancerByMockitoWithCGLIB$$a3ecb24f {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$addOrRemovePeer$16$Method;
	*** CGLIB$addOrRemovePeer$16$Proxy;
	*** CGLIB$addToRoster$9$Method;
	*** CGLIB$addToRoster$9$Proxy;
	*** CGLIB$clone$32$Method;
	*** CGLIB$clone$32$Proxy;
	*** CGLIB$connect$2$Method;
	*** CGLIB$connect$2$Proxy;
	*** CGLIB$connect$3$Method;
	*** CGLIB$connect$3$Proxy;
	*** CGLIB$disconnect$4$Method;
	*** CGLIB$disconnect$4$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$29$Method;
	*** CGLIB$equals$29$Proxy;
	*** CGLIB$finalize$28$Method;
	*** CGLIB$finalize$28$Proxy;
	*** CGLIB$getJid$25$Method;
	*** CGLIB$getJid$25$Proxy;
	*** CGLIB$getMappedServer$12$Method;
	*** CGLIB$getMappedServer$12$Proxy;
	*** CGLIB$getP2PClient$15$Method;
	*** CGLIB$getP2PClient$15$Proxy;
	*** CGLIB$getPingTimeout$20$Method;
	*** CGLIB$getPingTimeout$20$Proxy;
	*** CGLIB$getProxyTracker$14$Method;
	*** CGLIB$getProxyTracker$14$Proxy;
	*** CGLIB$hashCode$31$Method;
	*** CGLIB$hashCode$31$Proxy;
	*** CGLIB$instanceOfflineOrUntrusted$24$Method;
	*** CGLIB$instanceOfflineOrUntrusted$24$Proxy;
	*** CGLIB$instanceOnlineAndTrusted$27$Method;
	*** CGLIB$instanceOnlineAndTrusted$27$Proxy;
	*** CGLIB$isLoggedIn$5$Method;
	*** CGLIB$isLoggedIn$5$Proxy;
	*** CGLIB$onAuthStatus$18$Method;
	*** CGLIB$onAuthStatus$18$Proxy;
	*** CGLIB$onClosedBetaEvent$26$Method;
	*** CGLIB$onClosedBetaEvent$26$Proxy;
	*** CGLIB$onConnectivityChanged$19$Method;
	*** CGLIB$onConnectivityChanged$19$Proxy;
	*** CGLIB$onReset$23$Method;
	*** CGLIB$onReset$23$Proxy;
	*** CGLIB$onUpdatePresenceEvent$22$Method;
	*** CGLIB$onUpdatePresenceEvent$22$Proxy;
	*** CGLIB$removeFromRoster$10$Method;
	*** CGLIB$removeFromRoster$10$Proxy;
	*** CGLIB$sendInvite$6$Method;
	*** CGLIB$sendInvite$6$Proxy;
	*** CGLIB$sendPacket$13$Method;
	*** CGLIB$sendPacket$13$Proxy;
	*** CGLIB$setPingTimeout$21$Method;
	*** CGLIB$setPingTimeout$21$Proxy;
	*** CGLIB$start$0$Method;
	*** CGLIB$start$0$Proxy;
	*** CGLIB$stop$1$Method;
	*** CGLIB$stop$1$Proxy;
	*** CGLIB$subscribe$17$Method;
	*** CGLIB$subscribe$17$Proxy;
	*** CGLIB$subscribed$11$Method;
	*** CGLIB$subscribed$11$Proxy;
	*** CGLIB$toString$30$Method;
	*** CGLIB$toString$30$Proxy;
	*** CGLIB$unsubscribe$7$Method;
	*** CGLIB$unsubscribe$7$Proxy;
	*** CGLIB$unsubscribed$8$Method;
	*** CGLIB$unsubscribed$8$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK5();
}

-keep class org.lantern.DefaultXmppHandler$1 {
	*** this$0;
}

-keep class org.lantern.DefaultXmppHandler$2 {
	*** this$0;
}

-keep class org.lantern.DefaultXmppHandler$3 {
	*** this$0;
}

-keep class org.lantern.DefaultXmppHandler$4 {
	*** this$0;
}

-keep class org.lantern.DefaultXmppHandler$5 {
	*** this$0;
	*** val$conn;
	*** val$pres;
}

-keep class org.lantern.DefaultXmppHandler$DefaultP2PConnectionListener {
	*** this$0;
	org.lantern.DefaultXmppHandler$DefaultP2PConnectionListener(org.lantern.DefaultXmppHandler);
}

-keep class org.lantern.DefaultXmppHandler$DefaultPacketListener {
	*** $SWITCH_TABLE$org$jivesoftware$smack$packet$Presence$Type;
	*** this$0;
	org.lantern.DefaultXmppHandler$DefaultPacketListener(org.lantern.DefaultXmppHandler);
	*** $SWITCH_TABLE$org$jivesoftware$smack$packet$Presence$Type();
	*** access$0(org.lantern.DefaultXmppHandler$DefaultPacketListener,org.jivesoftware.smack.packet.Packet,org.jivesoftware.smack.packet.Presence,java.lang.String,org.jivesoftware.smack.packet.Presence$Type);
	*** access$1(org.lantern.DefaultXmppHandler$DefaultPacketListener,org.jivesoftware.smack.packet.Packet,org.jivesoftware.smack.packet.Presence,java.lang.String,org.jivesoftware.smack.packet.Presence$Type);
	*** handleHubMessage(org.jivesoftware.smack.packet.Packet,org.jivesoftware.smack.packet.Presence,java.lang.String,org.jivesoftware.smack.packet.Presence$Type);
	*** handlePeerMessage(org.jivesoftware.smack.packet.Packet,org.jivesoftware.smack.packet.Presence,java.lang.String,org.jivesoftware.smack.packet.Presence$Type);
}

-keep class org.lantern.DefaultXmppHandler$DefaultPacketListener$1 {
	*** this$1;
	*** val$pack;
}

-keep class org.lantern.DefaultXmppHandler$PingListener {
	*** this$0;
	org.lantern.DefaultXmppHandler$PingListener(org.lantern.DefaultXmppHandler);
}

-keep class org.lantern.DefaultXmppHandler$Reconnector {
	*** this$0;
	org.lantern.DefaultXmppHandler$Reconnector(org.lantern.DefaultXmppHandler);
}

-keep class org.lantern.DefaultXmppHandlerTest {
	*** LOG;
	*** closedBetaEvent;
}

-keep class org.lantern.Diagnostics {
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus;
	*** PROXY_LOCK;
	*** certsFile;
	*** fallbackServerHost;
	*** fallbackServerPort;
	*** log;
	*** output;
	*** text;
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus();
	*** copyFallback();
	*** output(java.lang.String);
	*** output(java.lang.String,java.lang.Exception);
	*** parseFallbackProxy();
	*** runDiagnostics(java.lang.String,java.lang.String);
	*** testProxy();
	*** testWhitelistedSite(java.lang.String,int);
}

-keep class org.lantern.Diagnostics$1 {
	*** this$0;
	*** val$frame;
}

-keep class org.lantern.Diagnostics$2 {
	*** this$0;
}

-keep class org.lantern.DisplayWrapper {
	*** display;
	*** getDisplay();
}

-keep class org.lantern.FallbackProxies {
	*** proxies;
	*** getProxies();
}

-keep class org.lantern.FallbackProxy {
	*** base64PublicKey;
	*** ip;
	*** port;
	*** getIp();
	*** getPort();
}

-keep class org.lantern.FallbackProxyTest {
	*** LITTLEPROXY_TEST;
	*** SERVER_PORT;
	*** log;
	*** originalFallbackKeystorePath;
	*** access$0(org.lantern.FallbackProxyTest);
	*** addTestCertToTrustStore(org.lantern.LanternTrustStore);
	*** hitSite(org.apache.http.impl.client.DefaultHttpClient,java.lang.String);
	*** startGiveModeProxy(org.lantern.LanternTrustStore,org.lantern.LanternKeyStoreManager);
}

-keep class org.lantern.FallbackProxyTest$1 {
	*** this$0;
	*** val$clientFactory;
}

-keep class org.lantern.FallbackTray {
	*** linuxTray;
	*** log;
	*** model;
	*** nonLinuxTray;
	*** createTray();
	*** fallback();
}

-keep class org.lantern.FallbackTray$1 {
	*** this$0;
}

-keep class org.lantern.FallbackTray$2 {
	*** this$0;
}

-keep class org.lantern.GeoData {
	*** countrycode;
	*** latitude;
	*** longitude;
	*** getCountrycode();
	*** getLatitude();
	*** getLongitude();
	*** setCountrycode(java.lang.String);
	*** setLatitude(double);
	*** setLongitude(double);
}

-keep class org.lantern.GoogleTalkState {
	*** ENUM$VALUES;
	*** LOGIN_FAILED;
	*** connected;
	*** connecting;
	*** notConnected;
	*** values();
}

-keep class org.lantern.HttpClientFactoryTest {
	*** log;
	*** testExceptional(org.apache.http.client.HttpClient);
	*** testGoogleDocs(org.lantern.util.HttpClientFactory);
	*** testStats(org.apache.http.client.HttpClient);
}

-keep class org.lantern.HttpClientFactoryTest$1 {
	*** this$0;
	*** answer(org.mockito.invocation.InvocationOnMock);
}

-keep class org.lantern.JsonUtils {
	*** LOG;
	*** getValueFromJson(java.lang.String,java.lang.String);
	*** jsonify(java.lang.Object);
	*** jsonify(java.lang.Object,java.lang.Class);
}

-keep class org.lantern.KscopeAdTest {
	*** LOG;
}

-keep class org.lantern.LaePinnedCertTest {
	*** LOG;
}

-keep class org.lantern.LaePinnedCertTest$1 {
	*** this$0;
	*** val$completed;
}

-keep class org.lantern.LanternClientConstants {
	*** CONFIG_DIR;
	*** CONTROLLER_URL;
	*** DATA_DIR;
	*** DEFAULT_MODEL_FILE;
	*** DEFAULT_TRANSFERS_FILE;
	*** GIT_VERSION;
	*** GNOME_AUTOSTART;
	*** LANTERN_JID;
	*** LANTERN_VERSION_HTTP_HEADER_VALUE;
	*** LAUNCHD_PLIST;
	*** LOG;
	*** LOG_DIR;
	*** START_TIME;
	*** STATS_URL;
	*** TEST_PROPS;
	*** TEST_PROPS2;
	*** VERSION;
	*** isDevMode;
	*** isDevMode();
	*** setControllerId(java.lang.String);
}

-keep class org.lantern.LanternConstants {
	*** ON_APP_ENGINE;
	*** UTF8;
}

-keep class org.lantern.LanternFeedback {
	*** FORM_ORDER;
	*** httpClientFactory;
	*** log;
	org.lantern.LanternFeedback(org.lantern.util.HttpClientFactory);
	*** getHttpPost(java.lang.String);
	*** postForm(java.lang.String,java.util.List);
	*** submit(java.lang.String,java.lang.String);
	*** submitFeedback(java.util.Map);
	*** systemInfo();
}

-keep class org.lantern.LanternFeedback$$EnhancerByMockitoWithCGLIB$$95b5b2d5 {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$clone$7$Method;
	*** CGLIB$clone$7$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$4$Method;
	*** CGLIB$equals$4$Proxy;
	*** CGLIB$finalize$3$Method;
	*** CGLIB$finalize$3$Proxy;
	*** CGLIB$getHttpPost$1$Method;
	*** CGLIB$getHttpPost$1$Proxy;
	*** CGLIB$hashCode$6$Method;
	*** CGLIB$hashCode$6$Proxy;
	*** CGLIB$submit$2$Method;
	*** CGLIB$submit$2$Proxy;
	*** CGLIB$systemInfo$0$Method;
	*** CGLIB$systemInfo$0$Proxy;
	*** CGLIB$toString$5$Method;
	*** CGLIB$toString$5$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_STATIC_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK8();
	*** CGLIB$clone$7();
	*** CGLIB$equals$4(java.lang.Object);
	*** CGLIB$finalize$3();
	*** CGLIB$findMethodProxy(org.mockito.cglib.core.Signature);
	*** CGLIB$getHttpPost$1(java.lang.String);
	*** CGLIB$hashCode$6();
	*** CGLIB$submit$2(java.lang.String,java.lang.String);
	*** CGLIB$systemInfo$0();
	*** CGLIB$toString$5();
	*** equals(java.lang.Object);
	*** getCallback(int);
	*** getCallbacks();
	*** getHttpPost(java.lang.String);
	*** hashCode();
	*** newInstance(java.lang.Class[],java.lang.Object[],org.mockito.cglib.proxy.Callback[]);
	*** newInstance(org.mockito.cglib.proxy.Callback);
	*** newInstance(org.mockito.cglib.proxy.Callback[]);
	*** setCallback(int,org.mockito.cglib.proxy.Callback);
	*** setCallbacks(org.mockito.cglib.proxy.Callback[]);
	*** submit(java.lang.String,java.lang.String);
	*** toString();
}

-keep class org.lantern.LanternKeyStoreManager {
	*** CERT_FILE;
	*** CONFIG_DIR;
	*** KEYSTORE_FILE;
	*** PASS;
	*** keyManagerFactoryRef;
	*** localCert;
	*** log;
	*** started;
	org.lantern.LanternKeyStoreManager();
	org.lantern.LanternKeyStoreManager(java.io.File);
	*** createKeyStore();
	*** generateLocalCert(java.lang.String);
	*** getBase64Cert(java.lang.String);
	*** getCertificatePassword();
	*** getKeyManagerFactory();
	*** getKeyStorePassword();
	*** keyStoreAsInputStream();
	*** reset();
	*** start();
	*** stop();
	*** waitForKeystore();
}

-keep class org.lantern.LanternMappedTcpAnswererServer {
	*** externalPort;
	*** isPortMapped;
	*** log;
	*** serverAddress;
}

-keep class org.lantern.LanternModule {
	*** commandLine;
	*** geoIpLookupService;
	*** log;
	*** natPmpService;
	*** upnpService;
	*** commandLine();
	*** copyFireFoxExtension();
	*** getExtensionDir();
	*** newBasicCipherProvider();
	*** setGeoIpLookupService(org.lantern.geoip.GeoIpLookupService);
	*** setNatPmpService(org.lastbamboo.common.portmapping.NatPmpService);
	*** setUpnpService(org.lastbamboo.common.portmapping.UpnpService);
}

-keep class org.lantern.LanternModule$1 {
	*** this$0;
}

-keep class org.lantern.LanternModuleTest$1 {
	*** this$0;
}

-keep class org.lantern.LanternModuleTest$2 {
	*** this$0;
}

-keep class org.lantern.LanternProxyingTest {
	*** log;
	*** launch(org.lantern.Launcher);
	*** testWhitelistedSite(java.lang.String,org.apache.http.client.HttpClient,int);
}

-keep class org.lantern.LanternProxyingTest$1 {
	*** this$0;
	*** val$launcher;
}

-keep class org.lantern.LanternRosterEntry {
	*** autosub;
	*** available;
	*** away;
	*** email;
	*** index;
	*** log;
	*** name;
	*** sortKey;
	*** statusMessage;
	*** subscriptionStatus;
	*** user;
	*** vcard;
	*** compareTo(org.lantern.LanternRosterEntry);
	*** extractSubscriptionStatus(org.jivesoftware.smack.RosterEntry);
	*** extractSubscriptionStatus(org.jivesoftware.smack.packet.RosterPacket$ItemStatus);
	*** getEmail();
	*** getIndex();
	*** getSubscriptionStatus();
	*** getUser();
	*** isAvailable();
	*** setAvailable(boolean);
	*** setIndex(int);
	*** setStatusMessage(java.lang.String);
}

-keep class org.lantern.LanternService {
	*** start();
}

-keep class org.lantern.LanternSocketsUtil {
	*** log;
	*** stats;
	*** threadPool;
	*** trustStore;
	*** access$0(org.lantern.LanternSocketsUtil);
	*** newTlsServerSocketFactory();
	*** newTlsServerSocketFactory(java.lang.String[]);
	*** newTlsServerSocketFactoryJavaCipherSuites();
	*** newTlsSocketFactory(java.lang.String[]);
	*** newTlsSocketFactoryJavaCipherSuites();
	*** sf();
	*** ssf();
	*** wrappedServerSocketFactory(java.lang.String[]);
	*** wrappedSocketFactory(java.lang.String[]);
}

-keep class org.lantern.LanternSocketsUtil$1 {
	*** this$0;
	*** threadNumber;
}

-keep class org.lantern.LanternSocketsUtil$2 {
	*** this$0;
	*** val$cipherSuites;
	*** configure(javax.net.ssl.SSLServerSocket);
}

-keep class org.lantern.LanternSocketsUtil$3 {
	*** this$0;
	*** val$cipherSuites;
	*** configure(javax.net.ssl.SSLSocket);
}

-keep class org.lantern.LanternSocketsUtilTest {
	*** LOG;
	*** SERVER_PORT;
	*** msg;
	*** accept(org.lantern.LanternSocketsUtil,java.util.concurrent.atomic.AtomicReference);
	*** testClient(javax.net.ssl.SSLSocketFactory,java.util.concurrent.atomic.AtomicReference);
}

-keep class org.lantern.LanternSocketsUtilTest$1 {
	*** this$0;
	*** val$data;
	*** val$server;
}

-keep class org.lantern.LanternTrustStore {
	*** ksm;
	*** log;
	*** sslContextRef;
	*** tmf;
	*** trustStore;
	org.lantern.LanternTrustStore(org.lantern.LanternKeyStoreManager);
	*** addCert(java.lang.String,java.lang.String);
	*** addCert(java.net.URI,java.security.cert.Certificate);
	*** addCert(java.security.KeyStore,java.security.cert.CertificateFactory,java.lang.String,java.lang.String);
	*** blankTrustStore();
	*** containsCertificate(java.security.cert.X509Certificate);
	*** deleteCert(java.lang.String);
	*** getSslContext();
	*** initTrustManagerFactory();
	*** listEntries();
	*** listEntries(java.security.KeyStore);
	*** newSSLEngine();
	*** onTrustStoreChanged();
	*** provideSslContext();
}

-keep class org.lantern.LanternTrustStore$$EnhancerByMockitoWithCGLIB$$63e1c9ee {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$addCert$1$Method;
	*** CGLIB$addCert$1$Proxy;
	*** CGLIB$addCert$2$Method;
	*** CGLIB$addCert$2$Proxy;
	*** CGLIB$clone$11$Method;
	*** CGLIB$clone$11$Proxy;
	*** CGLIB$containsCertificate$5$Method;
	*** CGLIB$containsCertificate$5$Proxy;
	*** CGLIB$deleteCert$0$Method;
	*** CGLIB$deleteCert$0$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$8$Method;
	*** CGLIB$equals$8$Proxy;
	*** CGLIB$finalize$7$Method;
	*** CGLIB$finalize$7$Proxy;
	*** CGLIB$getSslContext$4$Method;
	*** CGLIB$getSslContext$4$Proxy;
	*** CGLIB$hashCode$10$Method;
	*** CGLIB$hashCode$10$Proxy;
	*** CGLIB$listEntries$6$Method;
	*** CGLIB$listEntries$6$Proxy;
	*** CGLIB$newSSLEngine$3$Method;
	*** CGLIB$newSSLEngine$3$Proxy;
	*** CGLIB$toString$9$Method;
	*** CGLIB$toString$9$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK6();
}

-keep class org.lantern.LanternTrustStoreTest {
	*** log;
	*** trySite(org.apache.http.client.HttpClient,java.lang.String);
}

-keep class org.lantern.LanternUtils {
	*** LOG;
	*** amFallbackProxy;
	*** keystorePath;
	*** model;
	*** privateProps;
	*** privatePropsFile;
	*** secureRandom;
	*** activateOtr(org.jivesoftware.smack.XMPPConnection);
	*** addCSPHeader(javax.servlet.http.HttpServletResponse);
	*** addStartupWMClass(java.lang.String);
	*** certFromBase64(java.lang.String);
	*** certFromBytes(byte[]);
	*** checkTrueOrFalse(java.lang.String,java.lang.String,java.lang.String);
	*** defaultPhotoUrl();
	*** fileInJarToString(java.lang.String);
	*** findKeytoolPath();
	*** fullDelete(java.io.File);
	*** getAccessToken();
	*** getFallbackKeystorePath();
	*** getRefreshToken();
	*** getRequestHeaders(javax.servlet.http.HttpServletRequest);
	*** getScreenCenter(int,int);
	*** getTargetForPath(java.lang.Object,java.lang.String);
	*** hasNetworkConnection();
	*** installPolicyFiles();
	*** isAnonymizedGoogleTalkAddress(java.lang.String);
	*** isDevMode();
	*** isFallbackProxy();
	*** isFalse(java.lang.String);
	*** isGet();
	*** isLanternHub(java.lang.String);
	*** isLocalHost(java.net.InetSocketAddress);
	*** isTesting();
	*** isTrue(java.lang.String);
	*** isUnlimitedKeyStrength();
	*** isa(java.lang.String,int);
	*** loadJarLibrary(java.lang.Class,java.lang.String);
	*** newURI(java.lang.String);
	*** openOutgoingPeer(java.net.URI,org.lastbamboo.common.p2p.P2PClient,java.util.Map);
	*** openOutgoingPeerSocket(java.net.URI,org.lastbamboo.common.p2p.P2PClient,java.util.Map,boolean);
	*** persistCredentials();
	*** photoUrl(java.lang.String);
	*** photoUrlBase();
	*** randomPort();
	*** readLineCliNoConsole();
	*** replaceInFile(java.io.File,java.lang.String,java.lang.String);
	*** runCommand(java.lang.String,java.lang.String[]);
	*** runKeytool(java.lang.String[]);
	*** setFallbackKeystorePath(java.lang.String);
	*** setFallbackProxy(boolean);
	*** setFromPath(java.lang.Object,java.lang.String,java.lang.Object);
	*** setModel(org.lantern.state.Model);
	*** toEmail(org.jivesoftware.smack.XMPPConnection);
	*** toHttpsCandidates(java.lang.String);
	*** toTyped(java.lang.String);
	*** waitForFile(java.io.File);
	*** waitForServer(int);
	*** waitForServer(int,int);
	*** waitForServer(java.lang.String,int,int);
}

-keep class org.lantern.LanternUtilsTest {
	*** LOG;
	*** access$0();
}

-keep class org.lantern.LanternUtilsTest$1 {
	*** this$0;
}

-keep class org.lantern.LanternXmppRetryStrategyFactory {
	*** LOG;
	*** access$0();
}

-keep class org.lantern.LanternXmppUtil {
	*** LOG;
	*** proxySocketFactory;
	*** socketsUtil;
	*** access$0(org.lantern.LanternXmppUtil);
	*** proxyInfo();
	*** xmppConfig();
	*** xmppConfig(org.jivesoftware.smack.proxy.ProxyInfo);
	*** xmppProxyConfig();
}

-keep class org.lantern.LanternXmppUtil$DirectSocketFactory {
	*** this$0;
	org.lantern.LanternXmppUtil$DirectSocketFactory(org.lantern.LanternXmppUtil);
	*** createSocket(java.lang.String,int);
	*** createSocket(java.net.InetAddress,int);
}

-keep class org.lantern.LanternXmppUtils {
	*** isLanternJid(java.lang.String);
	*** jidToEmail(java.lang.String);
}

-keep class org.lantern.Launcher {
	*** LOG;
	*** START_TIME;
	*** browserService;
	*** getModeProxy;
	*** giveModeProxy;
	*** httpClientFactory;
	*** injector;
	*** internalState;
	*** jettyLauncher;
	*** keyStoreManager;
	*** lanternModule;
	*** lanternStarted;
	*** messageService;
	*** model;
	*** modelUtils;
	*** proxyTracker;
	*** set;
	*** statsReporter;
	*** statsUpdater;
	*** syncService;
	*** systemTray;
	*** xmpp;
	*** access$0(org.lantern.Launcher,java.lang.Throwable,boolean);
	*** access$1(org.lantern.Launcher);
	*** access$10(org.lantern.Launcher);
	*** access$11(org.lantern.Launcher);
	*** access$12(org.lantern.Launcher);
	*** access$13(org.lantern.Launcher);
	*** access$14(org.lantern.Launcher);
	*** access$15(org.lantern.Launcher);
	*** access$16(org.lantern.Launcher);
	*** access$17(org.lantern.Launcher);
	*** access$18(org.lantern.Launcher);
	*** access$2(org.lantern.Launcher,java.lang.Class);
	*** access$3(org.lantern.Launcher,java.lang.Class);
	*** access$4(org.lantern.Launcher);
	*** access$5();
	*** access$6(org.lantern.Launcher);
	*** access$7(org.lantern.Launcher);
	*** access$8(org.lantern.Launcher);
	*** access$9(org.lantern.Launcher);
	*** addShutdownHook(org.lantern.Shutdownable);
	*** autoConnect();
	*** configureCipherSuites();
	*** configureDefaultLogger();
	*** configureProductionLogger();
	*** getInjector();
	*** gnomeAutoStart();
	*** handleError(java.lang.Throwable,boolean);
	*** instance(java.lang.Class);
	*** launch();
	*** launchLantern(boolean);
	*** log(java.lang.String);
	*** main(boolean,java.lang.String[]);
	*** msg(java.lang.Throwable);
	*** printLaunchTimes();
	*** shouldShowDashboard(org.lantern.state.Model,boolean,boolean);
	*** shutdownable(java.lang.Class);
	*** startServices();
	*** toSocketAddresses(java.util.Collection);
}

-keep class org.lantern.Launcher$1 {
	*** this$0;
	*** showMessage(java.lang.String,java.lang.String);
}

-keep class org.lantern.Launcher$2 {
	*** this$0;
}

-keep class org.lantern.Launcher$3 {
	*** this$0;
}

-keep class org.lantern.Launcher$4 {
	*** this$0;
	*** val$service;
}

-keep class org.lantern.Launcher$5 {
	*** this$0;
	*** val$showDashboard;
}

-keep class org.lantern.Launcher$6 {
	*** this$0;
}

-keep class org.lantern.Launcher$7 {
	*** this$0;
}

-keep class org.lantern.Launcher$8 {
	*** client;
	*** this$0;
	*** ver;
}

-keep class org.lantern.Launcher$9 {
	*** this$0;
	*** val$bugAppender;
}

-keep class org.lantern.LinuxBrowserLaunch {
	*** LOG;
	*** browsers;
	*** openURL(java.lang.String);
	*** seemsToHaveBrowser(java.lang.String);
}

-keep class org.lantern.MessageKey {
	*** ADDED_FRIEND;
	*** ALREADY_ADDED;
	*** CHECKING_INVITE;
	*** CONFIGURING_CONNECTION;
	*** CONTACT_ERROR;
	*** CONTACT_THANK_YOU;
	*** ENUM$VALUES;
	*** ERROR_ADDING_FRIEND;
	*** ERROR_CONNECTING_TO;
	*** ERROR_EMAILING_FRIEND;
	*** ERROR_REMOVING_FRIEND;
	*** ERROR_UPDATING_FRIEND;
	*** ICONLOC_MENUBAR;
	*** ICONLOC_SYSTRAY;
	*** ICONLOC_UNKNOWN;
	*** INVITED;
	*** INVITE_FAILED;
	*** LOAD_SETTINGS_ERROR;
	*** LOGGED_IN;
	*** MANUAL_PROXY;
	*** NO_PROXIES;
	*** REMOVED_FRIEND;
	*** SETUP;
	*** STUN_SERVER_LOOKUP;
	*** log;
	*** values();
}

-keep class org.lantern.MessageService {
	*** askQuestion(java.lang.String,java.lang.String,int);
	*** showMessage(java.lang.String,java.lang.String);
}

-keep class org.lantern.Messages {
	*** LOG;
	*** model;
	*** error(org.lantern.MessageKey,java.lang.String[]);
	*** error(org.lantern.MessageKey,java.lang.Throwable);
	*** error(org.lantern.MessageKey,java.lang.Throwable,java.lang.String[]);
	*** info(org.lantern.MessageKey);
	*** info(org.lantern.MessageKey,int,java.lang.String[]);
	*** info(org.lantern.MessageKey,java.lang.String[]);
	*** msg(java.lang.String,org.lantern.state.Notification$MessageType);
	*** msg(java.lang.String,org.lantern.state.Notification$MessageType,int);
	*** msg(org.lantern.MessageKey,org.lantern.state.Notification$MessageType);
	*** msg(org.lantern.MessageKey,org.lantern.state.Notification$MessageType,int,java.lang.String[]);
	*** msg(org.lantern.MessageKey,org.lantern.state.Notification$MessageType,java.lang.String[]);
	*** onMessageEvent(org.lantern.event.MessageEvent);
	*** warn(org.lantern.MessageKey);
	*** warn(org.lantern.MessageKey,java.lang.String[]);
}

-keep class org.lantern.NatPmpImpl {
	*** attemptedLoad;
	*** loadedNatPmp;
	*** log;
	*** requests;
	*** stats;
	*** addMapping(org.lastbamboo.common.portmapping.PortMappingProtocol,int,org.lastbamboo.common.portmapping.PortMapListener);
	*** addNatPmpMapping(org.lastbamboo.common.portmapping.PortMappingProtocol,int,int,org.lastbamboo.common.portmapping.PortMapListener);
	*** loadNatPmp();
	*** removeNatPmpMapping(int);
}

-keep class org.lantern.NatPmpImpl$1 {
	*** this$0;
	*** val$localPort;
	*** val$portMapListener;
	*** val$prot;
}

-keep class org.lantern.NatPmpImpl$MapRequest {
	*** externalPort;
	*** internalPort;
	*** lifeTimeSeconds;
	*** protocol;
	*** access$0(org.lantern.NatPmpImpl$MapRequest);
	*** access$1(org.lantern.NatPmpImpl$MapRequest);
	*** access$2(org.lantern.NatPmpImpl$MapRequest);
	*** access$3(org.lantern.NatPmpImpl$MapRequest,int);
}

-keep class org.lantern.NatPmpTest {
	*** log;
}

-keep class org.lantern.NatPmpTest$1 {
	*** this$0;
	*** val$ai;
	*** val$error;
}

-keep class org.lantern.NativeUtils {
	*** LOG;
	*** exec(java.lang.String[]);
	*** openSiteMac(java.lang.String);
	*** openSiteWindows(java.lang.String);
	*** openUri(java.lang.String);
}

-keep class org.lantern.OS {
	*** ENUM$VALUES;
	*** OSX;
	*** UBUNTU32;
	*** UBUNTU64;
	*** WINDOWS;
}

-keep class org.lantern.PacFileGenerator {
	*** LOG;
	*** generatePacFile(java.util.Collection,java.io.File);
	*** generatePacFileString(java.util.Collection);
	*** loadTemplate();
}

-keep class org.lantern.PacFileGeneratorTest {
	*** loadRefPac();
}

-keep class org.lantern.PeerFactory {
	*** addPeer(java.net.URI,org.lantern.state.Peer$Type);
	*** onOutgoingConnection(java.net.URI,java.net.InetSocketAddress,org.lantern.state.Peer$Type);
	*** peerForJid(java.net.URI);
	*** peerForSession(javax.net.ssl.SSLSession);
}

-keep class org.lantern.PeerFactory$$EnhancerByMockitoWithCGLIB$$2eb30b35 {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$addPeer$8$Method;
	*** CGLIB$addPeer$8$Proxy;
	*** CGLIB$clone$4$Method;
	*** CGLIB$clone$4$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$1$Method;
	*** CGLIB$equals$1$Proxy;
	*** CGLIB$finalize$0$Method;
	*** CGLIB$finalize$0$Proxy;
	*** CGLIB$hashCode$3$Method;
	*** CGLIB$hashCode$3$Proxy;
	*** CGLIB$onOutgoingConnection$7$Method;
	*** CGLIB$onOutgoingConnection$7$Proxy;
	*** CGLIB$peerForJid$5$Method;
	*** CGLIB$peerForJid$5$Proxy;
	*** CGLIB$peerForSession$6$Method;
	*** CGLIB$peerForSession$6$Proxy;
	*** CGLIB$toString$2$Method;
	*** CGLIB$toString$2$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK7();
}

-keep class org.lantern.PeerSocketTest {
	*** log;
}

-keep class org.lantern.Proxifier {
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus;
	*** $SWITCH_TABLE$org$lantern$state$Mode;
	*** LANTERN_PROXYING_FILE;
	*** LOG;
	*** PROXY_ALL;
	*** PROXY_GOOGLE;
	*** PROXY_OFF;
	*** PROXY_ON;
	*** WIN_PROXY;
	*** interactiveUnproxyCalled;
	*** lastProxyConnectionEvent;
	*** messageService;
	*** model;
	*** modelUtils;
	*** proxyTracker;
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus();
	*** $SWITCH_TABLE$org$lantern$state$Mode();
	*** configureOsxProxyViaScript(boolean,java.lang.String);
	*** copyFromLocal(java.io.File);
	*** getAndSetPacFileUrl(java.io.File);
	*** getPacFileUrl(java.io.File);
	*** interactiveUnproxy();
	*** isProxying();
	*** onModeChangedEvent(org.lantern.event.ModeChangedEvent);
	*** onProxyConnectionEvent(org.lantern.event.ProxyConnectionEvent);
	*** onQuit(org.lantern.event.QuitEvent);
	*** onReset(org.lantern.event.ResetEvent);
	*** onSetupComplete(org.lantern.event.SetupCompleteEvent);
	*** onSystemProxyChanged(org.lantern.event.SystemProxyChangedEvent);
	*** proxyAllSites(boolean);
	*** proxyGoogle();
	*** proxyLinux(java.lang.String);
	*** proxyOsx(java.lang.String);
	*** proxyWindows(java.lang.String);
	*** proxyWithChecks();
	*** refresh();
	*** start();
	*** startProxying();
	*** startProxying(boolean,java.io.File);
	*** stop();
	*** stopProxying();
	*** unproxyLinux();
	*** unproxyOsx();
	*** unproxyWindows();
}

-keep class org.lantern.Proxifier$ProxyConfigurationCancelled {
	*** this$0;
}

-keep class org.lantern.Proxifier$ProxyConfigurationError {
	*** this$0;
	org.lantern.Proxifier$ProxyConfigurationError(org.lantern.Proxifier);
}

-keep class org.lantern.ProxifierTest {
	*** newModelUtils();
}

-keep class org.lantern.ProxifierTest$1 {
	*** this$0;
}

-keep class org.lantern.ProxyHolder {
	*** LOG;
	*** failures;
	*** fiveTuple;
	*** jid;
	*** lanternTrustStore;
	*** peer;
	*** peerFactory;
	*** proxyTracker;
	*** timeOfDeath;
	*** type;
	*** addFailure();
	*** attemptNatTraversalIfConnectionFailed();
	*** compareTo(org.lantern.ProxyHolder);
	*** getFailures();
	*** getFiveTuple();
	*** getJid();
	*** getPeer();
	*** getProxyPassword();
	*** getProxyUsername();
	*** getRetryTime();
	*** getTimeOfDeath();
	*** getType();
	*** incrementFailures();
	*** isConnected();
	*** isNatTraversed();
	*** markConnected();
	*** needsConnectionTest();
	*** resetFailures();
	*** setTimeOfDeath(long);
}

-keep class org.lantern.ProxyService {
	*** proxyAllSites(boolean);
	*** refresh();
	*** startProxying(boolean,java.io.File);
	*** stopProxying();
}

-keep class org.lantern.ProxyService$$EnhancerByMockitoWithCGLIB$$fbfcf6a0 {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$clone$4$Method;
	*** CGLIB$clone$4$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$1$Method;
	*** CGLIB$equals$1$Proxy;
	*** CGLIB$finalize$0$Method;
	*** CGLIB$finalize$0$Proxy;
	*** CGLIB$hashCode$3$Method;
	*** CGLIB$hashCode$3$Proxy;
	*** CGLIB$proxyAllSites$6$Method;
	*** CGLIB$proxyAllSites$6$Proxy;
	*** CGLIB$proxyGoogle$8$Method;
	*** CGLIB$proxyGoogle$8$Proxy;
	*** CGLIB$refresh$9$Method;
	*** CGLIB$refresh$9$Proxy;
	*** CGLIB$startProxying$5$Method;
	*** CGLIB$startProxying$5$Proxy;
	*** CGLIB$stopProxying$7$Method;
	*** CGLIB$stopProxying$7$Proxy;
	*** CGLIB$toString$2$Method;
	*** CGLIB$toString$2$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK2();
}

-keep class org.lantern.ProxySocketFactory {
	*** RESPONSE_PATTERN;
	*** proxyTracker;
	*** socketsUtil;
	*** createSocket(java.lang.String,int);
	*** createSocket(java.lang.String,int,java.net.InetAddress,int);
	*** createSocket(java.net.InetAddress,int);
	*** createSocket(java.net.InetAddress,int,java.net.InetAddress,int);
	*** httpConnectSocket(java.lang.String,int);
}

-keep class org.lantern.ProxySocketFactoryTest {
	*** log;
}

-keep class org.lantern.ProxyTracker {
	*** addProxy(java.net.URI,java.net.InetSocketAddress);
	*** addressForConfiguredFallbackProxy();
	*** clearPeerProxySet();
	*** firstConnectedTcpProxyBlocking();
	*** getConnectedProxiesInOrderOfFallbackPreference();
	*** hasProxy();
	*** onCouldNotConnect(org.lantern.ProxyHolder);
	*** removeNattedProxy(java.net.URI);
}

-keep class org.lantern.ResourceBundleTest {
	*** log;
	*** convertPo(java.io.File,java.io.File);
}

-keep class org.lantern.ResourceBundleTest$1 {
	*** this$0;
}

-keep class org.lantern.Roster {
	*** $SWITCH_TABLE$org$lantern$state$Mode;
	*** censored;
	*** friendsHandler;
	*** kscopeRoutingTable;
	*** log;
	*** model;
	*** rosterEntries;
	*** smackRoster;
	*** xmppHandler;
	*** $SWITCH_TABLE$org$lantern$state$Mode();
	*** access$0(org.lantern.Roster);
	*** access$1(org.lantern.Roster,org.jivesoftware.smack.RosterEntry);
	*** access$2(org.lantern.Roster);
	*** access$3(org.lantern.Roster);
	*** access$4(org.lantern.Roster);
	*** access$5(org.lantern.Roster);
	*** addEntry(org.lantern.LanternRosterEntry,boolean);
	*** autoAcceptSubscription(java.lang.String);
	*** entriesAdded(java.util.Collection);
	*** entriesDeleted(java.util.Collection);
	*** entriesUpdated(java.util.Collection);
	*** fullRosterSync();
	*** getEntries();
	*** getEntry(java.lang.String);
	*** getRosterEntry(java.lang.String);
	*** onModeChangedEvent(org.lantern.event.ModeChangedEvent);
	*** onPresence(org.jivesoftware.smack.packet.Presence,boolean,boolean);
	*** onReset(org.lantern.event.ResetEvent);
	*** onRoster(org.lantern.XmppHandler);
	*** presenceChanged(org.jivesoftware.smack.packet.Presence);
	*** processPresence(org.jivesoftware.smack.packet.Presence,boolean,boolean);
	*** processRosterEntryPresences(org.jivesoftware.smack.RosterEntry);
	*** putNewElement(org.lantern.LanternRosterEntry,boolean);
	*** reset();
	*** sendKscope(java.lang.String);
	*** sendKscopeAdToAllPeers();
	*** setEntries(java.util.Map);
	*** updateIndex();
}

-keep class org.lantern.Roster$1 {
	*** this$0;
	*** val$ros;
}

-keep class org.lantern.RosterDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.lantern.RosterSerializer {
	*** serialize(org.lantern.Roster,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.lantern.RosterTest {
	*** path;
	*** buildEntry(int,java.lang.String,org.lantern.Roster,java.util.Map,java.util.SortedSet);
	*** makeMockRosterEntry(java.lang.String);
}

-keep class org.lantern.RoundTripTest {
	*** request;
	*** response;
}

-keep class org.lantern.SecurityUtils {
	*** constantTimeEquals(java.lang.String,java.lang.String);
}

-keep class org.lantern.SelectBrokenOnOSX$1 {
	*** val$serverSocket;
}

-keep class org.lantern.Shutdownable {
	*** stop();
}

-keep class org.lantern.SplashScreen {
	*** bar;
	*** closed;
	*** display;
	*** image;
	*** label;
	*** log;
	*** progress;
	*** splash;
	*** access$0(org.lantern.SplashScreen);
	*** access$1(org.lantern.SplashScreen);
	*** access$2(org.lantern.SplashScreen);
	*** access$3(org.lantern.SplashScreen);
	*** access$4(org.lantern.SplashScreen);
	*** access$5(org.lantern.SplashScreen,org.eclipse.swt.widgets.Shell);
	*** access$6(org.lantern.SplashScreen,org.eclipse.swt.graphics.Image);
	*** close();
}

-keep class org.lantern.SplashScreen$1 {
	*** this$0;
}

-keep class org.lantern.SplashScreen$2 {
	*** this$0;
}

-keep class org.lantern.Stats {
	*** getDownBytesPerSecond();
	*** getDownBytesThisRun();
	*** getUpBytesPerSecond();
	*** getUpBytesThisRun();
}

-keep class org.lantern.StatsTracker {
	*** countries;
	*** countryCode;
	*** countryService;
	*** directBytes;
	*** directRequests;
	*** distinctProxiedClientAddresses;
	*** downBytesPerSecondForPeers;
	*** downBytesPerSecondFromPeers;
	*** downBytesPerSecondViaProxies;
	*** log;
	*** lookupService;
	*** natpmp;
	*** proxiedRequests;
	*** totalBytesProxied;
	*** upBytesPerSecondForPeers;
	*** upBytesPerSecondToPeers;
	*** upBytesPerSecondViaProxies;
	*** upnp;
	*** addBytesProxied(long,java.net.InetSocketAddress);
	*** addDirectBytes(long);
	*** addDownBytesForPeers(long);
	*** addDownBytesFromPeers(long);
	*** addDownBytesViaProxies(long);
	*** addProxiedClientAddress(java.net.InetAddress);
	*** addUpBytesForPeers(long);
	*** addUpBytesToPeers(long);
	*** addUpBytesViaProxies(long);
	*** getBytesPerSecond(org.lantern.util.Counter);
	*** getCountOfDistinctProxiedClientAddresses();
	*** getCountryCode();
	*** getDirectBytes();
	*** getDirectRequests();
	*** getDownBytesPerSecond();
	*** getDownBytesPerSecondForPeers();
	*** getDownBytesPerSecondFromPeers();
	*** getDownBytesPerSecondViaProxies();
	*** getDownBytesThisRun();
	*** getDownBytesThisRunForPeers();
	*** getDownBytesThisRunFromPeers();
	*** getDownBytesThisRunViaProxies();
	*** getPeerCount();
	*** getPeerCountThisRun();
	*** getTotalBytesProxied();
	*** getTotalProxiedRequests();
	*** getUpBytesPerSecond();
	*** getUpBytesPerSecondForPeers();
	*** getUpBytesPerSecondToPeers();
	*** getUpBytesPerSecondViaProxies();
	*** getUpBytesThisRun();
	*** getUpBytesThisRunForPeers();
	*** getUpBytesThisRunToPeers();
	*** getUpBytesThisRunViaProxies();
	*** getUptime();
	*** getVersion();
	*** incrementDirectRequests();
	*** incrementProxiedRequests();
	*** isNatpmp();
	*** isUpnp();
	*** onLocationChanged(org.lantern.state.LocationChangedEvent);
	*** onReset(org.lantern.event.ResetEvent);
	*** resetCumulativeStats();
	*** resetUserStats();
	*** setNatpmp(boolean);
	*** setUpnp(boolean);
	*** toCountryData(java.net.InetSocketAddress);
}

-keep class org.lantern.StatsTracker$CountryData {
	*** addresses;
	*** bytes;
	*** data;
	*** lanternData;
	*** this$0;
	org.lantern.StatsTracker$CountryData(org.lantern.StatsTracker,org.lantern.Country);
	*** access$0(org.lantern.StatsTracker$CountryData);
	*** access$1(org.lantern.StatsTracker$CountryData,long);
	*** access$3(org.lantern.StatsTracker$CountryData);
}

-keep class org.lantern.StatsUpdater {
	*** httpClientFactory;
	*** log;
	*** model;
	*** run();
	*** updateModel(java.lang.Object,java.util.Map);
	*** updateStats();
}

-keep class org.lantern.SystemTray {
	*** addUpdate(java.util.Map);
	*** createTray();
	*** isActive();
	*** isSupported();
}

-keep class org.lantern.SystemTrayImpl {
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus;
	*** $SWITCH_TABLE$org$lantern$GoogleTalkState;
	*** LABEL_CONNECTED;
	*** LABEL_CONNECTING;
	*** LABEL_DISCONNECTED;
	*** active;
	*** browserService;
	*** connectionStatusItem;
	*** connectionStatusText;
	*** log;
	*** menu;
	*** model;
	*** shell;
	*** trayItem;
	*** trayItemImage;
	*** updateData;
	*** updateItem;
	*** $SWITCH_TABLE$org$lantern$ConnectivityStatus();
	*** $SWITCH_TABLE$org$lantern$GoogleTalkState();
	*** access$0(org.lantern.SystemTrayImpl);
	*** access$1(org.lantern.SystemTrayImpl);
	*** access$12(org.lantern.SystemTrayImpl,java.lang.String,int,int);
	*** access$13(org.lantern.SystemTrayImpl,org.eclipse.swt.graphics.Image);
	*** access$2(org.lantern.SystemTrayImpl);
	*** access$3(org.lantern.SystemTrayImpl);
	*** access$4(org.lantern.SystemTrayImpl,org.eclipse.swt.graphics.Image);
	*** access$5(org.lantern.SystemTrayImpl);
	*** access$6(org.lantern.SystemTrayImpl,java.lang.String);
	*** access$7(org.lantern.SystemTrayImpl);
	*** access$8(org.lantern.SystemTrayImpl,org.eclipse.swt.widgets.MenuItem);
	*** access$9(org.lantern.SystemTrayImpl);
	*** addUpdate(java.util.Map);
	*** changeIcon(java.lang.String);
	*** changeStatusLabel(java.lang.String);
	*** createTray();
	*** createTrayInternal();
	*** newImage(java.lang.String,int,int);
	*** onConnectivityStatus(org.lantern.ConnectivityStatus);
	*** setImage(org.eclipse.swt.graphics.Image);
	*** setStatusLabel(java.lang.String);
}

-keep class org.lantern.SystemTrayImpl$1 {
	*** this$0;
	*** val$display;
}

-keep class org.lantern.SystemTrayImpl$10 {
	*** this$0;
	*** val$data;
	*** access$0(org.lantern.SystemTrayImpl$10);
}

-keep class org.lantern.SystemTrayImpl$10$1 {
	*** this$1;
}

-keep class org.lantern.SystemTrayImpl$11 {
	*** this$0;
	*** val$fileName;
}

-keep class org.lantern.SystemTrayImpl$2 {
	*** this$0;
}

-keep class org.lantern.SystemTrayImpl$3 {
	*** this$0;
}

-keep class org.lantern.SystemTrayImpl$4 {
	*** this$0;
}

-keep class org.lantern.SystemTrayImpl$5 {
	*** this$0;
}

-keep class org.lantern.SystemTrayImpl$6 {
	*** this$0;
}

-keep class org.lantern.SystemTrayImpl$7 {
	*** this$0;
}

-keep class org.lantern.SystemTrayImpl$8 {
	*** this$0;
	*** val$image;
}

-keep class org.lantern.SystemTrayImpl$9 {
	*** this$0;
	*** val$status;
}

-keep class org.lantern.TestHttpServer {
	*** requests;
	*** running;
	*** socket;
	*** getRequests();
	*** stopServer();
}

-keep class org.lantern.TestUtils {
	*** LOG;
	*** countryService;
	*** encryptedFileService;
	*** geoIpLookupService;
	*** httpClientFactory;
	*** injector;
	*** jettyLauncher;
	*** ksm;
	*** lanternXmppUtil;
	*** loaded;
	*** localCipherProvider;
	*** messageService;
	*** model;
	*** modelIo;
	*** modelService;
	*** modelUtils;
	*** privateProps;
	*** privatePropsFile;
	*** proxifier;
	*** proxyTracker;
	*** roster;
	*** shutdownables;
	*** socketsUtil;
	*** started;
	*** statsTracker;
	*** trustStore;
	*** xmppHandler;
	*** addCloseHook(org.lantern.Shutdownable);
	*** getAccessToken();
	*** getCountryService();
	*** getEncryptedFileService();
	*** getGeoIpLookupService();
	*** getGoogleOauthCreds();
	*** getModel();
	*** getModelIo();
	*** getModelUtils();
	*** getProxifier();
	*** getRefreshToken();
	*** getRoster();
	*** getUserName();
	*** getXmppHandler();
	*** instance(java.lang.Class);
	*** load();
	*** load(boolean);
	*** newTestLanternModule();
	*** start(boolean);
	*** xmppConnection();
}

-keep class org.lantern.TestUtils$TestModelIo {
	*** file;
	*** write();
}

-keep class org.lantern.TestUtils$TestTransfersIo {
	*** file;
	*** write();
}

-keep class org.lantern.TestingUtils {
	*** privateProps;
	*** privatePropsFile;
	*** accessToken();
	*** getAccessToken();
	*** getRefreshToken();
	*** newCommandLine();
	*** newCommandLine(java.lang.String[]);
	*** newCountryService();
	*** newHttClientFactory();
	*** newKeyStoreManager();
	*** newModel();
	*** newOauthUtils();
	*** newProxyTracker();
	*** newXmppHandler();
	*** newXmppHandler(org.lantern.Censored,org.lantern.state.Model);
}

-keep class org.lantern.TestingUtils$1 {
	*** val$peerFactory;
	*** val$trustStore;
}

-keep class org.lantern.TokenResponseEvent {
	*** tokenResponse;
}

-keep class org.lantern.Tr {
	*** LOG;
	*** dir;
	*** en_us;
	*** prod;
	*** trans;
	*** reload();
	*** tr(java.lang.String);
	*** tr(org.lantern.MessageKey);
}

-keep class org.lantern.TrTest {
	*** originalLocale;
}

-keep class org.lantern.UdtSslTest {
	*** msg;
	*** readOnServer;
	*** accept(java.net.ServerSocket,org.lantern.LanternSocketsUtil);
	*** startServer(org.lantern.LanternSocketsUtil);
}

-keep class org.lantern.UdtSslTest$1 {
	*** this$0;
	*** val$server;
	*** val$util;
}

-keep class org.lantern.Upnp {
	*** log;
	*** mappings;
	*** publicIp;
	*** stats;
	*** addMapping(org.lastbamboo.common.portmapping.PortMappingProtocol,int,int,org.lastbamboo.common.portmapping.PortMapListener);
	*** addUpnpMapping(org.lastbamboo.common.portmapping.PortMappingProtocol,int,int,org.lastbamboo.common.portmapping.PortMapListener);
	*** getPublicIpAddress();
	*** logIGDResponse(int,fr.free.miniupnp.UPNPUrls);
	*** removeAllMappings();
	*** removeUpnpMappings(java.util.Collection);
	*** zeroTerminatedString(byte[]);
}

-keep class org.lantern.Upnp$1 {
	*** this$0;
	*** val$externalPortRequested;
	*** val$localPort;
	*** val$portMapListener;
	*** val$prot;
}

-keep class org.lantern.Upnp$UpnpMapping {
	*** externalPort;
	*** internalPort;
	*** prot;
}

-keep class org.lantern.UpnpTest {
	*** log;
	*** access$0(org.lantern.UpnpTest);
}

-keep class org.lantern.UpnpTest$1 {
	*** this$0;
	*** val$mapped;
}

-keep class org.lantern.Utf8ResourceBundle {
	*** createUtf8PropertyResourceBundle(java.util.ResourceBundle);
}

-keep class org.lantern.Utf8ResourceBundle$Utf8PropertyResourceBundle {
	*** bundle;
	org.lantern.Utf8ResourceBundle$Utf8PropertyResourceBundle(java.util.PropertyResourceBundle);
}

-keep class org.lantern.VersionNumber {
	*** components;
	*** compareTo(java.lang.Object);
	*** getComponentOrZero(int);
	*** toString();
}

-keep class org.lantern.VersionNumberDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.lantern.VersionNumberSerializer {
	*** serialize(org.lantern.VersionNumber,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.lantern.WebDriverException {
	*** createMessage(java.lang.String);
	*** getDriverInformation();
	*** getDriverName(java.lang.StackTraceElement[]);
	*** getSupportUrl();
	*** getSystemInformation();
}

-keep class org.lantern.Whitelist {
	*** SITES;
	*** defaultWhitelist;
	*** log;
	*** whitelist;
	*** addDefaultEntry(java.lang.String);
	*** addEntry(java.lang.String);
	*** getEntries();
	*** getEntriesAsStrings();
	*** isWhitelisted(java.lang.String);
	*** isWhitelisted(java.lang.String,java.util.Collection);
	*** normalized(java.lang.String);
	*** removeEntry(java.lang.String);
	*** reset();
	*** setEntries(java.util.Collection);
	*** setStringEntries(java.lang.String[]);
	*** toBaseUri(java.lang.String);
	*** toEntries(java.lang.String[]);
}

-keep class org.lantern.WhitelistEntry {
	*** defaultSetting;
	*** site;
	org.lantern.WhitelistEntry(java.lang.String,boolean);
	*** compareTo(org.lantern.WhitelistEntry);
	*** getSite();
}

-keep class org.lantern.WhitelistTest {
	*** newModelIo();
	*** testFile(java.lang.String);
}

-keep class org.lantern.XmppHandler {
	*** connect();
	*** disconnect();
	*** getJid();
	*** getMappedServer();
	*** getP2PClient();
	*** isLoggedIn();
	*** sendInvite(org.lantern.state.Friend,boolean,boolean);
	*** sendPacket(org.jivesoftware.smack.packet.Packet);
	*** start();
	*** stop();
	*** subscribe(java.lang.String);
	*** subscribed(java.lang.String);
	*** unsubscribe(java.lang.String);
	*** unsubscribed(java.lang.String);
}

-keep class org.lantern.endpoints.FriendApi {
	*** BASE;
	*** log;
	*** mapper;
	*** oauth;
	*** getFriend(long);
	*** insertFriend(org.lantern.state.ClientFriend);
	*** listFriends();
	*** post(java.lang.String,org.lantern.state.Friend);
	*** removeFriend(long);
	*** updateFriend(org.lantern.state.ClientFriend);
}

-keep class org.lantern.endpoints.FriendEndpointTest {
	*** log;
}

-keep class org.lantern.event.ClosedBetaEvent {
	*** inClosedBeta;
	*** to;
	*** getTo();
	*** isInClosedBeta();
}

-keep class org.lantern.event.Events {
	*** LOG;
	*** asyncEventBus;
	*** eventBus;
	*** inOrderAsyncEventBus;
	*** asyncEventBus();
	*** eventBus();
	*** inOrderAsyncEventBus();
	*** register(java.lang.Object);
	*** sync(org.lantern.state.SyncPath,java.lang.Object);
	*** syncConnectingStatus(java.lang.String);
	*** syncModal(org.lantern.state.Model);
	*** syncModal(org.lantern.state.Model,org.lantern.state.Modal);
	*** syncModel(org.lantern.state.Model);
	*** syncRoster(org.lantern.Roster);
	*** syncRosterEntry(org.lantern.LanternRosterEntry,int);
}

-keep class org.lantern.event.FriendStatusChangedEvent {
	*** friend;
	*** getFriend();
}

-keep class org.lantern.event.GoogleTalkStateEvent {
	*** jid;
	*** state;
	*** getJid();
	*** getState();
}

-keep class org.lantern.event.KscopeAdEvent {
	*** ad;
	*** getAd();
}

-keep class org.lantern.event.MessageEvent {
	*** msg;
	*** title;
	*** type;
	*** getMsg();
	*** getTitle();
	*** getType();
}

-keep class org.lantern.event.ModeChangedEvent {
	*** newMode;
	*** getNewMode();
}

-keep class org.lantern.event.PeerCertEvent {
	*** cert;
	*** jid;
	*** getCert();
	*** getJid();
}

-keep class org.lantern.event.PresenceEvent {
	*** jid;
	*** presence;
	org.lantern.event.PresenceEvent(java.lang.String,org.jivesoftware.smack.packet.Presence);
}

-keep class org.lantern.event.ProxyConnectionEvent {
	*** connectivityStatus;
	*** getConnectivityStatus();
}

-keep class org.lantern.event.RefreshTokenEvent {
	*** refreshToken;
	*** getRefreshToken();
}

-keep class org.lantern.event.SyncEvent {
	*** op;
	*** path;
	*** value;
	org.lantern.event.SyncEvent(org.lantern.event.SyncType,java.lang.String,java.lang.Object);
	*** getOp();
	*** getPath();
	*** getValue();
}

-keep class org.lantern.event.SyncType {
	*** ADD;
	*** DELETE;
	*** ENUM$VALUES;
	*** REPLACE;
}

-keep class org.lantern.event.SystemProxyChangedEvent {
	*** systemProxy;
	*** isSystemProxy();
}

-keep class org.lantern.event.UpdateEvent {
	*** data;
	org.lantern.event.UpdateEvent(java.util.Map);
	*** getData();
}

-keep class org.lantern.event.UpdatePresenceEvent {
	*** presence;
	*** getPresence();
}

-keep class org.lantern.exceptional4j.ExceptionalAppender {
	*** addSanitizer(org.lantern.exceptional4j.Sanitizer);
}

-keep class org.lantern.geoip.GeoIpCompressor {
	*** $assertionsDisabled;
	*** LOG;
	*** countryIdToCountry;
	*** countryToCountryId;
	*** ipRangeList;
	*** locIdToPixelId;
	*** pixelIdList;
	*** pixelIdToCountry;
	*** pixelIdToQuantizedLatLon;
	*** quantizedLocationToPixelId;
	*** rangeCounts;
	*** compress(java.io.File,java.io.File);
	*** compressInternal(java.io.File,java.io.File);
	*** decompress(java.io.File,java.io.File);
	*** decompressInternal(java.io.File,java.io.File);
	*** getLatFromQuantized(int);
	*** getLonFromQuantized(int);
	*** normalizeCountry(java.lang.String);
	*** quantizedLatLon(double,double);
	*** readBlocks(java.io.File);
	*** readCompressedBlocks(java.io.InputStream);
	*** readCompressedData(java.io.InputStream);
	*** readCompressedLocations(java.io.InputStream);
	*** readLocations(java.io.File);
	*** writeCompressedBlocks(org.apache.commons.io.output.CountingOutputStream);
	*** writeCompressedLocations(org.apache.commons.io.output.CountingOutputStream);
	*** writeDecompressedBlocks(java.io.File);
	*** writeDecompressedLocations(java.io.File);
}

-keep class org.lantern.geoip.GeoIpCompressorRunner {
	*** parseArgs(java.lang.String[]);
}

-keep class org.lantern.geoip.GeoIpCompressorRunner$Args {
	*** compress;
	*** compressed;
	*** dir;
	org.lantern.geoip.GeoIpCompressorRunner$Args();
}

-keep class org.lantern.geoip.GeoIpCompressorTest {
	*** readBlocksCSV(java.io.File);
	*** readLocationCSV(java.io.File);
}

-keep class org.lantern.geoip.GeoIpCompressorTest$Block {
	*** endIp;
	*** pixelId;
	*** startIp;
	org.lantern.geoip.GeoIpCompressorTest$Block();
}

-keep class org.lantern.geoip.GeoIpCompressorTest$Location {
	*** country;
	*** latitude;
	*** longitude;
	org.lantern.geoip.GeoIpCompressorTest$Location();
}

-keep class org.lantern.geoip.GeoIpLookupService {
	*** LOG;
	*** dataLoaded;
	*** geoDataByIpRange;
	*** lowerRanges;
	*** upperRanges;
	org.lantern.geoip.GeoIpLookupService(boolean);
	*** access$0(org.lantern.geoip.GeoIpLookupService);
	*** getGeoData(byte[]);
	*** getGeoData(java.lang.String);
	*** getGeoData(java.net.InetAddress);
	*** loadData();
	*** loadDataInternal();
	*** threadLoadData();
}

-keep class org.lantern.geoip.GeoIpLookupService$1 {
	*** this$0;
}

-keep class org.lantern.geoip.Order1Model {
	*** categoriesForItems;
	*** frequency;
	*** frequencyByCategory;
	*** noOfSymbols;
	*** previous;
}

-keep class org.lantern.http.GeoIp {
	*** connected;
	*** geoIpLookupService;
	*** model;
}

-keep class org.lantern.http.GoogleOauth2CallbackServer {
	*** httpClientFactory;
	*** internalState;
	*** log;
	*** model;
	*** modelIo;
	*** modelUtils;
	*** msgs;
	*** port;
	*** proxifier;
	*** server;
	*** xmppHandler;
	*** access$0(org.lantern.http.GoogleOauth2CallbackServer);
	*** access$1(org.lantern.http.GoogleOauth2CallbackServer);
	*** newContext(java.lang.String,java.lang.String);
	*** start();
	*** stop();
}

-keep class org.lantern.http.GoogleOauth2CallbackServer$1 {
	*** this$0;
}

-keep class org.lantern.http.GoogleOauth2CallbackServlet {
	*** googleOauth2CallbackServer;
	*** httpClientFactory;
	*** internalState;
	*** log;
	*** model;
	*** modelIo;
	*** modelUtils;
	*** msgs;
	*** proxifier;
	*** xmppHandler;
	*** access$0(org.lantern.http.GoogleOauth2CallbackServlet);
	*** access$1(org.lantern.http.GoogleOauth2CallbackServlet);
	*** access$2(org.lantern.http.GoogleOauth2CallbackServlet);
	*** access$3(org.lantern.http.GoogleOauth2CallbackServlet);
	*** connectToGoogleTalk(java.util.Map);
	*** fetchEmail(java.util.Map,org.apache.http.client.HttpClient);
	*** loadAllToks(java.lang.String,org.apache.http.client.HttpClient);
	*** processRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
	*** redirectToDashboard(javax.servlet.http.HttpServletResponse);
}

-keep class org.lantern.http.GoogleOauth2CallbackServlet$1 {
	*** this$0;
}

-keep class org.lantern.http.GoogleOauth2RedirectServlet {
	*** censored;
	*** handler;
	*** httpClientFactory;
	*** internalState;
	*** log;
	*** model;
	*** modelIo;
	*** modelUtils;
	*** msgs;
	*** proxifier;
	*** newGtalkOauthUrl();
	*** processRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class org.lantern.http.HttpUtils {
	*** LOG;
	*** getRequestHeaders(javax.servlet.http.HttpServletRequest);
	*** sendClientError(javax.servlet.http.HttpServletResponse,java.lang.String);
	*** sendError(javax.servlet.http.HttpServletResponse,int,java.lang.String);
	*** toHeaderMap(javax.servlet.http.HttpServletRequest);
	*** toParamMap(javax.servlet.ServletRequest);
}

-keep class org.lantern.http.InteractionServlet {
	*** $SWITCH_TABLE$org$lantern$http$InteractionServlet$Interaction;
	*** $SWITCH_TABLE$org$lantern$state$Modal;
	*** censored;
	*** friender;
	*** internalState;
	*** lanternFeedback;
	*** log;
	*** model;
	*** modelIo;
	*** modelService;
	*** msgs;
	*** switchModals;
	*** $SWITCH_TABLE$org$lantern$http$InteractionServlet$Interaction();
	*** $SWITCH_TABLE$org$lantern$state$Modal();
	*** applyJson(java.lang.String);
	*** backupSettings();
	*** email(java.lang.String);
	*** handleClose(java.lang.String);
	*** handleException(java.lang.String);
	*** handleExceptionalInteractions(org.lantern.state.Modal,org.lantern.http.InteractionServlet$Interaction,java.lang.String);
	*** handleReset();
	*** handleSetModeWelcome(org.lantern.state.Mode);
	*** jsonToMap(java.lang.String);
	*** onConnectivityChanged(org.lantern.ConnectivityChangedEvent);
	*** onLocationChanged(org.lantern.state.LocationChangedEvent);
	*** processRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse);
}

-keep class org.lantern.http.InteractionServlet$Interaction {
	*** ABOUT;
	*** ACCEPT;
	*** CANCEL;
	*** CLOSE;
	*** CONTACT;
	*** CONTINUE;
	*** ENUM$VALUES;
	*** EXCEPTION;
	*** FRIEND;
	*** GET;
	*** GIVE;
	*** LANTERNFRIENDS;
	*** PROXIEDSITES;
	*** REJECT;
	*** REQUESTINVITE;
	*** RESET;
	*** RETRY;
	*** SET;
	*** SETTINGS;
	*** SPONSOR;
	*** UNEXPECTEDSTATEREFRESH;
	*** UNEXPECTEDSTATERESET;
	*** URL;
	*** valueOf(java.lang.String);
	*** values();
}

-keep class org.lantern.http.JettyLauncher {
	*** interactionServlet;
	*** log;
	*** model;
	*** photoServlet;
	*** redirectServlet;
	*** server;
	*** syncer;
	*** access$0(org.lantern.http.JettyLauncher);
	*** access$1(org.lantern.http.JettyLauncher,javax.servlet.http.HttpServletResponse,java.io.File);
	*** access$2(org.lantern.http.JettyLauncher);
	*** access$3(org.lantern.http.JettyLauncher);
	*** access$4(org.lantern.http.JettyLauncher,int,java.lang.String);
	*** apiPath();
	*** newContext(java.lang.String,java.lang.String);
	*** recordApiLocation(int,java.lang.String);
	*** start();
	*** start(int);
	*** stop();
	*** writeFileToResponse(javax.servlet.http.HttpServletResponse,java.io.File);
}

-keep class org.lantern.http.JettyLauncher$1 {
	*** this$0;
}

-keep class org.lantern.http.JettyLauncher$2 {
	*** this$0;
	*** val$port;
	*** val$prefix;
}

-keep class org.lantern.http.PhotoServlet {
	*** CONNECTION_LOCK;
	*** cache;
	*** conn;
	*** log;
	*** modelUtils;
	*** noImage;
	*** establishConnection();
	*** getVCard(java.lang.String);
	*** loadNoImage();
	*** sendError(javax.servlet.http.HttpServletResponse,int,java.lang.String);
}

-keep class org.lantern.kscope.DefaultKscopeAdHandler {
	*** log;
	*** networkTracker;
	*** proxyTracker;
	*** routingTable;
	*** trustStore;
	*** xmppHandler;
	*** addProxy(org.lantern.network.InstanceInfo);
	*** handleAd(java.lang.String,org.lantern.kscope.LanternKscopeAdvertisement);
	*** instanceOfflineOrUntrusted(org.lantern.network.InstanceInfo);
	*** instanceOnlineAndTrusted(org.lantern.network.InstanceInfo);
	*** onBase64Cert(java.net.URI,java.lang.String);
	*** relayKScopeAd(org.lantern.network.InstanceInfo);
}

-keep class org.lantern.kscope.KscopeAdHandler {
	*** handleAd(java.lang.String,org.lantern.kscope.LanternKscopeAdvertisement);
	*** onBase64Cert(java.net.URI,java.lang.String);
}

-keep class org.lantern.kscope.LanternKscopeAdvertisement {
	*** address;
	*** jid;
	*** lanternVersion;
	*** localAddress;
	*** localPort;
	*** port;
	*** ttl;
	*** version;
	org.lantern.kscope.LanternKscopeAdvertisement(java.lang.String,java.lang.String,int,java.lang.String,int,boolean);
	*** getAddress();
	*** getJid();
	*** getLanternVersion();
	*** getLocalAddress();
	*** getLocalPort();
	*** getPort();
	*** getTtl();
	*** hasMappedEndpoint();
	*** makeRelayAd(org.lantern.kscope.LanternKscopeAdvertisement);
	*** setTtl(int);
}

-keep class org.lantern.kscope.LanternTrustGraphNode {
	*** handler;
	*** log;
}

-keep class org.lantern.kscope.ReceivedKScopeAd {
	*** ad;
	*** from;
	*** getAd();
	*** getFrom();
}

-keep class org.lantern.linux.AppIndicator {
	*** app_indicator_new(java.lang.String,java.lang.String,int);
	*** app_indicator_set_icon_full(org.lantern.linux.AppIndicator$AppIndicatorInstanceStruct,java.lang.String,java.lang.String);
	*** app_indicator_set_menu(org.lantern.linux.AppIndicator$AppIndicatorInstanceStruct,com.sun.jna.Pointer);
	*** app_indicator_set_status(org.lantern.linux.AppIndicator$AppIndicatorInstanceStruct,int);
}

-keep class org.lantern.linux.AppIndicator$AppIndicatorClassStruct {
	*** fallback;
	org.lantern.linux.AppIndicator$AppIndicatorClassStruct();
}

-keep class org.lantern.linux.AppIndicator$AppIndicatorClassStruct$ByReference {
	*** this$1;
}

-keep class org.lantern.linux.AppIndicator$AppIndicatorInstanceStruct {
	*** parent;
}

-keep class org.lantern.linux.Gobject {
	*** g_signal_connect_data(com.sun.jna.Pointer,java.lang.String,org.lantern.linux.Gobject$GCallback,com.sun.jna.Pointer,com.sun.jna.Pointer,int);
}

-keep class org.lantern.linux.Gobject$GObjectClassStruct {
	org.lantern.linux.Gobject$GObjectClassStruct();
}

-keep class org.lantern.linux.Gobject$GObjectClassStruct$ByReference {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GObjectClassStruct$ByValue {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GObjectStruct {
	*** g_type_instance;
	org.lantern.linux.Gobject$GObjectStruct();
}

-keep class org.lantern.linux.Gobject$GObjectStruct$ByReference {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GObjectStruct$ByValue {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GTypeClassStruct {
	org.lantern.linux.Gobject$GTypeClassStruct();
}

-keep class org.lantern.linux.Gobject$GTypeClassStruct$ByReference {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GTypeClassStruct$ByValue {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GTypeInstanceStruct {
	*** g_class;
	org.lantern.linux.Gobject$GTypeInstanceStruct();
}

-keep class org.lantern.linux.Gobject$GTypeInstanceStruct$ByReference {
	*** this$1;
}

-keep class org.lantern.linux.Gobject$GTypeInstanceStruct$ByValue {
	*** this$1;
}

-keep class org.lantern.linux.Gtk {
	*** gtk_menu_item_new_with_label(java.lang.String);
	*** gtk_menu_item_set_label(com.sun.jna.Pointer,java.lang.String);
	*** gtk_menu_new();
	*** gtk_menu_shell_append(com.sun.jna.Pointer,com.sun.jna.Pointer);
	*** gtk_widget_set_sensitive(com.sun.jna.Pointer,int);
	*** gtk_widget_show_all(com.sun.jna.Pointer);
}

-keep class org.lantern.monitoring.StatsReporter {
	*** LOG;
	*** memoryMXBean;
	*** metrics;
	*** model;
	*** osStats;
	*** stats;
	*** access$0(org.lantern.monitoring.StatsReporter,java.lang.String);
	*** access$1(org.lantern.monitoring.StatsReporter);
	*** access$2(org.lantern.monitoring.StatsReporter);
	*** access$3(org.lantern.monitoring.StatsReporter);
	*** access$4();
	*** getSystemStat(java.lang.String);
	*** initializeLanternMetrics();
	*** initializeSystemMetrics();
	*** isOnUnix();
	*** start();
	*** startReportingMetricsToLibrato();
	*** stop();
}

-keep class org.lantern.monitoring.StatsReporter$1 {
	*** this$0;
	*** getValue();
}

-keep class org.lantern.monitoring.StatsReporter$2 {
	*** this$0;
	*** getValue();
}

-keep class org.lantern.monitoring.StatsReporter$3 {
	*** this$0;
	*** getValue();
}

-keep class org.lantern.monitoring.StatsReporter$4 {
	*** this$0;
	*** getValue();
}

-keep class org.lantern.monitoring.StatsReporter$5 {
	*** this$0;
	*** getValue();
}

-keep class org.lantern.monitoring.StatsReporter$6 {
	*** this$0;
	*** getValue();
}

-keep class org.lantern.monitoring.StatsReporter$7 {
	*** this$0;
	*** val$getter;
	*** val$name;
	*** getValue();
}

-keep class org.lantern.network.InstanceInfo {
	*** addressOnInternet;
	*** addressOnLan;
	*** data;
	*** id;
	org.lantern.network.InstanceInfo(java.lang.Object,java.net.InetSocketAddress,java.net.InetSocketAddress,java.lang.Object);
	*** getAddressOnInternet();
	*** getAddressOnLan();
	*** getData();
	*** getId();
	*** hasMappedEndpoint();
}

-keep class org.lantern.network.NetworkTracker {
	*** LOG;
	*** listeners;
	*** onlineInstancesByAdvertisingUser;
	*** trustedCertificatesByInstance;
	*** trustedOnlineInstances;
	*** trustedUsers;
	*** addListener(org.lantern.network.NetworkTrackerListener);
	*** certificateTrusted(java.lang.Object,java.security.cert.Certificate);
	*** getTrustedOnlineInstances();
	*** identifyTrustedOnlineInstances();
	*** instanceOffline(java.lang.Object,java.lang.Object);
	*** instanceOnline(java.lang.Object,java.lang.Object,org.lantern.network.InstanceInfo);
	*** notifyListenersAboutInstances(java.util.Set);
	*** onReset(org.lantern.event.ResetEvent);
	*** reevaluateTrustedOnlineInstances();
	*** userTrusted(java.lang.Object);
	*** userUntrusted(java.lang.Object);
}

-keep class org.lantern.network.NetworkTrackerListener {
	*** instanceOfflineOrUntrusted(org.lantern.network.InstanceInfo);
	*** instanceOnlineAndTrusted(org.lantern.network.InstanceInfo);
}

-keep class org.lantern.network.NetworkTrackerTest$1 {
	*** this$0;
	*** val$instancesTrustedByListener;
}

-keep class org.lantern.oauth.LanternGoogleOAuth2Credentials {
	*** accessToken;
	*** clientID;
	*** clientSecret;
	*** log;
	*** refreshToken;
	*** resource;
	*** username;
}

-keep class org.lantern.oauth.LanternSaslGoogleOAuth2Mechanism {
	*** config;
	*** log;
	*** oauthUtils;
	*** authenticate(java.lang.String,java.lang.String,javax.security.auth.callback.CallbackHandler);
	*** setOauthUtils(org.lantern.oauth.OauthUtils);
}

-keep class org.lantern.oauth.LanternSaslGoogleOAuth2Mechanism$1 {
	*** this$0;
	*** val$authenticationText;
}

-keep class org.lantern.oauth.OauthUtils {
	*** LOG;
	*** httpClientFactory;
	*** lastResponse;
	*** model;
	*** modelIo;
	*** nextExpiryTime;
	*** refreshToken;
	*** secrets;
	org.lantern.oauth.OauthUtils(org.lantern.util.HttpClientFactory,org.lantern.state.Model,org.lantern.oauth.RefreshToken);
	org.lantern.oauth.OauthUtils(org.lantern.util.HttpClientFactory,org.lantern.state.Model,org.lantern.oauth.RefreshToken,org.lantern.state.ModelIo);
	*** access$0();
	*** access$1(org.lantern.oauth.OauthUtils);
	*** access$2(org.lantern.oauth.OauthUtils);
	*** access$3(org.lantern.oauth.OauthUtils,org.apache.http.client.HttpClient,org.apache.http.client.methods.HttpRequestBase);
	*** accessToken(org.apache.http.client.HttpClient);
	*** configureOauth(org.apache.http.client.HttpClient,org.apache.http.client.methods.HttpRequestBase);
	*** deleteRequest(java.lang.String);
	*** getRequest(java.lang.String);
	*** googleOauth(java.lang.String,java.lang.String,java.lang.String);
	*** httpRequest(org.apache.http.client.HttpClient,org.apache.http.client.methods.HttpRequestBase);
	*** httpRequest(org.apache.http.client.methods.HttpRequestBase);
	*** loadClientSecrets();
	*** oauthTokens();
	*** oauthTokens(org.apache.http.client.HttpClient,java.lang.String);
	*** postRequest(java.lang.String,java.lang.String);
}

-keep class org.lantern.oauth.OauthUtils$1 {
	*** this$0;
	*** call(org.apache.http.client.HttpClient,java.lang.String);
}

-keep class org.lantern.oauth.OauthUtils$2 {
	*** this$0;
	*** val$request;
	*** call(org.apache.http.client.HttpClient,java.lang.String);
}

-keep class org.lantern.oauth.OauthUtils$HttpFallbackFunc {
	*** this$0;
	org.lantern.oauth.OauthUtils$HttpFallbackFunc(org.lantern.oauth.OauthUtils);
	org.lantern.oauth.OauthUtils$HttpFallbackFunc(org.lantern.oauth.OauthUtils,org.lantern.oauth.OauthUtils$HttpFallbackFunc);
	*** call(org.apache.http.client.HttpClient,java.lang.String);
	*** execute();
}

-keep class org.lantern.oauth.RefreshToken {
	*** log;
	*** model;
	*** tok;
	*** onRefreshToken(org.lantern.event.RefreshTokenEvent);
	*** refreshToken();
}

-keep class org.lantern.pginstrument.PGInstrumenter {
	*** access$100(org.lantern.pginstrument.PGInstrumenter);
}

-keep class org.lantern.pginstrument.PGInstrumenter$2 {
	*** val$inst;
	*** val$instrumenter;
}

-keep class org.lantern.privacy.AbstractAESLocalCipherProvider {
	*** log;
	*** secureRandom;
	org.lantern.privacy.AbstractAESLocalCipherProvider();
	org.lantern.privacy.AbstractAESLocalCipherProvider(java.io.File,java.io.File);
	*** feedUserInput(char[],boolean);
	*** getAlgorithm();
	*** getKeyLength();
	*** isInitialized();
	*** loadKeyData();
	*** newLocalCipher(int);
	*** requiresAdditionalUserInput();
	*** reset();
	*** storeKeyData(byte[]);
}

-keep class org.lantern.privacy.AbstractLocalCipherProvider {
	*** DEFAULT_CIPHER_PARAMS_FILE;
	*** DEFAULT_VALIDATOR_FILE;
	*** localKey;
	*** log;
	*** paramsFile;
	*** secureRandom;
	*** validatorFile;
	org.lantern.privacy.AbstractLocalCipherProvider();
	org.lantern.privacy.AbstractLocalCipherProvider(java.io.File,java.io.File);
	*** checkKeyValid(byte[],byte[]);
	*** createValidator(byte[]);
	*** createValidator(byte[],byte[]);
	*** feedLocalKey(java.security.Key);
	*** feedUserInput(char[],boolean);
	*** getAlgorithm();
	*** getCipher();
	*** getLocalKey(boolean);
	*** hasLocalKey();
	*** initializeCipher(javax.crypto.Cipher,int,java.security.Key);
	*** isInitialized();
	*** loadParameters();
	*** loadValidator();
	*** newLocalCipher(int);
	*** requiresAdditionalUserInput();
	*** reset();
	*** saveParameters(javax.crypto.Cipher);
	*** storeValidator(byte[]);
	*** zeroFill(byte[]);
}

-keep class org.lantern.privacy.DefaultEncryptedFileService {
	*** localCipherProvider;
	*** log;
	*** checkFile(java.io.File);
	*** localDecryptInputStream(java.io.File);
	*** localDecryptInputStream(java.io.InputStream);
	*** localEncryptOutputStream(java.io.File);
	*** localEncryptOutputStream(java.io.OutputStream);
}

-keep class org.lantern.privacy.DefaultLocalCipherProvider {
	*** log;
	*** secureRandom;
	*** getAlgorithm();
	*** reset();
}

-keep class org.lantern.privacy.EncryptedFileService {
	*** localDecryptInputStream(java.io.File);
	*** localEncryptOutputStream(java.io.File);
}

-keep class org.lantern.privacy.LocalCipherProvider {
	*** feedUserInput(char[],boolean);
	*** isInitialized();
	*** newLocalCipher(int);
	*** requiresAdditionalUserInput();
}

-keep class org.lantern.privacy.LocalCipherProvider$$EnhancerByMockitoWithCGLIB$$f65d86a6 {
	*** CGLIB$BOUND;
	*** CGLIB$CALLBACK_0;
	*** CGLIB$CALLBACK_1;
	*** CGLIB$STATIC_CALLBACKS;
	*** CGLIB$THREAD_CALLBACKS;
	*** CGLIB$clone$4$Method;
	*** CGLIB$clone$4$Proxy;
	*** CGLIB$emptyArgs;
	*** CGLIB$equals$1$Method;
	*** CGLIB$equals$1$Proxy;
	*** CGLIB$feedUserInput$8$Method;
	*** CGLIB$feedUserInput$8$Proxy;
	*** CGLIB$finalize$0$Method;
	*** CGLIB$finalize$0$Proxy;
	*** CGLIB$hashCode$3$Method;
	*** CGLIB$hashCode$3$Proxy;
	*** CGLIB$isInitialized$7$Method;
	*** CGLIB$isInitialized$7$Proxy;
	*** CGLIB$newLocalCipher$9$Method;
	*** CGLIB$newLocalCipher$9$Proxy;
	*** CGLIB$requiresAdditionalUserInput$6$Method;
	*** CGLIB$requiresAdditionalUserInput$6$Proxy;
	*** CGLIB$reset$5$Method;
	*** CGLIB$reset$5$Proxy;
	*** CGLIB$toString$2$Method;
	*** CGLIB$toString$2$Proxy;
	*** CGLIB$BIND_CALLBACKS(java.lang.Object);
	*** CGLIB$SET_THREAD_CALLBACKS(org.mockito.cglib.proxy.Callback[]);
	*** CGLIB$STATICHOOK1();
}

-keep class org.lantern.privacy.MacLocalCipherProvider {
	*** log;
}

-keep class org.lantern.privacy.SecretServiceLocalCipherProvider {
	*** LOG;
	*** closeConnection(org.freedesktop.dbus.DBusConnection);
	*** prompt(org.freedesktop.dbus.Path,org.freedesktop.dbus.DBusConnection);
	*** secretServiceAvailable();
	*** unlockPath(org.freedesktop.dbus.Path,org.freedesktop.Secret.Service,org.freedesktop.dbus.DBusConnection);
}

-keep class org.lantern.privacy.SecretServiceLocalCipherProvider$PromptHandler {
	*** gotResult;
	*** lock;
	*** sig;
	*** this$0;
	*** await();
}

-keep class org.lantern.privacy.WindowsLocalCipherProvider {
	*** DEFAULT_KEY_FILE;
	*** DPAPI_INITIALIZED;
	*** keyFile;
	*** log;
	org.lantern.privacy.WindowsLocalCipherProvider(java.io.File,java.io.File,java.io.File);
	*** initDPAPI();
}

-keep class org.lantern.proxy.AbstractHttpProxyServerAdapter {
	*** bootstrap;
	*** server;
	org.lantern.proxy.AbstractHttpProxyServerAdapter(org.littleshoot.proxy.HttpProxyServerBootstrap);
	*** getServer();
	*** start();
	*** stop();
}

-keep class org.lantern.proxy.CertTrackingSslEngineSource {
	*** LOG;
	*** keyStoreManager;
	*** serverContext;
	*** trustStore;
	*** access$0(org.lantern.proxy.CertTrackingSslEngineSource);
	*** buildFallbackServerContext(org.lantern.proxy.CertTrackingSslEngineSource$CertTrackingTrustManager);
	*** configureCipherSuites(javax.net.ssl.SSLEngine);
	*** fallbackSslEngine(org.lantern.proxy.CertTrackingSslEngineSource$CertTrackingTrustManager);
	*** newSslEngine();
	*** standardSslEngine(org.lantern.proxy.CertTrackingSslEngineSource$CertTrackingTrustManager);
}

-keep class org.lantern.proxy.CertTrackingSslEngineSource$CertTrackingTrustManager {
	*** log;
	*** this$0;
	org.lantern.proxy.CertTrackingSslEngineSource$CertTrackingTrustManager(org.lantern.proxy.CertTrackingSslEngineSource);
}

-keep class org.lantern.proxy.DispatchingChainedProxyManager {
	*** LOG;
	*** proxyTracker;
	*** logFallbackOrder(java.util.Collection);
	*** lookupChainedProxies(io.netty.handler.codec.http.HttpRequest,java.util.Queue);
}

-keep class org.lantern.proxy.GetModeProxy$1 {
	*** val$stats;
	*** proxyFor(org.littleshoot.proxy.FullFlowContext);
}

-keep class org.lantern.proxy.GiveModeHttpFilters {
	*** LOG;
	*** forbidden();
}

-keep class org.lantern.proxy.GiveModeProxy {
	*** log;
}

-keep class org.lantern.proxy.GiveModeProxy$2 {
	*** val$peerFactory;
	*** val$stats;
	*** peerFor(javax.net.ssl.SSLSession);
	*** peerFor(org.littleshoot.proxy.FlowContext);
}

-keep class org.lantern.proxy.UdtServerFiveTupleListener {
	*** giveModeProxy;
	*** log;
	*** model;
	*** onOfferAnswerFailed(org.lastbamboo.common.offer.answer.OfferAnswer);
	*** onTcpSocket(java.net.Socket);
	*** onUdpSocket(java.lang.Object);
	*** onUdpSocket(org.littleshoot.util.FiveTuple);
}

-keep class org.lantern.state.ClientFriend {
	*** email;
	*** id;
	*** lastUpdated;
	*** loggedIn;
	*** mode;
	*** name;
	*** nextQuery;
	*** pendingSubscriptionRequest;
	*** status;
	*** userEmail;
	*** getEmail();
	*** getId();
	*** getName();
	*** getStatus();
	*** setEmail(java.lang.String);
	*** setLoggedIn(boolean);
	*** setMode(org.jivesoftware.smack.packet.Presence$Mode);
	*** setName(java.lang.String);
	*** setNextQuery(long);
	*** setPendingSubscriptionRequest(boolean);
	*** setStatus(org.lantern.state.Friend$Status);
	*** shouldNotifyAgain();
}

-keep class org.lantern.state.ClientFriends {
	*** items;
	*** url;
	*** getItems();
}

-keep class org.lantern.state.CometDSyncStrategy {
	*** exec;
	*** log;
	*** access$0(org.lantern.state.CometDSyncStrategy);
	*** sync(org.cometd.bayeux.server.ServerSession,org.lantern.event.SyncType,java.lang.String,java.lang.Object);
}

-keep class org.lantern.state.CometDSyncStrategy$1 {
	*** this$0;
}

-keep class org.lantern.state.CometDSyncStrategy$2 {
	*** this$0;
	*** val$ch;
	*** val$ops;
}

-keep class org.lantern.state.CometDSyncStrategy$SyncData {
	*** op;
	*** path;
	*** value;
	org.lantern.state.CometDSyncStrategy$SyncData(java.lang.String,java.lang.String,java.lang.Object);
}

-keep class org.lantern.state.Connectivity {
	*** connectingStatus;
	*** gtalk;
	*** gtalkAuthorized;
	*** internet;
	*** invited;
	*** ip;
	*** lanternController;
	*** lastConnectedLong;
	*** log;
	*** nProxies;
	*** pacUrl;
	*** peerId;
	*** type;
	*** getIp();
	*** getLanternController();
	*** isGtalkAuthorized();
	*** isInternet();
	*** isInvited();
	*** setConnectingStatus(java.lang.String);
	*** setGtalkAuthorized(boolean);
	*** setInternet(java.lang.Boolean);
	*** setInvited(boolean);
	*** setIp(java.lang.String);
	*** setLanternController(boolean);
	*** setNProxies(int);
	*** setPacUrl(java.lang.String);
}

-keep class org.lantern.state.DateSerializer {
	*** serialize(java.util.Date,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.lantern.state.DefaultFriendsHandler {
	*** $SWITCH_TABLE$org$lantern$state$Friend$Status;
	*** api;
	*** friendsLoaded;
	*** friendsLoading;
	*** loadedFriends;
	*** log;
	*** model;
	*** msgs;
	*** networkTracker;
	*** notificationManager;
	*** refreshToken;
	*** service;
	*** xmppHandler;
	*** $SWITCH_TABLE$org$lantern$state$Friend$Status();
	*** access$0(org.lantern.state.DefaultFriendsHandler);
	*** access$1(org.lantern.state.DefaultFriendsHandler);
	*** access$2(org.lantern.state.DefaultFriendsHandler);
	*** access$3(org.lantern.state.DefaultFriendsHandler);
	*** access$4(org.lantern.state.DefaultFriendsHandler,java.util.Map);
	*** access$5(org.lantern.state.DefaultFriendsHandler,org.lantern.state.ClientFriend);
	*** access$6(org.lantern.state.DefaultFriendsHandler);
	*** access$8(org.lantern.state.DefaultFriendsHandler,java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** access$9(org.lantern.state.DefaultFriendsHandler);
	*** addFriend(java.lang.String);
	*** addIncomingSubscriptionRequest(java.lang.String);
	*** checkForBulkInvites();
	*** clear();
	*** friendNotification(org.lantern.state.ClientFriend);
	*** friends();
	*** fullRemove(org.lantern.state.ClientFriend);
	*** getFriend(java.lang.String);
	*** getFriends();
	*** getOrCreateFriend(java.lang.String);
	*** handleBulkInvites();
	*** handlePeer(java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** insert(org.lantern.state.ClientFriend);
	*** invite(org.lantern.state.Friend,boolean);
	*** isFriend(java.lang.String);
	*** isFriend(org.lantern.state.Friend);
	*** isOnServer(org.lantern.state.ClientFriend);
	*** isRejected(java.lang.String);
	*** isRejected(org.lantern.state.ClientFriend);
	*** loadFriends();
	*** onProxyConnection(org.lantern.event.ProxyConnectionEvent);
	*** onRefreshToken(org.lantern.event.RefreshTokenEvent);
	*** onReset(org.lantern.event.ResetEvent);
	*** peerRunningLantern(java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** presenceForNewPeer(java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** put(org.lantern.state.ClientFriend);
	*** put(org.lantern.state.ClientFriend,boolean);
	*** remove(java.lang.String);
	*** removeFriend(java.lang.String);
	*** setStatus(org.lantern.state.ClientFriend,org.lantern.state.Friend$Status);
	*** subscribe(java.lang.String);
	*** sync(org.lantern.state.ClientFriend);
	*** syncFriends();
	*** trackFriend(org.lantern.state.ClientFriend);
	*** update(org.lantern.state.ClientFriend);
	*** updateName(java.lang.String,java.lang.String);
	*** vals(java.util.Map);
}

-keep class org.lantern.state.DefaultFriendsHandler$1 {
	*** this$0;
	*** call();
}

-keep class org.lantern.state.DefaultFriendsHandler$2 {
	*** this$0;
	*** val$email;
	*** val$pres;
}

-keep class org.lantern.state.DefaultFriendsHandler$3 {
	*** this$0;
}

-keep class org.lantern.state.DefaultModelService {
	*** gnomeAutostart;
	*** launchdPlist;
	*** log;
	*** model;
	*** proxifier;
	org.lantern.state.DefaultModelService(java.io.File,java.io.File,org.lantern.state.Model,org.lantern.ProxyService);
	*** getMode();
	*** getSettings();
	*** resetProxiedSites();
	*** setAutoReport(boolean);
	*** setMode(org.lantern.state.Mode);
	*** setProxiedSites(java.util.List);
	*** setProxyAllSites(boolean);
	*** setRunAtSystemStart(boolean);
	*** setShowFriendPrompts(boolean);
	*** setStartAtLoginLinux(boolean);
	*** setStartAtLoginOsx(boolean);
	*** setStartAtLoginWindows(boolean);
	*** setSystemProxy(boolean);
}

-keep class org.lantern.state.DefaultModelUtils {
	*** LOG;
	*** model;
	*** addToClosedBeta(java.lang.String);
	*** isConfigured();
	*** isInClosedBeta(java.lang.String);
	*** isOauthConfigured();
	*** loadClientSecrets();
	*** newGoogleOauthCreds(java.lang.String);
	*** shouldProxy();
	*** syncConnectingStatus(java.lang.String);
}

-keep class org.lantern.state.Friend {
	*** getEmail();
	*** getId();
	*** getStatus();
	*** setStatus(org.lantern.state.Friend$Status);
}

-keep class org.lantern.state.Friend$Status {
	*** ENUM$VALUES;
	*** friend;
	*** pending;
	*** rejected;
	*** values();
}

-keep class org.lantern.state.Friends {
	*** friends;
	*** needsSync;
	*** vals(java.util.Map);
}

-keep class org.lantern.state.FriendsHandler {
	*** addFriend(java.lang.String);
	*** addIncomingSubscriptionRequest(java.lang.String);
	*** getFriend(java.lang.String);
	*** getFriends();
	*** isFriend(java.lang.String);
	*** isRejected(java.lang.String);
	*** peerRunningLantern(java.lang.String,org.jivesoftware.smack.packet.Presence);
	*** removeFriend(java.lang.String);
	*** setStatus(org.lantern.state.ClientFriend,org.lantern.state.Friend$Status);
	*** syncFriends();
	*** updateName(java.lang.String,java.lang.String);
}

-keep class org.lantern.state.Global {
	*** bps;
	*** bytesEver;
	*** npeers;
	*** nusers;
}

-keep class org.lantern.state.InternalState {
	*** lastModal;
	*** log;
	*** modalSeqGet;
	*** modalSeqGive;
	*** modalsCompleted;
	*** model;
	*** msgs;
	*** notInvited;
	*** advanceModal(org.lantern.state.Modal);
	*** getLastModal();
	*** isNotInvited();
	*** onReset(org.lantern.event.ResetEvent);
	*** setCompletedTo(org.lantern.state.Modal);
	*** setLastModal(org.lantern.state.Modal);
	*** setModalCompleted(org.lantern.state.Modal);
	*** setNotInvited(boolean);
}

-keep class org.lantern.state.JsonModelModifier {
	*** log;
	*** modelService;
	*** applyJson(java.lang.String);
}

-keep class org.lantern.state.Location {
	*** country;
	*** lat;
	*** lon;
	*** getCountry();
	*** getLat();
	*** getLon();
	*** setCountry(java.lang.String);
	*** setLat(double);
	*** setLon(double);
}

-keep class org.lantern.state.LocationChangedEvent {
	*** newLocation;
	*** oldCountry;
	*** getNewCountry();
	*** getNewLocation();
	*** getOldCountry();
}

-keep class org.lantern.state.Modal {
	*** ENUM$VALUES;
	*** about;
	*** authorize;
	*** authorizeLater;
	*** confirmReset;
	*** connecting;
	*** contact;
	*** finished;
	*** firstInviteReceived;
	*** giveModeForbidden;
	*** lanternFriends;
	*** none;
	*** notInvited;
	*** proxiedSites;
	*** requestInvite;
	*** requestSent;
	*** scenarios;
	*** settings;
	*** settingsLoadFailure;
	*** sponsor;
	*** sponsorToContinue;
	*** systemProxy;
	*** updateAvailable;
	*** welcome;
	*** valueOf(java.lang.String);
	*** values();
}

-keep class org.lantern.state.Mode {
	*** ENUM$VALUES;
	*** get;
	*** give;
	*** unknown;
	*** values();
}

-keep class org.lantern.state.Model {
	*** connectivity;
	*** countryService;
	*** friends;
	*** global;
	*** instanceId;
	*** isEverGetMode;
	*** launchd;
	*** location;
	*** log;
	*** maxNotificationId;
	*** modal;
	*** nodeId;
	*** notifications;
	*** nproxiedSitesMax;
	*** peerCollector;
	*** profile;
	*** reportIp;
	*** roster;
	*** settings;
	*** setupComplete;
	*** showVis;
	*** system;
	*** transfers;
	*** version;
	*** welcomeMessageShown;
	*** xsrfToken;
	*** addNotification(java.lang.String,org.lantern.state.Notification$MessageType,int);
	*** addNotification(org.lantern.state.Notification);
	*** clearNotifications();
	*** closeNotification(int);
	*** generateInstanceId();
	*** getConnectivity();
	*** getCountries();
	*** getCountryService();
	*** getGlobal();
	*** getInstanceId();
	*** getLocation();
	*** getModal();
	*** getNodeId();
	*** getNotifications();
	*** getNproxiedSitesMax();
	*** getPeerCollector();
	*** getPeers();
	*** getProfile();
	*** getReportIp();
	*** getRoster();
	*** getSettings();
	*** getSystem();
	*** getVersion();
	*** getXsrfToken();
	*** isEverGetMode();
	*** isLaunchd();
	*** isSetupComplete();
	*** isShowVis();
	*** isWelcomeMessageShown();
	*** loadFrom(org.lantern.state.Model);
	*** setCountryService(org.lantern.CountryService);
	*** setEverGetMode(boolean);
	*** setFriends(java.util.Collection);
	*** setInstanceId(java.lang.String);
	*** setLaunchd(boolean);
	*** setModal(org.lantern.state.Modal);
	*** setNodeId(java.lang.String);
	*** setNproxiedSitesMax(int);
	*** setProfile(org.lantern.state.Profile);
	*** setReportIp(java.lang.String);
	*** setRoster(org.lantern.Roster);
	*** setSettings(org.lantern.state.Settings);
	*** setSetupComplete(boolean);
	*** setShowVis(boolean);
	*** setTransfers(org.lantern.state.Transfers);
	*** setWelcomeMessageShown(boolean);
}

-keep class org.lantern.state.ModelIo {
	*** commandLine;
	*** countryService;
	*** localCipherProvider;
	*** log;
	org.lantern.state.ModelIo(java.io.File,org.lantern.privacy.EncryptedFileService,org.lantern.state.Transfers,org.lantern.CountryService,org.apache.commons.cli.CommandLine,org.lantern.privacy.LocalCipherProvider);
	*** blank();
	*** loadLocalPasswordFile(java.lang.String);
	*** loadOAuth2ClientSecretsFile(java.lang.String,org.lantern.state.Settings);
	*** loadOAuth2UserCredentialsFile(java.lang.String,org.lantern.state.Settings);
	*** parseOptionDefaultTrue(org.apache.commons.cli.CommandLine,java.lang.String);
	*** processCommandLine(org.apache.commons.cli.CommandLine,org.lantern.state.Model);
	*** read();
	*** reload();
	*** write(java.lang.Object);
	*** write(org.lantern.state.Model);
}

-keep class org.lantern.state.ModelIoTest {
	*** LOG;
	*** testFile;
}

-keep class org.lantern.state.ModelService {
	*** getMode();
	*** setMode(org.lantern.state.Mode);
}

-keep class org.lantern.state.ModelTest {
	*** log;
	*** autostart();
	*** plist();
	*** testFile(java.lang.String);
}

-keep class org.lantern.state.ModelUtils {
	*** addToClosedBeta(java.lang.String);
	*** isConfigured();
	*** isInClosedBeta(java.lang.String);
	*** isOauthConfigured();
	*** loadClientSecrets();
	*** newGoogleOauthCreds(java.lang.String);
	*** shouldProxy();
	*** syncConnectingStatus(java.lang.String);
}

-keep class org.lantern.state.NPeers {
	*** ever;
	*** online;
}

-keep class org.lantern.state.NUsers {
	*** ever;
	*** online;
}

-keep class org.lantern.state.Notification {
	*** autoClose;
	*** message;
	*** type;
	org.lantern.state.Notification(java.lang.String,org.lantern.state.Notification$MessageType,int);
	*** getMessage();
}

-keep class org.lantern.state.Notification$MessageType {
	*** ENUM$VALUES;
	*** error;
	*** important;
	*** info;
	*** success;
	*** warning;
}

-keep class org.lantern.state.Peer {
	*** bytesDn;
	*** bytesDnCounter;
	*** bytesUp;
	*** bytesUpCounter;
	*** country;
	*** incoming;
	*** ip;
	*** lastConnected;
	*** lastConnectedLong;
	*** lat;
	*** lon;
	*** mapped;
	*** mode;
	*** numberOfOpenConnections;
	*** online;
	*** peerid;
	*** port;
	*** rosterEntry;
	*** type;
	*** version;
	*** addBytesDn(long);
	*** addBytesUp(long);
	*** connected();
	*** disconnected();
	*** getBpsDown();
	*** getBpsUp();
	*** getIp();
	*** getLastConnectedLong();
	*** getNSockets();
	*** getPeerid();
	*** getPort();
	*** getRosterEntry();
	*** hasGeoData();
	*** setCountry(java.lang.String);
	*** setIp(java.lang.String);
	*** setLat(double);
	*** setLon(double);
	*** setMapped(boolean);
	*** setMode(org.lantern.state.Mode);
	*** setOnline(boolean);
	*** setPort(int);
	*** setRosterEntry(org.lantern.LanternRosterEntry);
	*** setType(java.lang.String);
	*** setVersion(java.lang.String);
}

-keep class org.lantern.state.Peer$Type {
	*** ENUM$VALUES;
	*** cloud;
	*** laeproxy;
	*** pc;
}

-keep class org.lantern.state.PeerCount {
	*** get;
	*** give;
	*** getGet();
	*** getGive();
	*** setGet(long);
	*** setGive(long);
}

-keep class org.lantern.state.PeerCountDeserializer {
	*** deserialize(org.codehaus.jackson.JsonParser,org.codehaus.jackson.map.DeserializationContext);
}

-keep class org.lantern.state.PeerCountSerializer {
	*** serialize(org.lantern.state.PeerCount,org.codehaus.jackson.JsonGenerator,org.codehaus.jackson.map.SerializerProvider);
}

-keep class org.lantern.state.PeerLastConnectedChangedEvent {
	*** peer;
	*** getPeer();
	*** setPeer(org.lantern.state.Peer);
}

-keep class org.lantern.state.Peers {
	*** peers;
	*** addPeer(java.net.URI,org.lantern.state.Peer);
	*** getPeer(java.net.URI);
	*** getPeers();
	*** reset();
}

-keep class org.lantern.state.Profile {
	*** birthday;
	*** email;
	*** family_name;
	*** gender;
	*** given_name;
	*** hd;
	*** id;
	*** link;
	*** locale;
	*** name;
	*** picture;
	*** verified_email;
	*** getEmail();
	*** getName();
}

-keep class org.lantern.state.Settings {
	*** accessToken;
	*** autoReport;
	*** bindToLocalhost;
	*** clientID;
	*** clientSecret;
	*** expiryTime;
	*** inClosedBeta;
	*** keychainEnabled;
	*** lang;
	*** log;
	*** mode;
	*** proxyAllSites;
	*** proxyPort;
	*** refreshToken;
	*** runAtSystemStart;
	*** serverPort;
	*** showFriendPrompts;
	*** stunServers;
	*** systemProxy;
	*** tcp;
	*** udp;
	*** udpProxyPriority;
	*** uiEnabled;
	*** useAnonymousPeers;
	*** useCentralProxies;
	*** useCloudProxies;
	*** useGoogleOAuth2;
	*** useLaeProxies;
	*** useTrustedPeers;
	*** whitelist;
	*** getAccessToken();
	*** getClientID();
	*** getClientSecret();
	*** getExpiryTime();
	*** getInClosedBeta();
	*** getLang();
	*** getMode();
	*** getProxiedSites();
	*** getProxyPort();
	*** getRefreshToken();
	*** getServerPort();
	*** getStunServers();
	*** getUdpProxyPriority();
	*** getWhitelist();
	*** isAutoReport();
	*** isBindToLocalhost();
	*** isKeychainEnabled();
	*** isProxyAllSites();
	*** isRunAtSystemStart();
	*** isShowFriendPrompts();
	*** isSystemProxy();
	*** isTcp();
	*** isUdp();
	*** isUiEnabled();
	*** isUseAnonymousPeers();
	*** isUseCentralProxies();
	*** isUseCloudProxies();
	*** isUseGoogleOAuth2();
	*** isUseLaeProxies();
	*** isUseTrustedPeers();
	*** setAccessToken(java.lang.String);
	*** setAutoReport(boolean);
	*** setBindToLocalhost(boolean);
	*** setClientID(java.lang.String);
	*** setClientSecret(java.lang.String);
	*** setExpiryTime(long);
	*** setInClosedBeta(java.util.Set);
	*** setKeychainEnabled(boolean);
	*** setLang(java.lang.String);
	*** setMode(org.lantern.state.Mode);
	*** setProxiedSites(java.lang.String[]);
	*** setProxyAllSites(boolean);
	*** setProxyPort(int);
	*** setRefreshToken(java.lang.String);
	*** setRunAtSystemStart(boolean);
	*** setServerPort(int);
	*** setShowFriendPrompts(boolean);
	*** setStunServers(java.util.Set);
	*** setSystemProxy(boolean);
	*** setTcp(boolean);
	*** setUdp(boolean);
	*** setUdpProxyPriority(java.lang.String);
	*** setUiEnabled(boolean);
	*** setUseAnonymousPeers(boolean);
	*** setUseCentralProxies(boolean);
	*** setUseCloudProxies(boolean);
	*** setUseGoogleOAuth2(boolean);
	*** setUseLaeProxies(boolean);
	*** setUseTrustedPeers(boolean);
	*** setWhitelist(org.lantern.Whitelist);
}

-keep class org.lantern.state.StaticSettings {
	*** API_PORT;
	*** LOG;
	*** constantsFile;
	*** prefix;
	*** createPropertiesFile();
	*** getApiPort();
	*** getLocalEndpoint();
	*** getLocalEndpoint(int,java.lang.String);
	*** getPrefix();
	*** loadSettings();
}

-keep class org.lantern.state.Storage {
	*** cls;
	*** encryptedFileService;
	*** file;
	*** log;
	*** newFile;
	*** obj;
	org.lantern.state.Storage(org.lantern.privacy.EncryptedFileService,java.io.File,java.lang.Class);
	*** blank();
	*** get();
	*** read();
	*** stop();
	*** write();
	*** write(java.lang.Object);
}

-keep class org.lantern.state.SyncPath {
	*** ALL;
	*** AUTO_CONNECT;
	*** AUTO_REPORT;
	*** CONNECTING_STATUS;
	*** CONNECTIVITY;
	*** CONNECTIVITY_GTALK;
	*** CONNECTIVITY_INTERNET;
	*** CONNECTIVITY_LANTERN_CONTROLLER;
	*** CONNECTIVITY_NPROXIES;
	*** COUNTRIES;
	*** ENUM$VALUES;
	*** FRIENDS;
	*** GLOBAL;
	*** INVITED;
	*** LOCATION;
	*** MODAL;
	*** MODE;
	*** NOTIFICATIONS;
	*** PEERS;
	*** PROFILE;
	*** PROXY_ALL_SITES;
	*** ROSTER;
	*** SETTINGS;
	*** SETUPCOMPLETE;
	*** SHOWVIS;
	*** SHOW_FRIEND_PROMPTS;
	*** START_AT_LOGIN;
	*** SYSTEMPROXY;
	*** TRANSFERS;
	*** VERSION;
	*** path;
	*** getPath();
}

-keep class org.lantern.state.SyncService {
	*** log;
	*** model;
	*** session;
	*** strategy;
	*** timer;
	*** transfers;
	*** access$0(org.lantern.state.SyncService);
	*** access$1(org.lantern.state.SyncService,org.lantern.event.SyncType,org.lantern.state.SyncPath,java.lang.Object);
	*** access$2(org.lantern.state.SyncService);
	*** access$3(org.lantern.state.SyncService);
	*** access$4(org.lantern.state.SyncService,org.lantern.state.SyncPath,java.lang.Object);
	*** closedBeta(org.lantern.event.ClosedBetaEvent);
	*** delegateSync(org.lantern.event.SyncType,java.lang.String,java.lang.Object);
	*** delegateSync(org.lantern.event.SyncType,org.lantern.state.SyncPath,java.lang.Object);
	*** delegateSync(org.lantern.state.SyncPath,java.lang.Object);
	*** metaConnect(org.cometd.bayeux.server.ServerSession,org.cometd.bayeux.Message);
	*** onSync(org.lantern.event.SyncEvent);
	*** start();
	*** stop();
}

-keep class org.lantern.state.SyncService$1 {
	*** this$0;
}

-keep class org.lantern.state.SyncService$2 {
	*** this$0;
}

-keep class org.lantern.state.SyncStrategy {
	*** sync(org.cometd.bayeux.server.ServerSession,org.lantern.event.SyncType,java.lang.String,java.lang.Object);
}

-keep class org.lantern.state.SystemData {
	*** bytesFree;
	*** memory;
	*** os;
	*** screenSize;
	*** getLang();
}

-keep class org.lantern.state.Transfers {
	*** historicalDownBytes;
	*** historicalUpBytes;
	*** statsTracker;
	*** getBpsDn();
	*** getBpsUp();
	*** getBytesDn();
	*** getBytesUp();
	*** getDownTotalThisRun();
	*** getStatsTracker();
	*** getUpTotalThisRun();
	*** setStatsTracker(org.lantern.Stats);
}

-keep class org.lantern.state.TransfersIo {
	*** log;
	*** tracker;
	org.lantern.state.TransfersIo(java.io.File,org.lantern.ClientStats,org.lantern.privacy.EncryptedFileService,java.util.Timer);
	*** blank();
	*** initSaveThread(java.util.Timer);
	*** read();
}

-keep class org.lantern.state.TransfersIo$1 {
	*** this$0;
}

-keep class org.lantern.state.UDPProxyPriority {
	*** ENUM$VALUES;
	*** HIGHER;
	*** LOWER;
	*** SAME;
	*** multiplier;
	*** adjustComparisonResult(int);
	*** valueOf(java.lang.String);
}

-keep class org.lantern.state.Version {
	*** installed;
	*** latest;
	*** updateAvailable;
	*** getInstalled();
}

-keep class org.lantern.state.Version$Installed {
	*** api;
	*** git;
	*** gitFull;
	*** installerSHA1;
	*** installerUrl;
	*** major;
	*** minor;
	*** modelSchema;
	*** patch;
	*** releaseDate;
	*** tag;
	*** this$0;
	*** getGit();
}

-keep class org.lantern.state.Version$SemanticVersion {
	*** major;
	*** minor;
	*** mock;
	*** patch;
	*** this$0;
}

-keep class org.lantern.stubs.PeerFactoryStub {
	*** peersByJid;
}

-keep class org.lantern.stubs.ProxyTrackerStub {
	org.lantern.stubs.ProxyTrackerStub();
}

-keep class org.lantern.ui.FriendNotificationDialog {
	*** email;
	*** friend;
	*** friendsHandler;
	*** log;
	*** name;
	*** access$0(org.lantern.ui.FriendNotificationDialog);
	*** access$1(org.lantern.ui.FriendNotificationDialog);
	*** access$2(org.lantern.ui.FriendNotificationDialog);
	*** doSetup();
	*** later();
	*** loadText();
	*** no();
	*** setFriendStatus(org.lantern.state.Friend$Status);
	*** setup();
	*** yes();
}

-keep class org.lantern.ui.FriendNotificationDialog$1 {
	*** this$0;
}

-keep class org.lantern.ui.FriendNotificationDialog$2 {
	*** this$0;
	*** val$status;
}

-keep class org.lantern.ui.FriendNotificationDialog$3 {
	*** this$0;
}

-keep class org.lantern.ui.NotificationDialog {
	*** window;
	org.lantern.ui.NotificationDialog(org.lantern.ui.NotificationManager);
	*** dispose();
}

-keep class org.lantern.ui.NotificationDialog$1 {
	*** this$0;
	*** val$manager;
}

-keep class org.lantern.ui.NotificationManager {
	*** log;
	*** notifications;
	*** settings;
	*** access$0(org.lantern.ui.NotificationManager);
	*** access$1(org.lantern.ui.NotificationManager);
	*** addNotification(org.lantern.ui.NotificationDialog);
	*** clear();
	*** doNotify(org.lantern.ui.NotificationDialog);
	*** getClientArea();
	*** onReset(org.lantern.event.ResetEvent);
	*** remove(org.lantern.ui.NotificationDialog);
	*** shouldNotify();
}

-keep class org.lantern.ui.NotificationManager$1 {
	*** this$0;
	*** val$notification;
}

-keep class org.lantern.util.BitInputStream {
	*** remainingBits;
	*** stream;
	*** toReturn;
	*** flush();
	*** read(int);
	*** readBit();
}

-keep class org.lantern.util.BitOutputStream {
	*** remainingBits;
	*** stream;
	*** toWrite;
	*** flush();
	*** write(int,int);
	*** writeBit(int);
}

-keep class org.lantern.util.Counter {
	*** ALL_COUNTERS;
	*** LOG;
	*** latestSnapshot;
	*** movingAverageWindowInMillis;
	*** rate;
	*** total;
	*** access$0();
	*** access$1(org.lantern.util.Counter);
	*** access$2();
	*** add(long);
	*** averageOverOneSecond();
	*** calculateRate();
	*** getRate();
	*** getTotal();
}

-keep class org.lantern.util.Counter$Snapshot {
	*** prior;
	*** timestamp;
	*** total;
	org.lantern.util.Counter$Snapshot();
	org.lantern.util.Counter$Snapshot(org.lantern.util.Counter$Snapshot,long);
}

-keep class org.lantern.util.DefaultStopwatch {
	*** id;
	*** logger;
	*** maxDescription;
	*** maxTime;
	*** minDescription;
	*** minTime;
	*** name;
	*** numCalls;
	*** startTimes;
	*** total;
	org.lantern.util.DefaultStopwatch(java.lang.String,java.lang.String);
	org.lantern.util.DefaultStopwatch(java.lang.String,java.lang.String,java.lang.String);
	*** compareTo(org.lantern.util.DefaultStopwatch);
	*** getAverage();
	*** getMax();
	*** getMin();
	*** getSummary();
	*** getTotal();
	*** stop(java.lang.String);
}

-keep class org.lantern.util.Desktop {
	*** getDesktopPath();
}

-keep class org.lantern.util.HttpClientFactory {
	*** censored;
	*** log;
	*** proxyTracker;
	*** socketsUtil;
	*** configureDefaults(org.apache.http.HttpHost,org.apache.http.impl.client.DefaultHttpClient);
	*** newClient();
	*** newClient(org.apache.http.HttpHost,boolean);
	*** newDirectClient();
	*** newProxyBlocking();
}

-keep class org.lantern.util.HttpClientFactory$1 {
	*** this$0;
	*** val$sf;
}

-keep class org.lantern.util.LanternHostNameVerifier {
	*** log;
	*** proxy;
}

-keep class org.lantern.util.PublicIpAddress {
	*** LOG;
	*** cacheTime;
	*** lastLookupTime;
	*** publicIp;
	*** threadPool;
	*** access$0(java.net.InetAddress);
	*** access$1(long);
	*** access$2();
	*** getPublicIpAddress();
	*** getPublicIpAddress(boolean);
	*** ifConfigLookup();
	*** stunLookup();
	*** wikiMediaLookup();
}

-keep class org.lantern.util.PublicIpAddress$1 {
	*** count;
}

-keep class org.lantern.util.PublicIpAddress$2 {
	*** this$0;
	*** val$sock;
	*** call();
}

-keep class org.lantern.util.Stopwatch {
	*** getName();
	*** getTotal();
	*** logSummary();
	*** reset();
	*** start();
	*** stop();
}

-keep class org.lantern.util.StopwatchManager {
	*** LOG;
	*** watches;
	*** getStopwatch(java.lang.String,java.lang.String,java.lang.String);
	*** getStopwatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** logSummaries(java.lang.String);
}

-keep class org.lantern.util.Threads {
	*** newCachedThreadPool(java.lang.String);
	*** newDaemonThreadFactory(java.lang.String);
	*** newSingleThreadScheduledExecutor(java.lang.String);
}

-keep class org.lantern.util.Threads$1 {
	*** count;
	*** val$name;
}

-keep class org.lantern.util.Threads$2 {
	*** val$counter;
	*** val$name;
}

-keep class org.lantern.util.Threads$3 {
	*** val$counter;
	*** val$name;
}

-keep class org.lantern.win.Registry {
	*** LOG;
	*** read(java.lang.String,java.lang.String);
	*** readWithCommandReg(java.lang.String,java.lang.String);
	*** write(java.lang.String,java.lang.String,java.lang.Integer);
	*** write(java.lang.String,java.lang.String,java.lang.String);
	*** writeWithCommandReg(java.lang.String,java.lang.String,java.lang.Integer);
	*** writeWithCommandReg(java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.lantern.win.RegistryTest {
	*** LOG;
	*** writeWithAdvApi(java.lang.String,java.lang.String,java.lang.String);
	*** writeWithCommandReg(java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.lantern.win.WinProxy {
	org.lantern.win.WinProxy(java.io.File);
	*** closeQuietly(java.io.Closeable);
	*** copy(java.io.InputStream,java.io.OutputStream);
	*** copyFromJar(java.io.File);
	*** setPacFile(java.lang.String);
	*** unproxy();
}

-keep class org.lantern.win.WindowsRegCommand {
	*** LOG;
	*** access$0();
	*** read(java.lang.String,java.lang.String);
	*** write(java.lang.String,java.lang.String,java.lang.String,java.lang.String);
	*** writeREG_DWORD(java.lang.String,java.lang.String,int);
	*** writeREG_SZ(java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.lantern.win.WindowsRegCommand$1 {
	*** val$is;
	*** val$key;
	*** val$sw;
	*** val$valueName;
}

-keep class org.lantern.win.WindowsRegCommand$2 {
	*** val$is;
	*** val$key;
	*** val$sw;
	*** val$valueName;
}

-keep class org.lastbamboo.common.amazon.ec2.AmazonEc2Utils {
	*** onEc2();
}

-keep class org.lastbamboo.common.ice.BarchartUdtSocketFactory {
	*** log;
	*** sslSocketFactory;
	*** threadPool;
	*** clear(org.littleshoot.mina.common.IoSession,org.lastbamboo.common.ice.IceStunUdpPeer,org.lastbamboo.common.ice.IceAgent);
}

-keep class org.lastbamboo.common.ice.BarchartUdtSocketFactory$1 {
	*** count;
}

-keep class org.lastbamboo.common.ice.EndpointFactory {
	*** log;
	*** clear(org.littleshoot.mina.common.IoSession,org.lastbamboo.common.ice.IceStunUdpPeer,org.lastbamboo.common.ice.IceAgent);
}

-keep class org.lastbamboo.common.ice.GeneralIceMediaStreamFactory {
	*** newIceMediaStream(org.lastbamboo.common.offer.answer.IceMediaStreamDesc,org.lastbamboo.common.ice.IceAgent,org.lastbamboo.common.turn.client.TurnClientListener);
}

-keep class org.lastbamboo.common.ice.IceMediaStreamFactoryImpl {
	*** m_log;
	*** m_stunServerCandidateProvider;
}

-keep class org.lastbamboo.common.ice.IceOfferAnswer {
	*** gatherCandidates();
}

-keep class org.lastbamboo.common.ice.IceOfferAnswerFactory {
	*** m_answererServer;
	*** m_log;
	*** m_mediaStreamFactory;
	*** m_offererServer;
	*** m_socketFactory;
	*** m_stunCandidateProvider;
	*** m_turnCandidateProvider;
	*** m_turnClientListener;
	*** m_udpSocketFactory;
	*** createOfferAnswer(boolean,org.lastbamboo.common.offer.answer.OfferAnswerListener,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
	*** encodeCandidates(boolean,org.lastbamboo.common.ice.IceOfferAnswer,org.lastbamboo.common.ice.IceOfferAnswer,org.lastbamboo.common.ice.IceOfferAnswer,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
	*** newTcpOfferAnswer(org.lastbamboo.common.offer.answer.OfferAnswerListener,boolean,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
	*** newTurnOfferAnswer(boolean,org.lastbamboo.common.offer.answer.OfferAnswerListener,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
	*** newUdpOfferAnswer(boolean,org.lastbamboo.common.offer.answer.OfferAnswerListener,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
}

-keep class org.lastbamboo.common.ice.IceState {
	*** $VALUES;
	*** COMPLETED;
	*** FAILED;
	*** RUNNING;
}

-keep class org.lastbamboo.common.ice.IceStunUdpPeer {
	*** close();
	*** getStunServer();
}

-keep class org.lastbamboo.common.ice.IceTieBreaker {
	*** m_byteArray;
	*** s_random;
}

-keep class org.lastbamboo.common.ice.MappedServerSocket {
	*** getHostAddress();
	*** getMappedPort();
	*** isPortMapped();
}

-keep class org.lastbamboo.common.ice.MappedTcpOffererServerPool {
	*** log;
	*** natPmpService;
	*** serverSocketFactory;
	*** servers;
	*** upnpService;
	*** access$000(org.lastbamboo.common.ice.MappedTcpOffererServerPool);
	*** addServerSocket(org.lastbamboo.common.ice.PortMappedServerSocket);
	*** randomPortServer();
	*** serverSocket();
}

-keep class org.lastbamboo.common.ice.MappedTcpOffererServerPool$1 {
	*** this$0;
}

-keep class org.lastbamboo.common.ice.PortMappedServerSocket {
	*** externalPort;
	*** hasMappedPort;
	*** isPublic;
	*** log;
	*** serverSocket;
}

-keep class org.lastbamboo.common.ice.TcpTurnOfferAnswer {
	*** connect();
}

-keep class org.lastbamboo.common.ice.sdp.IceCandidateSdpEncoder {
	*** getSdp();
	*** visitCandidates(java.util.Collection);
}

-keep class org.lastbamboo.common.offer.answer.IceConfig {
	*** cipherSuites;
	*** disableUdpOnLocalNetwork;
	*** tcp;
	*** udp;
	*** getCipherSuites();
	*** isTcp();
	*** isUdp();
	*** setCipherSuites(java.lang.String[]);
	*** setDisableUdpOnLocalNetwork(boolean);
	*** setTcp(boolean);
	*** setUdp(boolean);
}

-keep class org.lastbamboo.common.offer.answer.IceMediaStreamDesc {
	*** m_mimeContentSubtype;
	*** m_mimeContentType;
	*** m_numComponents;
	*** m_tcp;
	*** m_udp;
	*** m_useRelay;
	*** reliable;
	org.lastbamboo.common.offer.answer.IceMediaStreamDesc(boolean,boolean,java.lang.String,java.lang.String,int,boolean,boolean);
	*** getMimeContentSubtype();
	*** getMimeContentType();
	*** isTcp();
	*** isUdp();
	*** isUseRelay();
	*** newReliable();
	*** newReliableNoRelay();
	*** newUnreliableUdpStream();
	*** newUnreliableUdpStreamNoRelay();
}

-keep class org.lastbamboo.common.offer.answer.OfferAnswer {
	*** close();
	*** generateAnswer();
	*** processOffer(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.lastbamboo.common.offer.answer.OfferAnswerFactory {
	*** createAnswerer(org.lastbamboo.common.offer.answer.OfferAnswerListener,boolean);
	*** getMappedPort();
	*** isAnswererPortMapped();
}

-keep class org.lastbamboo.common.offer.answer.OfferAnswerListener {
	*** onUdpSocket(java.lang.Object);
}

-keep class org.lastbamboo.common.offer.answer.OfferAnswerTransactionListener {
	*** onTransactionFailed(org.lastbamboo.common.offer.answer.OfferAnswerMessage);
	*** onTransactionSucceeded(org.lastbamboo.common.offer.answer.OfferAnswerMessage);
}

-keep class org.lastbamboo.common.p2p.DefaultTcpUdpEndpoint {
	*** newSocket(java.net.URI);
}

-keep class org.lastbamboo.common.p2p.DefaultTcpUdpSocket {
	*** newSocket(java.net.URI);
}

-keep class org.lastbamboo.common.p2p.P2PClient {
	*** addConnectionListener(org.lastbamboo.common.p2p.P2PConnectionListener);
	*** logout();
}

-keep class org.lastbamboo.common.p2p.P2PConnectionEvent {
	*** connected;
	*** incoming;
	*** jid;
	*** mapping;
	*** remoteSocketAddress;
	*** sock;
	*** socketType;
}

-keep class org.lastbamboo.common.p2p.P2PConstants {
	*** MESSAGE_TYPE;
}

-keep class org.lastbamboo.common.p2p.PortMappingState {
	*** UNKNOWN;
}

-keep class org.lastbamboo.common.p2p.SocketFactory {
	*** newRawSocket(java.net.URI);
	*** newSocket(java.net.URI);
}

-keep class org.lastbamboo.common.p2p.SocketType {
	*** UNKNOWN;
}

-keep class org.lastbamboo.common.portmapping.NatPmpService {
	*** addNatPmpMapping(org.lastbamboo.common.portmapping.PortMappingProtocol,int,int,org.lastbamboo.common.portmapping.PortMapListener);
	*** shutdown();
}

-keep class org.lastbamboo.common.portmapping.PortMapListener {
	*** onPortMap(int);
	*** onPortMapError();
}

-keep class org.lastbamboo.common.portmapping.PortMappingProtocol {
	*** $VALUES;
	*** TCP;
	*** UDP;
}

-keep class org.lastbamboo.common.portmapping.UpnpService {
	*** addUpnpMapping(org.lastbamboo.common.portmapping.PortMappingProtocol,int,int,org.lastbamboo.common.portmapping.PortMapListener);
	*** shutdown();
}

-keep class org.lastbamboo.common.stun.client.PublicIpAddress {
	*** LOG;
	*** cacheTime;
	*** lastLookupTime;
	*** publicIp;
	*** threadPool;
	*** ifConfigLookup();
	*** stunLookup();
	*** wikiMediaLookup();
}

-keep class org.lastbamboo.common.stun.client.PublicIpAddress$1 {
	*** count;
}

-keep class org.lastbamboo.common.stun.client.StunClient {
	*** connect();
}

-keep class org.lastbamboo.common.stun.client.StunClientConfig {
	*** isUseDnsSec();
}

-keep class org.lastbamboo.common.stun.client.StunClientMessageVisitor {
	*** m_log;
	*** m_transactionTracker;
	*** notifyTransaction(org.littleshoot.stun.stack.message.StunMessage);
}

-keep class org.lastbamboo.common.stun.client.StunClientMessageVisitorFactory {
	*** m_transactionTracker;
}

-keep class org.lastbamboo.common.stun.client.StunServerRepository {
	*** servers;
	*** getServers();
	*** setStunServers(java.util.Collection);
}

-keep class org.lastbamboo.common.stun.client.UdpStunClient {
	*** LOG;
	*** m_currentIoSession;
	*** m_idsToResponses;
	*** m_ioHandler;
	*** m_ioServiceListeners;
	*** m_localAddress;
	*** m_originalLocalAddress;
	*** m_sessions;
	*** m_stunServer;
	*** m_stunServers;
	*** m_transactionTracker;
	org.lastbamboo.common.stun.client.UdpStunClient(java.net.InetSocketAddress,java.util.Collection,org.littleshoot.stun.stack.transaction.StunTransactionTracker,org.littleshoot.mina.common.IoHandler);
	*** access$400();
	*** connect(java.net.InetSocketAddress,java.net.InetSocketAddress);
	*** createConnector();
	*** notifyWaiters(org.littleshoot.stun.stack.message.StunMessage,org.littleshoot.stun.stack.message.StunMessage);
	*** onFailure(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** onSuccess(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** pickStunServerInetAddress();
	*** pickStunServerInetAddress(java.net.InetSocketAddress);
	*** waitIfNoResponse(org.littleshoot.stun.stack.message.StunMessage,long);
	*** write(org.littleshoot.stun.stack.message.BindingRequest,java.net.InetSocketAddress);
	*** write(org.littleshoot.stun.stack.message.BindingRequest,java.net.InetSocketAddress,long);
}

-keep class org.lastbamboo.common.stun.client.UdpStunClient$1 {
	*** this$0;
	*** visitBindingErrorResponse(org.littleshoot.stun.stack.message.BindingErrorResponse);
	*** visitBindingSuccessResponse(org.littleshoot.stun.stack.message.BindingSuccessResponse);
	*** visitConnectErrorMesssage(org.littleshoot.stun.stack.message.ConnectErrorStunMessage);
}

-keep class org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer {
	*** failures;
	*** isa;
	*** successes;
	*** this$0;
	org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer(org.lastbamboo.common.stun.client.UdpStunClient,java.net.InetSocketAddress);
	*** access$100(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** access$200(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** access$208(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** access$300(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** access$308(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** compareTo(org.lastbamboo.common.stun.client.UdpStunClient$RankedStunServer);
	*** getScore();
}

-keep class org.lastbamboo.common.stun.server.StunServer {
	*** close();
}

-keep class org.lastbamboo.common.turn.http.server.ServerDataFeeder {
	*** m_addressesToSessions;
	*** m_log;
	*** m_serverAddress;
	*** onRemoteAddressOpened(java.net.InetSocketAddress,org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient {
	*** answererListener;
	*** callSocketListener;
	*** connecting;
	*** connectionAttempts;
	*** credentials;
	*** exec;
	*** incomingControlSockets;
	*** listeners;
	*** log;
	*** loggedOut;
	*** messageListeners;
	*** offerAnswerFactory;
	*** outgoingControlSockets;
	*** plainTextRelayAddress;
	*** publicIp;
	*** relayWaitTime;
	*** sentMessageIds;
	*** socketFactory;
	*** socketOfferAnswerFactory;
	*** transactionIdsToProcessors;
	*** urisToMappedServers;
	*** useRelay;
	*** xmppConnection;
	*** xmppServerHost;
	*** xmppServerPort;
	*** xmppServiceName;
	*** access$1100(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$1200(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$1300(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$1900(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$300(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$400(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$500(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$600(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient);
	*** access$800();
	*** access$900(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient,org.jivesoftware.smack.packet.Message);
	*** closeOutgoing(java.net.URI,java.net.Socket);
	*** controlSocket(java.net.URI,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
	*** error(java.lang.String,java.lang.Long,java.net.Socket);
	*** establishControlSocket(java.net.URI,org.lastbamboo.common.offer.answer.IceMediaStreamDesc);
	*** isLoggedOut();
	*** login(java.lang.String,java.lang.String,java.lang.String);
	*** login(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String);
	*** login(org.littleshoot.commom.xmpp.XmppCredentials);
	*** login(org.littleshoot.commom.xmpp.XmppCredentials,java.lang.String,int,java.lang.String);
	*** logout();
	*** newConnectionToMappedServerSocket(java.net.URI,boolean);
	*** newError(java.lang.String,java.lang.Long);
	*** newError(org.jivesoftware.smack.packet.Message);
	*** newGoogleTalkDirectClient(org.lastbamboo.common.offer.answer.OfferAnswerFactory,org.lastbamboo.common.offer.answer.OfferAnswerFactory,java.net.InetSocketAddress,org.littleshoot.util.SessionSocketListener,int,org.littleshoot.util.PublicIp,javax.net.SocketFactory,org.lastbamboo.common.offer.answer.OfferAnswerListener);
	*** newInviteOk(java.lang.Long,byte[]);
	*** newInviteToEstablishControlSocket(java.lang.String,byte[],org.lastbamboo.common.offer.answer.OfferAnswerTransactionListener,org.littleshoot.util.KeyStorage);
	*** newRawSocket(java.net.URI);
	*** newRawUnreliableSocket(java.net.URI);
	*** newSocket(java.net.URI);
	*** newSocket(java.net.URI,org.lastbamboo.common.offer.answer.IceMediaStreamDesc,boolean);
	*** newUnreliableSocket(java.net.URI);
	*** notifyConnectionListeners(java.lang.String,java.net.Socket,boolean,boolean,org.lastbamboo.common.p2p.PortMappingState,org.lastbamboo.common.p2p.SocketType);
	*** notifyConnectionListeners(java.net.URI,java.net.Socket,boolean,boolean,org.lastbamboo.common.p2p.PortMappingState,org.lastbamboo.common.p2p.SocketType);
	*** processInviteOverControlSocket(org.littleshoot.mina.common.ByteBuffer,java.net.Socket,java.lang.String);
	*** processInviteToEstablishControlSocket(org.jivesoftware.smack.packet.Message);
	*** processMessages();
	*** toXml(org.jivesoftware.smack.packet.Message);
	*** writeMessage(org.jivesoftware.smack.packet.Message,java.net.Socket);
}

-keep class org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$1 {
	*** counter;
}

-keep class org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$3 {
	*** this$0;
}

-keep class org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$5 {
	*** this$0;
}

-keep class org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$PacketProcessor {
	*** msg;
	*** this$0;
	org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$PacketProcessor(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient,org.jivesoftware.smack.packet.Message);
	*** addMappedServer();
	*** notifyListeners();
	*** toOfferAnswerMessage(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$TransactionData);
	*** toTransactionData();
}

-keep class org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$TransactionData {
	*** access$1000(org.littleshoot.commom.xmpp.ControlEndpointXmppP2PClient$TransactionData);
}

-keep class org.littleshoot.commom.xmpp.GenericIQProvider {
	org.littleshoot.commom.xmpp.GenericIQProvider();
	*** clearControlCharacters(java.lang.String);
	*** parseIQ(org.xmlpull.v1.XmlPullParser);
}

-keep class org.littleshoot.commom.xmpp.GenericIQProvider$1 {
	*** this$0;
	*** val$buf;
}

-keep class org.littleshoot.commom.xmpp.GoogleOAuth2Credentials {
	*** accessToken;
	*** clientID;
	*** clientSecret;
	*** log;
	*** refreshToken;
	*** resource;
	*** username;
	org.littleshoot.commom.xmpp.GoogleOAuth2Credentials(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.littleshoot.commom.xmpp.XmppConfig {
	*** connectionRetyStrategyFactory;
	*** useDnsSec;
	*** isUseDnsSec();
	*** newRetyStrategy();
	*** setRetyStrategyFactory(org.littleshoot.commom.xmpp.XmppConnectionRetyStrategyFactory);
}

-keep class org.littleshoot.commom.xmpp.XmppConnectionRetyStrategy {
	*** retry();
	*** sleep();
}

-keep class org.littleshoot.commom.xmpp.XmppConnectionRetyStrategyFactory {
	*** newStrategy();
}

-keep class org.littleshoot.commom.xmpp.XmppCredentials {
	*** createConnection(org.jivesoftware.smack.ConnectionConfiguration);
	*** getKey();
	*** getUsername();
	*** login(org.jivesoftware.smack.XMPPConnection);
}

-keep class org.littleshoot.commom.xmpp.XmppP2PClient {
	*** addMessageListener(org.jivesoftware.smack.MessageListener);
	*** getXmppConnection();
	*** handleClose();
	*** login(org.littleshoot.commom.xmpp.XmppCredentials);
}

-keep class org.littleshoot.commom.xmpp.XmppUtils {
	*** LOG;
	*** connectors;
	*** globalConfig;
	*** globalProxyConfig;
	*** xmppConnections;
	*** access$000(org.littleshoot.commom.xmpp.XmppCredentials,org.jivesoftware.smack.ConnectionConfiguration,org.littleshoot.commom.xmpp.XmppP2PClient);
	*** access$100();
	*** extractStunServers(java.lang.String);
	*** extractXmppProperty(org.w3c.dom.Document,java.lang.String);
	*** getGTalkProperty(org.jivesoftware.smack.XMPPConnection,java.lang.String);
	*** getGlobalConfig();
	*** getGlobalProxyConfig();
	*** getHost(java.lang.String);
	*** getOtr(org.jivesoftware.smack.XMPPConnection);
	*** getProxyConfig(org.jivesoftware.smack.ConnectionConfiguration,java.lang.Throwable);
	*** getSharedStatus(org.jivesoftware.smack.XMPPConnection);
	*** getVCard(org.jivesoftware.smack.XMPPConnection,java.lang.String);
	*** goOffTheRecord(java.lang.String,org.jivesoftware.smack.XMPPConnection);
	*** goOnTheRecord(java.lang.String,org.jivesoftware.smack.XMPPConnection);
	*** googleStunServers(org.jivesoftware.smack.XMPPConnection);
	*** isEstablished(org.jivesoftware.smack.XMPPConnection);
	*** jidToUser(java.lang.String);
	*** newConfig(java.net.InetAddress,int,java.lang.String);
	*** newConnection(org.littleshoot.commom.xmpp.XmppCredentials,org.jivesoftware.smack.ConnectionConfiguration,org.littleshoot.commom.xmpp.XmppP2PClient);
	*** persistentXmppConnection(java.lang.String,java.lang.String,java.lang.String,int);
	*** persistentXmppConnection(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,int,java.lang.String,org.littleshoot.commom.xmpp.XmppP2PClient);
	*** persistentXmppConnection(org.littleshoot.commom.xmpp.XmppCredentials,int,java.lang.String,int,java.lang.String,org.littleshoot.commom.xmpp.XmppP2PClient);
	*** sendXmppMessage(org.jivesoftware.smack.XMPPConnection,java.lang.String,org.jivesoftware.smack.packet.IQ$Type);
	*** setGTalkProperty(org.jivesoftware.smack.XMPPConnection,java.lang.String);
	*** setGlobalConfig(org.jivesoftware.smack.ConnectionConfiguration);
	*** setGlobalProxyConfig(org.jivesoftware.smack.ConnectionConfiguration);
	*** simpleGoogleTalkConnection(org.littleshoot.commom.xmpp.XmppCredentials);
	*** singleXmppConnection(org.littleshoot.commom.xmpp.XmppCredentials,java.lang.String,int,java.lang.String,org.littleshoot.commom.xmpp.XmppP2PClient);
	*** singleXmppConnection(org.littleshoot.commom.xmpp.XmppCredentials,java.lang.String,int,java.lang.String,org.littleshoot.commom.xmpp.XmppP2PClient,org.jivesoftware.smack.ConnectionConfiguration);
	*** toString(org.jivesoftware.smack.packet.Packet);
}

-keep class org.littleshoot.commom.xmpp.XmppUtils$2 {
	*** count;
}

-keep class org.littleshoot.commom.xmpp.XmppUtils$3 {
	*** val$clientListener;
	*** val$config;
	*** val$credentials;
	*** call();
}

-keep class org.littleshoot.commom.xmpp.XmppUtils$4 {
	*** createSocket(java.lang.String,int);
	*** createSocket(java.net.InetAddress,int);
}

-keep class org.littleshoot.commom.xmpp.XmppUtils$5 {
	*** val$clientListener;
	*** handleClose();
}

-keep class org.littleshoot.commom.xmpp.XmppUtils$6 {
	*** val$query;
}

-keep class org.littleshoot.dnssec4j.DnsSec {
	*** getByName(java.lang.String);
	*** verify(java.net.InetSocketAddress);
}

-keep class org.littleshoot.dnssec4j.VerifiedAddressFactory {
	*** newInetSocketAddress(java.lang.String,int,boolean);
	*** newVerifiedInetAddress(java.lang.String,boolean);
}

-keep class org.littleshoot.dnssec4j.VerifiedSocketFactory {
	*** delegate;
}

-keep class org.littleshoot.mina.common.ByteBuffer {
	*** allocator;
	*** primitiveTypeNames;
	*** useDirectBuffers;
	org.littleshoot.mina.common.ByteBuffer();
	*** access$000();
	*** acquire();
	*** allocate(int);
	*** allocate(int,boolean);
	*** array();
	*** arrayOffset();
	*** asCharBuffer();
	*** asDoubleBuffer();
	*** asFloatBuffer();
	*** asInputStream();
	*** asIntBuffer();
	*** asLongBuffer();
	*** asOutputStream();
	*** asReadOnlyBuffer();
	*** asShortBuffer();
	*** autoExpand(int);
	*** autoExpand(int,int);
	*** buf();
	*** capacity();
	*** capacity(int);
	*** checkFieldSize(int);
	*** clear();
	*** compact();
	*** compareTo(org.littleshoot.mina.common.ByteBuffer);
	*** duplicate();
	*** equals(java.lang.Object);
	*** expand(int);
	*** expand(int,int);
	*** fill(byte,int);
	*** fill(int);
	*** fillAndReset(byte,int);
	*** fillAndReset(int);
	*** flip();
	*** get();
	*** get(byte[]);
	*** get(byte[],int,int);
	*** get(int);
	*** getAllocator();
	*** getChar();
	*** getChar(int);
	*** getDouble();
	*** getDouble(int);
	*** getFloat();
	*** getFloat(int);
	*** getHexDump();
	*** getInt();
	*** getInt(int);
	*** getLong();
	*** getLong(int);
	*** getObject();
	*** getObject(java.lang.ClassLoader);
	*** getPrefixedString(int,java.nio.charset.CharsetDecoder);
	*** getPrefixedString(java.nio.charset.CharsetDecoder);
	*** getShort();
	*** getShort(int);
	*** getString(int,java.nio.charset.CharsetDecoder);
	*** getString(java.nio.charset.CharsetDecoder);
	*** getUnsigned();
	*** getUnsigned(int);
	*** getUnsignedInt();
	*** getUnsignedInt(int);
	*** getUnsignedShort();
	*** getUnsignedShort(int);
	*** hasRemaining();
	*** hashCode();
	*** isAutoExpand();
	*** isDirect();
	*** isPooled();
	*** isReadOnly();
	*** limit();
	*** limit(int);
	*** mark();
	*** markValue();
	*** order();
	*** order(java.nio.ByteOrder);
	*** position();
	*** position(int);
	*** prefixedDataAvailable(int);
	*** prefixedDataAvailable(int,int);
	*** put(byte);
	*** put(byte[]);
	*** put(byte[],int,int);
	*** put(int,byte);
	*** put(java.nio.ByteBuffer);
	*** put(org.littleshoot.mina.common.ByteBuffer);
	*** putChar(char);
	*** putChar(int,char);
	*** putDouble(double);
	*** putDouble(int,double);
	*** putFloat(float);
	*** putFloat(int,float);
	*** putInt(int);
	*** putInt(int,int);
	*** putLong(int,long);
	*** putLong(long);
	*** putObject(java.lang.Object);
	*** putPrefixedString(java.lang.CharSequence,int,int,byte,java.nio.charset.CharsetEncoder);
	*** putPrefixedString(java.lang.CharSequence,int,int,java.nio.charset.CharsetEncoder);
	*** putPrefixedString(java.lang.CharSequence,int,java.nio.charset.CharsetEncoder);
	*** putPrefixedString(java.lang.CharSequence,java.nio.charset.CharsetEncoder);
	*** putShort(int,short);
	*** putShort(short);
	*** putString(java.lang.CharSequence,int,java.nio.charset.CharsetEncoder);
	*** putString(java.lang.CharSequence,java.nio.charset.CharsetEncoder);
	*** release();
	*** remaining();
	*** reset();
	*** rewind();
	*** setAllocator(org.littleshoot.mina.common.ByteBufferAllocator);
	*** setAutoExpand(boolean);
	*** setPooled(boolean);
	*** setUseDirectBuffers(boolean);
	*** skip(int);
	*** slice();
	*** sweep();
	*** sweep(byte);
	*** toString();
	*** wrap(byte[]);
	*** wrap(java.nio.ByteBuffer);
}

-keep class org.littleshoot.mina.common.ByteBuffer$1 {
	*** this$0;
}

-keep class org.littleshoot.mina.common.ByteBuffer$2 {
	*** this$0;
}

-keep class org.littleshoot.mina.common.ByteBuffer$3 {
	*** this$0;
	*** val$classLoader;
}

-keep class org.littleshoot.mina.common.ByteBuffer$4 {
	*** this$0;
}

-keep class org.littleshoot.mina.common.ByteBufferAllocator {
	*** allocate(int,boolean);
	*** dispose();
	*** wrap(java.nio.ByteBuffer);
}

-keep class org.littleshoot.mina.common.ByteBufferProxy {
	*** buf;
	org.littleshoot.mina.common.ByteBufferProxy(org.littleshoot.mina.common.ByteBuffer);
	*** compareTo(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.mina.common.CloseFuture {
	*** isClosed();
	*** setClosed();
}

-keep class org.littleshoot.mina.common.ConnectFuture {
	*** getSession();
	*** setException(java.lang.Throwable);
	*** setSession(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.DefaultIoFilterChainBuilder {
	*** entries;
	*** addLast(java.lang.String,org.littleshoot.mina.common.IoFilter);
	*** checkBaseName(java.lang.String);
	*** clear();
	*** contains(java.lang.String);
	*** getAll();
	*** getEntry(java.lang.String);
	*** register(int,org.littleshoot.mina.common.IoFilterChain$Entry);
}

-keep class org.littleshoot.mina.common.DefaultIoFilterChainBuilder$EntryImpl {
	*** filter;
	*** name;
	org.littleshoot.mina.common.DefaultIoFilterChainBuilder$EntryImpl(java.lang.String,org.littleshoot.mina.common.IoFilter);
	*** getName();
}

-keep class org.littleshoot.mina.common.ExceptionMonitor {
	*** exceptionCaught(java.lang.Throwable);
	*** getInstance();
}

-keep class org.littleshoot.mina.common.ExecutorThreadModel {
	*** defaultFilter;
	*** filter;
	*** service2model;
	*** threadNamePrefix;
	*** access$000(org.littleshoot.mina.common.ExecutorThreadModel);
	*** getInstance(java.lang.String);
	*** setExecutor(java.util.concurrent.Executor);
}

-keep class org.littleshoot.mina.common.ExecutorThreadModel$1 {
	*** this$0;
	*** threadId;
	*** val$originalThreadFactory;
}

-keep class org.littleshoot.mina.common.ExpiringSessionRecycler {
	*** mapExpirer;
	*** sessionMap;
	org.littleshoot.mina.common.ExpiringSessionRecycler(int);
	org.littleshoot.mina.common.ExpiringSessionRecycler(int,int);
	*** generateKey(java.net.SocketAddress,java.net.SocketAddress);
	*** generateKey(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.ExpiringSessionRecycler$DefaultExpirationListener {
	*** this$0;
	org.littleshoot.mina.common.ExpiringSessionRecycler$DefaultExpirationListener(org.littleshoot.mina.common.ExpiringSessionRecycler);
	*** expired(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.IdleStatus {
	*** BOTH_IDLE;
	*** READER_IDLE;
	*** WRITER_IDLE;
	*** strValue;
}

-keep class org.littleshoot.mina.common.IoAcceptor {
	*** unbindAll();
}

-keep class org.littleshoot.mina.common.IoAcceptorConfig {
	*** isDisconnectOnUnbind();
}

-keep class org.littleshoot.mina.common.IoConnector {
	*** connect(java.net.SocketAddress,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler);
	*** connect(java.net.SocketAddress,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** connect(java.net.SocketAddress,org.littleshoot.mina.common.IoHandler);
	*** connect(java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
}

-keep class org.littleshoot.mina.common.IoFilter {
	*** exceptionCaught(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** filterClose(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession);
	*** filterWrite(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** messageReceived(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** messageSent(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** onPostAdd(org.littleshoot.mina.common.IoFilterChain,java.lang.String,org.littleshoot.mina.common.IoFilter$NextFilter);
	*** onPostRemove(org.littleshoot.mina.common.IoFilterChain,java.lang.String,org.littleshoot.mina.common.IoFilter$NextFilter);
	*** onPreAdd(org.littleshoot.mina.common.IoFilterChain,java.lang.String,org.littleshoot.mina.common.IoFilter$NextFilter);
	*** onPreRemove(org.littleshoot.mina.common.IoFilterChain,java.lang.String,org.littleshoot.mina.common.IoFilter$NextFilter);
	*** sessionClosed(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession);
	*** sessionCreated(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession);
	*** sessionIdle(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IdleStatus);
	*** sessionOpened(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.IoFilter$NextFilter {
	*** exceptionCaught(org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** filterClose(org.littleshoot.mina.common.IoSession);
	*** filterWrite(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** messageReceived(org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** messageSent(org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** sessionClosed(org.littleshoot.mina.common.IoSession);
	*** sessionCreated(org.littleshoot.mina.common.IoSession);
	*** sessionIdle(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IdleStatus);
	*** sessionOpened(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.IoFilter$WriteRequest {
	*** UNUSED_FUTURE;
	*** destination;
	*** future;
	*** message;
	org.littleshoot.mina.common.IoFilter$WriteRequest(java.lang.Object,org.littleshoot.mina.common.WriteFuture,java.net.SocketAddress);
	*** getDestination();
	*** getFuture();
	*** getMessage();
}

-keep class org.littleshoot.mina.common.IoFilterAdapter {
	org.littleshoot.mina.common.IoFilterAdapter();
}

-keep class org.littleshoot.mina.common.IoFilterChain {
	*** addFirst(java.lang.String,org.littleshoot.mina.common.IoFilter);
	*** addLast(java.lang.String,org.littleshoot.mina.common.IoFilter);
	*** clear();
	*** contains(java.lang.Class);
	*** fireExceptionCaught(org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** fireMessageReceived(org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** fireMessageSent(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** fireSessionClosed(org.littleshoot.mina.common.IoSession);
	*** fireSessionCreated(org.littleshoot.mina.common.IoSession);
	*** fireSessionOpened(org.littleshoot.mina.common.IoSession);
	*** getSession();
}

-keep class org.littleshoot.mina.common.IoFilterChain$Entry {
	*** getFilter();
	*** getName();
	*** getNextFilter();
}

-keep class org.littleshoot.mina.common.IoFilterChainBuilder {
	*** buildFilterChain(org.littleshoot.mina.common.IoFilterChain);
}

-keep class org.littleshoot.mina.common.IoFuture {
	*** addListener(org.littleshoot.mina.common.IoFutureListener);
	*** getSession();
	*** join();
	*** join(long);
}

-keep class org.littleshoot.mina.common.IoFutureListener {
	*** operationComplete(org.littleshoot.mina.common.IoFuture);
}

-keep class org.littleshoot.mina.common.IoHandler {
	*** exceptionCaught(org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** messageReceived(org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** messageSent(org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** sessionClosed(org.littleshoot.mina.common.IoSession);
	*** sessionCreated(org.littleshoot.mina.common.IoSession);
	*** sessionIdle(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IdleStatus);
	*** sessionOpened(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.IoHandlerAdapter {
	org.littleshoot.mina.common.IoHandlerAdapter();
}

-keep class org.littleshoot.mina.common.IoService {
	*** addListener(org.littleshoot.mina.common.IoServiceListener);
	*** getDefaultConfig();
	*** getFilterChain();
	*** getFilterChainBuilder();
	*** getManagedServiceAddresses();
	*** getManagedSessions(java.net.SocketAddress);
	*** isManaged(java.net.SocketAddress);
	*** removeListener(org.littleshoot.mina.common.IoServiceListener);
	*** setFilterChainBuilder(org.littleshoot.mina.common.IoFilterChainBuilder);
}

-keep class org.littleshoot.mina.common.IoServiceConfig {
	*** getFilterChainBuilder();
	*** getSessionConfig();
	*** getThreadModel();
	*** setThreadModel(org.littleshoot.mina.common.ThreadModel);
}

-keep class org.littleshoot.mina.common.IoServiceListener {
	*** serviceActivated(org.littleshoot.mina.common.IoService,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** serviceDeactivated(org.littleshoot.mina.common.IoService,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** sessionCreated(org.littleshoot.mina.common.IoSession);
	*** sessionDestroyed(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.IoSession {
	*** close();
	*** getAttribute(java.lang.String);
	*** getCloseFuture();
	*** getConfig();
	*** getFilterChain();
	*** getHandler();
	*** getLocalAddress();
	*** getRemoteAddress();
	*** getService();
	*** getServiceAddress();
	*** getServiceConfig();
	*** getTrafficMask();
	*** getTransportType();
	*** getWrittenBytes();
	*** isClosing();
	*** isConnected();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
	*** setIdleTime(org.littleshoot.mina.common.IdleStatus,int);
	*** write(java.lang.Object);
}

-keep class org.littleshoot.mina.common.IoSessionRecycler {
	*** put(org.littleshoot.mina.common.IoSession);
	*** recycle(java.net.SocketAddress,java.net.SocketAddress);
	*** remove(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.common.PooledByteBufferAllocator {
	*** directBufferStacks;
	*** disposed;
	*** expirer;
	*** heapBufferStacks;
	*** threadId;
	*** timeout;
	org.littleshoot.mina.common.PooledByteBufferAllocator(int);
	*** access$108();
	*** access$200(org.littleshoot.mina.common.PooledByteBufferAllocator);
	*** access$300(org.littleshoot.mina.common.PooledByteBufferAllocator);
	*** access$400(org.littleshoot.mina.common.PooledByteBufferAllocator);
	*** access$500(org.littleshoot.mina.common.PooledByteBufferAllocator);
	*** access$600(org.littleshoot.mina.common.PooledByteBufferAllocator,int,boolean);
	*** allocate0(int,boolean);
	*** allocateContainer();
	*** ensureNotDisposed();
	*** getBufferStackIndex(org.littleshoot.mina.util.ExpiringStack[],int);
	*** getTimeoutMillis();
	*** release0(org.littleshoot.mina.common.PooledByteBufferAllocator$UnexpandableByteBuffer);
	*** setTimeout(int);
}

-keep class org.littleshoot.mina.common.PooledByteBufferAllocator$Expirer {
	*** this$0;
	*** timeToStop;
	*** shutdown();
}

-keep class org.littleshoot.mina.common.PooledByteBufferAllocator$PooledByteBuffer {
	*** buf;
	*** refCount;
	*** this$0;
	*** access$000(org.littleshoot.mina.common.PooledByteBufferAllocator$PooledByteBuffer);
	*** buf();
	*** init(org.littleshoot.mina.common.PooledByteBufferAllocator$UnexpandableByteBuffer,boolean);
	*** setPooled(boolean);
}

-keep class org.littleshoot.mina.common.PooledByteBufferAllocator$UnexpandableByteBuffer {
	*** buf();
	*** init();
	*** isDerived();
	*** isPooled();
	*** release();
	*** setPooled(boolean);
}

-keep class org.littleshoot.mina.common.SimpleByteBufferAllocator$SimpleByteBuffer {
	*** buf;
	*** refCount;
}

-keep class org.littleshoot.mina.common.TrafficMask {
	*** ALL;
	*** NONE;
	*** READ;
	*** WRITE;
	*** interestOps;
	*** name;
	*** and(org.littleshoot.mina.common.TrafficMask);
	*** getInstance(int);
	*** getInterestOps();
	*** isReadable();
	*** isWritable();
	*** not();
	*** or(org.littleshoot.mina.common.TrafficMask);
}

-keep class org.littleshoot.mina.common.TransportType {
	*** DATAGRAM;
	*** SOCKET;
	*** VM_PIPE;
	*** connectionless;
	*** envelopeType;
	*** name2type;
	*** names;
	org.littleshoot.mina.common.TransportType(java.lang.String[],java.lang.Class,boolean);
	*** getEnvelopeType();
	*** getInstance(java.lang.String);
	*** isConnectionless();
	*** register(java.lang.String[],org.littleshoot.mina.common.TransportType);
}

-keep class org.littleshoot.mina.common.WriteFuture {
	*** setWritten(boolean);
}

-keep class org.littleshoot.mina.common.support.AbstractIoFilterChain {
	*** CONNECT_FUTURE;
	*** head;
	*** name2entry;
	*** session;
	*** tail;
	org.littleshoot.mina.common.support.AbstractIoFilterChain(org.littleshoot.mina.common.IoSession);
	*** access$1000(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** access$1100(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** access$1200(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** access$1300(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** access$1400(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** access$600(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** access$700(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** access$800(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** access$900(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IdleStatus);
	*** callNextExceptionCaught(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** callNextMessageReceived(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** callNextMessageSent(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** callNextSessionClosed(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** callNextSessionCreated(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** callNextSessionIdle(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IdleStatus);
	*** callNextSessionOpened(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** callPreviousFilterClose(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession);
	*** callPreviousFilterWrite(org.littleshoot.mina.common.IoFilterChain$Entry,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** checkAddable(java.lang.String);
	*** checkOldName(java.lang.String);
	*** clear();
	*** deregister(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** deregister0(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** doClose(org.littleshoot.mina.common.IoSession);
	*** doWrite(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** fireExceptionCaught(org.littleshoot.mina.common.IoSession,java.lang.Throwable);
	*** fireFilterClose(org.littleshoot.mina.common.IoSession);
	*** fireFilterWrite(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$WriteRequest);
	*** getEntry(java.lang.String);
	*** getSession();
	*** register(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl,java.lang.String,org.littleshoot.mina.common.IoFilter);
	*** remove(java.lang.String);
}

-keep class org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl {
	*** filter;
	*** name;
	*** nextEntry;
	*** nextFilter;
	*** prevEntry;
	*** this$0;
	org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl(org.littleshoot.mina.common.support.AbstractIoFilterChain,org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl,org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl,java.lang.String,org.littleshoot.mina.common.IoFilter);
	*** access$300(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** access$302(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl,org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** access$400(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** access$402(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl,org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** access$500(org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl);
	*** getFilter();
	*** getName();
	*** getNextFilter();
}

-keep class org.littleshoot.mina.common.support.AbstractIoFilterChain$EntryImpl$1 {
	*** this$1;
	*** val$this$0;
}

-keep class org.littleshoot.mina.common.support.AbstractIoFilterChain$HeadFilter {
	*** this$0;
	org.littleshoot.mina.common.support.AbstractIoFilterChain$HeadFilter(org.littleshoot.mina.common.support.AbstractIoFilterChain);
}

-keep class org.littleshoot.mina.common.support.AbstractIoFilterChain$TailFilter {
	org.littleshoot.mina.common.support.AbstractIoFilterChain$TailFilter();
}

-keep class org.littleshoot.mina.common.support.BaseByteBuffer {
	*** autoExpand;
	*** mark;
	org.littleshoot.mina.common.support.BaseByteBuffer();
	*** capacity();
	*** capacity(int);
	*** capacity0(int);
	*** isDirect();
	*** limit();
	*** order();
	*** position();
	*** setAutoExpand(boolean);
}

-keep class org.littleshoot.mina.common.support.BaseIoConnector {
	org.littleshoot.mina.common.support.BaseIoConnector();
}

-keep class org.littleshoot.mina.common.support.BaseIoConnectorConfig {
	*** connectTimeout;
	org.littleshoot.mina.common.support.BaseIoConnectorConfig();
}

-keep class org.littleshoot.mina.common.support.BaseIoService {
	*** filterChainBuilder;
	*** listeners;
	org.littleshoot.mina.common.support.BaseIoService();
	*** getFilterChainBuilder();
	*** getListeners();
}

-keep class org.littleshoot.mina.common.support.BaseIoServiceConfig {
	*** defaultThreadModel;
	*** filterChainBuilder;
	*** threadModel;
	org.littleshoot.mina.common.support.BaseIoServiceConfig();
	*** clone();
	*** getDefaultThreadModel();
	*** setThreadModel(org.littleshoot.mina.common.ThreadModel);
}

-keep class org.littleshoot.mina.common.support.BaseIoSession {
	*** SCHEDULED_COUNTER_RESETTER;
	*** attributes;
	*** closeFuture;
	*** closing;
	*** creationTime;
	*** idleCountForBoth;
	*** idleCountForRead;
	*** idleCountForWrite;
	*** idleTimeForBoth;
	*** idleTimeForRead;
	*** idleTimeForWrite;
	*** lastIdleTimeForBoth;
	*** lastIdleTimeForRead;
	*** lastIdleTimeForWrite;
	*** lastReadTime;
	*** lastWriteTime;
	*** lock;
	*** readBytes;
	*** readMessages;
	*** scheduledForFlush;
	*** scheduledWriteBytes;
	*** scheduledWriteRequests;
	*** trafficMask;
	*** writeTimeout;
	*** writtenBytes;
	*** writtenMessages;
	org.littleshoot.mina.common.support.BaseIoSession();
	*** access$000(org.littleshoot.mina.common.support.BaseIoSession);
	*** access$100(org.littleshoot.mina.common.support.BaseIoSession);
	*** close0();
	*** getAttribute(java.lang.String);
	*** getCloseFuture();
	*** getIdleTime(org.littleshoot.mina.common.IdleStatus);
	*** getTrafficMask();
	*** increaseReadBytes(int);
	*** increaseReadMessages();
	*** increaseScheduledWriteBytes(int);
	*** increaseScheduledWriteRequests();
	*** increaseWrittenBytes(int);
	*** increaseWrittenMessages();
	*** isClosing();
	*** isScheduledForFlush();
	*** removeAttribute(java.lang.String);
	*** setAttribute(java.lang.String,java.lang.Object);
	*** setScheduledForFlush(boolean);
	*** setTrafficMask(org.littleshoot.mina.common.TrafficMask);
	*** updateTrafficMask();
	*** write(java.lang.Object,java.net.SocketAddress);
	*** write0(org.littleshoot.mina.common.IoFilter$WriteRequest);
}

-keep class org.littleshoot.mina.common.support.BaseIoSessionConfig {
	org.littleshoot.mina.common.support.BaseIoSessionConfig();
}

-keep class org.littleshoot.mina.common.support.ByteBufferHexDumper {
	*** getHexdump(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.mina.common.support.DefaultConnectFuture {
	org.littleshoot.mina.common.support.DefaultConnectFuture();
	*** newFailedFuture(java.lang.Throwable);
	*** setException(java.lang.Throwable);
}

-keep class org.littleshoot.mina.common.support.DefaultIoFuture {
	*** firstListener;
	*** lock;
	*** otherListeners;
	*** ready;
	*** result;
	*** session;
	*** waiters;
	org.littleshoot.mina.common.support.DefaultIoFuture(org.littleshoot.mina.common.IoSession);
	org.littleshoot.mina.common.support.DefaultIoFuture(org.littleshoot.mina.common.IoSession,java.lang.Object);
	*** await0(long,boolean);
	*** awaitUninterruptibly();
	*** awaitUninterruptibly(long);
	*** getValue();
	*** isReady();
	*** notifyListener(org.littleshoot.mina.common.IoFutureListener);
	*** notifyListeners();
	*** setValue(java.lang.Object);
}

-keep class org.littleshoot.mina.common.support.DefaultWriteFuture {
	*** newNotWrittenFuture(org.littleshoot.mina.common.IoSession);
	*** setWritten(boolean);
}

-keep class org.littleshoot.mina.common.support.DelegatedIoConnector {
	*** delegate;
	org.littleshoot.mina.common.support.DelegatedIoConnector();
	*** getDefaultConfig();
	*** init(org.littleshoot.mina.common.IoConnector);
}

-keep class org.littleshoot.mina.common.support.IoServiceListenerSupport {
	*** listeners;
	*** managedServiceAddresses;
	*** managedSessions;
	*** add(org.littleshoot.mina.common.IoServiceListener);
	*** disconnectSessions(java.net.SocketAddress,org.littleshoot.mina.common.IoServiceConfig);
	*** fireServiceActivated(org.littleshoot.mina.common.IoService,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** fireServiceDeactivated(org.littleshoot.mina.common.IoService,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** fireSessionCreated(org.littleshoot.mina.common.IoSession);
	*** fireSessionDestroyed(org.littleshoot.mina.common.IoSession);
	*** getManagedServiceAddresses();
	*** getManagedSessions(java.net.SocketAddress);
	*** isManaged(java.net.SocketAddress);
	*** remove(org.littleshoot.mina.common.IoServiceListener);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolCodecException {
	org.littleshoot.mina.filter.codec.ProtocolCodecException();
	org.littleshoot.mina.filter.codec.ProtocolCodecException(java.lang.String);
	org.littleshoot.mina.filter.codec.ProtocolCodecException(java.lang.String,java.lang.Throwable);
	org.littleshoot.mina.filter.codec.ProtocolCodecException(java.lang.Throwable);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolCodecFactory {
	*** getDecoder();
	*** getEncoder();
}

-keep class org.littleshoot.mina.filter.codec.ProtocolCodecFilter {
	*** DECODER;
	*** DECODER_OUT;
	*** EMPTY_BUFFER;
	*** EMPTY_PARAMS;
	*** ENCODER;
	*** factory;
	*** access$200();
	*** disposeDecoder(org.littleshoot.mina.common.IoSession);
	*** disposeDecoderOut(org.littleshoot.mina.common.IoSession);
	*** disposeEncoder(org.littleshoot.mina.common.IoSession);
	*** getDecoder(org.littleshoot.mina.common.IoSession);
	*** getDecoderOut(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$NextFilter);
	*** getEncoder(org.littleshoot.mina.common.IoSession);
	*** getEncoderOut(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoFilter$WriteRequest);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolCodecFilter$HiddenByteBuffer {
	org.littleshoot.mina.filter.codec.ProtocolCodecFilter$HiddenByteBuffer(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolCodecFilter$MessageByteBuffer {
	*** message;
	org.littleshoot.mina.filter.codec.ProtocolCodecFilter$MessageByteBuffer(java.lang.Object);
	*** access$000(org.littleshoot.mina.filter.codec.ProtocolCodecFilter$MessageByteBuffer);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolCodecFilter$ProtocolEncoderOutputImpl {
	*** nextFilter;
	*** session;
	*** writeRequest;
}

-keep class org.littleshoot.mina.filter.codec.ProtocolDecoder {
	*** decode(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.common.ByteBuffer,org.littleshoot.mina.filter.codec.ProtocolDecoderOutput);
	*** dispose(org.littleshoot.mina.common.IoSession);
	*** finishDecode(org.littleshoot.mina.common.IoSession,org.littleshoot.mina.filter.codec.ProtocolDecoderOutput);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolDecoderException {
	*** hexdump;
	*** getHexdump();
	*** setHexdump(java.lang.String);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolDecoderOutput {
	*** flush();
	*** write(java.lang.Object);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolEncoder {
	*** dispose(org.littleshoot.mina.common.IoSession);
	*** encode(org.littleshoot.mina.common.IoSession,java.lang.Object,org.littleshoot.mina.filter.codec.ProtocolEncoderOutput);
}

-keep class org.littleshoot.mina.filter.codec.ProtocolEncoderOutput {
	*** write(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.mina.filter.codec.support.SimpleProtocolDecoderOutput {
	*** messageQueue;
	*** nextFilter;
	*** session;
}

-keep class org.littleshoot.mina.filter.codec.support.SimpleProtocolEncoderOutput {
	*** bufferQueue;
	org.littleshoot.mina.filter.codec.support.SimpleProtocolEncoderOutput();
	*** doFlush(org.littleshoot.mina.common.ByteBuffer);
	*** flush();
}

-keep class org.littleshoot.mina.filter.executor.ExecutorFilter {
	*** executor;
	*** logger;
	org.littleshoot.mina.filter.executor.ExecutorFilter(java.util.concurrent.Executor);
	*** access$400(org.littleshoot.mina.filter.executor.ExecutorFilter);
	*** fireEvent(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.filter.executor.ExecutorFilter$EventType,java.lang.Object);
	*** getExecutor();
	*** processEvent(org.littleshoot.mina.common.IoFilter$NextFilter,org.littleshoot.mina.common.IoSession,org.littleshoot.mina.filter.executor.ExecutorFilter$EventType,java.lang.Object);
}

-keep class org.littleshoot.mina.filter.executor.ExecutorFilter$Event {
	*** data;
	*** nextFilter;
	*** type;
	*** getData();
	*** getNextFilter();
	*** getType();
}

-keep class org.littleshoot.mina.filter.executor.ExecutorFilter$EventType {
	*** CLOSED;
	*** EXCEPTION;
	*** IDLE;
	*** OPENED;
	*** READ;
	*** RECEIVED;
	*** SENT;
	*** WRITTEN;
	*** value;
}

-keep class org.littleshoot.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable {
	*** buffer;
	*** this$0;
}

-keep class org.littleshoot.mina.filter.executor.ExecutorFilter$SessionBuffer {
	*** KEY;
	*** eventQueue;
	*** processingCompleted;
	*** session;
	*** access$000(org.littleshoot.mina.common.IoSession);
	*** access$100(org.littleshoot.mina.filter.executor.ExecutorFilter$SessionBuffer);
	*** access$200(org.littleshoot.mina.filter.executor.ExecutorFilter$SessionBuffer);
	*** access$202(org.littleshoot.mina.filter.executor.ExecutorFilter$SessionBuffer,boolean);
	*** access$300(org.littleshoot.mina.filter.executor.ExecutorFilter$SessionBuffer);
	*** getSessionBuffer(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.mina.transport.socket.nio.DatagramConnector {
	*** getDefaultConfig();
}

-keep class org.littleshoot.mina.transport.socket.nio.DatagramConnectorConfig {
	*** DEFAULT_RECYCLER;
	*** sessionConfig;
	*** sessionRecycler;
	*** getSessionConfig();
	*** getSessionRecycler();
}

-keep class org.littleshoot.mina.transport.socket.nio.DatagramServiceConfig {
	*** getSessionRecycler();
}

-keep class org.littleshoot.mina.transport.socket.nio.DatagramSessionConfig {
	*** getReceiveBufferSize();
	*** getSendBufferSize();
	*** getTrafficClass();
	*** isBroadcast();
	*** isReuseAddress();
	*** setBroadcast(boolean);
	*** setReceiveBufferSize(int);
	*** setReuseAddress(boolean);
	*** setSendBufferSize(int);
	*** setTrafficClass(int);
}

-keep class org.littleshoot.mina.transport.socket.nio.SocketSessionConfig {
	*** setKeepAlive(boolean);
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramAcceptorDelegate {
	*** getListeners();
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate {
	*** cancelQueue;
	*** defaultConfig;
	*** executor;
	*** flushingSessions;
	*** id;
	*** lock;
	*** nextId;
	*** registerQueue;
	*** selector;
	*** trafficControllingSessions;
	*** worker;
	*** wrapper;
	*** access$1000(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$1102(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate,org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$Worker);
	*** access$200(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$202(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate,java.nio.channels.Selector);
	*** access$300(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$400(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$500(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate,java.util.Set);
	*** access$600(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$700(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$800(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** access$900(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
	*** buildFilterChain(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$RegistrationRequest,org.littleshoot.mina.common.IoSession);
	*** cancelKeys();
	*** connect(java.net.SocketAddress,java.net.SocketAddress,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** doUpdateTrafficMask();
	*** flush(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** flushSessions();
	*** getDefaultConfig();
	*** getSessionRecycler(org.littleshoot.mina.common.IoSession);
	*** processReadySessions(java.util.Set);
	*** readSession(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** registerNew();
	*** scheduleFlush(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** scheduleTrafficControl(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** setDefaultConfig(org.littleshoot.mina.transport.socket.nio.DatagramConnectorConfig);
	*** startupWorker();
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$RegistrationRequest {
	*** channel;
	*** config;
	*** handler;
	org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$RegistrationRequest(java.nio.channels.DatagramChannel,org.littleshoot.mina.common.IoHandler,org.littleshoot.mina.common.IoServiceConfig);
	*** access$1200(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$RegistrationRequest);
	*** access$1300(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$RegistrationRequest);
	*** access$1400(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$RegistrationRequest);
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$Worker {
	*** this$0;
	org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate$Worker(org.littleshoot.mina.transport.socket.nio.support.DatagramConnectorDelegate);
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramService {
	*** closeSession(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** flushSession(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** updateTrafficMask(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramSessionConfigImpl {
	*** DEFAULT_BROADCAST;
	*** DEFAULT_RECEIVE_BUFFER_SIZE;
	*** DEFAULT_REUSE_ADDRESS;
	*** DEFAULT_SEND_BUFFER_SIZE;
	*** DEFAULT_TRAFFIC_CLASS;
	*** GET_TRAFFIC_CLASS_AVAILABLE;
	*** SET_RECEIVE_BUFFER_SIZE_AVAILABLE;
	*** SET_SEND_BUFFER_SIZE_AVAILABLE;
	*** SET_TRAFFIC_CLASS_AVAILABLE;
	*** broadcast;
	*** receiveBufferSize;
	*** reuseAddress;
	*** sendBufferSize;
	*** trafficClass;
	org.littleshoot.mina.transport.socket.nio.support.DatagramSessionConfigImpl();
	*** initialize();
	*** isGetTrafficClassAvailable();
	*** isSetReceiveBufferSizeAvailable();
	*** isSetSendBufferSizeAvailable();
	*** isSetTrafficClassAvailable();
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl {
	*** ch;
	*** config;
	*** filterChain;
	*** handler;
	*** key;
	*** localAddress;
	*** managerDelegate;
	*** readBufferSize;
	*** remoteAddress;
	*** serviceAddress;
	*** serviceConfig;
	*** wrapperManager;
	*** writeRequestQueue;
	*** access$100(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
	*** access$202(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl,int);
	*** getChannel();
	*** getConfig();
	*** getFilterChain();
	*** getLocalAddress();
	*** getManagerDelegate();
	*** getReadBufferSize();
	*** getRemoteAddress();
	*** getSelectionKey();
	*** getServiceConfig();
	*** getWriteRequestQueue();
	*** setSelectionKey(java.nio.channels.SelectionKey);
}

-keep class org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl$SessionConfigImpl {
	*** this$0;
	org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl$SessionConfigImpl(org.littleshoot.mina.transport.socket.nio.support.DatagramSessionImpl);
}

-keep class org.littleshoot.mina.util.ByteBufferUtil {
	*** releaseIfPossible(java.lang.Object);
}

-keep class org.littleshoot.mina.util.ExpirationListener {
	*** expired(java.lang.Object);
}

-keep class org.littleshoot.mina.util.ExpiringMap {
	*** delegate;
	*** expirationListeners;
	*** expirer;
	*** expirerCount;
	org.littleshoot.mina.util.ExpiringMap(int,int);
	org.littleshoot.mina.util.ExpiringMap(java.util.concurrent.ConcurrentHashMap,java.util.concurrent.CopyOnWriteArrayList,int,int);
	*** access$008();
	*** access$100(org.littleshoot.mina.util.ExpiringMap);
	*** access$200(org.littleshoot.mina.util.ExpiringMap);
	*** addExpirationListener(org.littleshoot.mina.util.ExpirationListener);
	*** containsKey(java.lang.Object);
	*** get(java.lang.Object);
	*** getExpirationInterval();
	*** getExpirer();
	*** getTimeToLive();
	*** put(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** setExpirationInterval(int);
	*** setTimeToLive(int);
}

-keep class org.littleshoot.mina.util.ExpiringMap$Expirer {
	*** expirationIntervalMillis;
	*** expirerThread;
	*** running;
	*** stateLock;
	*** this$0;
	*** timeToLiveMillis;
	*** getExpirationInterval();
	*** getTimeToLive();
	*** processExpires();
	*** setExpirationInterval(long);
	*** setTimeToLive(long);
	*** startExpiringIfNotStarted();
	*** stopExpiring();
}

-keep class org.littleshoot.mina.util.ExpiringMap$ExpiringObject {
	*** key;
	*** lastAccessTime;
	*** lastAccessTimeLock;
	*** this$0;
	*** value;
	*** getKey();
	*** getLastAccessTime();
	*** getValue();
	*** setLastAccessTime(long);
}

-keep class org.littleshoot.mina.util.ExpiringStack {
	*** items;
	*** size;
	*** timestamps;
	*** clear();
	*** expireBefore(long);
	*** pop();
	*** push(java.lang.Object);
}

-keep class org.littleshoot.mina.util.IdentityHashSet {
	*** delegate;
}

-keep class org.littleshoot.mina.util.NamePreservingRunnable {
	*** logger;
	*** newName;
	*** runnable;
	*** setName(java.lang.Thread,java.lang.String);
}

-keep class org.littleshoot.mina.util.SessionLog {
	*** isWarnEnabled(org.littleshoot.mina.common.IoSession);
	*** warn(org.littleshoot.mina.common.IoSession,java.lang.String);
	*** warn(org.littleshoot.mina.common.IoSession,java.lang.String,java.lang.Throwable);
}

-keep class org.littleshoot.mina.util.SessionUtil {
	*** initialize(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.p2p.P2PEndpoints {
	*** log;
	*** emptyNatPmpService();
	*** emptyUpnpService();
	*** newIceOfferAnswerFactory(org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,org.lastbamboo.common.ice.MappedServerSocket,javax.net.SocketFactory,javax.net.ServerSocketFactory,boolean);
	*** newIceSocketOfferAnswerFactory(org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,org.lastbamboo.common.ice.MappedServerSocket,javax.net.SocketFactory,javax.net.ServerSocketFactory,boolean);
	*** newXmppP2PHttpClient(java.lang.String,org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,java.net.InetSocketAddress,javax.net.SocketFactory,javax.net.ServerSocketFactory,java.net.InetSocketAddress,org.littleshoot.util.SessionSocketListener,boolean,org.lastbamboo.common.offer.answer.OfferAnswerListener);
	*** newXmppP2PHttpClient(java.lang.String,org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,java.net.InetSocketAddress,javax.net.ssl.SSLSocketFactory,javax.net.ServerSocketFactory,java.net.InetSocketAddress,boolean,org.lastbamboo.common.offer.answer.OfferAnswerListener);
	*** newXmppP2PHttpClient(java.lang.String,org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,java.net.InetSocketAddress,org.lastbamboo.common.offer.answer.OfferAnswerListener);
	*** newXmppP2PHttpClient(java.lang.String,org.lastbamboo.common.portmapping.NatPmpService,org.lastbamboo.common.portmapping.UpnpService,org.lastbamboo.common.ice.MappedServerSocket,javax.net.SocketFactory,javax.net.ServerSocketFactory,java.net.InetSocketAddress,org.littleshoot.util.SessionSocketListener,boolean,org.lastbamboo.common.offer.answer.OfferAnswerListener);
}

-keep class org.littleshoot.p2p.P2PEndpoints$2 {
	*** getCandidate();
	*** getCandidates();
}

-keep class org.littleshoot.p2p.P2PEndpoints$3 {
	*** getCandidate();
}

-keep class org.littleshoot.p2p.P2PEndpoints$4 {
	*** getCandidate();
	*** getCandidates();
}

-keep class org.littleshoot.p2p.P2PEndpoints$5 {
	*** getCandidate();
}

-keep class org.littleshoot.proxy.ActivityTracker {
	*** bytesReceivedFromClient(org.littleshoot.proxy.FlowContext,int);
	*** bytesReceivedFromServer(org.littleshoot.proxy.FullFlowContext,int);
	*** bytesSentToClient(org.littleshoot.proxy.FlowContext,int);
	*** bytesSentToServer(org.littleshoot.proxy.FullFlowContext,int);
	*** clientConnected(java.net.InetSocketAddress);
	*** clientDisconnected(java.net.InetSocketAddress,javax.net.ssl.SSLSession);
	*** clientSSLHandshakeSucceeded(java.net.InetSocketAddress,javax.net.ssl.SSLSession);
	*** requestReceivedFromClient(org.littleshoot.proxy.FlowContext,io.netty.handler.codec.http.HttpRequest);
	*** requestSentToServer(org.littleshoot.proxy.FullFlowContext,io.netty.handler.codec.http.HttpRequest);
	*** responseReceivedFromServer(org.littleshoot.proxy.FullFlowContext,io.netty.handler.codec.http.HttpResponse);
	*** responseSentToClient(org.littleshoot.proxy.FlowContext,io.netty.handler.codec.http.HttpResponse);
}

-keep class org.littleshoot.proxy.ActivityTrackerAdapter {
	org.littleshoot.proxy.ActivityTrackerAdapter();
}

-keep class org.littleshoot.proxy.ChainedProxy {
	*** connectionFailed(java.lang.Throwable);
	*** connectionSucceeded();
	*** disconnected();
	*** getChainedProxyAddress();
	*** getLocalAddress();
	*** getTransportProtocol();
	*** requiresEncryption();
}

-keep class org.littleshoot.proxy.ChainedProxyAdapter {
	*** FALLBACK_TO_DIRECT_CONNECTION;
}

-keep class org.littleshoot.proxy.ChainedProxyManager {
	*** lookupChainedProxies(io.netty.handler.codec.http.HttpRequest,java.util.Queue);
}

-keep class org.littleshoot.proxy.FlowContext {
	*** clientAddress;
	*** clientSslSession;
	org.littleshoot.proxy.FlowContext(org.littleshoot.proxy.impl.ClientToProxyConnection);
	*** getClientAddress();
	*** getClientSslSession();
}

-keep class org.littleshoot.proxy.FullFlowContext {
	*** chainedProxy;
	*** serverHostAndPort;
	*** getChainedProxy();
}

-keep class org.littleshoot.proxy.HttpFilters {
	*** requestPost(io.netty.handler.codec.http.HttpObject);
	*** requestPre(io.netty.handler.codec.http.HttpObject);
	*** responsePost(io.netty.handler.codec.http.HttpObject);
	*** responsePre(io.netty.handler.codec.http.HttpObject);
}

-keep class org.littleshoot.proxy.HttpFiltersAdapter {
	*** originalRequest;
	org.littleshoot.proxy.HttpFiltersAdapter(io.netty.handler.codec.http.HttpRequest);
}

-keep class org.littleshoot.proxy.HttpFiltersSource {
	*** filterRequest(io.netty.handler.codec.http.HttpRequest);
	*** getMaximumRequestBufferSizeInBytes();
	*** getMaximumResponseBufferSizeInBytes();
}

-keep class org.littleshoot.proxy.HttpFiltersSourceAdapter {
	org.littleshoot.proxy.HttpFiltersSourceAdapter();
}

-keep class org.littleshoot.proxy.HttpProxyServer {
	*** clone();
	*** stop();
}

-keep class org.littleshoot.proxy.HttpProxyServerBootstrap {
	*** plusActivityTracker(org.littleshoot.proxy.ActivityTracker);
	*** start();
	*** withAddress(java.net.InetSocketAddress);
	*** withAllowLocalOnly(boolean);
	*** withAuthenticateSslClients(boolean);
	*** withChainProxyManager(org.littleshoot.proxy.ChainedProxyManager);
	*** withFiltersSource(org.littleshoot.proxy.HttpFiltersSource);
	*** withListenOnAllAddresses(boolean);
	*** withName(java.lang.String);
	*** withPort(int);
	*** withSslEngineSource(org.littleshoot.proxy.SslEngineSource);
	*** withTransportProtocol(org.littleshoot.proxy.TransportProtocol);
}

-keep class org.littleshoot.proxy.MitmManager {
	*** clientSslEngineFor(javax.net.ssl.SSLSession);
	*** serverSslEngine();
}

-keep class org.littleshoot.proxy.ProxyAuthenticator {
	*** authenticate(java.lang.String,java.lang.String);
}

-keep class org.littleshoot.proxy.SslEngineSource {
	*** newSslEngine();
}

-keep class org.littleshoot.proxy.TransportProtocol {
	*** $VALUES;
	*** TCP;
	*** UDT;
	*** values();
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection {
	*** CONNECTION_ESTABLISHED;
	*** HOP_BY_HOP_HEADERS;
	*** RespondCONNECTSuccessful;
	*** bytesReadMonitor;
	*** bytesWrittenMonitor;
	*** clientSslSession;
	*** currentFilters;
	*** currentServerConnection;
	*** mitming;
	*** numberOfCurrentlyConnectedServers;
	*** numberOfCurrentlyConnectingServers;
	*** numberOfReusedServerConnections;
	*** requestReadMonitor;
	*** responseWrittenMonitor;
	*** serverConnectionsByHostAndPort;
	*** access$002(org.littleshoot.proxy.impl.ClientToProxyConnection,javax.net.ssl.SSLSession);
	*** access$100(org.littleshoot.proxy.impl.ClientToProxyConnection);
	*** access$200();
	*** access$300(org.littleshoot.proxy.impl.ClientToProxyConnection,io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpResponseStatus);
	*** access$400(org.littleshoot.proxy.impl.ClientToProxyConnection);
	*** authenticationRequired(io.netty.handler.codec.http.HttpRequest);
	*** closeConnectionsAfterWriteIfNecessary(org.littleshoot.proxy.impl.ProxyToServerConnection,io.netty.handler.codec.http.HttpRequest,io.netty.handler.codec.http.HttpResponse,io.netty.handler.codec.http.HttpObject);
	*** connectionFailedUnrecoverably(io.netty.handler.codec.http.HttpRequest);
	*** copy(io.netty.handler.codec.http.HttpRequest);
	*** disconnectClientIfNecessary();
	*** doReadHTTPInitial(io.netty.handler.codec.http.HttpRequest);
	*** fixHttpVersionHeaderIfNecessary(io.netty.handler.codec.http.HttpResponse);
	*** flowContext();
	*** getClientAddress();
	*** getSslEngine();
	*** identifyHostAndPort(io.netty.handler.codec.http.HttpRequest);
	*** initChannelPipeline(io.netty.channel.ChannelPipeline);
	*** isMitming();
	*** isTunneling();
	*** modifyRequestHeadersToReflectProxying(io.netty.handler.codec.http.HttpRequest);
	*** modifyResponseHeadersToReflectProxying(io.netty.handler.codec.http.HttpResponse);
	*** readHTTPInitial(io.netty.handler.codec.http.HttpRequest);
	*** recordClientConnected();
	*** recordClientDisconnected();
	*** recordClientSSLHandshakeSucceeded();
	*** removeSDCHEncoding(io.netty.handler.codec.http.HttpHeaders);
	*** respond(org.littleshoot.proxy.impl.ProxyToServerConnection,org.littleshoot.proxy.HttpFilters,io.netty.handler.codec.http.HttpRequest,io.netty.handler.codec.http.HttpResponse,io.netty.handler.codec.http.HttpObject);
	*** responseFor(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpResponseStatus);
	*** responseFor(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpResponseStatus,io.netty.buffer.ByteBuf,int);
	*** responseFor(io.netty.handler.codec.http.HttpVersion,io.netty.handler.codec.http.HttpResponseStatus,java.lang.String);
	*** resumeReadingIfNecessary();
	*** serverBecameSaturated(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** serverBecameWriteable(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** serverConnectionFlowStarted(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** serverConnectionSucceeded(org.littleshoot.proxy.impl.ProxyToServerConnection,boolean);
	*** serverDisconnected(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** shortCircuitRespond(io.netty.handler.codec.http.HttpResponse);
	*** shouldCloseClientConnection(io.netty.handler.codec.http.HttpRequest,io.netty.handler.codec.http.HttpResponse,io.netty.handler.codec.http.HttpObject);
	*** shouldCloseServerConnection(io.netty.handler.codec.http.HttpRequest,io.netty.handler.codec.http.HttpResponse,io.netty.handler.codec.http.HttpObject);
	*** stripConnectionTokens(io.netty.handler.codec.http.HttpHeaders);
	*** stripHopByHopHeaders(io.netty.handler.codec.http.HttpHeaders);
	*** switchProxyConnectionHeader(io.netty.handler.codec.http.HttpHeaders);
	*** timedOut();
	*** writeAuthenticationRequired();
	*** writeBadGateway(io.netty.handler.codec.http.HttpRequest);
	*** writeEmptyBuffer();
	*** writeGatewayTimeout();
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection$1 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection$2 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection$3 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection$4 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection$5 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ClientToProxyConnection$6 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ConnectionFlow {
	*** clientConnection;
	*** connectLock;
	*** currentStep;
	*** serverConnection;
	*** steps;
	*** suppressInitialRequest;
	*** access$000(org.littleshoot.proxy.impl.ConnectionFlow,org.littleshoot.proxy.impl.ProxyConnectionLogger);
	*** access$100(org.littleshoot.proxy.impl.ConnectionFlow);
	*** access$200(org.littleshoot.proxy.impl.ConnectionFlow);
	*** advance();
	*** doProcessCurrentStep(org.littleshoot.proxy.impl.ProxyConnectionLogger);
	*** fail();
	*** fail(java.lang.Throwable);
	*** notifyThreadsWaitingForConnection();
	*** processCurrentStep();
	*** read(java.lang.Object);
	*** start();
	*** succeed();
	*** then(org.littleshoot.proxy.impl.ConnectionFlowStep);
}

-keep class org.littleshoot.proxy.impl.ConnectionFlow$1 {
	*** this$0;
	*** val$LOG;
}

-keep class org.littleshoot.proxy.impl.ConnectionFlow$2 {
	*** this$0;
	*** val$LOG;
}

-keep class org.littleshoot.proxy.impl.ConnectionFlowStep {
	*** LOG;
	*** connection;
	*** state;
	org.littleshoot.proxy.impl.ConnectionFlowStep(org.littleshoot.proxy.impl.ProxyConnection,org.littleshoot.proxy.impl.ConnectionState);
	*** execute();
	*** getConnection();
	*** getState();
	*** onSuccess(org.littleshoot.proxy.impl.ConnectionFlow);
	*** read(org.littleshoot.proxy.impl.ConnectionFlow,java.lang.Object);
	*** shouldExecuteOnEventLoop();
	*** shouldSuppressInitialRequest();
}

-keep class org.littleshoot.proxy.impl.ConnectionState {
	*** $VALUES;
	*** AWAITING_CHUNK;
	*** AWAITING_CONNECT_OK;
	*** AWAITING_INITIAL;
	*** AWAITING_PROXY_AUTHENTICATION;
	*** CONNECTING;
	*** DISCONNECTED;
	*** DISCONNECT_REQUESTED;
	*** HANDSHAKING;
	*** NEGOTIATING_CONNECT;
	*** partOfConnectionFlow;
	org.littleshoot.proxy.impl.ConnectionState(java.lang.String,int,boolean);
	*** isPartOfConnectionFlow();
	*** values();
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer {
	*** LOG;
	*** activityTrackers;
	*** address;
	*** authenticateSslClients;
	*** chainProxyManager;
	*** filtersSource;
	*** idleConnectionTimeout;
	*** mitmManager;
	*** proxyAuthenticator;
	*** serverGroup;
	*** sslEngineSource;
	*** transparent;
	*** transportProtocol;
	*** useDnsSec;
	org.littleshoot.proxy.impl.DefaultHttpProxyServer(java.lang.String,org.littleshoot.proxy.TransportProtocol,java.net.InetSocketAddress,org.littleshoot.proxy.SslEngineSource,boolean,org.littleshoot.proxy.ProxyAuthenticator,org.littleshoot.proxy.ChainedProxyManager,org.littleshoot.proxy.MitmManager,org.littleshoot.proxy.HttpFiltersSource,boolean,boolean,int,java.util.Collection);
	org.littleshoot.proxy.impl.DefaultHttpProxyServer(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup,org.littleshoot.proxy.TransportProtocol,java.net.InetSocketAddress,org.littleshoot.proxy.SslEngineSource,boolean,org.littleshoot.proxy.ProxyAuthenticator,org.littleshoot.proxy.ChainedProxyManager,org.littleshoot.proxy.MitmManager,org.littleshoot.proxy.HttpFiltersSource,boolean,boolean,int,java.util.Collection);
	*** access$1200();
	*** access$1400(org.littleshoot.proxy.impl.DefaultHttpProxyServer);
	*** access$1500(org.littleshoot.proxy.impl.DefaultHttpProxyServer);
	*** access$800(org.littleshoot.proxy.impl.DefaultHttpProxyServer);
	*** access$900(org.littleshoot.proxy.impl.DefaultHttpProxyServer);
	*** bootstrap();
	*** clone();
	*** doStart();
	*** getActivityTrackers();
	*** getChainProxyManager();
	*** getFiltersSource();
	*** getIdleConnectionTimeout();
	*** getMitmManager();
	*** getProxyAuthenticator();
	*** getProxyToServerWorkerFor(org.littleshoot.proxy.TransportProtocol);
	*** isTransparent();
	*** isUseDnsSec();
	*** registerChannel(io.netty.channel.Channel);
	*** start();
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$1 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$2 {
	*** this$0;
	*** newChannel();
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$3 {
	*** this$0;
	*** operationComplete(io.netty.channel.ChannelFuture);
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$4 {
	*** $SwitchMap$org$littleshoot$proxy$TransportProtocol;
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$DefaultHttpProxyServerBootstrap {
	*** activityTrackers;
	*** address;
	*** allowLocalOnly;
	*** authenticateSslClients;
	*** chainProxyManager;
	*** filtersSource;
	*** idleConnectionTimeout;
	*** listenOnAllAddresses;
	*** mitmManager;
	*** name;
	*** original;
	*** port;
	*** proxyAuthenticator;
	*** sslEngineSource;
	*** transparent;
	*** transportProtocol;
	*** useDnsSec;
	org.littleshoot.proxy.impl.DefaultHttpProxyServer$DefaultHttpProxyServerBootstrap();
	org.littleshoot.proxy.impl.DefaultHttpProxyServer$DefaultHttpProxyServerBootstrap(java.util.Properties);
	org.littleshoot.proxy.impl.DefaultHttpProxyServer$DefaultHttpProxyServerBootstrap(org.littleshoot.proxy.impl.DefaultHttpProxyServer,org.littleshoot.proxy.TransportProtocol,java.net.InetSocketAddress,org.littleshoot.proxy.SslEngineSource,boolean,org.littleshoot.proxy.ProxyAuthenticator,org.littleshoot.proxy.ChainedProxyManager,org.littleshoot.proxy.MitmManager,org.littleshoot.proxy.HttpFiltersSource,boolean,boolean,int,java.util.Collection);
	*** build();
	*** determineListenAddress();
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup {
	*** allChannels;
	*** clientToProxyBossPools;
	*** clientToProxyWorkerPools;
	*** name;
	*** proxyToServerWorkerPools;
	*** stopped;
	org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup(java.lang.String);
	*** access$1000(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** access$1100(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** access$1300(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** access$400(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** access$500(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** access$600(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** access$700(org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup);
	*** stop();
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup$1 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup$2 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.DefaultHttpProxyServer$ServerGroup$CategorizedThreadFactory {
	*** category;
	*** num;
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.NetworkUtils {
	*** LOG;
	*** firstLocalNonLoopbackIpv4Address();
	*** getLocalHost();
	*** getLocalHostViaUdp();
}

-keep class org.littleshoot.proxy.impl.ProxyConnection {
	*** LOG;
	*** StartTunneling;
	*** channel;
	*** ctx;
	*** currentState;
	*** lastReadTime;
	*** proxyServer;
	*** runsAsSslClient;
	*** sslEngine;
	*** tunneling;
	org.littleshoot.proxy.impl.ProxyConnection(org.littleshoot.proxy.impl.ConnectionState,org.littleshoot.proxy.impl.DefaultHttpProxyServer,boolean);
	*** EncryptChannel(javax.net.ssl.SSLEngine);
	*** access$002(org.littleshoot.proxy.impl.ProxyConnection,boolean);
	*** access$100(org.littleshoot.proxy.impl.ProxyConnection,io.netty.util.concurrent.Promise);
	*** aggregateContentForFiltering(io.netty.channel.ChannelPipeline,int);
	*** becameSaturated();
	*** becameWritable();
	*** become(org.littleshoot.proxy.impl.ConnectionState);
	*** channelInactive(io.netty.channel.ChannelHandlerContext);
	*** channelRegistered(io.netty.channel.ChannelHandlerContext);
	*** closeChannel(io.netty.util.concurrent.Promise);
	*** connected();
	*** disconnect();
	*** disconnected();
	*** doWrite(java.lang.Object);
	*** encrypt(io.netty.channel.ChannelPipeline,javax.net.ssl.SSLEngine,boolean);
	*** encrypt(javax.net.ssl.SSLEngine,boolean);
	*** exceptionCaught(java.lang.Throwable);
	*** getCurrentState();
	*** getLOG();
	*** getSslEngine();
	*** is(org.littleshoot.proxy.impl.ConnectionState);
	*** isConnecting();
	*** isSaturated();
	*** isTunneling();
	*** read(java.lang.Object);
	*** readHTTP(io.netty.handler.codec.http.HttpObject);
	*** readHTTPChunk(io.netty.handler.codec.http.HttpContent);
	*** readHTTPInitial(io.netty.handler.codec.http.HttpObject);
	*** readRaw(io.netty.buffer.ByteBuf);
	*** resumeReading();
	*** stopReading();
	*** timedOut();
	*** write(java.lang.Object);
	*** writeHttp(io.netty.handler.codec.http.HttpObject);
	*** writeRaw(io.netty.buffer.ByteBuf);
	*** writeToChannel(java.lang.Object);
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$1 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$2 {
	*** this$0;
	*** val$sslEngine;
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$3 {
	*** this$0;
	*** val$promise;
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$4 {
	*** this$0;
	*** val$promise;
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$5 {
	*** $SwitchMap$org$littleshoot$proxy$impl$ConnectionState;
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$BytesReadMonitor {
	*** this$0;
	org.littleshoot.proxy.impl.ProxyConnection$BytesReadMonitor(org.littleshoot.proxy.impl.ProxyConnection);
	*** bytesRead(int);
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$BytesWrittenMonitor {
	*** this$0;
	org.littleshoot.proxy.impl.ProxyConnection$BytesWrittenMonitor(org.littleshoot.proxy.impl.ProxyConnection);
	*** bytesWritten(int);
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$RequestReadMonitor {
	*** this$0;
	org.littleshoot.proxy.impl.ProxyConnection$RequestReadMonitor(org.littleshoot.proxy.impl.ProxyConnection);
	*** requestRead(io.netty.handler.codec.http.HttpRequest);
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$RequestWrittenMonitor {
	*** this$0;
	org.littleshoot.proxy.impl.ProxyConnection$RequestWrittenMonitor(org.littleshoot.proxy.impl.ProxyConnection);
	*** requestWritten(io.netty.handler.codec.http.HttpRequest);
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$ResponseReadMonitor {
	*** this$0;
	org.littleshoot.proxy.impl.ProxyConnection$ResponseReadMonitor(org.littleshoot.proxy.impl.ProxyConnection);
	*** responseRead(io.netty.handler.codec.http.HttpResponse);
}

-keep class org.littleshoot.proxy.impl.ProxyConnection$ResponseWrittenMonitor {
	*** this$0;
	org.littleshoot.proxy.impl.ProxyConnection$ResponseWrittenMonitor(org.littleshoot.proxy.impl.ProxyConnection);
	*** responseWritten(io.netty.handler.codec.http.HttpResponse);
}

-keep class org.littleshoot.proxy.impl.ProxyConnectionLogger {
	*** connection;
	*** fqcn;
	*** logger;
	*** debug(java.lang.String,java.lang.Object[]);
	*** debug(java.lang.String,java.lang.Throwable);
	*** doLog(int,java.lang.String,java.lang.Object[],java.lang.Throwable);
	*** error(java.lang.String,java.lang.Throwable);
	*** fullMessage(java.lang.String);
	*** info(java.lang.String,java.lang.Object[]);
	*** log(int,java.lang.String,java.lang.Object[]);
	*** log(int,java.lang.String,java.lang.Throwable);
	*** warn(java.lang.String,java.lang.Object[]);
	*** warn(java.lang.String,java.lang.Throwable);
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection {
	*** ConnectChannel;
	*** HTTPCONNECTWithChainedProxy;
	*** MitmEncryptClientChannel;
	*** availableChainedProxies;
	*** bytesReadMonitor;
	*** bytesWrittenMonitor;
	*** chainedProxy;
	*** clientConnection;
	*** connectLock;
	*** connectionFlow;
	*** currentFilters;
	*** currentHttpRequest;
	*** currentHttpResponse;
	*** initialRequest;
	*** issuedRequests;
	*** localAddress;
	*** remoteAddress;
	*** requestWrittenMonitor;
	*** responseReadMonitor;
	*** serverConnection;
	*** serverHostAndPort;
	*** transportProtocol;
	*** access$000(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** access$100(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** access$200(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** access$300(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** access$400(org.littleshoot.proxy.impl.ProxyToServerConnection,io.netty.channel.ChannelPipeline,io.netty.handler.codec.http.HttpRequest);
	*** access$500(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** access$600(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** access$700(org.littleshoot.proxy.impl.ProxyToServerConnection);
	*** addressFor(java.lang.String,org.littleshoot.proxy.impl.DefaultHttpProxyServer);
	*** connectAndWrite(io.netty.handler.codec.http.HttpRequest);
	*** connectionFailed(java.lang.Throwable);
	*** connectionSucceeded(boolean);
	*** create(org.littleshoot.proxy.impl.DefaultHttpProxyServer,org.littleshoot.proxy.impl.ClientToProxyConnection,java.lang.String,io.netty.handler.codec.http.HttpRequest);
	*** getChainedProxy();
	*** getChainedProxyAddress();
	*** getInitialRequest();
	*** getRemoteAddress();
	*** getServerHostAndPort();
	*** hasDownstreamChainedProxy();
	*** identifyCurrentRequest();
	*** initChannelPipeline(io.netty.channel.ChannelPipeline,io.netty.handler.codec.http.HttpRequest);
	*** initializeConnectionFlow();
	*** readHTTPInitial(io.netty.handler.codec.http.HttpResponse);
	*** rememberCurrentResponse(io.netty.handler.codec.http.HttpResponse);
	*** respondWith(io.netty.handler.codec.http.HttpObject);
	*** setupConnectionParameters();
	*** write(java.lang.Object);
	*** write(java.lang.Object,org.littleshoot.proxy.HttpFilters);
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$1 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$1$1 {
	*** this$1;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$1$2 {
	*** this$1;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$2 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$3 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$4 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$5 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$6 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$7 {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$8 {
	*** $SwitchMap$org$littleshoot$proxy$TransportProtocol;
}

-keep class org.littleshoot.proxy.impl.ProxyToServerConnection$HeadAwareHttpResponseDecoder {
	*** this$0;
}

-keep class org.littleshoot.proxy.impl.ProxyUtils {
	*** GMT;
	*** HTTP_PREFIX;
	*** LOG;
	*** hostName;
	*** addVia(io.netty.handler.codec.http.HttpMessage);
	*** checkTrueOrFalse(java.lang.String,java.lang.String,java.lang.String);
	*** copyMutableResponseFields(io.netty.handler.codec.http.HttpResponse);
	*** extractBooleanDefaultFalse(java.util.Properties,java.lang.String);
	*** extractInt(java.util.Properties,java.lang.String);
	*** formatDate(java.util.Date);
	*** formatDate(java.util.Date,java.lang.String);
	*** httpDate();
	*** isCONNECT(io.netty.handler.codec.http.HttpObject);
	*** isChunked(io.netty.handler.codec.http.HttpObject);
	*** isLastChunk(io.netty.handler.codec.http.HttpObject);
	*** parseHostAndPort(io.netty.handler.codec.http.HttpRequest);
	*** parseHostAndPort(java.lang.String);
	*** stripHost(java.lang.String);
}

-keep class org.littleshoot.stun.stack.StunAddressProvider {
	*** getServerReflexiveAddress();
}

-keep class org.littleshoot.stun.stack.StunConstants {
	*** SERVERS;
	*** SERVERS_ARRAY;
}

-keep class org.littleshoot.stun.stack.StunIoHandler {
	*** m_log;
	*** m_visitorFactory;
	*** messageReceived(org.littleshoot.mina.common.IoSession,java.lang.Object);
}

-keep class org.littleshoot.stun.stack.decoder.StunMessageDecodingState {
	*** EMPTY_ATTRIBUTES;
	*** m_log;
	*** access$200();
	*** access$500();
	*** access$600(int,byte[],java.util.Map);
	*** createMessage(int,byte[],java.util.Map);
}

-keep class org.littleshoot.stun.stack.decoder.StunMessageDecodingState$1 {
	*** $SwitchMap$org$littleshoot$stun$stack$message$StunMessageType;
}

-keep class org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadBody {
	*** m_transactionId;
	*** m_type;
	org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadBody(int,int,byte[]);
}

-keep class org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadMessageLength {
	*** m_messageType;
	org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadMessageLength(int);
}

-keep class org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadMessageType {
	org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadMessageType();
}

-keep class org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadTransactionId {
	*** m_messageLength;
	*** m_messageType;
	org.littleshoot.stun.stack.decoder.StunMessageDecodingState$ReadTransactionId(int,int);
}

-keep class org.littleshoot.stun.stack.encoder.StunAttributeEncoder {
	*** LOG;
	*** UTF_8_ENCODER;
	*** m_buf;
	*** visitAddressAttribute(org.littleshoot.stun.stack.message.attributes.StunAddressAttribute);
	*** writeHeader(org.littleshoot.stun.stack.message.attributes.StunAttribute);
}

-keep class org.littleshoot.stun.stack.encoder.StunMessageEncoder {
	*** m_log;
	*** encode(org.littleshoot.stun.stack.message.StunMessage);
	*** putAttributes(java.util.Map,org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.stun.stack.encoder.StunProtocolEncoder {
	*** LOG;
}

-keep class org.littleshoot.stun.stack.message.AbstractStunMessage {
	*** EMPTY_MAP;
	*** MAGIC_COOKIE_BUF;
	*** m_attributes;
	*** m_bodyLength;
	*** m_messageType;
	*** m_totalLength;
	*** m_transactionId;
	org.littleshoot.stun.stack.message.AbstractStunMessage(org.apache.commons.id.uuid.UUID,org.littleshoot.stun.stack.message.StunMessageType,java.util.Map);
	org.littleshoot.stun.stack.message.AbstractStunMessage(org.littleshoot.stun.stack.message.StunMessageType);
	org.littleshoot.stun.stack.message.AbstractStunMessage(org.littleshoot.stun.stack.message.StunMessageType,java.util.Map);
	*** calculateBodyLength(java.util.Map);
	*** createAttributes(org.littleshoot.stun.stack.message.attributes.StunAttribute[]);
	*** createTransactionId();
	*** getTransactionId();
}

-keep class org.littleshoot.stun.stack.message.BindingRequest {
	*** LOG;
}

-keep class org.littleshoot.stun.stack.message.BindingSuccessResponse {
	*** LOG;
	*** m_mappedAddress;
	*** createAttributes(java.net.InetSocketAddress);
	*** getAddress(java.util.Map);
	*** getMappedAddress();
}

-keep class org.littleshoot.stun.stack.message.StunMessage {
	*** getAttributes();
	*** getBodyLength();
	*** getTotalLength();
	*** getTransactionId();
	*** getType();
}

-keep class org.littleshoot.stun.stack.message.StunMessageType {
	*** $VALUES;
	*** ALLOCATE_ERROR_RESPONSE;
	*** ALLOCATE_REQUEST;
	*** ALLOCATE_SUCCESS_RESPONSE;
	*** BINDING_ERROR_RESPONSE;
	*** BINDING_REQUEST;
	*** BINDING_SUCCESS_RESPONSE;
	*** CONNECTION_STATUS_INDICATION;
	*** CONNECT_REQUEST;
	*** DATA_INDICATION;
	*** SEND_INDICATION;
	*** m_messageType;
	*** s_intsToEnums;
	*** toInt();
	*** toType(int);
	*** values();
}

-keep class org.littleshoot.stun.stack.message.StunMessageVisitor {
	*** visitBindingRequest(org.littleshoot.stun.stack.message.BindingRequest);
	*** visitBindingSuccessResponse(org.littleshoot.stun.stack.message.BindingSuccessResponse);
}

-keep class org.littleshoot.stun.stack.message.StunMessageVisitorAdapter {
	*** LOG;
	org.littleshoot.stun.stack.message.StunMessageVisitorAdapter();
}

-keep class org.littleshoot.stun.stack.message.StunMessageVisitorFactory {
	*** createVisitor(org.littleshoot.mina.common.IoSession);
}

-keep class org.littleshoot.stun.stack.message.VisitableStunMessage {
	*** accept(org.littleshoot.stun.stack.message.StunMessageVisitor);
}

-keep class org.littleshoot.stun.stack.message.attributes.AbstractStunAddressAttribute {
	*** m_addressFamily;
	*** m_inetSocketAddress;
	org.littleshoot.stun.stack.message.attributes.AbstractStunAddressAttribute(org.littleshoot.stun.stack.message.attributes.StunAttributeType,java.net.InetSocketAddress);
	*** getBodyLength(java.net.InetSocketAddress);
	*** getInetSocketAddress();
}

-keep class org.littleshoot.stun.stack.message.attributes.AbstractStunAttribute {
	*** m_attributeType;
	*** m_bodyLength;
	org.littleshoot.stun.stack.message.attributes.AbstractStunAttribute(org.littleshoot.stun.stack.message.attributes.StunAttributeType,int);
}

-keep class org.littleshoot.stun.stack.message.attributes.AddressAttributeReader {
	*** LOG;
	*** readAddress(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.stun.stack.message.attributes.ErrorCodeAttribute {
	*** getErrorClass();
	*** getErrorNumber();
	*** getReasonPhrase();
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAddressAttribute {
	*** getAddressFamily();
	*** getInetSocketAddress();
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAttribute {
	*** accept(org.littleshoot.stun.stack.message.attributes.StunAttributeVisitor);
	*** getAttributeType();
	*** getBodyLength();
	*** getTotalLength();
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAttributeType {
	*** $VALUES;
	*** ALTERNATE_SERVER;
	*** CONNECT_STAT;
	*** DATA;
	*** ERROR_CODE;
	*** FINGERPRINT;
	*** ICE_CONTROLLED;
	*** ICE_CONTROLLING;
	*** ICE_PRIORITY;
	*** ICE_USE_CANDIDATE;
	*** MAPPED_ADDRESS;
	*** MESSAGE_INTEGRITY;
	*** NONCE;
	*** PASSWORD;
	*** REALM;
	*** REFRESH_INTERVAL;
	*** RELAY_ADDRESS;
	*** REMOTE_ADDRESS;
	*** SERVER;
	*** UNKNOWN_ATTRIBUTES;
	*** USERNAME;
	*** XOR_MAPPED_ADDRESS;
	*** m_type;
	*** s_intsToEnums;
	*** toInt();
	*** toType(int);
	*** values();
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAttributeVisitor {
	*** visitMappedAddress(org.littleshoot.stun.stack.message.attributes.MappedAddressAttribute);
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAttributesFactory {
	*** createAttributes(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAttributesFactoryImpl {
	*** LOG;
	*** addAttribute(java.util.Map,org.littleshoot.mina.common.ByteBuffer);
	*** createAttribute(org.littleshoot.stun.stack.message.attributes.StunAttributeType,byte[]);
}

-keep class org.littleshoot.stun.stack.message.attributes.StunAttributesFactoryImpl$1 {
	*** $SwitchMap$org$littleshoot$stun$stack$message$attributes$StunAttributeType;
}

-keep class org.littleshoot.stun.stack.message.attributes.ice.IceControlledAttribute {
	*** getTieBreaker();
}

-keep class org.littleshoot.stun.stack.message.attributes.ice.IceControllingAttribute {
	*** getTieBreaker();
}

-keep class org.littleshoot.stun.stack.message.attributes.ice.IcePriorityAttribute {
	*** getPriority();
}

-keep class org.littleshoot.stun.stack.message.attributes.turn.ConnectionStatus {
	*** toLong();
	*** valueOf(long);
}

-keep class org.littleshoot.stun.stack.message.attributes.turn.ConnectionStatusAttribute {
	*** getConnectionStatus();
}

-keep class org.littleshoot.stun.stack.message.attributes.turn.DataAttribute {
	*** getData();
}

-keep class org.littleshoot.stun.stack.transaction.StunClientTransaction {
	*** addListener(org.littleshoot.stun.stack.transaction.StunTransactionListener);
	*** getRequest();
}

-keep class org.littleshoot.stun.stack.transaction.StunClientTransactionImpl {
	*** m_log;
	*** m_remoteAddress;
	*** m_request;
	*** m_transactionListeners;
	*** m_transactionStartTime;
	*** m_transactionTime;
	*** access$000(org.littleshoot.stun.stack.transaction.StunClientTransactionImpl);
	*** isSameTransaction(org.littleshoot.stun.stack.message.StunMessage);
	*** notifyFailure(org.littleshoot.stun.stack.message.StunMessage);
	*** notifyListeners(org.littleshoot.stun.stack.message.StunMessage,com.google.common.base.Function);
	*** setTransactionTime();
	*** visitAllocateErrorResponse(org.littleshoot.stun.stack.message.turn.AllocateErrorResponse);
	*** visitAllocateRequest(org.littleshoot.stun.stack.message.turn.AllocateRequest);
	*** visitAllocateSuccessResponse(org.littleshoot.stun.stack.message.turn.AllocateSuccessResponse);
	*** visitBindingErrorResponse(org.littleshoot.stun.stack.message.BindingErrorResponse);
	*** visitBindingRequest(org.littleshoot.stun.stack.message.BindingRequest);
	*** visitBindingSuccessResponse(org.littleshoot.stun.stack.message.BindingSuccessResponse);
	*** visitCanceledMessage(org.littleshoot.stun.stack.message.CanceledStunMessage);
	*** visitConnectErrorMesssage(org.littleshoot.stun.stack.message.ConnectErrorStunMessage);
	*** visitConnectRequest(org.littleshoot.stun.stack.message.turn.ConnectRequest);
	*** visitConnectionStatusIndication(org.littleshoot.stun.stack.message.turn.ConnectionStatusIndication);
	*** visitDataIndication(org.littleshoot.stun.stack.message.turn.DataIndication);
	*** visitNullMessage(org.littleshoot.stun.stack.message.NullStunMessage);
	*** visitSendIndication(org.littleshoot.stun.stack.message.turn.SendIndication);
}

-keep class org.littleshoot.stun.stack.transaction.StunClientTransactionImpl$1 {
	*** this$0;
	*** val$response;
	*** apply(org.littleshoot.stun.stack.transaction.StunTransactionListener);
}

-keep class org.littleshoot.stun.stack.transaction.StunTransactionListener {
	*** onTransactionSucceeded(org.littleshoot.stun.stack.message.StunMessage,org.littleshoot.stun.stack.message.StunMessage);
}

-keep class org.littleshoot.stun.stack.transaction.StunTransactionTracker {
	*** addTransaction(org.littleshoot.stun.stack.message.StunMessage,org.littleshoot.stun.stack.transaction.StunTransactionListener,java.net.InetSocketAddress,java.net.InetSocketAddress);
	*** getClientTransaction(org.littleshoot.stun.stack.message.StunMessage);
}

-keep class org.littleshoot.stun.stack.transaction.StunTransactionTrackerImpl {
	*** log;
	*** transactions;
	*** getTransactionKey(org.littleshoot.stun.stack.message.StunMessage);
	*** removeTransaction(org.littleshoot.stun.stack.message.StunMessage);
	*** trackTransaction(org.littleshoot.stun.stack.transaction.StunClientTransaction);
}

-keep class org.littleshoot.util.BitUtils {
	*** byteArrayToInteger(byte[]);
	*** byteArrayToInteger(byte[],int);
	*** byteArrayToLong(byte[],int);
	*** toByteArray(int);
}

-keep class org.littleshoot.util.CandidateProvider {
	*** getCandidates();
}

-keep class org.littleshoot.util.CommonUtils {
	*** LOG;
	*** SIZE_LIMIT;
	*** keyGenerator;
	*** littleShootProps;
	*** secureRandom;
	*** combine(byte[][]);
	*** combine(java.util.Collection);
	*** decodeBase64(java.lang.String);
	*** decodeSingleMessage(byte[],byte[],java.util.concurrent.atomic.AtomicInteger);
	*** encodeSingleMessage(byte[],byte[],int,int);
	*** generateKey();
	*** getLittleShootDir();
	*** getProps();
	*** getPropsFile();
	*** intToByteArray(int);
	*** isStringTrue(java.lang.String);
	*** nativeCall(java.lang.String[]);
	*** randomPort();
	*** saveProps(java.util.Properties);
	*** unsignedShortToInt(byte[]);
}

-keep class org.littleshoot.util.DefaultHttpClient {
	*** executeMethod(org.apache.commons.httpclient.HttpMethod);
}

-keep class org.littleshoot.util.FiveTuple {
	*** local;
	*** protocol;
	*** remote;
	*** equals(java.lang.Object);
	*** getLocal();
	*** getProtocol();
	*** getRemote();
	*** hashCode();
}

-keep class org.littleshoot.util.FiveTuple$Protocol {
	*** $VALUES;
	*** TCP;
	*** UDP;
}

-keep class org.littleshoot.util.NetworkUtils {
	*** LOG;
	*** getLocalHost();
	*** getLocalHostViaUdp();
	*** isPublicAddress();
	*** isPublicAddress(java.net.InetAddress);
}

-keep class org.littleshoot.util.PublicIp {
	*** getPublicIpAddress();
}

-keep class org.littleshoot.util.SessionSocketListener {
	*** reconnected();
}

-keep class org.littleshoot.util.ThreadUtils {
	*** dumpStack();
	*** dumpStack(java.lang.Throwable);
}

-keep class org.littleshoot.util.mina.DecodingState {
	*** decode(org.littleshoot.mina.common.ByteBuffer,org.littleshoot.mina.filter.codec.ProtocolDecoderOutput);
}

-keep class org.littleshoot.util.mina.DecodingStateMachine {
	*** LOG;
	*** currentState;
	*** m_childOutput;
	*** m_childProducts;
	org.littleshoot.util.mina.DecodingStateMachine();
	*** access$000(org.littleshoot.util.mina.DecodingStateMachine);
	*** debugStateTransition(org.littleshoot.util.mina.DecodingState);
	*** debugStateTransition2(org.littleshoot.util.mina.DecodingState,org.littleshoot.mina.common.ByteBuffer);
	*** destroy();
	*** finishDecode(java.util.List,org.littleshoot.mina.filter.codec.ProtocolDecoderOutput);
	*** init();
}

-keep class org.littleshoot.util.mina.DecodingStateMachine$1 {
	*** this$0;
}

-keep class org.littleshoot.util.mina.FixedLengthDecodingState {
	*** m_buffer;
	*** m_length;
	org.littleshoot.util.mina.FixedLengthDecodingState(int);
	*** finishDecode(org.littleshoot.mina.common.ByteBuffer,org.littleshoot.mina.filter.codec.ProtocolDecoderOutput);
}

-keep class org.littleshoot.util.mina.MinaUtils {
	*** DECODER;
	*** LOG;
	*** createBuffer(org.littleshoot.mina.common.ByteBuffer);
	*** getString(org.littleshoot.mina.common.ByteBuffer);
	*** putUnsignedByte(org.littleshoot.mina.common.ByteBuffer,int);
	*** putUnsignedInt(org.littleshoot.mina.common.ByteBuffer,long);
	*** putUnsignedShort(org.littleshoot.mina.common.ByteBuffer,int);
	*** toAsciiString(org.littleshoot.mina.common.ByteBuffer);
	*** toByteArray(org.littleshoot.mina.common.ByteBuffer);
}

-keep class org.littleshoot.util.mina.StateMachineProtocolDecoder {
	*** LOG;
	*** m_currentState;
	*** m_stateMachine;
	org.littleshoot.util.mina.StateMachineProtocolDecoder(org.littleshoot.util.mina.DecodingStateMachine);
}

-keep class org.littleshoot.util.mina.decode.binary.UnsignedShortDecodingState {
	org.littleshoot.util.mina.decode.binary.UnsignedShortDecodingState();
	*** finishDecode(int,org.littleshoot.mina.filter.codec.ProtocolDecoderOutput);
}

-keep class org.littleshoot.util.xml.XPathUtils {
	*** LOG;
	*** m_doc;
	*** m_path;
	*** getNodes(java.lang.String);
	*** getString(java.lang.String);
	*** newXPath(java.io.InputStream);
	*** newXPath(org.w3c.dom.Document);
}

-keep class org.littleshoot.util.xml.XmlUtils {
	*** EMPTY_NODE_LIST;
	*** LOG;
	*** s_path;
	*** s_xPathFactory;
	*** printDoc(org.w3c.dom.Document);
	*** toDoc(java.io.InputStream);
	*** toDoc(java.lang.String);
	*** toString(org.w3c.dom.Document);
}

-keep class org.mockito.Answers {
	*** $VALUES;
	*** CALLS_REAL_METHODS;
	*** RETURNS_DEEP_STUBS;
	*** RETURNS_DEFAULTS;
	*** RETURNS_MOCKS;
	*** RETURNS_SMART_NULLS;
	*** implementation;
	*** get();
}

-keep class org.mockito.ArgumentMatcher {
	org.mockito.ArgumentMatcher();
}

-keep class org.mockito.Matchers {
	*** mockingProgress;
	org.mockito.Matchers();
	*** any();
	*** anyObject();
	*** anyString();
	*** notNull();
	*** notNull(java.lang.Class);
	*** reportMatcher(org.hamcrest.Matcher);
}

-keep class org.mockito.MockSettings {
	*** defaultAnswer(org.mockito.stubbing.Answer);
	*** name(java.lang.String);
	*** spiedInstance(java.lang.Object);
}

-keep class org.mockito.Mockito {
	*** CALLS_REAL_METHODS;
	*** MOCKITO_CORE;
	*** RETURNS_DEEP_STUBS;
	*** RETURNS_DEFAULTS;
	*** RETURNS_MOCKS;
	*** RETURNS_SMART_NULLS;
	*** doNothing();
	*** mock(java.lang.Class);
	*** mock(java.lang.Class,org.mockito.MockSettings);
	*** mock(java.lang.Class,org.mockito.stubbing.Answer);
	*** spy(java.lang.Object);
	*** times(int);
	*** when(java.lang.Object);
	*** withSettings();
}

-keep class org.mockito.asm.AnnotationVisitor {
	*** visit(java.lang.String,java.lang.Object);
	*** visitAnnotation(java.lang.String,java.lang.String);
	*** visitArray(java.lang.String);
	*** visitEnd();
	*** visitEnum(java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.mockito.asm.AnnotationWriter {
	*** next;
	*** getSize();
	*** put(org.mockito.asm.AnnotationWriter[],int,org.mockito.asm.ByteVector);
	*** put(org.mockito.asm.ByteVector);
}

-keep class org.mockito.asm.Attribute {
	*** next;
	*** type;
	*** value;
	*** getCount();
	*** getLabels();
	*** getSize(org.mockito.asm.ClassWriter,byte[],int,int,int);
	*** isCodeAttribute();
	*** put(org.mockito.asm.ClassWriter,byte[],int,int,int,org.mockito.asm.ByteVector);
	*** read(org.mockito.asm.ClassReader,int,int,char[],int,org.mockito.asm.Label[]);
	*** write(org.mockito.asm.ClassWriter,byte[],int,int,int);
}

-keep class org.mockito.asm.ByteVector {
	*** data;
	*** length;
	*** enlarge(int);
	*** put11(int,int);
	*** put12(int,int);
	*** putByte(int);
	*** putByteArray(byte[],int,int);
	*** putInt(int);
	*** putLong(long);
	*** putShort(int);
	*** putUTF8(java.lang.String);
}

-keep class org.mockito.asm.ClassAdapter {
	*** cv;
	org.mockito.asm.ClassAdapter(org.mockito.asm.ClassVisitor);
}

-keep class org.mockito.asm.ClassReader {
	*** b;
	*** header;
	*** items;
	*** maxStringLength;
	*** strings;
	org.mockito.asm.ClassReader(byte[]);
	org.mockito.asm.ClassReader(byte[],int,int);
	org.mockito.asm.ClassReader(java.io.InputStream);
	*** accept(org.mockito.asm.ClassVisitor,int);
	*** accept(org.mockito.asm.ClassVisitor,org.mockito.asm.Attribute[],int);
	*** copyPool(org.mockito.asm.ClassWriter);
	*** readAnnotationValue(int,char[],java.lang.String,org.mockito.asm.AnnotationVisitor);
	*** readAnnotationValues(int,char[],boolean,org.mockito.asm.AnnotationVisitor);
	*** readAttribute(org.mockito.asm.Attribute[],java.lang.String,int,int,char[],int,org.mockito.asm.Label[]);
	*** readClass(int,char[]);
	*** readClass(java.io.InputStream);
	*** readConst(int,char[]);
	*** readFrameType(java.lang.Object[],int,int,char[],org.mockito.asm.Label[]);
	*** readInt(int);
	*** readLabel(int,org.mockito.asm.Label[]);
	*** readLong(int);
	*** readParameterAnnotations(int,java.lang.String,char[],boolean,org.mockito.asm.MethodVisitor);
	*** readShort(int);
	*** readUTF(int,int,char[]);
	*** readUTF8(int,char[]);
	*** readUnsignedShort(int);
}

-keep class org.mockito.asm.ClassVisitor {
	*** visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]);
	*** visitAnnotation(java.lang.String,boolean);
	*** visitAttribute(org.mockito.asm.Attribute);
	*** visitEnd();
	*** visitField(int,java.lang.String,java.lang.String,java.lang.String,java.lang.Object);
	*** visitInnerClass(java.lang.String,java.lang.String,java.lang.String,int);
	*** visitMethod(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]);
	*** visitOuterClass(java.lang.String,java.lang.String,java.lang.String);
	*** visitSource(java.lang.String,java.lang.String);
}

-keep class org.mockito.asm.ClassWriter {
	*** TYPE;
	*** access;
	*** anns;
	*** attrs;
	*** computeFrames;
	*** computeMaxs;
	*** cr;
	*** enclosingMethod;
	*** enclosingMethodOwner;
	*** firstField;
	*** firstMethod;
	*** ianns;
	*** index;
	*** innerClasses;
	*** innerClassesCount;
	*** interfaceCount;
	*** interfaces;
	*** invalidFrames;
	*** items;
	*** key;
	*** key2;
	*** key3;
	*** lastField;
	*** lastMethod;
	*** name;
	*** pool;
	*** signature;
	*** sourceDebug;
	*** sourceFile;
	*** superName;
	*** thisName;
	*** threshold;
	*** typeCount;
	*** typeTable;
	*** version;
	org.mockito.asm.ClassWriter(int);
	*** addType(java.lang.String);
	*** addType(org.mockito.asm.Item);
	*** addUninitializedType(java.lang.String,int);
	*** get(org.mockito.asm.Item);
	*** getCommonSuperClass(java.lang.String,java.lang.String);
	*** getMergedType(int,int);
	*** newClass(java.lang.String);
	*** newClassItem(java.lang.String);
	*** newConstItem(java.lang.Object);
	*** newDouble(double);
	*** newFieldItem(java.lang.String,java.lang.String,java.lang.String);
	*** newFloat(float);
	*** newInteger(int);
	*** newLong(long);
	*** newMethodItem(java.lang.String,java.lang.String,java.lang.String,boolean);
	*** newNameType(java.lang.String,java.lang.String);
	*** newString(java.lang.String);
	*** newUTF8(java.lang.String);
	*** put(org.mockito.asm.Item);
	*** put122(int,int,int);
	*** toByteArray();
	*** visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]);
}

-keep class org.mockito.asm.Edge {
	*** info;
	*** next;
	*** successor;
}

-keep class org.mockito.asm.FieldVisitor {
	*** visitAnnotation(java.lang.String,boolean);
	*** visitAttribute(org.mockito.asm.Attribute);
	*** visitEnd();
}

-keep class org.mockito.asm.FieldWriter {
	*** access;
	*** anns;
	*** attrs;
	*** cw;
	*** desc;
	*** ianns;
	*** name;
	*** next;
	*** signature;
	*** value;
	*** getSize();
	*** put(org.mockito.asm.ByteVector);
}

-keep class org.mockito.asm.Frame {
	*** SIZE;
	*** initializationCount;
	*** initializations;
	*** inputLocals;
	*** inputStack;
	*** outputLocals;
	*** outputStack;
	*** outputStackTop;
	*** owner;
	*** execute(int,int,org.mockito.asm.ClassWriter,org.mockito.asm.Item);
	*** get(int);
	*** init(int);
	*** init(org.mockito.asm.ClassWriter,int);
	*** initInputFrame(org.mockito.asm.ClassWriter,int,org.mockito.asm.Type[],int);
	*** merge(org.mockito.asm.ClassWriter,int,int[],int);
	*** merge(org.mockito.asm.ClassWriter,org.mockito.asm.Frame,int);
	*** pop();
	*** pop(int);
	*** pop(java.lang.String);
	*** push(int);
	*** push(org.mockito.asm.ClassWriter,java.lang.String);
	*** set(int,int);
	*** type(org.mockito.asm.ClassWriter,java.lang.String);
}

-keep class org.mockito.asm.Handler {
	*** desc;
	*** end;
	*** handler;
	*** next;
	*** start;
	*** type;
}

-keep class org.mockito.asm.Item {
	*** hashCode;
	*** index;
	*** intVal;
	*** longVal;
	*** next;
	*** strVal1;
	*** strVal2;
	*** strVal3;
	*** type;
	*** isEqualTo(org.mockito.asm.Item);
	*** set(double);
	*** set(float);
	*** set(int);
	*** set(int,java.lang.String,java.lang.String,java.lang.String);
	*** set(long);
}

-keep class org.mockito.asm.Label {
	*** frame;
	*** inputStackTop;
	*** line;
	*** next;
	*** outputStackMax;
	*** position;
	*** referenceCount;
	*** srcAndRefPositions;
	*** status;
	*** successor;
	*** successors;
	*** addReference(int,int);
	*** addToSubroutine(long,int);
	*** getFirst();
	*** inSameSubroutine(org.mockito.asm.Label);
	*** inSubroutine(long);
	*** put(org.mockito.asm.MethodWriter,org.mockito.asm.ByteVector,int,boolean);
	*** resolve(org.mockito.asm.MethodWriter,int,byte[]);
	*** visitSubroutine(org.mockito.asm.Label,long,int);
}

-keep class org.mockito.asm.MethodAdapter {
	*** mv;
	org.mockito.asm.MethodAdapter(org.mockito.asm.MethodVisitor);
	*** visitInsn(int);
}

-keep class org.mockito.asm.MethodVisitor {
	*** visitAnnotation(java.lang.String,boolean);
	*** visitAnnotationDefault();
	*** visitAttribute(org.mockito.asm.Attribute);
	*** visitCode();
	*** visitEnd();
	*** visitFieldInsn(int,java.lang.String,java.lang.String,java.lang.String);
	*** visitFrame(int,int,java.lang.Object[],int,java.lang.Object[]);
	*** visitIincInsn(int,int);
	*** visitInsn(int);
	*** visitIntInsn(int,int);
	*** visitJumpInsn(int,org.mockito.asm.Label);
	*** visitLabel(org.mockito.asm.Label);
	*** visitLdcInsn(java.lang.Object);
	*** visitLineNumber(int,org.mockito.asm.Label);
	*** visitLocalVariable(java.lang.String,java.lang.String,java.lang.String,org.mockito.asm.Label,org.mockito.asm.Label,int);
	*** visitLookupSwitchInsn(org.mockito.asm.Label,int[],org.mockito.asm.Label[]);
	*** visitMaxs(int,int);
	*** visitMethodInsn(int,java.lang.String,java.lang.String,java.lang.String);
	*** visitMultiANewArrayInsn(java.lang.String,int);
	*** visitParameterAnnotation(int,java.lang.String,boolean);
	*** visitTableSwitchInsn(int,int,org.mockito.asm.Label,org.mockito.asm.Label[]);
	*** visitTryCatchBlock(org.mockito.asm.Label,org.mockito.asm.Label,org.mockito.asm.Label,java.lang.String);
	*** visitTypeInsn(int,java.lang.String);
	*** visitVarInsn(int,int);
}

-keep class org.mockito.asm.MethodWriter {
	*** access;
	*** annd;
	*** anns;
	*** attrs;
	*** cattrs;
	*** classReaderLength;
	*** classReaderOffset;
	*** code;
	*** compute;
	*** currentBlock;
	*** cw;
	*** desc;
	*** descriptor;
	*** exceptionCount;
	*** exceptions;
	*** firstHandler;
	*** frame;
	*** frameCount;
	*** frameIndex;
	*** handlerCount;
	*** ianns;
	*** ipanns;
	*** labels;
	*** lastHandler;
	*** lineNumber;
	*** lineNumberCount;
	*** localVar;
	*** localVarCount;
	*** localVarType;
	*** localVarTypeCount;
	*** maxLocals;
	*** maxStack;
	*** maxStackSize;
	*** name;
	*** next;
	*** panns;
	*** previousBlock;
	*** previousFrame;
	*** previousFrameOffset;
	*** resize;
	*** signature;
	*** stackMap;
	*** stackSize;
	*** subroutines;
	*** synthetics;
	*** addSuccessor(int,org.mockito.asm.Label);
	*** endFrame();
	*** getArgumentsAndReturnSizes(java.lang.String);
	*** getNewOffset(int[],int[],int,int);
	*** getNewOffset(int[],int[],org.mockito.asm.Label);
	*** getSize();
	*** noSuccessor();
	*** put(org.mockito.asm.ByteVector);
	*** readInt(byte[],int);
	*** readShort(byte[],int);
	*** readUnsignedShort(byte[],int);
	*** resizeInstructions();
	*** startFrame(int,int,int);
	*** visitFrame(org.mockito.asm.Frame);
	*** visitLabel(org.mockito.asm.Label);
	*** visitSwitchInsn(org.mockito.asm.Label,org.mockito.asm.Label[]);
	*** writeFrame();
	*** writeFrameType(java.lang.Object);
	*** writeFrameTypes(int,int);
	*** writeShort(byte[],int,int);
}

-keep class org.mockito.asm.Opcodes {
	*** DOUBLE;
	*** FLOAT;
	*** INTEGER;
	*** LONG;
	*** NULL;
	*** TOP;
	*** UNINITIALIZED_THIS;
}

-keep class org.mockito.asm.Type {
	*** BOOLEAN_TYPE;
	*** BYTE_TYPE;
	*** CHAR_TYPE;
	*** DOUBLE_TYPE;
	*** FLOAT_TYPE;
	*** INT_TYPE;
	*** LONG_TYPE;
	*** SHORT_TYPE;
	*** VOID_TYPE;
	*** buf;
	*** len;
	*** off;
	*** sort;
	org.mockito.asm.Type(int,char[],int,int);
	*** equals(java.lang.Object);
	*** getArgumentTypes(java.lang.String);
	*** getClassName();
	*** getDescriptor();
	*** getDescriptor(java.lang.Class);
	*** getDescriptor(java.lang.StringBuffer);
	*** getDescriptor(java.lang.StringBuffer,java.lang.Class);
	*** getDimensions();
	*** getElementType();
	*** getInternalName();
	*** getMethodDescriptor(java.lang.reflect.Method);
	*** getMethodDescriptor(org.mockito.asm.Type,org.mockito.asm.Type[]);
	*** getObjectType(java.lang.String);
	*** getOpcode(int);
	*** getReturnType(java.lang.String);
	*** getSize();
	*** getSort();
	*** getType(char[],int);
	*** getType(java.lang.Class);
	*** getType(java.lang.String);
	*** hashCode();
}

-keep class org.mockito.cglib.core.AbstractClassGenerator {
	*** CURRENT;
	*** NAME_KEY;
	*** attemptLoad;
	*** classLoader;
	*** className;
	*** key;
	*** namePrefix;
	*** namingPolicy;
	*** source;
	*** strategy;
	*** useCache;
	org.mockito.cglib.core.AbstractClassGenerator(org.mockito.cglib.core.AbstractClassGenerator$Source);
	*** create(java.lang.Object);
	*** firstInstance(java.lang.Class);
	*** getAttemptLoad();
	*** getClassLoader();
	*** getClassName();
	*** getClassName(java.lang.ClassLoader);
	*** getClassNameCache(java.lang.ClassLoader);
	*** getCurrent();
	*** getDefaultClassLoader();
	*** getNamingPolicy();
	*** getStrategy();
	*** setAttemptLoad(boolean);
	*** setClassLoader(java.lang.ClassLoader);
	*** setNamePrefix(java.lang.String);
	*** setNamingPolicy(org.mockito.cglib.core.NamingPolicy);
	*** setStrategy(org.mockito.cglib.core.GeneratorStrategy);
}

-keep class org.mockito.cglib.core.AbstractClassGenerator$1 {
	*** this$0;
	*** val$nameCache;
}

-keep class org.mockito.cglib.core.AbstractClassGenerator$Source {
	*** cache;
	*** name;
}

-keep class org.mockito.cglib.core.Block {
	*** e;
	*** end;
	*** start;
	*** end();
	*** getCodeEmitter();
	*** getEnd();
	*** getStart();
}

-keep class org.mockito.cglib.core.ClassEmitter {
	*** classInfo;
	*** fieldInfo;
	*** hookCounter;
	*** rawStaticInit;
	*** staticHook;
	*** staticHookSig;
	*** staticInit;
	org.mockito.cglib.core.ClassEmitter(org.mockito.asm.ClassVisitor);
	*** begin_class(int,int,java.lang.String,org.mockito.asm.Type,org.mockito.asm.Type[],java.lang.String);
	*** begin_method(int,org.mockito.cglib.core.Signature,org.mockito.asm.Type[]);
	*** begin_static();
	*** declare_field(int,java.lang.String,org.mockito.asm.Type,java.lang.Object);
	*** end_class();
	*** getAccess();
	*** getClassInfo();
	*** getClassType();
	*** getFieldInfo(java.lang.String);
	*** getNextHook();
	*** getStaticHook();
	*** getSuperType();
	*** init();
	*** isFieldDeclared(java.lang.String);
	*** setTarget(org.mockito.asm.ClassVisitor);
}

-keep class org.mockito.cglib.core.ClassEmitter$1 {
	*** this$0;
	*** val$access;
	*** val$classType;
	*** val$interfaces;
	*** val$superType;
}

-keep class org.mockito.cglib.core.ClassEmitter$2 {
	*** this$0;
}

-keep class org.mockito.cglib.core.ClassEmitter$3 {
	*** this$0;
}

-keep class org.mockito.cglib.core.ClassEmitter$FieldInfo {
	*** access;
	*** name;
	*** type;
	*** value;
	*** equals(java.lang.Object);
}

-keep class org.mockito.cglib.core.ClassGenerator {
	*** generateClass(org.mockito.asm.ClassVisitor);
}

-keep class org.mockito.cglib.core.ClassInfo {
	org.mockito.cglib.core.ClassInfo();
	*** getModifiers();
	*** getSuperType();
	*** getType();
}

-keep class org.mockito.cglib.core.ClassNameReader {
	*** EARLY_EXIT;
	*** access$100();
	*** getClassInfo(org.mockito.asm.ClassReader);
	*** getClassName(org.mockito.asm.ClassReader);
}

-keep class org.mockito.cglib.core.ClassNameReader$1 {
	*** val$array;
}

-keep class org.mockito.cglib.core.ClassNameReader$EarlyExitException {
	org.mockito.cglib.core.ClassNameReader$EarlyExitException();
}

-keep class org.mockito.cglib.core.CodeEmitter {
	*** BOOLEAN_VALUE;
	*** CHAR_VALUE;
	*** CSTRUCT_NULL;
	*** CSTRUCT_STRING;
	*** DOUBLE_VALUE;
	*** FLOAT_VALUE;
	*** INT_VALUE;
	*** LONG_VALUE;
	*** ce;
	*** state;
	org.mockito.cglib.core.CodeEmitter(org.mockito.cglib.core.ClassEmitter,org.mockito.asm.MethodVisitor,int,org.mockito.cglib.core.Signature,org.mockito.asm.Type[]);
	*** aaload();
	*** aaload(int);
	*** aastore();
	*** aconst_null();
	*** array_load(org.mockito.asm.Type);
	*** arraylength();
	*** athrow();
	*** begin_block();
	*** box(org.mockito.asm.Type);
	*** cast_numeric(org.mockito.asm.Type,org.mockito.asm.Type);
	*** catch_exception(org.mockito.cglib.core.Block,org.mockito.asm.Type);
	*** checkcast(org.mockito.asm.Type);
	*** checkcast_this();
	*** create_arg_array();
	*** dup();
	*** dup2();
	*** dup2_x1();
	*** dup2_x2();
	*** dup_x1();
	*** dup_x2();
	*** emit_field(int,org.mockito.asm.Type,java.lang.String,org.mockito.asm.Type);
	*** emit_invoke(int,org.mockito.asm.Type,org.mockito.cglib.core.Signature);
	*** emit_type(int,org.mockito.asm.Type);
	*** end_method();
	*** getClassEmitter();
	*** getReturnType();
	*** getfield(java.lang.String);
	*** getstatic(org.mockito.asm.Type,java.lang.String,org.mockito.asm.Type);
	*** goTo(org.mockito.asm.Label);
	*** if_cmp(org.mockito.asm.Type,int,org.mockito.asm.Label);
	*** if_icmp(int,org.mockito.asm.Label);
	*** if_jump(int,org.mockito.asm.Label);
	*** ifnonnull(org.mockito.asm.Label);
	*** ifnull(org.mockito.asm.Label);
	*** iinc(org.mockito.cglib.core.Local,int);
	*** instance_of(org.mockito.asm.Type);
	*** instance_of_this();
	*** invoke(org.mockito.cglib.core.MethodInfo);
	*** invoke(org.mockito.cglib.core.MethodInfo,org.mockito.asm.Type);
	*** invoke_constructor(org.mockito.asm.Type);
	*** invoke_constructor(org.mockito.asm.Type,org.mockito.cglib.core.Signature);
	*** invoke_constructor_this();
	*** invoke_constructor_this(org.mockito.cglib.core.Signature);
	*** invoke_interface(org.mockito.asm.Type,org.mockito.cglib.core.Signature);
	*** invoke_static(org.mockito.asm.Type,org.mockito.cglib.core.Signature);
	*** invoke_static_this(org.mockito.cglib.core.Signature);
	*** invoke_virtual(org.mockito.asm.Type,org.mockito.cglib.core.Signature);
	*** invoke_virtual_this(org.mockito.cglib.core.Signature);
	*** isSorted(int[]);
	*** isStaticHook();
	*** load_arg(int);
	*** load_args();
	*** load_args(int,int);
	*** load_local(org.mockito.asm.Type,int);
	*** load_local(org.mockito.cglib.core.Local);
	*** load_this();
	*** make_label();
	*** make_local();
	*** make_local(org.mockito.asm.Type);
	*** mark();
	*** mark(org.mockito.asm.Label);
	*** math(int,org.mockito.asm.Type);
	*** new_instance(org.mockito.asm.Type);
	*** new_instance_this();
	*** newarray();
	*** newarray(org.mockito.asm.Type);
	*** pop();
	*** pop2();
	*** process_switch(int[],org.mockito.cglib.core.ProcessSwitchCallback);
	*** process_switch(int[],org.mockito.cglib.core.ProcessSwitchCallback,boolean);
	*** push(double);
	*** push(float);
	*** push(int);
	*** push(java.lang.String);
	*** push(long);
	*** putfield(java.lang.String);
	*** putstatic(org.mockito.asm.Type,java.lang.String,org.mockito.asm.Type);
	*** return_value();
	*** skipArgs(int);
	*** store_local(org.mockito.asm.Type,int);
	*** store_local(org.mockito.cglib.core.Local);
	*** super_invoke();
	*** super_invoke(org.mockito.cglib.core.Signature);
	*** super_invoke_constructor();
	*** super_invoke_constructor(org.mockito.cglib.core.Signature);
	*** swap();
	*** swap(org.mockito.asm.Type,org.mockito.asm.Type);
	*** throw_exception(org.mockito.asm.Type,java.lang.String);
	*** unbox(org.mockito.asm.Type);
	*** unbox_or_zero(org.mockito.asm.Type);
	*** visitMaxs(int,int);
	*** zero_or_null(org.mockito.asm.Type);
}

-keep class org.mockito.cglib.core.CodeEmitter$State {
	*** access;
	*** argumentTypes;
	*** classInfo;
	*** exceptionTypes;
	*** localOffset;
	*** sig;
}

-keep class org.mockito.cglib.core.CodeGenerationException {
	*** cause;
}

-keep class org.mockito.cglib.core.CollectionUtils {
	*** bucket(java.util.Collection,org.mockito.cglib.core.Transformer);
	*** filter(java.util.Collection,org.mockito.cglib.core.Predicate);
	*** getIndexMap(java.util.List);
	*** reverse(java.util.Map,java.util.Map);
	*** transform(java.util.Collection,org.mockito.cglib.core.Transformer);
}

-keep class org.mockito.cglib.core.Constants {
	*** EMPTY_CLASS_ARRAY;
	*** SIG_STATIC;
	*** TYPES_EMPTY;
	*** TYPE_BIG_DECIMAL;
	*** TYPE_BIG_INTEGER;
	*** TYPE_BOOLEAN;
	*** TYPE_BYTE;
	*** TYPE_CHARACTER;
	*** TYPE_CLASS;
	*** TYPE_CLASS_ARRAY;
	*** TYPE_DOUBLE;
	*** TYPE_ERROR;
	*** TYPE_FLOAT;
	*** TYPE_INTEGER;
	*** TYPE_LONG;
	*** TYPE_NUMBER;
	*** TYPE_OBJECT;
	*** TYPE_OBJECT_ARRAY;
	*** TYPE_RUNTIME_EXCEPTION;
	*** TYPE_SHORT;
	*** TYPE_SIGNATURE;
	*** TYPE_STRING;
	*** TYPE_STRING_BUFFER;
	*** TYPE_THROWABLE;
}

-keep class org.mockito.cglib.core.Customizer {
	*** customize(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type);
}

-keep class org.mockito.cglib.core.DebuggingClassWriter {
	*** className;
	*** debugLocation;
	*** superName;
	*** traceEnabled;
	*** access$001(org.mockito.cglib.core.DebuggingClassWriter);
	*** access$100();
	*** access$200(org.mockito.cglib.core.DebuggingClassWriter);
	*** access$300();
}

-keep class org.mockito.cglib.core.DebuggingClassWriter$1 {
	*** this$0;
}

-keep class org.mockito.cglib.core.DefaultGeneratorStrategy {
	*** INSTANCE;
	*** getClassWriter();
	*** transform(byte[]);
	*** transform(org.mockito.cglib.core.ClassGenerator);
}

-keep class org.mockito.cglib.core.DefaultNamingPolicy {
	*** INSTANCE;
	org.mockito.cglib.core.DefaultNamingPolicy();
	*** getClassName(java.lang.String,java.lang.String,java.lang.Object,org.mockito.cglib.core.Predicate);
	*** getTag();
}

-keep class org.mockito.cglib.core.DuplicatesPredicate {
	*** unique;
}

-keep class org.mockito.cglib.core.EmitUtils {
	*** APPEND_BOOLEAN;
	*** APPEND_CHAR;
	*** APPEND_DOUBLE;
	*** APPEND_FLOAT;
	*** APPEND_INT;
	*** APPEND_LONG;
	*** APPEND_STRING;
	*** CSTRUCT_NULL;
	*** CSTRUCT_THROWABLE;
	*** DEFAULT_DELIMITERS;
	*** DOUBLE_TO_LONG_BITS;
	*** EQUALS;
	*** FLOAT_TO_INT_BITS;
	*** FOR_NAME;
	*** GET_DECLARED_METHOD;
	*** GET_NAME;
	*** HASH_CODE;
	*** LENGTH;
	*** SET_LENGTH;
	*** STRING_CHAR_AT;
	*** STRING_LENGTH;
	*** TO_STRING;
	*** access$100();
	*** access$200(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.asm.Label,org.mockito.cglib.core.Customizer,org.mockito.cglib.core.ProcessArrayCallback);
	*** access$300(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.cglib.core.EmitUtils$ArrayDelimiters,org.mockito.cglib.core.Customizer,org.mockito.cglib.core.ProcessArrayCallback);
	*** access$500();
	*** access$800(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback,org.mockito.cglib.core.EmitUtils$ParameterTyper,org.mockito.asm.Label,org.mockito.asm.Label);
	*** access$900(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback,org.mockito.cglib.core.EmitUtils$ParameterTyper,org.mockito.asm.Label,org.mockito.asm.Label,java.util.BitSet);
	*** add_property(org.mockito.cglib.core.ClassEmitter,java.lang.String,org.mockito.asm.Type,java.lang.String);
	*** append_string(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.cglib.core.EmitUtils$ArrayDelimiters,org.mockito.cglib.core.Customizer);
	*** append_string_helper(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.cglib.core.EmitUtils$ArrayDelimiters,org.mockito.cglib.core.Customizer,org.mockito.cglib.core.ProcessArrayCallback);
	*** begin_method(org.mockito.cglib.core.ClassEmitter,org.mockito.cglib.core.MethodInfo);
	*** begin_method(org.mockito.cglib.core.ClassEmitter,org.mockito.cglib.core.MethodInfo,int);
	*** constructor_switch(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback);
	*** factory_method(org.mockito.cglib.core.ClassEmitter,org.mockito.cglib.core.Signature);
	*** getSwitchKeys(java.util.Map);
	*** hash_array(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,int,org.mockito.cglib.core.Customizer);
	*** hash_code(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,int,org.mockito.cglib.core.Customizer);
	*** hash_long(org.mockito.cglib.core.CodeEmitter);
	*** hash_object(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.cglib.core.Customizer);
	*** hash_primitive(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type);
	*** load_class(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type);
	*** load_class_helper(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type);
	*** load_class_this(org.mockito.cglib.core.CodeEmitter);
	*** load_method(org.mockito.cglib.core.CodeEmitter,org.mockito.cglib.core.MethodInfo);
	*** member_helper_size(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback,org.mockito.cglib.core.EmitUtils$ParameterTyper,org.mockito.asm.Label,org.mockito.asm.Label);
	*** member_helper_type(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback,org.mockito.cglib.core.EmitUtils$ParameterTyper,org.mockito.asm.Label,org.mockito.asm.Label,java.util.BitSet);
	*** member_switch_helper(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback,boolean);
	*** method_switch(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback);
	*** not_equals(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.asm.Label,org.mockito.cglib.core.Customizer);
	*** not_equals_helper(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.asm.Label,org.mockito.cglib.core.Customizer,org.mockito.cglib.core.ProcessArrayCallback);
	*** null_constructor(org.mockito.cglib.core.ClassEmitter);
	*** nullcmp(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Label,org.mockito.asm.Label);
	*** process_array(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.cglib.core.ProcessArrayCallback);
	*** process_arrays(org.mockito.cglib.core.CodeEmitter,org.mockito.asm.Type,org.mockito.cglib.core.ProcessArrayCallback);
	*** push_array(org.mockito.cglib.core.CodeEmitter,java.lang.Object[]);
	*** push_object(org.mockito.cglib.core.CodeEmitter,java.lang.Object);
	*** remapComponentType(java.lang.Class);
	*** shrinkStringBuffer(org.mockito.cglib.core.CodeEmitter,int);
	*** stringSwitchHelper(org.mockito.cglib.core.CodeEmitter,java.util.List,org.mockito.cglib.core.ObjectSwitchCallback,org.mockito.asm.Label,org.mockito.asm.Label,int);
	*** string_switch(org.mockito.cglib.core.CodeEmitter,java.lang.String[],int,org.mockito.cglib.core.ObjectSwitchCallback);
	*** string_switch_hash(org.mockito.cglib.core.CodeEmitter,java.lang.String[],org.mockito.cglib.core.ObjectSwitchCallback,boolean);
	*** string_switch_trie(org.mockito.cglib.core.CodeEmitter,java.lang.String[],org.mockito.cglib.core.ObjectSwitchCallback);
	*** wrap_throwable(org.mockito.cglib.core.Block,org.mockito.asm.Type);
	*** wrap_undeclared_throwable(org.mockito.cglib.core.CodeEmitter,org.mockito.cglib.core.Block,org.mockito.asm.Type[],org.mockito.asm.Type);
}

-keep class org.mockito.cglib.core.EmitUtils$10 {
	*** val$cache;
}

-keep class org.mockito.cglib.core.EmitUtils$12 {
	*** val$buckets;
	*** val$cached;
	*** val$callback;
	*** val$def;
	*** val$e;
	*** val$end;
}

-keep class org.mockito.cglib.core.EmitUtils$13 {
	*** val$typer;
}

-keep class org.mockito.cglib.core.EmitUtils$14 {
	*** val$buckets;
	*** val$callback;
	*** val$def;
	*** val$e;
	*** val$end;
	*** val$typer;
}

-keep class org.mockito.cglib.core.EmitUtils$15 {
	*** val$j;
	*** val$typer;
}

-keep class org.mockito.cglib.core.EmitUtils$16 {
	*** val$callback;
	*** val$checked;
	*** val$def;
	*** val$e;
	*** val$end;
	*** val$fbuckets;
	*** val$typer;
}

-keep class org.mockito.cglib.core.EmitUtils$6 {
	*** val$buckets;
	*** val$callback;
	*** val$def;
	*** val$e;
	*** val$end;
	*** val$skipEquals;
}

-keep class org.mockito.cglib.core.EmitUtils$7 {
	*** val$customizer;
	*** val$e;
	*** val$multiplier;
}

-keep class org.mockito.cglib.core.EmitUtils$8 {
	*** val$customizer;
	*** val$e;
	*** val$notEquals;
	*** processElement(org.mockito.asm.Type);
}

-keep class org.mockito.cglib.core.EmitUtils$9 {
	*** val$customizer;
	*** val$d;
	*** val$e;
}

-keep class org.mockito.cglib.core.EmitUtils$ArrayDelimiters {
	*** after;
	*** before;
	*** inside;
	*** access$400(org.mockito.cglib.core.EmitUtils$ArrayDelimiters);
	*** access$600(org.mockito.cglib.core.EmitUtils$ArrayDelimiters);
	*** access$700(org.mockito.cglib.core.EmitUtils$ArrayDelimiters);
}

-keep class org.mockito.cglib.core.EmitUtils$ParameterTyper {
	*** getParameterTypes(org.mockito.cglib.core.MethodInfo);
}

-keep class org.mockito.cglib.core.GeneratorStrategy {
	*** generate(org.mockito.cglib.core.ClassGenerator);
}

-keep class org.mockito.cglib.core.KeyFactory {
	*** APPEND_STRING;
	*** CLASS_BY_NAME;
	*** EQUALS;
	*** GET_CLASS;
	*** GET_NAME;
	*** HASH_CODE;
	*** KEY_FACTORY;
	*** OBJECT_BY_CLASS;
	*** PRIMES;
	*** TO_STRING;
	org.mockito.cglib.core.KeyFactory();
	*** access$000();
	*** access$100();
	*** access$200();
	*** access$300();
	*** access$400();
	*** access$500();
	*** access$600();
	*** access$700();
	*** create(java.lang.Class);
	*** create(java.lang.Class,org.mockito.cglib.core.Customizer);
	*** create(java.lang.ClassLoader,java.lang.Class,org.mockito.cglib.core.Customizer);
}

-keep class org.mockito.cglib.core.KeyFactory$Generator {
	*** SOURCE;
	*** constant;
	*** customizer;
	*** keyInterface;
	*** multiplier;
	*** create();
	*** getFieldName(int);
	*** setCustomizer(org.mockito.cglib.core.Customizer);
	*** setInterface(java.lang.Class);
}

-keep class org.mockito.cglib.core.Local {
	*** index;
	*** type;
	*** getIndex();
	*** getType();
}

-keep class org.mockito.cglib.core.LocalVariablesSorter {
	*** firstLocal;
	*** state;
	org.mockito.cglib.core.LocalVariablesSorter(int,java.lang.String,org.mockito.asm.MethodVisitor);
	org.mockito.cglib.core.LocalVariablesSorter(org.mockito.cglib.core.LocalVariablesSorter);
	*** newLocal(int);
	*** remap(int);
	*** remap(int,int);
}

-keep class org.mockito.cglib.core.LocalVariablesSorter$State {
	*** mapping;
	*** nextLocal;
	org.mockito.cglib.core.LocalVariablesSorter$State();
}

-keep class org.mockito.cglib.core.MethodInfo {
	org.mockito.cglib.core.MethodInfo();
	*** getClassInfo();
	*** getExceptionTypes();
	*** getModifiers();
	*** getSignature();
	*** toString();
}

-keep class org.mockito.cglib.core.MethodInfoTransformer {
	*** INSTANCE;
	*** getInstance();
}

-keep class org.mockito.cglib.core.MethodWrapper {
	*** KEY_FACTORY;
	*** create(java.lang.reflect.Method);
	*** createSet(java.util.Collection);
}

-keep class org.mockito.cglib.core.MethodWrapper$MethodWrapperKey {
	*** newInstance(java.lang.String,java.lang.String[],java.lang.String);
}

-keep class org.mockito.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$2139e083 {
	*** FIELD_0;
	*** FIELD_1;
	*** FIELD_2;
}

-keep class org.mockito.cglib.core.NamingPolicy {
	*** getClassName(java.lang.String,java.lang.String,java.lang.Object,org.mockito.cglib.core.Predicate);
}

-keep class org.mockito.cglib.core.ObjectSwitchCallback {
	*** processCase(java.lang.Object,org.mockito.asm.Label);
	*** processDefault();
}

-keep class org.mockito.cglib.core.Predicate {
	*** evaluate(java.lang.Object);
}

-keep class org.mockito.cglib.core.ProcessArrayCallback {
	*** processElement(org.mockito.asm.Type);
}

-keep class org.mockito.cglib.core.ProcessSwitchCallback {
	*** processCase(int,org.mockito.asm.Label);
	*** processDefault();
}

-keep class org.mockito.cglib.core.ReflectUtils {
	*** CGLIB_PACKAGES;
	*** DEFINE_CLASS;
	*** PROTECTION_DOMAIN;
	*** defaultLoader;
	*** primitives;
	*** transforms;
	*** access$000();
	*** access$002(java.lang.reflect.Method);
	*** addAllInterfaces(java.lang.Class,java.util.List);
	*** addAllMethods(java.lang.Class,java.util.List);
	*** defineClass(java.lang.String,byte[],java.lang.ClassLoader);
	*** findConstructor(java.lang.String,java.lang.ClassLoader);
	*** findInterfaceMethod(java.lang.Class);
	*** findMethod(java.lang.String,java.lang.ClassLoader);
	*** findMethods(java.lang.String[],java.lang.reflect.Method[]);
	*** findNewInstance(java.lang.Class);
	*** findPackageProtected(java.lang.Class[]);
	*** getClass(java.lang.String,java.lang.ClassLoader);
	*** getClass(java.lang.String,java.lang.ClassLoader,java.lang.String[]);
	*** getClassInfo(java.lang.Class);
	*** getConstructor(java.lang.Class,java.lang.Class[]);
	*** getExceptionTypes(java.lang.reflect.Member);
	*** getMethodInfo(java.lang.reflect.Member);
	*** getMethodInfo(java.lang.reflect.Member,int);
	*** getNames(java.lang.Class[]);
	*** getPropertiesHelper(java.lang.Class,boolean,boolean);
	*** getSignature(java.lang.reflect.Member);
	*** newInstance(java.lang.Class);
	*** newInstance(java.lang.Class,java.lang.Class[],java.lang.Object[]);
	*** newInstance(java.lang.reflect.Constructor,java.lang.Object[]);
	*** parseTypes(java.lang.String,java.lang.ClassLoader);
}

-keep class org.mockito.cglib.core.ReflectUtils$3 {
	*** ci;
	*** val$member;
	*** val$modifiers;
	*** val$sig;
}

-keep class org.mockito.cglib.core.ReflectUtils$4 {
	*** val$clazz;
	*** val$sc;
	*** val$type;
}

-keep class org.mockito.cglib.core.RejectModifierPredicate {
	*** rejectMask;
}

-keep class org.mockito.cglib.core.Signature {
	*** desc;
	*** name;
	org.mockito.cglib.core.Signature(java.lang.String,java.lang.String);
	*** equals(java.lang.Object);
	*** getArgumentTypes();
	*** getDescriptor();
	*** getName();
	*** getReturnType();
	*** hashCode();
	*** toString();
}

-keep class org.mockito.cglib.core.Transformer {
	*** transform(java.lang.Object);
}

-keep class org.mockito.cglib.core.TypeUtils {
	*** rtransforms;
	*** transforms;
	*** DCONST(double);
	*** FCONST(float);
	*** ICONST(int);
	*** LCONST(long);
	*** NEWARRAY(org.mockito.asm.Type);
	*** add(org.mockito.asm.Type[],org.mockito.asm.Type);
	*** emulateClassGetName(org.mockito.asm.Type);
	*** escapeType(java.lang.String);
	*** fromInternalName(java.lang.String);
	*** fromInternalNames(java.lang.String[]);
	*** getBoxedType(org.mockito.asm.Type);
	*** getClassName(org.mockito.asm.Type);
	*** getComponentType(org.mockito.asm.Type);
	*** getPackageName(java.lang.String);
	*** getPackageName(org.mockito.asm.Type);
	*** getTypes(java.lang.Class[]);
	*** isAbstract(int);
	*** isArray(org.mockito.asm.Type);
	*** isConstructor(org.mockito.cglib.core.MethodInfo);
	*** isFinal(int);
	*** isInterface(int);
	*** isPrimitive(org.mockito.asm.Type);
	*** isProtected(int);
	*** isPublic(int);
	*** isStatic(int);
	*** map(java.lang.String);
	*** parseConstructor(java.lang.String);
	*** parseConstructor(org.mockito.asm.Type[]);
	*** parseSignature(java.lang.String);
	*** parseType(java.lang.String);
	*** parseTypes(java.lang.String,int,int);
	*** toInternalNames(org.mockito.asm.Type[]);
	*** upperFirst(java.lang.String);
}

-keep class org.mockito.cglib.core.VisibilityPredicate {
	*** pkg;
	*** protectedOk;
}

-keep class org.mockito.cglib.proxy.CallbackFilter {
	*** accept(java.lang.reflect.Method);
}

-keep class org.mockito.cglib.proxy.CallbackGenerator {
	*** generate(org.mockito.cglib.core.ClassEmitter,org.mockito.cglib.proxy.CallbackGenerator$Context,java.util.List);
	*** generateStatic(org.mockito.cglib.core.CodeEmitter,org.mockito.cglib.proxy.CallbackGenerator$Context,java.util.List);
}

-keep class org.mockito.cglib.proxy.CallbackGenerator$Context {
	*** beginMethod(org.mockito.cglib.core.ClassEmitter,org.mockito.cglib.core.MethodInfo);
	*** emitCallback(org.mockito.cglib.core.CodeEmitter,int);
	*** getImplSignature(org.mockito.cglib.core.MethodInfo);
	*** getIndex(org.mockito.cglib.core.MethodInfo);
	*** getOriginalModifiers(org.mockito.cglib.core.MethodInfo);
}

-keep class org.mockito.cglib.proxy.CallbackInfo {
	*** CALLBACKS;
	*** cls;
	*** generator;
	*** type;
	*** determineType(java.lang.Class);
	*** determineType(org.mockito.cglib.proxy.Callback);
	*** determineTypes(java.lang.Class[]);
	*** determineTypes(org.mockito.cglib.proxy.Callback[]);
	*** getGenerator(org.mockito.asm.Type);
	*** getGenerators(org.mockito.asm.Type[]);
}

-keep class org.mockito.cglib.proxy.DispatcherGenerator {
	*** DISPATCHER;
	*** INSTANCE;
	*** LOAD_OBJECT;
	*** PROXY_REF_DISPATCHER;
	*** PROXY_REF_INSTANCE;
	*** PROXY_REF_LOAD_OBJECT;
	*** proxyRef;
}

-keep class org.mockito.cglib.proxy.Enhancer {
	*** ALL_ZERO;
	*** BIND_CALLBACKS;
	*** CALLBACK;
	*** CALLBACK_ARRAY;
	*** CSTRUCT_NULL;
	*** FACTORY;
	*** GET_CALLBACK;
	*** GET_CALLBACKS;
	*** ILLEGAL_ARGUMENT_EXCEPTION;
	*** ILLEGAL_STATE_EXCEPTION;
	*** KEY_FACTORY;
	*** MULTIARG_NEW_INSTANCE;
	*** NEW_INSTANCE;
	*** SET_CALLBACK;
	*** SET_CALLBACKS;
	*** SET_STATIC_CALLBACKS;
	*** SET_THREAD_CALLBACKS;
	*** SINGLE_NEW_INSTANCE;
	*** SOURCE;
	*** THREAD_LOCAL;
	*** THREAD_LOCAL_GET;
	*** THREAD_LOCAL_SET;
	*** argumentTypes;
	*** arguments;
	*** callbackTypes;
	*** callbacks;
	*** classOnly;
	*** filter;
	*** interceptDuringConstruction;
	*** interfaces;
	*** serialVersionUID;
	*** superclass;
	*** useFactory;
	org.mockito.cglib.proxy.Enhancer();
	*** access$000(int);
	*** access$100(org.mockito.cglib.proxy.Enhancer);
	*** access$200();
	*** access$300(org.mockito.cglib.proxy.Enhancer,org.mockito.cglib.core.CodeEmitter,int);
	*** access$400(org.mockito.cglib.proxy.Enhancer,org.mockito.cglib.core.Signature,int);
	*** access$500(org.mockito.cglib.proxy.Enhancer);
	*** create();
	*** createClass();
	*** createHelper();
	*** createUsingReflection(java.lang.Class);
	*** emitBindCallbacks(org.mockito.cglib.core.ClassEmitter);
	*** emitCommonNewInstance(org.mockito.cglib.core.CodeEmitter);
	*** emitConstructors(org.mockito.cglib.core.ClassEmitter,java.util.List);
	*** emitCurrentCallback(org.mockito.cglib.core.CodeEmitter,int);
	*** emitGetCallback(org.mockito.cglib.core.ClassEmitter,int[]);
	*** emitGetCallbacks(org.mockito.cglib.core.ClassEmitter);
	*** emitMethods(org.mockito.cglib.core.ClassEmitter,java.util.List,java.util.List);
	*** emitNewInstanceCallback(org.mockito.cglib.core.ClassEmitter);
	*** emitNewInstanceCallbacks(org.mockito.cglib.core.ClassEmitter);
	*** emitNewInstanceMultiarg(org.mockito.cglib.core.ClassEmitter,java.util.List);
	*** emitSetCallback(org.mockito.cglib.core.ClassEmitter,int[]);
	*** emitSetCallbacks(org.mockito.cglib.core.ClassEmitter);
	*** emitSetStaticCallbacks(org.mockito.cglib.core.ClassEmitter);
	*** emitSetThreadCallbacks(org.mockito.cglib.core.ClassEmitter);
	*** filterConstructors(java.lang.Class,java.util.List);
	*** getCallbackField(int);
	*** getCallbackKeys();
	*** getCallbacksSetter(java.lang.Class,java.lang.String);
	*** getMethods(java.lang.Class,java.lang.Class[],java.util.List,java.util.List,java.util.Set);
	*** rename(org.mockito.cglib.core.Signature,int);
	*** setCallback(org.mockito.cglib.proxy.Callback);
	*** setCallbackFilter(org.mockito.cglib.proxy.CallbackFilter);
	*** setCallbackTypes(java.lang.Class[]);
	*** setCallbacks(org.mockito.cglib.proxy.Callback[]);
	*** setCallbacksHelper(java.lang.Class,org.mockito.cglib.proxy.Callback[],java.lang.String);
	*** setInterfaces(java.lang.Class[]);
	*** setSuperclass(java.lang.Class);
	*** setThreadCallbacks(java.lang.Class,org.mockito.cglib.proxy.Callback[]);
	*** setUseFactory(boolean);
	*** validate();
}

-keep class org.mockito.cglib.proxy.Enhancer$2 {
	*** this$0;
	*** val$forcePublic;
}

-keep class org.mockito.cglib.proxy.Enhancer$3 {
	*** this$0;
	*** val$e;
}

-keep class org.mockito.cglib.proxy.Enhancer$4 {
	*** this$0;
	*** val$e;
}

-keep class org.mockito.cglib.proxy.Enhancer$5 {
	*** this$0;
	*** val$e;
}

-keep class org.mockito.cglib.proxy.Enhancer$6 {
	*** this$0;
	*** val$indexes;
	*** val$originalModifiers;
	*** val$positions;
}

-keep class org.mockito.cglib.proxy.Enhancer$EnhancerKey {
	*** newInstance(java.lang.String,java.lang.String[],org.mockito.cglib.proxy.CallbackFilter,org.mockito.asm.Type[],boolean,boolean,java.lang.Long);
}

-keep class org.mockito.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$1e94e966 {
	*** FIELD_0;
	*** FIELD_1;
	*** FIELD_2;
	*** FIELD_3;
	*** FIELD_4;
	*** FIELD_5;
	*** FIELD_6;
}

-keep class org.mockito.cglib.proxy.Factory {
	*** getCallback(int);
	*** newInstance(java.lang.Class[],java.lang.Object[],org.mockito.cglib.proxy.Callback[]);
	*** newInstance(org.mockito.cglib.proxy.Callback[]);
	*** setCallback(int,org.mockito.cglib.proxy.Callback);
	*** setCallbacks(org.mockito.cglib.proxy.Callback[]);
}

-keep class org.mockito.cglib.proxy.FixedValueGenerator {
	*** FIXED_VALUE;
	*** INSTANCE;
	*** LOAD_OBJECT;
}

-keep class org.mockito.cglib.proxy.InvocationHandlerGenerator {
	*** INSTANCE;
	*** INVOCATION_HANDLER;
	*** INVOKE;
	*** METHOD;
	*** UNDECLARED_THROWABLE_EXCEPTION;
}

-keep class org.mockito.cglib.proxy.LazyLoaderGenerator {
	*** INSTANCE;
	*** LAZY_LOADER;
	*** LOAD_OBJECT;
	*** loadMethod(int);
}

-keep class org.mockito.cglib.proxy.MethodInterceptor {
	*** intercept(java.lang.Object,java.lang.reflect.Method,java.lang.Object[],org.mockito.cglib.proxy.MethodProxy);
}

-keep class org.mockito.cglib.proxy.MethodInterceptorGenerator {
	*** ABSTRACT_METHOD_ERROR;
	*** CSTRUCT_SIGNATURE;
	*** FIND_METHODS;
	*** FIND_PROXY;
	*** FIND_PROXY_TYPES;
	*** GET_DECLARED_METHODS;
	*** GET_DECLARING_CLASS;
	*** INSTANCE;
	*** INTERCEPT;
	*** MAKE_PROXY;
	*** METHOD;
	*** METHOD_INTERCEPTOR;
	*** METHOD_PROXY;
	*** METHOD_TO_CLASS;
	*** REFLECT_UTILS;
	*** TO_STRING;
	*** generateFindProxy(org.mockito.cglib.core.ClassEmitter,java.util.Map);
	*** getMethodField(org.mockito.cglib.core.Signature);
	*** getMethodProxyField(org.mockito.cglib.core.Signature);
	*** superHelper(org.mockito.cglib.core.CodeEmitter,org.mockito.cglib.core.MethodInfo);
}

-keep class org.mockito.cglib.proxy.MethodInterceptorGenerator$2 {
	*** this$0;
	*** val$e;
	*** val$sigMap;
}

-keep class org.mockito.cglib.proxy.MethodProxy {
	*** createInfo;
	*** fastClassInfo;
	*** initLock;
	*** sig1;
	*** sig2;
	*** create(java.lang.Class,java.lang.Class,java.lang.String,java.lang.String,java.lang.String);
	*** helper(org.mockito.cglib.proxy.MethodProxy$CreateInfo,java.lang.Class);
	*** init();
	*** invokeSuper(java.lang.Object,java.lang.Object[]);
}

-keep class org.mockito.cglib.proxy.MethodProxy$CreateInfo {
	*** attemptLoad;
	*** c1;
	*** c2;
	*** namingPolicy;
	*** strategy;
}

-keep class org.mockito.cglib.proxy.MethodProxy$FastClassInfo {
	*** f1;
	*** f2;
	*** i1;
	*** i2;
	org.mockito.cglib.proxy.MethodProxy$FastClassInfo();
}

-keep class org.mockito.cglib.proxy.NoOpGenerator {
	*** INSTANCE;
}

-keep class org.mockito.cglib.reflect.FastClass {
	*** type;
	org.mockito.cglib.reflect.FastClass(java.lang.Class);
	*** create(java.lang.ClassLoader,java.lang.Class);
	*** getConstructor(java.lang.reflect.Constructor);
	*** getIndex(java.lang.Class[]);
	*** getIndex(java.lang.String,java.lang.Class[]);
	*** getIndex(org.mockito.cglib.core.Signature);
	*** getMethod(java.lang.reflect.Method);
	*** invoke(int,java.lang.Object,java.lang.Object[]);
	*** newInstance(int,java.lang.Object[]);
}

-keep class org.mockito.cglib.reflect.FastClass$Generator {
	*** SOURCE;
	*** type;
	*** create();
	*** setType(java.lang.Class);
}

-keep class org.mockito.cglib.reflect.FastClassEmitter {
	*** CONSTRUCTOR_GET_INDEX;
	*** CSTRUCT_CLASS;
	*** FAST_CLASS;
	*** GET_MAX_INDEX;
	*** GET_SIGNATURE_WITHOUT_RETURN_TYPE;
	*** ILLEGAL_ARGUMENT_EXCEPTION;
	*** INVOCATION_TARGET_EXCEPTION;
	*** INVOCATION_TARGET_EXCEPTION_ARRAY;
	*** INVOKE;
	*** METHOD_GET_INDEX;
	*** NEW_INSTANCE;
	*** SIGNATURE_GET_INDEX;
	*** TO_STRING;
	*** emitIndexByClassArray(java.util.List);
	*** emitIndexBySignature(java.util.List);
	*** getIntRange(int);
	*** invokeSwitchHelper(org.mockito.cglib.core.CodeEmitter,java.util.List,int,org.mockito.asm.Type);
	*** signatureSwitchHelper(org.mockito.cglib.core.CodeEmitter,java.util.List);
}

-keep class org.mockito.cglib.reflect.FastClassEmitter$1 {
	*** this$0;
}

-keep class org.mockito.cglib.reflect.FastClassEmitter$3 {
	*** this$0;
	*** val$e;
	*** val$signatures;
}

-keep class org.mockito.cglib.reflect.FastClassEmitter$4 {
	*** val$arg;
	*** val$base;
	*** val$e;
	*** val$illegalArg;
	*** val$info;
}

-keep class org.mockito.cglib.reflect.FastClassEmitter$GetIndexCallback {
	*** e;
	*** indexes;
}

-keep class org.mockito.configuration.IMockitoConfiguration {
	*** cleansStackTrace();
	*** enableClassCache();
	*** getAnnotationEngine();
	*** getDefaultAnswer();
	*** getReturnValues();
}

-keep class org.mockito.exceptions.Reporter {
	*** cannotCallRealMethodOnInterface();
	*** cannotMockFinalClass(java.lang.Class);
	*** cannotStubVoidMethodWithAReturnValue(java.lang.String);
	*** cannotStubWithNullThrowable();
	*** checkedExceptionInvalid(java.lang.Throwable);
	*** createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy,org.mockito.invocation.DescribedInvocation,org.mockito.invocation.Location);
	*** createTooManyInvocationsMessage(int,int,org.mockito.invocation.DescribedInvocation,org.mockito.invocation.Location);
	*** createWantedButNotInvokedMessage(org.mockito.invocation.DescribedInvocation);
	*** extraInterfacesAcceptsOnlyInterfaces(java.lang.Class);
	*** extraInterfacesCannotContainMockedType(java.lang.Class);
	*** extraInterfacesDoesNotAcceptNullParameters();
	*** extraInterfacesRequiresAtLeastOneInterface();
	*** incorrectUseOfAdditionalMatchers(java.lang.String,int,java.util.Collection);
	*** incorrectUseOfApi();
	*** invalidArgumentPositionRangeAtInvocationTime(org.mockito.invocation.InvocationOnMock,boolean,int);
	*** invalidArgumentRangeAtIdentityAnswerCreationTime();
	*** invalidUseOfMatchers(int,java.util.List);
	*** invocationListenerDoesNotAcceptNullParameters();
	*** invocationListenerThrewException(org.mockito.listeners.InvocationListener,java.lang.Throwable);
	*** invocationListenersRequiresAtLeastOneListener();
	*** locationsOf(java.util.Collection);
	*** misplacedArgumentMatcher(java.util.List);
	*** missingMethodInvocation();
	*** mockedTypeIsInconsistentWithDelegatedInstanceType(java.lang.Class,java.lang.Object);
	*** mockedTypeIsInconsistentWithSpiedInstanceType(java.lang.Class,java.lang.Object);
	*** mocksHaveToBePassedToVerifyNoMoreInteractions();
	*** mocksHaveToBePassedWhenCreatingInOrder();
	*** notAMockPassedToVerify(java.lang.Class);
	*** notAMockPassedToVerifyNoMoreInteractions();
	*** notAMockPassedToWhenMethod();
	*** notAMockPassedWhenCreatingInOrder();
	*** nullPassedToVerify();
	*** nullPassedToVerifyNoMoreInteractions();
	*** nullPassedToWhenMethod();
	*** nullPassedWhenCreatingInOrder();
	*** onlyVoidMethodsCanBeSetToDoNothing();
	*** possibleArgumentTypesOf(org.mockito.invocation.InvocationOnMock);
	*** reportNoSubMatchersFound(java.lang.String);
	*** unfinishedStubbing(org.mockito.invocation.Location);
	*** unfinishedVerificationException(org.mockito.invocation.Location);
	*** wrongTypeOfArgumentToReturn(org.mockito.invocation.InvocationOnMock,java.lang.String,java.lang.Class,int);
	*** wrongTypeOfReturnValue(java.lang.String,java.lang.String,java.lang.String);
}

-keep class org.mockito.exceptions.base.MockitoAssertionError {
	*** unfilteredStackTrace;
	org.mockito.exceptions.base.MockitoAssertionError(java.lang.String);
}

-keep class org.mockito.exceptions.base.MockitoException {
	*** unfilteredStackTrace;
	org.mockito.exceptions.base.MockitoException(java.lang.String);
	org.mockito.exceptions.base.MockitoException(java.lang.String,java.lang.Throwable);
	*** filterStackTrace();
}

-keep class org.mockito.exceptions.stacktrace.StackTraceCleaner {
	*** isOut(java.lang.StackTraceElement);
}

-keep class org.mockito.internal.InternalMockHandler {
	*** getInvocationContainer();
	*** getMockSettings();
	*** setAnswersForStubbing(java.util.List);
	*** voidMethodStubbable(java.lang.Object);
}

-keep class org.mockito.internal.MockitoCore {
	*** mockUtil;
	*** mockingProgress;
	*** reporter;
	*** assertMocksNotEmpty(java.lang.Object[]);
	*** doAnswer(org.mockito.stubbing.Answer);
	*** ignoreStubs(java.lang.Object[]);
	*** inOrder(java.lang.Object[]);
	*** mock(java.lang.Class,org.mockito.MockSettings);
	*** mockingDetails(java.lang.Object);
	*** reset(java.lang.Object[]);
	*** stub();
	*** stub(java.lang.Object);
	*** stubVoid(java.lang.Object);
	*** validateMockitoUsage();
	*** verify(java.lang.Object,org.mockito.verification.VerificationMode);
	*** verifyNoMoreInteractions(java.lang.Object[]);
	*** when(java.lang.Object);
}

-keep class org.mockito.internal.configuration.ClassPathLoader {
	*** mockMaker;
	*** stackTraceCleanerProvider;
	*** closeQuietly(java.io.InputStream);
	*** findPlatformMockMaker();
	*** findPluginImplementation(java.lang.Class,java.lang.Object);
	*** getMockMaker();
	*** getStackTraceCleanerProvider();
	*** loadConfiguration();
	*** loadImplementations(java.lang.Class);
	*** readerToLines(java.io.Reader);
	*** stripCommentAndWhitespace(java.lang.String);
}

-keep class org.mockito.internal.configuration.GlobalConfiguration {
	*** globalConfiguration;
	*** createConfig();
	*** enableClassCache();
	*** getDefaultAnswer();
	*** validate();
}

-keep class org.mockito.internal.creation.AbstractMockitoMethodProxy {
	org.mockito.internal.creation.AbstractMockitoMethodProxy();
}

-keep class org.mockito.internal.creation.CglibMockMaker {
	*** cast(org.mockito.invocation.MockHandler);
}

-keep class org.mockito.internal.creation.ClassNameFinder {
	*** classNameForMock(java.lang.Object);
}

-keep class org.mockito.internal.creation.DelegatingMethod {
	*** $assertionsDisabled;
	*** method;
}

-keep class org.mockito.internal.creation.DelegatingMockitoMethodProxy {
	*** methodProxy;
}

-keep class org.mockito.internal.creation.MethodInterceptorFilter {
	*** cglibHacker;
	*** handler;
	*** mockSettings;
	*** objectMethodsGuru;
	*** createMockitoMethod(java.lang.reflect.Method);
	*** createMockitoMethodProxy(org.mockito.cglib.proxy.MethodProxy);
	*** getHandler();
	*** hashCodeForMock(java.lang.Object);
}

-keep class org.mockito.internal.creation.MockSettingsImpl {
	*** confirm(java.lang.Class);
	*** defaultAnswer(org.mockito.stubbing.Answer);
	*** invocationListeners(org.mockito.listeners.InvocationListener[]);
	*** invocationListenersContainsType(java.lang.Class);
	*** prepareExtraInterfaces(org.mockito.internal.creation.settings.CreationSettings);
	*** validatedSettings(java.lang.Class,org.mockito.internal.creation.settings.CreationSettings);
}

-keep class org.mockito.internal.creation.MockitoMethodProxy {
	*** getMethodProxy();
	*** invokeSuper(java.lang.Object,java.lang.Object[]);
}

-keep class org.mockito.internal.creation.cglib.CGLIBHacker {
	*** reflectOnCreateInfo(org.mockito.cglib.proxy.MethodProxy);
	*** setMockitoNamingPolicy(org.mockito.internal.creation.MockitoMethodProxy);
}

-keep class org.mockito.internal.creation.cglib.MockitoNamingPolicy {
	*** INSTANCE;
	org.mockito.internal.creation.cglib.MockitoNamingPolicy();
}

-keep class org.mockito.internal.creation.jmock.ClassImposterizer {
	*** IGNORE_BRIDGE_METHODS;
	*** INSTANCE;
	*** NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES;
	*** objenesis;
	*** canImposterise(java.lang.Class);
	*** createProxy(java.lang.Class,org.mockito.cglib.proxy.MethodInterceptor);
	*** createProxyClass(java.lang.Class,java.lang.Class[]);
	*** imposterise(org.mockito.cglib.proxy.MethodInterceptor,java.lang.Class,java.lang.Class[]);
	*** imposterise(org.mockito.cglib.proxy.MethodInterceptor,java.lang.Class,java.util.Collection);
	*** prepend(java.lang.Class,java.lang.Class[]);
	*** setConstructorsAccessible(java.lang.Class,boolean);
}

-keep class org.mockito.internal.creation.jmock.ClassImposterizer$3 {
	*** this$0;
}

-keep class org.mockito.internal.creation.jmock.SearchingClassLoader {
	*** nextToSearch;
	*** addIfNewElement(java.util.List,java.lang.ClassLoader);
	*** combine(java.util.List);
	*** combineLoadersOf(java.lang.Class,java.lang.Class[]);
	*** combineLoadersOf(java.lang.Class[]);
}

-keep class org.mockito.internal.creation.jmock.SerializableNoOp {
	*** SERIALIZABLE_INSTANCE;
}

-keep class org.mockito.internal.creation.settings.CreationSettings {
	*** defaultAnswer;
	*** extraInterfaces;
	*** invocationListeners;
	*** mockName;
	*** name;
	*** serializable;
	*** spiedInstance;
	*** typeToMock;
	org.mockito.internal.creation.settings.CreationSettings();
	*** getExtraInterfaces();
	*** getName();
	*** getSpiedInstance();
	*** isSerializable();
	*** setExtraInterfaces(java.util.Set);
	*** setMockName(org.mockito.mock.MockName);
	*** setTypeToMock(java.lang.Class);
}

-keep class org.mockito.internal.debugging.Localized {
	*** getLocation();
	*** getObject();
}

-keep class org.mockito.internal.debugging.LocationImpl {
	*** stackTraceFilter;
	*** stackTraceHolder;
	org.mockito.internal.debugging.LocationImpl(org.mockito.internal.exceptions.stacktrace.StackTraceFilter);
}

-keep class org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter {
	*** filter(java.lang.Throwable);
}

-keep class org.mockito.internal.exceptions.stacktrace.StackTraceFilter {
	*** cleaner;
	*** filter(java.lang.StackTraceElement[],boolean);
}

-keep class org.mockito.internal.exceptions.util.ScenarioPrinter {
	*** print(java.util.List);
}

-keep class org.mockito.internal.handler.InvocationNotifierHandler {
	*** invocationListeners;
	*** mockHandler;
	*** notifyMethodCall(org.mockito.invocation.Invocation,java.lang.Object);
	*** notifyMethodCallException(org.mockito.invocation.Invocation,java.lang.Throwable);
}

-keep class org.mockito.internal.handler.MockHandlerFactory {
	*** create(org.mockito.mock.MockCreationSettings);
}

-keep class org.mockito.internal.handler.MockHandlerImpl {
	*** invocationContainerImpl;
	*** matchersBinder;
	*** mockSettings;
	*** mockingProgress;
}

-keep class org.mockito.internal.handler.NullResultGuardian {
	*** delegate;
}

-keep class org.mockito.internal.invocation.ArgumentsComparator {
	*** argumentsMatch(org.mockito.internal.invocation.InvocationMatcher,java.lang.Object[]);
	*** argumentsMatch(org.mockito.internal.invocation.InvocationMatcher,org.mockito.invocation.Invocation);
	*** varArgsMatch(org.mockito.internal.invocation.InvocationMatcher,org.mockito.invocation.Invocation);
}

-keep class org.mockito.internal.invocation.ArgumentsProcessor {
	*** argumentsToMatchers(java.lang.Object[]);
	*** expandVarArgs(boolean,java.lang.Object[]);
}

-keep class org.mockito.internal.invocation.InvocationImpl {
	*** arguments;
	*** isIgnoredForVerification;
	*** location;
	*** method;
	*** mock;
	*** rawArguments;
	*** realMethod;
	*** sequenceNumber;
	*** stubInfo;
	*** verified;
	*** equalArguments(java.lang.Object[]);
	*** getArguments();
	*** getMethod();
}

-keep class org.mockito.internal.invocation.InvocationMatcher {
	*** invocation;
	*** matchers;
	org.mockito.internal.invocation.InvocationMatcher(org.mockito.invocation.Invocation,java.util.List);
	*** captureArgumentsFrom(org.mockito.invocation.Invocation);
	*** getInvocation();
	*** getMatchers();
	*** getMethod();
	*** hasSameMethod(org.mockito.invocation.Invocation);
	*** matches(org.mockito.invocation.Invocation);
	*** safelyArgumentsMatch(java.lang.Object[]);
	*** toString();
}

-keep class org.mockito.internal.invocation.MatchersBinder {
	*** bindMatchers(org.mockito.internal.progress.ArgumentMatcherStorage,org.mockito.invocation.Invocation);
	*** validateMatchers(org.mockito.invocation.Invocation,java.util.List);
}

-keep class org.mockito.internal.invocation.MockitoMethod {
	*** getJavaMethod();
	*** getName();
	*** getParameterTypes();
	*** getReturnType();
	*** isVarArgs();
}

-keep class org.mockito.internal.invocation.StubInfoImpl {
	*** stubbedAt;
}

-keep class org.mockito.internal.invocation.finder.VerifiableInvocationsFinder {
	*** find(java.util.List);
}

-keep class org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod {
	*** methodProxy;
}

-keep class org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod {
	*** realMethod;
	org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod(org.mockito.internal.invocation.realmethod.RealMethod);
}

-keep class org.mockito.internal.invocation.realmethod.HasCGLIBMethodProxy {
	*** getMethodProxy();
}

-keep class org.mockito.internal.invocation.realmethod.RealMethod {
	*** invoke(java.lang.Object,java.lang.Object[]);
}

-keep class org.mockito.internal.junit.JUnitTool {
	*** createArgumentsAreDifferentException(java.lang.String,java.lang.String,java.lang.String);
	*** hasJUnit();
}

-keep class org.mockito.internal.listeners.MockingStartedListener {
	*** mockingStarted(java.lang.Object,java.lang.Class);
}

-keep class org.mockito.internal.matchers.Any {
	*** ANY;
}

-keep class org.mockito.internal.matchers.AnyVararg {
	*** ANY_VARARG;
}

-keep class org.mockito.internal.matchers.ArrayEquals {
	*** createObjectArray(java.lang.Object);
}

-keep class org.mockito.internal.matchers.CapturesArguments {
	*** captureFrom(java.lang.Object);
}

-keep class org.mockito.internal.matchers.ContainsExtraTypeInformation {
	*** typeMatches(java.lang.Object);
	*** withExtraTypeInfo();
}

-keep class org.mockito.internal.matchers.Equality {
	*** areEqual(java.lang.Object,java.lang.Object);
}

-keep class org.mockito.internal.matchers.Equals {
	*** wanted;
	*** describe(java.lang.Object);
	*** quoting();
}

-keep class org.mockito.internal.matchers.LocalizedMatcher {
	*** actualMatcher;
	*** location;
	*** getLocation();
}

-keep class org.mockito.internal.matchers.MatcherDecorator {
	*** getActualMatcher();
}

-keep class org.mockito.internal.matchers.NotNull {
	*** NOT_NULL;
}

-keep class org.mockito.internal.matchers.Null {
	*** NULL;
}

-keep class org.mockito.internal.progress.ArgumentMatcherStorage {
	*** pullLocalizedMatchers();
	*** reportMatcher(org.hamcrest.Matcher);
	*** reset();
	*** validateState();
}

-keep class org.mockito.internal.progress.ArgumentMatcherStorageImpl {
	*** matcherStack;
	*** assertIncorrectUseOfAdditionalMatchers(java.lang.String,int);
	*** assertMatchersFoundFor(java.lang.String);
	*** assertStateFor(java.lang.String,int);
	*** popLastArgumentMatchers(int);
}

-keep class org.mockito.internal.progress.HandyReturnValues {
	*** returnChar();
	*** returnFalse();
	*** returnFor(java.lang.Class);
	*** returnFor(java.lang.Object);
	*** returnList();
	*** returnMap();
	*** returnNull();
	*** returnSet();
	*** returnString();
	*** returnZero();
}

-keep class org.mockito.internal.progress.MockingProgress {
	*** getArgumentMatcherStorage();
	*** mockingStarted(java.lang.Object,java.lang.Class);
	*** pullOngoingStubbing();
	*** pullVerificationMode();
	*** reportOngoingStubbing(org.mockito.internal.progress.IOngoingStubbing);
	*** reset();
	*** resetOngoingStubbing();
	*** setListener(org.mockito.internal.listeners.MockingProgressListener);
	*** stubbingCompleted(org.mockito.invocation.Invocation);
	*** stubbingStarted();
	*** validateState();
	*** verificationStarted(org.mockito.verification.VerificationMode);
}

-keep class org.mockito.internal.progress.MockingProgressImpl {
	*** argumentMatcherStorage;
	*** iOngoingStubbing;
	*** listener;
	*** reporter;
	*** stubbingInProgress;
	*** verificationMode;
	*** getArgumentMatcherStorage();
	*** resetOngoingStubbing();
	*** validateMostStuff();
	*** validateState();
}

-keep class org.mockito.internal.progress.SequenceNumber {
	*** sequenceNumber;
	*** next();
}

-keep class org.mockito.internal.progress.ThreadSafeMockingProgress {
	*** mockingProgress;
	*** threadSafely();
}

-keep class org.mockito.internal.reporting.Discrepancy {
	*** getPluralizedActualCount();
	*** getPluralizedWantedCount();
}

-keep class org.mockito.internal.reporting.Pluralizer {
	*** pluralize(int);
}

-keep class org.mockito.internal.reporting.PrintSettings {
	*** print(java.util.List,org.mockito.invocation.Invocation);
}

-keep class org.mockito.internal.stubbing.BaseStubbing {
	org.mockito.internal.stubbing.BaseStubbing();
	*** thenReturn(java.lang.Object);
	*** thenThrow(java.lang.Class);
	*** thenThrow(java.lang.Throwable);
}

-keep class org.mockito.internal.stubbing.ConsecutiveStubbing {
	*** invocationContainerImpl;
	*** thenAnswer(org.mockito.stubbing.Answer);
}

-keep class org.mockito.internal.stubbing.InvocationContainer {
	*** getInvocations();
}

-keep class org.mockito.internal.stubbing.InvocationContainerImpl {
	*** $assertionsDisabled;
	*** answersForStubbing;
	*** invocationForStubbing;
	*** mockingProgress;
	*** registeredInvocations;
	*** stubbed;
	*** addAnswer(org.mockito.stubbing.Answer);
	*** addAnswer(org.mockito.stubbing.Answer,boolean);
	*** addConsecutiveAnswer(org.mockito.stubbing.Answer);
	*** findAnswerFor(org.mockito.invocation.Invocation);
	*** getInvocationForStubbing();
	*** getInvocations();
	*** getStubbedInvocations();
	*** hasAnswersForStubbing();
	*** hasInvocationForPotentialStubbing();
	*** invokedMock();
	*** resetInvocationForPotentialStubbing(org.mockito.internal.invocation.InvocationMatcher);
	*** setAnswersForStubbing(java.util.List);
	*** setInvocationForPotentialStubbing(org.mockito.internal.invocation.InvocationMatcher);
	*** setMethodForStubbing(org.mockito.internal.invocation.InvocationMatcher);
}

-keep class org.mockito.internal.stubbing.OngoingStubbingImpl {
	*** invocationContainerImpl;
	*** getRegisteredInvocations();
	*** thenAnswer(org.mockito.stubbing.Answer);
}

-keep class org.mockito.internal.stubbing.StubbedInvocationMatcher {
	*** answers;
	*** usedAt;
	*** addAnswer(org.mockito.stubbing.Answer);
	*** answer(org.mockito.invocation.InvocationOnMock);
	*** markStubUsed(org.mockito.invocation.DescribedInvocation);
}

-keep class org.mockito.internal.stubbing.StubberImpl {
	*** answers;
	*** reporter;
	*** doAnswer(org.mockito.stubbing.Answer);
}

-keep class org.mockito.internal.stubbing.answers.AnswersValidator {
	*** reporter;
	*** validate(org.mockito.stubbing.Answer,org.mockito.invocation.Invocation);
	*** validateDoNothing(org.mockito.internal.stubbing.answers.DoesNothing,org.mockito.internal.stubbing.answers.MethodInfo);
	*** validateException(org.mockito.internal.stubbing.answers.ThrowsException,org.mockito.internal.stubbing.answers.MethodInfo);
	*** validateMockingConcreteClass(org.mockito.internal.stubbing.answers.CallsRealMethods,org.mockito.internal.stubbing.answers.MethodInfo);
	*** validateReturnArgIdentity(org.mockito.internal.stubbing.answers.ReturnsArgumentAt,org.mockito.invocation.Invocation);
	*** validateReturnValue(org.mockito.internal.stubbing.answers.Returns,org.mockito.internal.stubbing.answers.MethodInfo);
}

-keep class org.mockito.internal.stubbing.answers.MethodInfo {
	*** method;
	*** getMethodName();
	*** isDeclaredOnInterface();
	*** isValidException(java.lang.Throwable);
	*** isValidReturnType(java.lang.Class);
	*** isVoid();
	*** printMethodReturnType();
	*** returnsPrimitive();
}

-keep class org.mockito.internal.stubbing.answers.Returns {
	*** value;
	*** getReturnType();
	*** printReturnType();
	*** returnsNull();
}

-keep class org.mockito.internal.stubbing.answers.ReturnsArgumentAt {
	*** wantedArgumentPosition;
	*** actualArgumentPosition(org.mockito.invocation.InvocationOnMock);
	*** argumentIndexOf(org.mockito.invocation.InvocationOnMock);
	*** argumentPositionInRange(org.mockito.invocation.InvocationOnMock);
	*** checkWithinAllowedRange(int);
	*** lastArgumentIndexOf(org.mockito.invocation.InvocationOnMock);
	*** returnedTypeOnSignature(org.mockito.invocation.InvocationOnMock);
	*** returningLastArg();
	*** validateIndexWithinInvocationRange(org.mockito.invocation.InvocationOnMock);
	*** wantedArgumentPosition();
}

-keep class org.mockito.internal.stubbing.answers.ThrowsException {
	*** filter;
	*** throwable;
	*** getThrowable();
}

-keep class org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs {
	*** delegate;
	*** getMock(org.mockito.invocation.InvocationOnMock);
	*** recordDeepStubMock(org.mockito.invocation.InvocationOnMock,org.mockito.internal.stubbing.InvocationContainerImpl);
}

-keep class org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues {
	*** methodsGuru;
	*** returnValueFor(java.lang.Class);
}

-keep class org.mockito.internal.stubbing.defaultanswers.ReturnsMocks {
	*** delegate;
	*** mockitoCore;
	*** returnValueFor(java.lang.Class);
}

-keep class org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues {
	*** delegate;
	*** returnValueFor(java.lang.Class);
}

-keep class org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls {
	*** delegate;
}

-keep class org.mockito.internal.util.Decamelizer {
	*** decamelizeMatcher(java.lang.String);
}

-keep class org.mockito.internal.util.MockCreationValidator {
	*** isTypeMockable(java.lang.Class);
	*** validateExtraInterfaces(java.lang.Class,java.util.Collection);
	*** validateMockedType(java.lang.Class,java.lang.Object);
	*** validateType(java.lang.Class);
}

-keep class org.mockito.internal.util.MockNameImpl {
	*** defaultName;
	*** mockName;
	*** toInstanceName(java.lang.Class);
}

-keep class org.mockito.internal.util.MockUtil {
	*** mockMaker;
	*** createMock(org.mockito.mock.MockCreationSettings);
	*** getMockHandler(java.lang.Object);
	*** getMockName(java.lang.Object);
	*** isMock(java.lang.Object);
	*** isMockitoMock(java.lang.Object);
	*** resetMock(java.lang.Object);
}

-keep class org.mockito.internal.util.ObjectMethodsGuru {
	*** isCompareToMethod(java.lang.reflect.Method);
	*** isEqualsMethod(java.lang.reflect.Method);
	*** isHashCodeMethod(java.lang.reflect.Method);
	*** isToString(java.lang.reflect.Method);
	*** isToString(org.mockito.internal.invocation.MockitoMethod);
}

-keep class org.mockito.internal.util.Primitives {
	*** primitiveOrWrapperDefaultValues;
	*** primitiveTypes;
	*** defaultValueForPrimitiveOrWrapper(java.lang.Class);
	*** isPrimitiveOrWrapper(java.lang.Class);
	*** primitiveTypeOf(java.lang.Class);
}

-keep class org.mockito.internal.util.RemoveFirstLine {
	*** of(java.lang.String);
}

-keep class org.mockito.internal.util.StringJoiner {
	*** join(java.lang.Object[]);
}

-keep class org.mockito.internal.util.collections.ArrayUtils {
	*** isEmpty(java.lang.Object[]);
}

-keep class org.mockito.internal.util.collections.ListUtil {
	*** filter(java.util.Collection,org.mockito.internal.util.collections.ListUtil$Filter);
}

-keep class org.mockito.internal.util.collections.Sets {
	*** newSet(java.lang.Object[]);
}

-keep class org.mockito.internal.util.reflection.AccessibilityChanger {
	*** $assertionsDisabled;
	*** wasAccessible;
	*** enableAccess(java.lang.reflect.AccessibleObject);
	*** safelyDisableAccess(java.lang.reflect.AccessibleObject);
}

-keep class org.mockito.internal.util.reflection.FieldCopier {
	*** copyValue(java.lang.Object,java.lang.Object,java.lang.reflect.Field);
}

-keep class org.mockito.internal.util.reflection.LenientCopyTool {
	*** fieldCopier;
	*** copy(java.lang.Object,java.lang.Object,java.lang.Class,java.lang.Class);
	*** copyToMock(java.lang.Object,java.lang.Object);
	*** copyValues(java.lang.Object,java.lang.Object,java.lang.Class);
}

-keep class org.mockito.internal.verification.MockAwareVerificationMode {
	*** getMock();
}

-keep class org.mockito.internal.verification.NoMoreInteractions {
	*** verify(org.mockito.internal.verification.api.VerificationData);
	*** verifyInOrder(org.mockito.internal.verification.api.VerificationDataInOrder);
}

-keep class org.mockito.internal.verification.RegisteredInvocations {
	*** invocations;
	*** add(org.mockito.invocation.Invocation);
	*** getAll();
	*** isEmpty();
	*** removeLast();
}

-keep class org.mockito.internal.verification.VerificationModeFactory {
	*** atLeast(int);
	*** atLeastOnce();
	*** atMost(int);
	*** calls(int);
	*** noMoreInteractions();
	*** only();
	*** times(int);
}

-keep class org.mockito.invocation.DescribedInvocation {
	*** getLocation();
}

-keep class org.mockito.invocation.Invocation {
	*** getLocation();
	*** getRawArguments();
	*** ignoreForVerification();
	*** isVerified();
	*** markStubbed(org.mockito.invocation.StubInfo);
	*** stubInfo();
}

-keep class org.mockito.invocation.InvocationOnMock {
	*** callRealMethod();
	*** getArguments();
	*** getMethod();
	*** getMock();
}

-keep class org.mockito.invocation.MockHandler {
	*** handle(org.mockito.invocation.Invocation);
}

-keep class org.mockito.listeners.InvocationListener {
	*** reportInvocation(org.mockito.listeners.MethodInvocationReport);
}

-keep class org.mockito.mock.MockCreationSettings {
	*** getDefaultAnswer();
	*** getExtraInterfaces();
	*** getInvocationListeners();
	*** getMockName();
	*** getSpiedInstance();
	*** getTypeToMock();
	*** isSerializable();
}

-keep class org.mockito.mock.MockName {
	*** isDefault();
}

-keep class org.mockito.plugins.MockMaker {
	*** createMock(org.mockito.mock.MockCreationSettings,org.mockito.invocation.MockHandler);
	*** getHandler(java.lang.Object);
	*** resetMock(java.lang.Object,org.mockito.invocation.MockHandler,org.mockito.mock.MockCreationSettings);
}

-keep class org.mockito.plugins.StackTraceCleanerProvider {
	*** getStackTraceCleaner(org.mockito.exceptions.stacktrace.StackTraceCleaner);
}

-keep class org.mockito.stubbing.Answer {
	*** answer(org.mockito.invocation.InvocationOnMock);
}

-keep class org.mockito.stubbing.DeprecatedOngoingStubbing {
	*** toAnswer(org.mockito.stubbing.Answer);
}

-keep class org.mockito.stubbing.OngoingStubbing {
	*** thenAnswer(org.mockito.stubbing.Answer);
	*** thenReturn(java.lang.Object);
	*** thenThrow(java.lang.Class[]);
	*** thenThrow(java.lang.Throwable[]);
}

-keep class org.mockito.stubbing.Stubber {
	*** when(java.lang.Object);
}

-keep class org.mockito.verification.VerificationMode {
	*** verify(org.mockito.internal.verification.api.VerificationData);
}

-keep class org.objenesis.ObjenesisBase {
	*** cache;
	*** strategy;
	org.objenesis.ObjenesisBase(org.objenesis.strategy.InstantiatorStrategy);
	org.objenesis.ObjenesisBase(org.objenesis.strategy.InstantiatorStrategy,boolean);
	*** getInstantiatorOf(java.lang.Class);
	*** newInstance(java.lang.Class);
}

-keep class org.objenesis.ObjenesisException {
	*** jdk14;
}

-keep class org.objenesis.instantiator.ObjectInstantiator {
	*** newInstance();
}

-keep class org.objenesis.instantiator.sun.SunReflectionFactoryInstantiator {
	*** class$java$lang$Object;
	*** mungedConstructor;
	*** class$(java.lang.String);
}

-keep class org.objenesis.strategy.BaseInstantiatorStrategy {
	*** JVM_NAME;
	*** VENDOR;
	*** VENDOR_VERSION;
	*** VM_INFO;
	*** VM_VERSION;
	org.objenesis.strategy.BaseInstantiatorStrategy();
}

-keep class org.objenesis.strategy.InstantiatorStrategy {
	*** newInstantiatorOf(java.lang.Class);
}

-keep class org.slf4j.ILoggerFactory {
	*** getLogger(java.lang.String);
}

-keep class org.slf4j.Logger {
	*** debug(java.lang.String);
	*** debug(java.lang.String,java.lang.Object);
	*** debug(java.lang.String,java.lang.Object,java.lang.Object);
	*** debug(java.lang.String,java.lang.Object[]);
	*** debug(java.lang.String,java.lang.Throwable);
	*** error(java.lang.String);
	*** error(java.lang.String,java.lang.Object);
	*** error(java.lang.String,java.lang.Object,java.lang.Object);
	*** error(java.lang.String,java.lang.Object[]);
	*** error(java.lang.String,java.lang.Throwable);
	*** getName();
	*** info(java.lang.String);
	*** info(java.lang.String,java.lang.Object);
	*** info(java.lang.String,java.lang.Object,java.lang.Object);
	*** info(java.lang.String,java.lang.Object[]);
	*** info(java.lang.String,java.lang.Throwable);
	*** isDebugEnabled();
	*** isDebugEnabled(org.slf4j.Marker);
	*** isErrorEnabled();
	*** isErrorEnabled(org.slf4j.Marker);
	*** isInfoEnabled();
	*** isInfoEnabled(org.slf4j.Marker);
	*** isTraceEnabled();
	*** isTraceEnabled(org.slf4j.Marker);
	*** isWarnEnabled();
	*** isWarnEnabled(org.slf4j.Marker);
	*** trace(java.lang.String);
	*** trace(java.lang.String,java.lang.Object);
	*** trace(java.lang.String,java.lang.Object,java.lang.Object);
	*** trace(java.lang.String,java.lang.Object[]);
	*** trace(java.lang.String,java.lang.Throwable);
	*** warn(java.lang.String);
	*** warn(java.lang.String,java.lang.Object);
	*** warn(java.lang.String,java.lang.Object,java.lang.Object);
	*** warn(java.lang.String,java.lang.Object[]);
	*** warn(java.lang.String,java.lang.Throwable);
}

-keep class org.slf4j.LoggerFactory {
	*** API_COMPATIBILITY_LIST;
	*** INITIALIZATION_STATE;
	*** NOP_FALLBACK_FACTORY;
	*** STATIC_LOGGER_BINDER_PATH;
	*** TEMP_FACTORY;
	*** bind();
	*** emitSubstituteLoggerWarning();
	*** failedBinding(java.lang.Throwable);
	*** findPossibleStaticLoggerBinderPathSet();
	*** getILoggerFactory();
	*** getLogger(java.lang.Class);
	*** getLogger(java.lang.String);
	*** isAmbiguousStaticLoggerBinderPathSet(java.util.Set);
	*** messageContainsOrgSlf4jImplStaticLoggerBinder(java.lang.String);
	*** performInitialization();
	*** reportActualBinding(java.util.Set);
	*** reportMultipleBindingAmbiguity(java.util.Set);
	*** versionSanityCheck();
}

-keep class org.slf4j.helpers.FormattingTuple {
	*** NULL;
	*** argArray;
	*** message;
	*** throwable;
	org.slf4j.helpers.FormattingTuple(java.lang.String,java.lang.Object[],java.lang.Throwable);
	*** getMessage();
	*** getThrowable();
	*** trimmedCopy(java.lang.Object[]);
}

-keep class org.slf4j.helpers.MarkerIgnoringBase {
	org.slf4j.helpers.MarkerIgnoringBase();
	*** getName();
}

-keep class org.slf4j.helpers.MessageFormatter {
	*** arrayFormat(java.lang.String,java.lang.Object[]);
	*** booleanArrayAppend(java.lang.StringBuffer,boolean[]);
	*** byteArrayAppend(java.lang.StringBuffer,byte[]);
	*** charArrayAppend(java.lang.StringBuffer,char[]);
	*** deeplyAppendParameter(java.lang.StringBuffer,java.lang.Object,java.util.Map);
	*** doubleArrayAppend(java.lang.StringBuffer,double[]);
	*** floatArrayAppend(java.lang.StringBuffer,float[]);
	*** format(java.lang.String,java.lang.Object);
	*** format(java.lang.String,java.lang.Object,java.lang.Object);
	*** getThrowableCandidate(java.lang.Object[]);
	*** intArrayAppend(java.lang.StringBuffer,int[]);
	*** isDoubleEscaped(java.lang.String,int);
	*** isEscapedDelimeter(java.lang.String,int);
	*** longArrayAppend(java.lang.StringBuffer,long[]);
	*** objectArrayAppend(java.lang.StringBuffer,java.lang.Object[],java.util.Map);
	*** safeObjectAppend(java.lang.StringBuffer,java.lang.Object);
	*** shortArrayAppend(java.lang.StringBuffer,short[]);
}

-keep class org.slf4j.helpers.NOPLogger {
	*** NOP_LOGGER;
}

-keep class org.slf4j.helpers.NamedLoggerBase {
	*** name;
	org.slf4j.helpers.NamedLoggerBase();
	*** getName();
}

-keep class org.slf4j.helpers.SubstituteLoggerFactory {
	*** loggerNameList;
	*** getLoggerNameList();
}

-keep class org.slf4j.helpers.Util {
	*** report(java.lang.String);
	*** report(java.lang.String,java.lang.Throwable);
}

-keep class org.slf4j.impl.Log4jLoggerAdapter {
	*** FQCN;
	*** logger;
	*** traceCapable;
	*** isTraceCapable();
	*** isTraceEnabled();
}

-keep class org.slf4j.impl.Log4jLoggerFactory {
	*** loggerMap;
}

-keep class org.slf4j.impl.StaticLoggerBinder {
	*** REQUESTED_API_VERSION;
	*** SINGLETON;
	*** loggerFactory;
	*** loggerFactoryClassStr;
	*** getLoggerFactory();
	*** getLoggerFactoryClassStr();
	*** getSingleton();
}

-keep class org.slf4j.spi.LocationAwareLogger {
	*** log(org.slf4j.Marker,java.lang.String,int,java.lang.String,java.lang.Object[],java.lang.Throwable);
}

-keep class org.w3c.dom.Attr {
	*** getOwnerElement();
	*** getSpecified();
	*** getValue();
	*** setValue(java.lang.String);
}

-keep class org.w3c.dom.CharacterData {
	*** appendData(java.lang.String);
	*** getData();
	*** setData(java.lang.String);
}

-keep class org.w3c.dom.DOMErrorHandler {
	*** handleError(org.w3c.dom.DOMError);
}

-keep class org.w3c.dom.DOMException {
	*** code;
}

-keep class org.w3c.dom.DOMImplementation {
	*** createDocument(java.lang.String,java.lang.String,org.w3c.dom.DocumentType);
	*** hasFeature(java.lang.String,java.lang.String);
}

-keep class org.w3c.dom.Document {
	*** createAttribute(java.lang.String);
	*** createAttributeNS(java.lang.String,java.lang.String);
	*** createCDATASection(java.lang.String);
	*** createComment(java.lang.String);
	*** createDocumentFragment();
	*** createElement(java.lang.String);
	*** createElementNS(java.lang.String,java.lang.String);
	*** createEntityReference(java.lang.String);
	*** createProcessingInstruction(java.lang.String,java.lang.String);
	*** createTextNode(java.lang.String);
	*** getDoctype();
	*** getDocumentElement();
	*** getElementById(java.lang.String);
	*** getElementsByTagName(java.lang.String);
	*** getImplementation();
}

-keep class org.w3c.dom.DocumentType {
	*** getEntities();
	*** getInternalSubset();
	*** getNotations();
	*** getPublicId();
	*** getSystemId();
}

-keep class org.w3c.dom.Element {
	*** getAttributeNode(java.lang.String);
	*** getAttributeNodeNS(java.lang.String,java.lang.String);
	*** removeAttributeNode(org.w3c.dom.Attr);
	*** setAttribute(java.lang.String,java.lang.String);
	*** setAttributeNS(java.lang.String,java.lang.String,java.lang.String);
	*** setAttributeNode(org.w3c.dom.Attr);
	*** setAttributeNodeNS(org.w3c.dom.Attr);
}

-keep class org.w3c.dom.Entity {
	*** getNotationName();
	*** getPublicId();
	*** getSystemId();
}

-keep class org.w3c.dom.NamedNodeMap {
	*** getLength();
	*** getNamedItem(java.lang.String);
	*** getNamedItemNS(java.lang.String,java.lang.String);
	*** item(int);
	*** setNamedItem(org.w3c.dom.Node);
	*** setNamedItemNS(org.w3c.dom.Node);
}

-keep class org.w3c.dom.Node {
	*** appendChild(org.w3c.dom.Node);
	*** cloneNode(boolean);
	*** getAttributes();
	*** getChildNodes();
	*** getFirstChild();
	*** getLastChild();
	*** getLocalName();
	*** getNamespaceURI();
	*** getNextSibling();
	*** getNodeName();
	*** getNodeType();
	*** getNodeValue();
	*** getOwnerDocument();
	*** getParentNode();
	*** getPrefix();
	*** getPreviousSibling();
	*** getTextContent();
	*** getUserData(java.lang.String);
	*** hasAttributes();
	*** hasChildNodes();
	*** insertBefore(org.w3c.dom.Node,org.w3c.dom.Node);
	*** isEqualNode(org.w3c.dom.Node);
	*** lookupNamespaceURI(java.lang.String);
	*** lookupPrefix(java.lang.String);
	*** normalize();
	*** removeChild(org.w3c.dom.Node);
	*** replaceChild(org.w3c.dom.Node,org.w3c.dom.Node);
	*** setNodeValue(java.lang.String);
	*** setUserData(java.lang.String,java.lang.Object,org.w3c.dom.UserDataHandler);
}

-keep class org.w3c.dom.NodeList {
	*** getLength();
	*** item(int);
}

-keep class org.w3c.dom.Notation {
	*** getPublicId();
	*** getSystemId();
}

-keep class org.w3c.dom.ProcessingInstruction {
	*** getData();
}

-keep class org.w3c.dom.UserDataHandler {
	*** handle(short,java.lang.String,java.lang.Object,org.w3c.dom.Node,org.w3c.dom.Node);
}

-keep class org.w3c.dom.events.EventException {
	*** code;
}

-keep class org.w3c.dom.events.EventListener {
	*** handleEvent(org.w3c.dom.events.Event);
}

-keep class org.w3c.dom.events.MutationEvent {
	*** initMutationEvent(java.lang.String,boolean,boolean,org.w3c.dom.Node,java.lang.String,java.lang.String,java.lang.String,short);
}

-keep class org.w3c.dom.ls.DOMImplementationLS {
	*** createLSSerializer();
}

-keep class org.w3c.dom.ls.LSParserFilter {
	*** acceptNode(org.w3c.dom.Node);
	*** getWhatToShow();
	*** startElement(org.w3c.dom.Element);
}

-keep class org.w3c.dom.ls.LSSerializer {
	*** writeToString(org.w3c.dom.Node);
}

-keep class org.w3c.dom.traversal.NodeIterator {
	*** nextNode();
}

-keep class org.xml.sax.Attributes {
	*** getLength();
	*** getLocalName(int);
	*** getQName(int);
	*** getType(int);
	*** getURI(int);
	*** getValue(int);
}

-keep class org.xml.sax.ContentHandler {
	*** characters(char[],int,int);
	*** endDocument();
	*** endElement(java.lang.String,java.lang.String,java.lang.String);
	*** endPrefixMapping(java.lang.String);
	*** processingInstruction(java.lang.String,java.lang.String);
	*** setDocumentLocator(org.xml.sax.Locator);
	*** startDocument();
	*** startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes);
	*** startPrefixMapping(java.lang.String,java.lang.String);
}

-keep class org.xml.sax.InputSource {
	*** byteStream;
	*** characterStream;
	*** encoding;
	*** publicId;
	*** systemId;
	*** getByteStream();
	*** getCharacterStream();
	*** getEncoding();
	*** getPublicId();
	*** getSystemId();
	*** setByteStream(java.io.InputStream);
	*** setCharacterStream(java.io.Reader);
	*** setSystemId(java.lang.String);
}

-keep class org.xml.sax.Locator {
	*** getColumnNumber();
	*** getLineNumber();
	*** getPublicId();
	*** getSystemId();
}

-keep class org.xml.sax.SAXException {
	*** exception;
	org.xml.sax.SAXException();
	org.xml.sax.SAXException(java.lang.String);
	org.xml.sax.SAXException(java.lang.String,java.lang.Exception);
	*** getException();
	*** getMessage();
}

-keep class org.xml.sax.SAXParseException {
	*** columnNumber;
	*** lineNumber;
	*** publicId;
	*** systemId;
	*** getColumnNumber();
	*** getLineNumber();
	*** getPublicId();
	*** getSystemId();
	*** init(java.lang.String,java.lang.String,int,int);
}

-keep class org.xml.sax.XMLReader {
	*** getErrorHandler();
	*** parse(org.xml.sax.InputSource);
	*** setContentHandler(org.xml.sax.ContentHandler);
	*** setDTDHandler(org.xml.sax.DTDHandler);
	*** setErrorHandler(org.xml.sax.ErrorHandler);
	*** setFeature(java.lang.String,boolean);
	*** setProperty(java.lang.String,java.lang.Object);
}

-keep class org.xml.sax.ext.LexicalHandler {
	*** comment(char[],int,int);
	*** endCDATA();
	*** endEntity(java.lang.String);
	*** startCDATA();
	*** startEntity(java.lang.String);
}

-keep class org.xml.sax.helpers.LocatorImpl {
	*** columnNumber;
	*** lineNumber;
	*** publicId;
	*** systemId;
	org.xml.sax.helpers.LocatorImpl();
	*** getColumnNumber();
	*** getLineNumber();
	*** getPublicId();
	*** getSystemId();
	*** setColumnNumber(int);
	*** setLineNumber(int);
	*** setPublicId(java.lang.String);
	*** setSystemId(java.lang.String);
}

-keep class org.xml.sax.helpers.XMLReaderFactory {
	*** createXMLReader();
}

-keep class org.xmlpull.mxp1.MXParser {
	*** NCODING;
	*** NO;
	*** TANDALONE;
	*** VERSION;
	*** YES;
	*** allStringsInterned;
	*** attributeCount;
	*** attributeName;
	*** attributeNameHash;
	*** attributePrefix;
	*** attributeUri;
	*** attributeValue;
	*** buf;
	*** bufAbsoluteStart;
	*** bufEnd;
	*** bufLoadFactor;
	*** bufSoftLimit;
	*** bufStart;
	*** charRefOneCharBuf;
	*** columnNumber;
	*** depth;
	*** elName;
	*** elNamespaceCount;
	*** elPrefix;
	*** elRawName;
	*** elRawNameEnd;
	*** elRawNameLine;
	*** elUri;
	*** emptyElementTag;
	*** entityEnd;
	*** entityName;
	*** entityNameBuf;
	*** entityNameHash;
	*** entityRefName;
	*** entityReplacement;
	*** entityReplacementBuf;
	*** eventType;
	*** inputEncoding;
	*** inputStream;
	*** lineNumber;
	*** location;
	*** lookupNameChar;
	*** lookupNameStartChar;
	*** namespaceEnd;
	*** namespacePrefix;
	*** namespacePrefixHash;
	*** namespaceUri;
	*** pastEndTag;
	*** pc;
	*** pcEnd;
	*** pcStart;
	*** pos;
	*** posEnd;
	*** posStart;
	*** preventBufferCompaction;
	*** processNamespaces;
	*** reachedEnd;
	*** reader;
	*** roundtripSupported;
	*** seenAmpersand;
	*** seenDocdecl;
	*** seenEndTag;
	*** seenMarkup;
	*** seenRoot;
	*** seenStartTag;
	*** text;
	*** tokenize;
	*** usePC;
	*** xmlDeclContent;
	*** xmlDeclStandalone;
	*** xmlDeclVersion;
	*** ensureAttributesCapacity(int);
	*** ensureElementsCapacity();
	*** ensureEntityCapacity();
	*** ensureNamespacesCapacity(int);
	*** ensurePC(int);
	*** fastHash(char[],int,int);
	*** fillBuf();
	*** findFragment(int,char[],int,int);
	*** getColumnNumber();
	*** getEventType();
	*** getLineNumber();
	*** getName();
	*** getNamespace();
	*** getNamespace(java.lang.String);
	*** getPositionDescription();
	*** getText();
	*** isNameChar(char);
	*** isNameStartChar(char);
	*** isS(char);
	*** isWhitespace();
	*** joinPC();
	*** lookuEntityReplacement(int);
	*** more();
	*** newString(char[],int,int);
	*** newStringIntern(char[],int,int);
	*** next();
	*** nextImpl();
	*** parseAttribute();
	*** parseCDSect(boolean);
	*** parseComment();
	*** parseDocdecl();
	*** parseEndTag();
	*** parseEntityRef();
	*** parseEpilog();
	*** parsePI();
	*** parseProlog();
	*** parseStartTag();
	*** parseXmlDecl(char);
	*** parseXmlDeclWithVersion(int,int);
	*** printable(char);
	*** printable(java.lang.String);
	*** require(int,java.lang.String,java.lang.String);
	*** requireInput(char,char[]);
	*** reset();
	*** resetStringCache();
	*** setInput(java.io.Reader);
	*** setName(char);
	*** setNameStart(char);
	*** skipS(char);
}

-keep class org.xmlpull.v1.XmlPullParser {
	*** TYPES;
	*** getAttributeCount();
	*** getAttributeName(int);
	*** getAttributePrefix(int);
	*** getAttributeValue(int);
	*** getAttributeValue(java.lang.String,java.lang.String);
	*** getColumnNumber();
	*** getDepth();
	*** getEventType();
	*** getLineNumber();
	*** getName();
	*** getNamespace();
	*** getNamespace(java.lang.String);
	*** getPositionDescription();
	*** getPrefix();
	*** getText();
	*** isEmptyElementTag();
	*** next();
	*** nextText();
	*** setFeature(java.lang.String,boolean);
	*** setInput(java.io.InputStream,java.lang.String);
	*** setInput(java.io.Reader);
}

-keep class org.xmlpull.v1.XmlPullParserException {
	*** column;
	*** detail;
	*** row;
	*** printStackTrace();
}

-keep class sun.awt.AWTAccessor {
	*** awtEventAccessor;
	*** checkboxMenuItemAccessor;
	*** clientPropertyKeyAccessor;
	*** componentAccessor;
	*** containerAccessor;
	*** cursorAccessor;
	*** defaultKeyboardFocusManagerAccessor;
	*** eventQueueAccessor;
	*** fileDialogAccessor;
	*** frameAccessor;
	*** inputEventAccessor;
	*** keyEventAccessor;
	*** kfmAccessor;
	*** menuAccessor;
	*** menuBarAccessor;
	*** menuComponentAccessor;
	*** menuItemAccessor;
	*** popupMenuAccessor;
	*** scrollPaneAdjustableAccessor;
	*** sequencedEventAccessor;
	*** systemTrayAccessor;
	*** trayIconAccessor;
	*** unsafe;
	*** windowAccessor;
	*** getAWTEventAccessor();
	*** getComponentAccessor();
	*** getDefaultKeyboardFocusManagerAccessor();
	*** getEventQueueAccessor();
	*** getKeyboardFocusManagerAccessor();
	*** getMenuComponentAccessor();
	*** getSequencedEventAccessor();
	*** getWindowAccessor();
	*** setAWTEventAccessor(sun.awt.AWTAccessor$AWTEventAccessor);
	*** setClientPropertyKeyAccessor(sun.awt.AWTAccessor$ClientPropertyKeyAccessor);
	*** setComponentAccessor(sun.awt.AWTAccessor$ComponentAccessor);
	*** setContainerAccessor(sun.awt.AWTAccessor$ContainerAccessor);
	*** setCursorAccessor(sun.awt.AWTAccessor$CursorAccessor);
	*** setDefaultKeyboardFocusManagerAccessor(sun.awt.AWTAccessor$DefaultKeyboardFocusManagerAccessor);
	*** setEventQueueAccessor(sun.awt.AWTAccessor$EventQueueAccessor);
	*** setFrameAccessor(sun.awt.AWTAccessor$FrameAccessor);
	*** setInputEventAccessor(sun.awt.AWTAccessor$InputEventAccessor);
	*** setKeyEventAccessor(sun.awt.AWTAccessor$KeyEventAccessor);
	*** setKeyboardFocusManagerAccessor(sun.awt.AWTAccessor$KeyboardFocusManagerAccessor);
	*** setMenuAccessor(sun.awt.AWTAccessor$MenuAccessor);
	*** setMenuComponentAccessor(sun.awt.AWTAccessor$MenuComponentAccessor);
	*** setMenuItemAccessor(sun.awt.AWTAccessor$MenuItemAccessor);
	*** setPopupMenuAccessor(sun.awt.AWTAccessor$PopupMenuAccessor);
	*** setWindowAccessor(sun.awt.AWTAccessor$WindowAccessor);
}

-keep class sun.awt.AWTAccessor$AWTEventAccessor {
	*** isSystemGenerated(java.awt.AWTEvent);
	*** setSystemGenerated(java.awt.AWTEvent);
}

-keep class sun.awt.AWTAccessor$ComponentAccessor {
	*** canBeFocusOwner(java.awt.Component);
	*** getAccessControlContext(java.awt.Component);
	*** getAppContext(java.awt.Component);
	*** getParent(java.awt.Component);
	*** isLightweight(java.awt.Component);
	*** requestFocus(java.awt.Component,sun.awt.CausedFocusEvent$Cause);
	*** setAppContext(java.awt.Component,sun.awt.AppContext);
	*** setBackgroundEraseDisabled(java.awt.Component,boolean);
	*** setMixingCutoutShape(java.awt.Component,java.awt.Shape);
	*** setRequestFocusController(sun.awt.RequestFocusController);
}

-keep class sun.awt.AWTAccessor$DefaultKeyboardFocusManagerAccessor {
	*** consumeNextKeyTyped(java.awt.DefaultKeyboardFocusManager,java.awt.event.KeyEvent);
}

-keep class sun.awt.AWTAccessor$EventQueueAccessor {
	*** isDispatchThreadImpl(java.awt.EventQueue);
	*** noEvents(java.awt.EventQueue);
	*** wakeup(java.awt.EventQueue,boolean);
}

-keep class sun.awt.AWTAccessor$KeyboardFocusManagerAccessor {
	*** processSynchronousLightweightTransfer(java.awt.Component,java.awt.Component,boolean,boolean,long);
	*** removeLastFocusRequest(java.awt.Component);
	*** shouldNativelyFocusHeavyweight(java.awt.Component,java.awt.Component,boolean,boolean,long,sun.awt.CausedFocusEvent$Cause);
}

-keep class sun.awt.AWTAccessor$MenuComponentAccessor {
	*** getAppContext(java.awt.MenuComponent);
	*** setAppContext(java.awt.MenuComponent,sun.awt.AppContext);
}

-keep class sun.awt.AWTAccessor$SequencedEventAccessor {
	*** getNested(java.awt.AWTEvent);
	*** isSequencedEvent(java.awt.AWTEvent);
}

-keep class sun.awt.AWTAccessor$WindowAccessor {
	*** setLWRequestStatus(java.awt.Window,boolean);
	*** updateWindow(java.awt.Window);
}

-keep class sun.awt.AWTAutoShutdown {
	*** activationLock;
	*** blockerThread;
	*** busyThreadSet;
	*** mainLock;
	*** peerMap;
	*** theInstance;
	*** timeoutPassed;
	*** toolkitThreadBusy;
	*** activateBlockerThread();
	*** dumpPeers(sun.util.logging.PlatformLogger);
	*** getInstance();
	*** getPeer(java.lang.Object);
	*** getShutdownEvent();
	*** isReadyToShutdown();
	*** notifyPeerMapUpdated();
	*** notifyThreadBusy(java.lang.Thread);
	*** notifyThreadFree(java.lang.Thread);
	*** notifyToolkitThreadBusy();
	*** notifyToolkitThreadFree();
	*** registerPeer(java.lang.Object,java.lang.Object);
	*** setToolkitBusy(boolean);
	*** unregisterPeer(java.lang.Object,java.lang.Object);
}

-keep class sun.awt.AWTSecurityManager {
	*** getAppContext();
}

-keep class sun.awt.AppContext {
	*** DISPOSAL_TIMEOUT;
	*** EVENT_QUEUE_COND_KEY;
	*** EVENT_QUEUE_KEY;
	*** EVENT_QUEUE_LOCK_KEY;
	*** THREAD_INTERRUPT_TIMEOUT;
	*** changeSupport;
	*** contextClassLoader;
	*** log;
	*** mainAppContext;
	*** mostRecentKeyValue;
	*** numAppContexts;
	*** shadowMostRecentKeyValue;
	*** state;
	*** table;
	*** threadAppContext;
	*** threadGroup;
	*** threadGroup2appContext;
	*** access$000();
	*** access$002(sun.awt.AppContext);
	*** access$100();
	*** access$200();
	*** access$300();
	*** access$400();
	*** access$600();
	*** addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** get(java.lang.Object);
	*** getAppContext();
	*** getAppContexts();
	*** getExecutionAppContext();
	*** initMainAppContext();
	*** isDisposed();
	*** put(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener);
	*** stopEventDispatchThreads();
}

-keep class sun.awt.AppContext$1 {
	*** this$0;
	*** run();
}

-keep class sun.awt.AppContext$2 {
	*** run();
}

-keep class sun.awt.AppContext$3 {
	*** run();
}

-keep class sun.awt.AppContext$PostShutdownEventRunnable {
	*** appContext;
}

-keep class sun.awt.AppContext$State {
	*** $VALUES;
	*** BEING_DISPOSED;
	*** DISPOSED;
	*** VALID;
}

-keep class sun.awt.CGraphicsConfig {
	*** colorModel;
	*** device;
	sun.awt.CGraphicsConfig(sun.awt.CGraphicsDevice);
	*** getColorModel(int);
	*** getDevice();
	*** nativeGetBounds(int);
}

-keep class sun.awt.CGraphicsDevice {
	*** DEFAULT_CONFIG;
	*** configs;
	*** displayID;
	*** fullScreenExclusivePermission;
	*** originalMode;
	*** scale;
	*** screenInsets;
	*** xResolution;
	*** yResolution;
	*** displayChanged();
	*** enterFullScreenExclusive(java.awt.Window);
	*** exitFullScreenExclusive(java.awt.Window);
	*** getCGDisplayID();
	*** getDisplayMode();
	*** getScaleFactor();
	*** getScreenInsets();
	*** getXResolution();
	*** getYResolution();
	*** invalidate(int);
	*** isDisplayChangeSupported();
	*** isFSExclusiveModeAllowed();
	*** isFullScreenSupported();
	*** nativeGetDisplayMode(int);
	*** nativeGetDisplayModes(int);
	*** nativeGetScaleFactor(int);
	*** nativeGetScreenInsets(int);
	*** nativeGetXResolution(int);
	*** nativeGetYResolution(int);
	*** nativeSetDisplayMode(int,int,int,int,int);
	*** setDisplayMode(java.awt.DisplayMode);
}

-keep class sun.awt.CGraphicsEnvironment {
	*** devices;
	*** displayReconfigContext;
	*** sLogicalFonts;
	*** access$000();
	*** deregisterDisplayReconfiguration(long);
	*** getDisplayIDs();
	*** getMainDisplayID();
	*** initCocoa();
	*** initDevices();
	*** registerDisplayReconfiguration();
}

-keep class sun.awt.CausedFocusEvent {
	*** getCause();
}

-keep class sun.awt.CausedFocusEvent$Cause {
	*** ACTIVATION;
	*** CLEAR_GLOBAL_FOCUS_OWNER;
	*** NATIVE_SYSTEM;
	*** ROLLBACK;
	*** TRAVERSAL_BACKWARD;
	*** TRAVERSAL_DOWN;
	*** TRAVERSAL_FORWARD;
	*** TRAVERSAL_UP;
	*** UNKNOWN;
}

-keep class sun.awt.ComponentFactory {
	*** getFontPeer(java.lang.String,int);
}

-keep class sun.awt.ConstrainableGraphics {
	*** constrain(int,int,int,int);
}

-keep class sun.awt.DebugSettings {
	*** init();
}

-keep class sun.awt.DisplayChangedListener {
	*** displayChanged();
	*** paletteChanged();
}

-keep class sun.awt.EmbeddedFrame {
	*** getAppletIfAncestorOf(java.awt.Component);
}

-keep class sun.awt.EventQueueDelegate {
	*** setDelegate(sun.awt.EventQueueDelegate$Delegate);
}

-keep class sun.awt.EventQueueItem {
	*** event;
	*** next;
}

-keep class sun.awt.ExtendedKeyCodes {
	*** getExtendedKeyCodeForChar(int);
}

-keep class sun.awt.FullScreenCapable {
	*** enterFullScreenMode();
	*** exitFullScreenMode();
}

-keep class sun.awt.HeadlessToolkit {
	*** componentFactory;
	*** kfmPeer;
	*** tk;
	*** getUnderlyingToolkit();
}

-keep class sun.awt.KeyboardFocusManagerPeerImpl {
	*** focusLog;
	*** kfmAccessor;
	sun.awt.KeyboardFocusManagerPeerImpl();
}

-keep class sun.awt.KeyboardFocusManagerPeerProvider {
	*** getKeyboardFocusManagerPeer();
}

-keep class sun.awt.ModalityEvent {
	*** dispatch();
}

-keep class sun.awt.ModalityListener {
	*** modalityPopped(sun.awt.ModalityEvent);
	*** modalityPushed(sun.awt.ModalityEvent);
}

-keep class sun.awt.MostRecentKeyValue {
	*** key;
	*** value;
	*** setPair(java.lang.Object,java.lang.Object);
}

-keep class sun.awt.OSInfo {
	*** WINDOWS_2000;
	*** WINDOWS_2003;
	*** WINDOWS_95;
	*** WINDOWS_98;
	*** WINDOWS_ME;
	*** WINDOWS_UNKNOWN;
	*** WINDOWS_VISTA;
	*** WINDOWS_XP;
	*** osTypeAction;
	*** windowsVersionMap;
	*** getOSType();
	*** getOSTypeAction();
}

-keep class sun.awt.OSInfo$1 {
	*** run();
}

-keep class sun.awt.OSInfo$OSType {
	*** $VALUES;
	*** LINUX;
	*** MACOSX;
	*** SOLARIS;
	*** UNKNOWN;
	*** WINDOWS;
}

-keep class sun.awt.OSInfo$WindowsVersion {
	*** major;
	*** minor;
	sun.awt.OSInfo$WindowsVersion(int,int);
	*** compareTo(sun.awt.OSInfo$WindowsVersion);
	*** getMajor();
	*** getMinor();
	*** toString();
}

-keep class sun.awt.PaintEventDispatcher {
	*** dispatcher;
	sun.awt.PaintEventDispatcher();
	*** createPaintEvent(java.awt.Component,int,int,int,int);
	*** queueSurfaceDataReplacing(java.awt.Component,java.lang.Runnable);
	*** setPaintEventDispatcher(sun.awt.PaintEventDispatcher);
}

-keep class sun.awt.PeerEvent {
	*** coalesceEvents(sun.awt.PeerEvent);
	*** getFlags();
}

-keep class sun.awt.PostEventQueue {
	*** eventQueue;
	*** isFlushing;
	*** queueHead;
	*** queueTail;
	*** flush();
	*** noEvents();
	*** postEvent(java.awt.AWTEvent);
}

-keep class sun.awt.RequestFocusController {
	*** acceptRequestFocus(java.awt.Component,java.awt.Component,boolean,boolean,sun.awt.CausedFocusEvent$Cause);
}

-keep class sun.awt.SunDisplayChanger {
	*** listeners;
	*** log;
	*** add(sun.awt.DisplayChangedListener);
	*** notifyListeners();
	*** notifyPaletteChanged();
	*** remove(sun.awt.DisplayChangedListener);
}

-keep class sun.awt.SunGraphicsCallback {
	*** runComponents(java.awt.Component[],java.awt.Graphics,int);
	*** runOneComponent(java.awt.Component,java.awt.Rectangle,java.awt.Graphics,java.awt.Shape,int);
}

-keep class sun.awt.SunHints {
	*** KEY_ALPHA_INTERPOLATION;
	*** KEY_ANTIALIASING;
	*** KEY_COLOR_RENDERING;
	*** KEY_DITHERING;
	*** KEY_FRACTIONALMETRICS;
	*** KEY_INTERPOLATION;
	*** KEY_RENDERING;
	*** KEY_STROKE_CONTROL;
	*** KEY_TEXT_ANTIALIASING;
	*** KEY_TEXT_ANTIALIAS_LCD_CONTRAST;
	*** VALUE_ALPHA_INTERPOLATION_DEFAULT;
	*** VALUE_ALPHA_INTERPOLATION_QUALITY;
	*** VALUE_ALPHA_INTERPOLATION_SPEED;
	*** VALUE_ANTIALIAS_DEFAULT;
	*** VALUE_ANTIALIAS_OFF;
	*** VALUE_ANTIALIAS_ON;
	*** VALUE_COLOR_RENDER_DEFAULT;
	*** VALUE_COLOR_RENDER_QUALITY;
	*** VALUE_COLOR_RENDER_SPEED;
	*** VALUE_DITHER_DEFAULT;
	*** VALUE_DITHER_DISABLE;
	*** VALUE_DITHER_ENABLE;
	*** VALUE_FRACTIONALMETRICS_DEFAULT;
	*** VALUE_FRACTIONALMETRICS_OFF;
	*** VALUE_FRACTIONALMETRICS_ON;
	*** VALUE_INTERPOLATION_BICUBIC;
	*** VALUE_INTERPOLATION_BILINEAR;
	*** VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
	*** VALUE_RENDER_DEFAULT;
	*** VALUE_RENDER_QUALITY;
	*** VALUE_RENDER_SPEED;
	*** VALUE_STROKE_DEFAULT;
	*** VALUE_STROKE_NORMALIZE;
	*** VALUE_STROKE_PURE;
	*** VALUE_TEXT_ANTIALIAS_DEFAULT;
	*** VALUE_TEXT_ANTIALIAS_GASP;
	*** VALUE_TEXT_ANTIALIAS_LCD_HBGR;
	*** VALUE_TEXT_ANTIALIAS_LCD_HRGB;
	*** VALUE_TEXT_ANTIALIAS_LCD_VBGR;
	*** VALUE_TEXT_ANTIALIAS_LCD_VRGB;
	*** VALUE_TEXT_ANTIALIAS_OFF;
	*** VALUE_TEXT_ANTIALIAS_ON;
}

-keep class sun.awt.SunHints$Key {
	*** description;
	sun.awt.SunHints$Key(int,java.lang.String);
	*** getIndex();
}

-keep class sun.awt.SunHints$Value {
	*** ValueObjects;
	*** description;
	*** index;
	*** myKey;
	*** get(int,int);
	*** getIndex();
	*** isCompatibleKey(sun.awt.SunHints$Key);
	*** register(sun.awt.SunHints$Key,sun.awt.SunHints$Value);
}

-keep class sun.awt.SunToolkit {
	*** $assertionsDisabled;
	*** AWT_LOCK;
	*** AWT_LOCK_COND;
	*** DEACTIVATION_TIMES_MAP_KEY;
	*** DEFAULT_MODAL_EXCLUSION_TYPE;
	*** appContextMap;
	*** checkedSystemAAFontSettings;
	*** dataTransfererClassName;
	*** desktopFontHints;
	*** eventDispatched;
	*** flushLock;
	*** imgCache;
	*** isFlushingPendingEvents;
	*** lastExtraCondition;
	*** mPeer;
	*** modalityListeners;
	*** numberOfButtons;
	*** queueEmpty;
	*** startupLocale;
	*** sunAwtDisableMixing;
	*** useSystemAAFontSettings;
	*** waitLock;
	*** windowClosingListener;
	sun.awt.SunToolkit();
	*** awtLock();
	*** awtTryLock();
	*** awtUnlock();
	*** checkAndSetPolicy(java.awt.Container);
	*** closeSplashScreen();
	*** createImage(java.awt.image.ImageProducer);
	*** createNewAppContext();
	*** createNewAppContext(java.lang.ThreadGroup);
	*** disableBackgroundEraseImpl(java.awt.Component);
	*** executeOnEventHandlerThread(java.lang.Object,java.lang.Runnable);
	*** executeOnEventHandlerThread(sun.awt.PeerEvent);
	*** fireDesktopFontPropertyChanges();
	*** flushPendingEvents();
	*** flushPendingEvents(sun.awt.AppContext);
	*** getAppContext(java.lang.Object);
	*** getContainingWindow(java.awt.Component);
	*** getDefaultKeyboardLocale();
	*** getDesktopAAHints();
	*** getDesktopAAHintsByName(java.lang.String);
	*** getDesktopFontHints();
	*** getFocusAcceleratorKeyMask();
	*** getImage(java.lang.String);
	*** getImageFromHash(java.awt.Toolkit,java.lang.String);
	*** getImageFromHash(java.awt.Toolkit,java.net.URL);
	*** getScaledIconImage(java.util.List,int,int);
	*** getScreenHeight();
	*** getScreenWidth();
	*** getStartupLocale();
	*** getSunAwtDisableMixing();
	*** getSystemEventQueueImpl();
	*** getSystemEventQueueImplPP();
	*** getSystemEventQueueImplPP(sun.awt.AppContext);
	*** initEQ(sun.awt.AppContext);
	*** invokeLaterOnAppContext(sun.awt.AppContext,java.lang.Runnable);
	*** isEQEmpty();
	*** isInstanceOf(java.lang.Class,java.lang.String);
	*** isInstanceOf(java.lang.Object,java.lang.String);
	*** isNativeGTKAvailable();
	*** isPostEventQueueEmpty();
	*** isPrintableCharacterModifiersMask(int);
	*** isSwingBackbufferTranslucencySupported();
	*** isWindowOpacitySupported();
	*** isWindowShapingSupported();
	*** isWindowTranslucencySupported();
	*** needUpdateWindow();
	*** needsXEmbedImpl();
	*** notifyModalityChange(int,java.awt.Dialog);
	*** notifyModalityPopped(java.awt.Dialog);
	*** notifyModalityPushed(java.awt.Dialog);
	*** postEvent(sun.awt.AppContext,java.awt.AWTEvent);
	*** postPriorityEvent(java.awt.AWTEvent);
	*** realSync(long);
	*** setAAFontSettingsCondition(boolean);
	*** setAppContext(java.lang.Object,sun.awt.AppContext);
	*** setDataTransfererClassName(java.lang.String);
	*** setSystemGenerated(java.awt.AWTEvent);
	*** setWindowDeactivationTime(java.awt.Window,long);
	*** syncNativeQueue(long);
	*** targetCreatedPeer(java.lang.Object,java.lang.Object);
	*** targetDisposedPeer(java.lang.Object,java.lang.Object);
	*** targetToAppContext(java.lang.Object);
	*** targetToPeer(java.lang.Object);
	*** useBufferPerWindow();
	*** useSystemAAFontSettings();
	*** waitForIdle(long);
	*** wakeupEventQueue(java.awt.EventQueue,boolean);
}

-keep class sun.awt.SunToolkit$ModalityListenerList {
	*** listeners;
	*** add(sun.awt.ModalityListener);
	*** remove(sun.awt.ModalityListener);
}

-keep class sun.awt.SunToolkitSubclass {
	*** flushPendingEvents(sun.awt.AppContext);
}

-keep class sun.awt.TimedWindowEvent {
	*** getWhen();
}

-keep class sun.awt.WindowClosingListener {
	*** windowClosingDelivered(java.awt.event.WindowEvent);
	*** windowClosingNotify(java.awt.event.WindowEvent);
}

-keep class sun.awt.dnd.SunDropTargetEvent {
	*** consume();
	*** dispatch();
	*** getDispatcher();
}

-keep class sun.awt.geom.Curve {
	*** pointCrossingsForCubic(double,double,double,double,double,double,double,double,double,double,int);
	*** pointCrossingsForLine(double,double,double,double,double,double);
	*** pointCrossingsForPath(java.awt.geom.PathIterator,double,double);
	*** pointCrossingsForQuad(double,double,double,double,double,double,double,double,int);
	*** rectCrossingsForCubic(int,double,double,double,double,double,double,double,double,double,double,double,double,int);
	*** rectCrossingsForLine(int,double,double,double,double,double,double,double,double);
	*** rectCrossingsForPath(java.awt.geom.PathIterator,double,double,double,double);
	*** rectCrossingsForQuad(int,double,double,double,double,double,double,double,double,double,double,int);
}

-keep class sun.awt.geom.PathConsumer2D {
	*** closePath();
	*** curveTo(float,float,float,float,float,float);
	*** lineTo(float,float);
	*** moveTo(float,float);
	*** pathDone();
	*** quadTo(float,float,float,float);
}

-keep class sun.awt.im.InputContext {
	*** disableNativeIM();
}

-keep class sun.awt.image.BufImgSurfaceData {
	*** createData(java.awt.image.BufferedImage);
}

-keep class sun.awt.image.ImageRepresentation {
	*** check(java.awt.image.ImageObserver);
	*** drawToBufImage(java.awt.Graphics,sun.awt.image.ToolkitImage,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawToBufImage(java.awt.Graphics,sun.awt.image.ToolkitImage,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawToBufImage(java.awt.Graphics,sun.awt.image.ToolkitImage,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawToBufImage(java.awt.Graphics,sun.awt.image.ToolkitImage,java.awt.geom.AffineTransform,java.awt.image.ImageObserver);
	*** prepare(java.awt.image.ImageObserver);
	*** reconstruct(int);
}

-keep class sun.awt.image.PixelConverter {
	*** alphaMask;
	*** instance;
	sun.awt.image.PixelConverter();
	*** getAlphaMask();
	*** pixelToRgb(int,java.awt.image.ColorModel);
	*** rgbToPixel(int,java.awt.image.ColorModel);
}

-keep class sun.awt.image.PixelConverter$Argb {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$ArgbBm {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$ArgbPre {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Bgrx {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$ByteGray {
	*** instance;
	sun.awt.image.PixelConverter$ByteGray();
	sun.awt.image.PixelConverter$ByteGray(sun.awt.image.PixelConverter$1);
}

-keep class sun.awt.image.PixelConverter$Rgba {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$RgbaPre {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Rgbx {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Ushort4444Argb {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Ushort555Rgb {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Ushort555Rgbx {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Ushort565Rgb {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$UshortGray {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Xbgr {
	*** instance;
}

-keep class sun.awt.image.PixelConverter$Xrgb {
	*** instance;
}

-keep class sun.awt.image.SunVolatileImage {
	*** getDestSurface();
}

-keep class sun.awt.image.SunWritableRaster {
	*** markDirty(java.awt.image.DataBuffer);
	*** stealData(java.awt.image.DataBufferInt,int);
}

-keep class sun.awt.image.SurfaceManager {
	*** flush();
	*** getCacheData(java.lang.Object);
	*** getCapabilities(java.awt.GraphicsConfiguration);
	*** getImageScale(java.awt.Image);
	*** getManager(java.awt.Image);
	*** getPrimarySurfaceData();
	*** restoreContents();
	*** setAccelerationPriority(float);
	*** setCacheData(java.lang.Object,java.lang.Object);
	*** setImageAccessor(sun.awt.image.SurfaceManager$ImageAccessor);
}

-keep class sun.awt.image.SurfaceManager$ProxiedGraphicsConfig {
	*** getProxyKey();
}

-keep class sun.awt.image.ToolkitImage {
	*** check(java.awt.image.ImageObserver);
	*** getImageRep();
	*** hasError();
}

-keep class sun.awt.util.IdentityArrayList {
	*** elementData;
	*** size;
	sun.awt.util.IdentityArrayList(int);
	*** add(int,java.lang.Object);
	*** add(java.lang.Object);
	*** addAll(java.util.Collection);
	*** contains(java.lang.Object);
	*** ensureCapacity(int);
	*** fastRemove(int);
	*** get(int);
	*** indexOf(java.lang.Object);
	*** outOfBoundsMsg(int);
	*** rangeCheck(int);
	*** rangeCheckForAdd(int);
	*** remove(java.lang.Object);
	*** size();
}

-keep class sun.font.AttributeMap {
	*** getValues();
}

-keep class sun.font.AttributeValues {
	*** DEFAULT;
	*** MASK_ALL;
	*** background;
	*** baselineTransform;
	*** bidiEmbedding;
	*** charReplacement;
	*** charTransform;
	*** defined;
	*** family;
	*** font;
	*** foreground;
	*** imHighlight;
	*** imUnderline;
	*** justification;
	*** kerning;
	*** ligatures;
	*** nondefault;
	*** numericShaping;
	*** posture;
	*** runDirection;
	*** size;
	*** strikethrough;
	*** superscript;
	*** swapColors;
	*** tracking;
	*** transform;
	*** underline;
	*** weight;
	*** width;
	*** anyDefined(int);
	*** anyNonDefault(int);
	*** clone();
	*** defineAll(int);
	*** equals(java.lang.Object,java.lang.Object);
	*** equals(sun.font.AttributeValues);
	*** extractRotation(java.awt.geom.Point2D$Double,java.awt.geom.AffineTransform,boolean);
	*** extractXRotation(java.awt.geom.AffineTransform,boolean);
	*** fromMap(java.util.Map);
	*** fromMap(java.util.Map,int);
	*** fromSerializableHashtable(java.util.Hashtable);
	*** get(sun.font.EAttribute);
	*** getBaselineTransform();
	*** getCharTransform();
	*** getFamily();
	*** getFont();
	*** getKerning();
	*** getLigatures();
	*** getMask(sun.font.EAttribute);
	*** getMask(sun.font.EAttribute[]);
	*** getPosture();
	*** getSize();
	*** getSuperscript();
	*** getTransform();
	*** getWeight();
	*** getWidth();
	*** i_equals(sun.font.EAttribute,sun.font.AttributeValues);
	*** i_get(sun.font.EAttribute);
	*** i_set(sun.font.EAttribute,java.lang.Object);
	*** i_set(sun.font.EAttribute,sun.font.AttributeValues);
	*** i_validate(sun.font.EAttribute);
	*** is16Hashtable(java.util.Hashtable);
	*** isNonDefault(sun.font.EAttribute);
	*** merge(java.util.Map);
	*** merge(java.util.Map,int);
	*** merge(sun.font.AttributeValues);
	*** merge(sun.font.AttributeValues,int);
	*** set(sun.font.EAttribute,java.lang.Object);
	*** setDefault(sun.font.EAttribute);
	*** setFamily(java.lang.String);
	*** setPosture(float);
	*** setSize(float);
	*** setTransform(java.awt.geom.AffineTransform);
	*** setWeight(float);
	*** toSerializableHashtable();
	*** unsetDefault();
	*** update(sun.font.EAttribute);
	*** updateDerivedTransforms();
}

-keep class sun.font.AttributeValues$1 {
	*** $SwitchMap$sun$font$EAttribute;
}

-keep class sun.font.CompositeFont {
	*** isStdComposite();
}

-keep class sun.font.CreatedFontTracker {
	*** acquirePermit();
	*** add(java.io.File);
	*** addBytes(int);
	*** getNumBytes();
	*** getTracker();
	*** releasePermit();
	*** remove(java.io.File);
	*** set(java.io.File,java.io.OutputStream);
	*** subBytes(int);
}

-keep class sun.font.EAttribute {
	*** $VALUES;
	*** EBACKGROUND;
	*** EBASELINE_TRANSFORM;
	*** EBIDI_EMBEDDING;
	*** ECHAR_REPLACEMENT;
	*** EFAMILY;
	*** EFONT;
	*** EFOREGROUND;
	*** EINPUT_METHOD_HIGHLIGHT;
	*** EINPUT_METHOD_UNDERLINE;
	*** EJUSTIFICATION;
	*** EKERNING;
	*** ELIGATURES;
	*** ENUMERIC_SHAPING;
	*** EPOSTURE;
	*** ERUN_DIRECTION;
	*** ESIZE;
	*** ESTRIKETHROUGH;
	*** ESUPERSCRIPT;
	*** ESWAP_COLORS;
	*** ETRACKING;
	*** ETRANSFORM;
	*** EUNDERLINE;
	*** EWEIGHT;
	*** EWIDTH;
	*** att;
	*** atts;
	*** mask;
	*** forAttribute(java.text.AttributedCharacterIterator$Attribute);
}

-keep class sun.font.Font2D {
	*** handle;
	*** canDisplay(char);
	*** canDisplay(int);
	*** getBaselineFor(char);
	*** getFamilyName(java.util.Locale);
	*** getFontMetrics(java.awt.Font,java.awt.font.FontRenderContext,float[]);
	*** getFontMetrics(java.awt.Font,java.awt.geom.AffineTransform,java.lang.Object,java.lang.Object,float[]);
	*** getFontName(java.util.Locale);
	*** getItalicAngle(java.awt.Font,java.awt.geom.AffineTransform,java.lang.Object,java.lang.Object);
	*** getMissingGlyphCode();
	*** getNumGlyphs();
	*** getPostscriptName();
	*** getStrike(java.awt.Font,java.awt.geom.AffineTransform,java.awt.geom.AffineTransform,int,int);
	*** getStyle();
	*** useAAForPtSize(int);
}

-keep class sun.font.Font2DHandle {
	*** font2D;
}

-keep class sun.font.FontAccess {
	*** access;
	sun.font.FontAccess();
	*** setFontAccess(sun.font.FontAccess);
}

-keep class sun.font.FontDesignMetrics {
	*** getMetrics(java.awt.Font);
	*** getMetrics(java.awt.Font,java.awt.font.FontRenderContext);
}

-keep class sun.font.FontLineMetrics {
	*** frc;
	*** numchars;
	*** clone();
}

-keep class sun.font.FontManager {
	*** createFont2D(java.io.File,int,boolean,sun.font.CreatedFontTracker);
	*** findFont2D(java.lang.String,int,int);
	*** getNewComposite(java.lang.String,int,sun.font.Font2DHandle);
	*** preferLocaleFonts();
	*** preferProportionalFonts();
	*** registerFont(java.awt.Font);
	*** usingPerAppContextComposites();
}

-keep class sun.font.FontManagerFactory {
	*** getInstance();
}

-keep class sun.font.FontManagerForSGE {
	*** getAllInstalledFonts();
	*** getCreatedFontFamilyNames();
	*** getCreatedFonts();
	*** getInstalledFontFamilyNames(java.util.Locale);
	*** useAlternateFontforJALocales();
}

-keep class sun.font.FontUtilities {
	*** getFont2D(java.awt.Font);
	*** isComplexText(char[],int,int);
}

-keep class sun.font.GlyphLayout {
	*** done(sun.font.GlyphLayout);
	*** get(sun.font.GlyphLayout$LayoutEngineFactory);
	*** layout(java.awt.Font,java.awt.font.FontRenderContext,char[],int,int,int,sun.font.StandardGlyphVector);
}

-keep class sun.font.GlyphList {
	*** dispose();
	*** getBounds();
	*** getGrayBits();
	*** getImages();
	*** getInstance();
	*** getMetrics();
	*** getNumGlyphs();
	*** getPositions();
	*** getStrike();
	*** getX();
	*** getY();
	*** isRGBOrder();
	*** isSubPixPos();
	*** setFromChars(sun.java2d.loops.FontInfo,char[],int,int,float,float);
	*** setFromGlyphVector(sun.java2d.loops.FontInfo,java.awt.font.GlyphVector,float,float);
	*** setFromString(sun.java2d.loops.FontInfo,java.lang.String,float,float);
	*** setGlyphIndex(int);
	*** usePositions();
}

-keep class sun.font.SunFontManager {
	*** usePlatformFontMetrics();
}

-keep class sun.instrument.InstrumentationImpl {
	*;
}

-keep class sun.instrument.InstrumentationImpl$1 {
	*;
}

-keep class sun.instrument.TransformerManager {
	*;
}

-keep class sun.instrument.TransformerManager$TransformerInfo {
	*;
}

-keep class sun.java2d.Disposer {
	*** deferredRecords;
	*** disposerInstance;
	*** pollingQueue;
	*** queue;
	*** records;
	*** refType;
	*** access$000();
	*** add(java.lang.Object,sun.java2d.DisposerRecord);
	*** addRecord(java.lang.Object,sun.java2d.DisposerRecord);
	*** clearDeferredRecords();
	*** initIDs();
}

-keep class sun.java2d.DisposerRecord {
	*** dispose();
}

-keep class sun.java2d.DisposerTarget {
	*** getDisposerReferent();
}

-keep class sun.java2d.NullSurfaceData {
	*** nullpipe;
	*** theInstance;
}

-keep class sun.java2d.StateTrackable$State {
	*** $VALUES;
	*** DYNAMIC;
	*** IMMUTABLE;
	*** STABLE;
	*** UNTRACKABLE;
	*** values();
}

-keep class sun.java2d.StateTrackableDelegate {
	*** IMMUTABLE_DELEGATE;
	*** UNTRACKABLE_DELEGATE;
	*** numDynamicAgents;
	*** theState;
	*** theTracker;
	*** createInstance(sun.java2d.StateTrackable$State);
	*** getState();
	*** getStateTracker();
	*** markDirty();
}

-keep class sun.java2d.StateTrackableDelegate$2 {
	*** $SwitchMap$sun$java2d$StateTrackable$State;
}

-keep class sun.java2d.StateTracker {
	*** ALWAYS_CURRENT;
	*** NEVER_CURRENT;
}

-keep class sun.java2d.SunGraphics2D {
	*** IDENT_ATX;
	*** IDENT_MATRIX;
	*** MinPenSizeAA;
	*** MinPenSizeAASquared;
	*** alphafill;
	*** antialiasHint;
	*** backgroundColor;
	*** cachedFRC;
	*** clipRegion;
	*** clipState;
	*** composite;
	*** compositeState;
	*** constrainClip;
	*** constrainX;
	*** constrainY;
	*** defaultComposite;
	*** defaultFont;
	*** defaultStroke;
	*** devClip;
	*** devScale;
	*** drawpipe;
	*** eargb;
	*** fillpipe;
	*** font;
	*** fontInfo;
	*** fontMetrics;
	*** foregroundColor;
	*** fractionalMetricsHint;
	*** glyphVectorFRC;
	*** glyphVectorFontInfo;
	*** hints;
	*** imageComp;
	*** imagepipe;
	*** interpolationHint;
	*** interpolationType;
	*** invalidpipe;
	*** lastCAblit;
	*** lastCAcomp;
	*** lcdTextContrast;
	*** lcdTextContrastDefaultValue;
	*** loops;
	*** paint;
	*** paintState;
	*** pixel;
	*** renderHint;
	*** shapepipe;
	*** stroke;
	*** strokeHint;
	*** strokeState;
	*** surfaceData;
	*** textAntialiasHint;
	*** textAtArr;
	*** textTxArr;
	*** textpipe;
	*** transX;
	*** transY;
	*** transform;
	*** transformState;
	*** usrClip;
	*** validFontInfo;
	*** checkFontInfo(sun.java2d.loops.FontInfo,java.awt.Font,java.awt.font.FontRenderContext);
	*** clip(java.awt.Shape);
	*** clipRect(int,int,int,int);
	*** clipTo(java.awt.Rectangle,java.awt.Rectangle);
	*** clone();
	*** cloneShape(java.awt.Shape);
	*** cloneTransform();
	*** constrain(int,int,int,int,sun.java2d.pipe.Region);
	*** copyImage(java.awt.Image,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** dispose();
	*** doCopyArea(int,int,int,int,int,int);
	*** drawHiDPIImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver);
	*** drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform);
	*** drawTranslatedRenderedImage(java.awt.image.RenderedImage,java.awt.Rectangle,int,int);
	*** fill(java.awt.Shape);
	*** fillRect(int,int,int,int);
	*** fixRectangleOrientation(double[],java.awt.geom.Rectangle2D);
	*** getBackground();
	*** getClip();
	*** getClipBounds(java.awt.Rectangle);
	*** getCompClip();
	*** getComposite();
	*** getDeviceColorModel();
	*** getFont();
	*** getFontInfo();
	*** getFontRenderContext();
	*** getGVFontInfo(java.awt.Font,java.awt.font.FontRenderContext);
	*** getImageRegion(java.awt.image.RenderedImage,sun.java2d.pipe.Region,java.awt.geom.AffineTransform,java.awt.geom.AffineTransform,int,int);
	*** getRenderingHints();
	*** getSurfaceData();
	*** getTileIndex(int,int,int);
	*** intersectByArea(java.awt.Shape,java.awt.Shape,boolean,boolean);
	*** intersectRectShape(java.awt.geom.Rectangle2D,java.awt.Shape,boolean,boolean);
	*** intersectShapes(java.awt.Shape,java.awt.Shape,boolean,boolean);
	*** invalidatePipe();
	*** invalidateTransform();
	*** isHiDPIImage(java.awt.Image);
	*** isIntegerTranslation(java.awt.geom.AffineTransform);
	*** makeHints(java.util.Map);
	*** revalidateAll();
	*** setClip(java.awt.Shape);
	*** setColor(java.awt.Color);
	*** setComposite(java.awt.Composite);
	*** setDevClip(int,int,int,int);
	*** setDevClip(java.awt.Rectangle);
	*** setPaint(java.awt.Paint);
	*** setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object);
	*** transform(java.awt.geom.AffineTransform);
	*** transformShape(int,int,java.awt.Shape);
	*** transformShape(java.awt.Shape);
	*** transformShape(java.awt.geom.AffineTransform,java.awt.Shape);
	*** translate(int,int);
	*** untransformShape(java.awt.Shape);
	*** validateBasicStroke(java.awt.BasicStroke);
	*** validateColor();
	*** validateCompClip();
	*** validatePipe();
}

-keep class sun.java2d.SunGraphicsEnvironment {
	*** defaultFont;
	*** displayChanger;
	*** isOpenSolaris;
	*** screens;
	sun.java2d.SunGraphicsEnvironment();
	*** access$002(java.awt.Font);
	*** addDisplayChangedListener(sun.awt.DisplayChangedListener);
	*** displayChanged();
	*** getAllFonts();
	*** getAvailableFontFamilyNames(java.util.Locale);
	*** getFontManagerForSGE();
	*** getNumScreens();
	*** getScreenDevices();
	*** getUsableBounds(java.awt.GraphicsDevice);
	*** isDisplayLocal();
	*** isFlipStrategyPreferred(java.awt.peer.ComponentPeer);
	*** makeScreenDevice(int);
}

-keep class sun.java2d.SunGraphicsEnvironment$1 {
	*** this$0;
}

-keep class sun.java2d.SurfaceData {
	*** AAClipColorShape;
	*** AAClipColorViaShape;
	*** AAClipCompShape;
	*** AAClipCompViaShape;
	*** AAClipPaintShape;
	*** AAClipPaintViaShape;
	*** AAColorShape;
	*** AAColorViaPgram;
	*** AAColorViaShape;
	*** AACompShape;
	*** AACompViaShape;
	*** AAPaintShape;
	*** AAPaintViaShape;
	*** aaTextRenderer;
	*** blitProxyKey;
	*** clipColorPipe;
	*** clipColorText;
	*** clipCompPipe;
	*** clipCompText;
	*** clipPaintPipe;
	*** clipPaintText;
	*** colorModel;
	*** colorPipe;
	*** colorPrimitives;
	*** colorText;
	*** colorViaPgram;
	*** colorViaShape;
	*** compPermission;
	*** compPipe;
	*** compShape;
	*** compText;
	*** compViaShape;
	*** disposerReferent;
	*** haveLCDLoop;
	*** havePgramSolidLoop;
	*** havePgramXORLoop;
	*** imagepipe;
	*** lcdTextRenderer;
	*** loopcache;
	*** outlineTextRenderer;
	*** pData;
	*** paintPipe;
	*** paintShape;
	*** paintText;
	*** paintViaShape;
	*** solidTextRenderer;
	*** stateDelegate;
	*** surfaceLost;
	*** surfaceType;
	*** valid;
	sun.java2d.SurfaceData(sun.java2d.StateTrackable$State,sun.java2d.loops.SurfaceType,java.awt.image.ColorModel);
	sun.java2d.SurfaceData(sun.java2d.StateTrackableDelegate,sun.java2d.loops.SurfaceType,java.awt.image.ColorModel);
	sun.java2d.SurfaceData(sun.java2d.loops.SurfaceType,java.awt.image.ColorModel);
	*** canRenderLCDText(sun.java2d.SunGraphics2D);
	*** canRenderParallelograms(sun.java2d.SunGraphics2D);
	*** checkCustomComposite();
	*** copyArea(sun.java2d.SunGraphics2D,int,int,int,int,int,int);
	*** getBounds();
	*** getColorModel();
	*** getDefaultScale();
	*** getDestination();
	*** getDeviceConfiguration();
	*** getFillCompositeType(sun.java2d.SunGraphics2D);
	*** getMaskFill(sun.java2d.SunGraphics2D);
	*** getNativeOps();
	*** getPaintSurfaceType(sun.java2d.SunGraphics2D);
	*** getPrimarySurfaceData(java.awt.Image);
	*** getRaster(int,int,int,int);
	*** getRenderLoops(sun.java2d.SunGraphics2D);
	*** getReplacement();
	*** getSourceSurfaceData(java.awt.Image,int,sun.java2d.loops.CompositeType,java.awt.Color);
	*** getState();
	*** getSurfaceType();
	*** getTextPipe(sun.java2d.SunGraphics2D,boolean);
	*** getTransparency();
	*** initIDs();
	*** invalidate();
	*** isNull(sun.java2d.SurfaceData);
	*** isValid();
	*** makeConverter(sun.java2d.pipe.AAShapePipe);
	*** makeConverter(sun.java2d.pipe.AAShapePipe,sun.java2d.pipe.ParallelogramPipe);
	*** makeProxyFor(sun.java2d.SurfaceData);
	*** makeRenderLoops(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** markDirty();
	*** pixelFor(int);
	*** setBlitProxyKey(java.lang.Object);
	*** validatePipe(sun.java2d.SunGraphics2D);
}

-keep class sun.java2d.SurfaceDataProxy {
	*** UNCACHED;
	*** isCachingAllowed();
	*** isValid();
	*** replaceData(sun.java2d.SurfaceData,int,sun.java2d.loops.CompositeType,java.awt.Color);
}

-keep class sun.java2d.SurfaceManagerFactory {
	*** instance;
	sun.java2d.SurfaceManagerFactory();
	*** setInstance(sun.java2d.SurfaceManagerFactory);
}

-keep class sun.java2d.cmm.CMSManager {
	*** GRAYspace;
	*** LINEAR_RGBspace;
	*** getModule();
}

-keep class sun.java2d.cmm.ColorTransform {
	*** colorConvert(byte[],byte[]);
	*** colorConvert(short[],short[]);
}

-keep class sun.java2d.cmm.PCMM {
	*** createTransform(java.awt.color.ICC_Profile,int,int);
	*** createTransform(sun.java2d.cmm.ColorTransform[]);
	*** freeProfile(long);
	*** getProfileData(long,byte[]);
	*** getProfileSize(long);
	*** getTagData(long,int,byte[]);
	*** getTagSize(long,int);
	*** loadProfile(byte[]);
	*** setTagData(long,int,byte[]);
}

-keep class sun.java2d.cmm.ProfileActivator {
	*** activate();
}

-keep class sun.java2d.cmm.ProfileDeferralInfo {
	*** colorSpaceType;
	*** filename;
	*** numComponents;
	*** profileClass;
}

-keep class sun.java2d.cmm.ProfileDeferralMgr {
	*** aVector;
	*** deferring;
	*** activateProfiles();
	*** registerDeferral(sun.java2d.cmm.ProfileActivator);
	*** unregisterDeferral(sun.java2d.cmm.ProfileActivator);
}

-keep class sun.java2d.jules.JulesPathBuf {
	*** isCairoAvailable();
}

-keep class sun.java2d.loops.Blit {
	*** blitcache;
	*** methodSignature;
	*** primTypeID;
	sun.java2d.loops.Blit(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** Blit(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,int,int,int,int,int,int);
	*** getFromCache(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.Blit$AnyBlit {
	*** instance;
}

-keep class sun.java2d.loops.BlitBg {
	*** blitcache;
	*** methodSignature;
	*** primTypeID;
	*** BlitBg(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,int,int,int,int,int,int,int);
	*** getFromCache(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.CompositeType {
	*** AlphaXor;
	*** Any;
	*** AnyAlpha;
	*** Clear;
	*** Dst;
	*** DstAtop;
	*** DstIn;
	*** DstOut;
	*** DstOver;
	*** General;
	*** OpaqueSrcOverNoEa;
	*** Src;
	*** SrcAtop;
	*** SrcIn;
	*** SrcNoEa;
	*** SrcOut;
	*** SrcOver;
	*** SrcOverNoEa;
	*** Xor;
	*** compositeUIDMap;
	*** desc;
	*** next;
	*** uniqueID;
	*** unusedUID;
	*** deriveSubType(java.lang.String);
	*** equals(java.lang.Object);
	*** forAlphaComposite(java.awt.AlphaComposite);
	*** getSuperType();
	*** getUniqueID();
	*** isDerivedFrom(sun.java2d.loops.CompositeType);
	*** makeUniqueID(java.lang.String);
}

-keep class sun.java2d.loops.CustomComponent {
	*** register();
}

-keep class sun.java2d.loops.DrawGlyphList {
	*** methodSignature;
	*** primTypeID;
	*** DrawGlyphList(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,sun.font.GlyphList);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawGlyphListAA {
	*** methodSignature;
	*** primTypeID;
	*** DrawGlyphListAA(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,sun.font.GlyphList);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawGlyphListLCD {
	*** methodSignature;
	*** primTypeID;
	*** DrawGlyphListLCD(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,sun.font.GlyphList);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawLine {
	*** methodSignature;
	*** primTypeID;
	*** DrawLine(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int,int,int,int);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawParallelogram {
	*** methodSignature;
	*** primTypeID;
	*** DrawParallelogram(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,double,double,double,double,double,double,double,double);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawPath {
	*** methodSignature;
	*** primTypeID;
	*** DrawPath(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int,int,java.awt.geom.Path2D$Float);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawPolygons {
	*** methodSignature;
	*** primTypeID;
	*** DrawPolygons(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int[],int[],int[],int,int,int,boolean);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.DrawRect {
	*** methodSignature;
	*** primTypeID;
	*** DrawRect(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int,int,int,int);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.FillParallelogram {
	*** methodSignature;
	*** primTypeID;
	*** FillParallelogram(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,double,double,double,double,double,double);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.FillPath {
	*** methodSignature;
	*** primTypeID;
	*** FillPath(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int,int,java.awt.geom.Path2D$Float);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.FillRect {
	*** methodSignature;
	*** primTypeID;
	*** FillRect(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int,int,int,int);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.FillSpans {
	*** methodSignature;
	*** primTypeID;
	*** FillSpans(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,int,long,sun.java2d.pipe.SpanIterator);
	*** FillSpans(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,sun.java2d.pipe.SpanIterator);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.FontInfo {
	*** aaHint;
	*** devTx;
	*** font;
	*** font2D;
	*** fontStrike;
	*** glyphTx;
	*** lcdRGBOrder;
	*** lcdSubPixPos;
	*** originX;
	*** originY;
	*** pixelHeight;
	*** clone();
}

-keep class sun.java2d.loops.GeneralRenderer {
	*** adjustLine(int[],int,int,int,int);
	*** doDrawLine(sun.java2d.SurfaceData,sun.java2d.loops.PixelWriter,int[],sun.java2d.pipe.Region,int,int,int,int);
	*** doSetRect(sun.java2d.SurfaceData,sun.java2d.loops.PixelWriter,int,int,int,int);
	*** outcode(int,int,int,int,int,int);
	*** register();
}

-keep class sun.java2d.loops.GraphicsPrimitive {
	*** cachedname;
	*** compositeType;
	*** destType;
	*** methodSignature;
	*** pNativePrim;
	*** sourceType;
	*** traceMap;
	*** tracefile;
	*** traceflags;
	*** traceout;
	*** uniqueID;
	*** unusedPrimID;
	sun.java2d.loops.GraphicsPrimitive(java.lang.String,int,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	sun.java2d.loops.GraphicsPrimitive(long,java.lang.String,int,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** convertFrom(sun.java2d.loops.Blit,sun.java2d.SurfaceData,int,int,int,int,sun.java2d.SurfaceData,int);
	*** createConverter(sun.java2d.loops.SurfaceType,sun.java2d.loops.SurfaceType);
	*** getDestType();
	*** getGeneralOp(int,sun.java2d.loops.CompositeType);
	*** getNativePrim();
	*** getPrimTypeID();
	*** getSignature();
	*** getTraceOutputFile();
	*** getUniqueID();
	*** makePrimTypeID();
	*** makePrimitive(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** makeUniqueID(int,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** satisfiesSameAs(sun.java2d.loops.GraphicsPrimitive);
	*** setupGeneralBinaryOp(sun.java2d.loops.GraphicsPrimitive$GeneralBinaryOp);
	*** simplename(java.lang.reflect.Field[],java.lang.Object);
	*** simplename(sun.java2d.loops.CompositeType);
	*** simplename(sun.java2d.loops.SurfaceType);
	*** traceWrap();
	*** tracingEnabled();
}

-keep class sun.java2d.loops.GraphicsPrimitive$GeneralBinaryOp {
	*** getCompositeType();
	*** getDestType();
	*** getPrimTypeID();
	*** getSignature();
	*** getSourceType();
	*** setPrimitives(sun.java2d.loops.Blit,sun.java2d.loops.Blit,sun.java2d.loops.GraphicsPrimitive,sun.java2d.loops.Blit);
}

-keep class sun.java2d.loops.GraphicsPrimitive$GeneralUnaryOp {
	*** getCompositeType();
	*** getDestType();
	*** getPrimTypeID();
	*** getSignature();
	*** setPrimitives(sun.java2d.loops.Blit,sun.java2d.loops.GraphicsPrimitive,sun.java2d.loops.Blit);
}

-keep class sun.java2d.loops.GraphicsPrimitive$TraceReporter {
	*** setShutdownHook();
}

-keep class sun.java2d.loops.GraphicsPrimitiveMgr {
	*** generalPrimitives;
	*** needssort;
	*** primFinder;
	*** primSorter;
	*** primitives;
	*** initIDs(java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class,java.lang.Class);
	*** locate(int,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.GraphicsPrimitiveMgr$PrimitiveSpec);
	*** locateGeneral(int);
	*** locatePrim(int,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** register(sun.java2d.loops.GraphicsPrimitive[]);
	*** registerGeneral(sun.java2d.loops.GraphicsPrimitive);
	*** registerNativeLoops();
	*** testPrimitiveInstantiation(boolean);
}

-keep class sun.java2d.loops.GraphicsPrimitiveMgr$PrimitiveSpec {
	*** uniqueID;
}

-keep class sun.java2d.loops.GraphicsPrimitiveProxy {
	*** owner;
	*** relativeClassName;
	*** getPackageName(java.lang.String);
	*** instantiate();
}

-keep class sun.java2d.loops.MaskBlit {
	*** blitcache;
	*** methodSignature;
	*** primTypeID;
	sun.java2d.loops.MaskBlit(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** MaskBlit(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,int,int,int,int,int,int,byte[],int,int);
	*** getFromCache(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.MaskFill {
	*** drawPgramSignature;
	*** fillPgramSignature;
	*** fillcache;
	*** methodSignature;
	*** primTypeID;
	sun.java2d.loops.MaskFill(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** DrawAAPgram(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,java.awt.Composite,double,double,double,double,double,double,double,double);
	*** FillAAPgram(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,java.awt.Composite,double,double,double,double,double,double);
	*** MaskFill(sun.java2d.SunGraphics2D,sun.java2d.SurfaceData,java.awt.Composite,int,int,int,int,byte[],int,int);
	*** canDoParallelograms();
	*** getFromCache(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locatePrim(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.PixelWriter {
	*** setRaster(java.awt.image.WritableRaster);
	*** writePixel(int,int);
}

-keep class sun.java2d.loops.ProcessPath {
	*** drawPath(sun.java2d.loops.ProcessPath$DrawHandler,java.awt.geom.Path2D$Float,int,int);
	*** fillPath(sun.java2d.loops.ProcessPath$DrawHandler,java.awt.geom.Path2D$Float,int,int);
}

-keep class sun.java2d.loops.ProcessPath$DrawHandler {
	*** strokeControl;
	*** xMax;
	*** xMaxf;
	*** xMin;
	*** xMinf;
	*** yMax;
	*** yMaxf;
	*** yMin;
	*** yMinf;
	sun.java2d.loops.ProcessPath$DrawHandler(int,int,int,int);
	sun.java2d.loops.ProcessPath$DrawHandler(int,int,int,int,int);
	*** setBounds(int,int,int,int);
	*** setBounds(int,int,int,int,int);
}

-keep class sun.java2d.loops.RenderCache {
	*** entries;
	*** get(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** put(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType,java.lang.Object);
}

-keep class sun.java2d.loops.RenderCache$Entry {
	*** comp;
	*** dst;
	*** src;
	*** this$0;
	*** value;
	*** getValue();
	*** matches(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.RenderLoops {
	*** drawGlyphListAALoop;
	*** drawGlyphListLCDLoop;
	*** drawGlyphListLoop;
	*** drawLineLoop;
	*** drawParallelogramLoop;
	*** drawPathLoop;
	*** drawPolygonsLoop;
	*** drawRectLoop;
	*** fillParallelogramLoop;
	*** fillPathLoop;
	*** fillRectLoop;
	*** fillSpansLoop;
}

-keep class sun.java2d.loops.ScaledBlit {
	*** blitcache;
	*** methodSignature;
	*** primTypeID;
	sun.java2d.loops.ScaledBlit(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** Scale(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,int,int,int,int,double,double,double,double);
	*** getFromCache(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.SurfaceType {
	*** Any;
	*** Any3Byte;
	*** Any4Byte;
	*** AnyByte;
	*** AnyByteBinary;
	*** AnyColor;
	*** AnyDcm;
	*** AnyInt;
	*** AnyPaint;
	*** AnyShort;
	*** ByteBinary1Bit;
	*** ByteBinary2Bit;
	*** ByteBinary4Bit;
	*** ByteGray;
	*** ByteIndexed;
	*** ByteIndexedBm;
	*** ByteIndexedOpaque;
	*** Custom;
	*** FourByteAbgr;
	*** FourByteAbgrPre;
	*** GradientPaint;
	*** Index12Gray;
	*** Index8Gray;
	*** IntArgb;
	*** IntArgbBm;
	*** IntArgbPre;
	*** IntBgr;
	*** IntBgrx;
	*** IntRgb;
	*** IntRgbx;
	*** LinearGradientPaint;
	*** OpaqueColor;
	*** OpaqueGradientPaint;
	*** OpaqueLinearGradientPaint;
	*** OpaqueRadialGradientPaint;
	*** OpaqueTexturePaint;
	*** RadialGradientPaint;
	*** TexturePaint;
	*** ThreeByteBgr;
	*** ThreeByteRgb;
	*** Ushort4444Argb;
	*** Ushort555Rgb;
	*** Ushort555Rgbx;
	*** Ushort565Rgb;
	*** UshortGray;
	*** UshortIndexed;
	*** desc;
	*** next;
	*** pixelConverter;
	*** surfaceUIDMap;
	*** uniqueID;
	*** unusedUID;
	*** deriveSubType(java.lang.String);
	*** deriveSubType(java.lang.String,sun.awt.image.PixelConverter);
	*** equals(java.lang.Object);
	*** getAlphaMask();
	*** getSuperType();
	*** getUniqueID();
	*** makeUniqueID(java.lang.String);
	*** pixelFor(int,java.awt.image.ColorModel);
	*** rgbFor(int,java.awt.image.ColorModel);
}

-keep class sun.java2d.loops.TransformBlit {
	*** blitcache;
	*** methodSignature;
	*** primTypeID;
	sun.java2d.loops.TransformBlit(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** Transform(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,java.awt.geom.AffineTransform,int,int,int,int,int,int,int);
	*** getFromCache(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.TransformHelper {
	*** helpercache;
	*** methodSignature;
	*** primTypeID;
	*** Transform(sun.java2d.loops.MaskBlit,sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,java.awt.geom.AffineTransform,int,int,int,int,int,int,int,int,int,int[],int,int);
	*** getFromCache(sun.java2d.loops.SurfaceType);
	*** locate(sun.java2d.loops.SurfaceType);
}

-keep class sun.java2d.loops.XORComposite {
	*** alphaMask;
	*** xorColor;
	*** xorPixel;
	*** getXorColor();
	*** getXorPixel();
}

-keep class sun.java2d.opengl.CGLGraphicsConfig {
	*** bufferCaps;
	*** cachedMaxTextureSize;
	*** cglAvailable;
	*** context;
	*** disposerReferent;
	*** imageCaps;
	*** oglCaps;
	*** pConfigInfo;
	*** pixfmt;
	*** totalDisplayBounds;
	*** _getMaxTextureSize();
	*** getBufferCapabilities();
	*** getCGLConfigInfo(int,int,int);
	*** getColorModel(int);
	*** getConfig(sun.awt.CGraphicsDevice,int);
	*** getContext();
	*** getMaxTextureSize();
	*** getOGLCapabilities(long);
	*** initCGL();
	*** isCapPresent(int);
	*** isDoubleBuffered();
	*** updateTotalDisplayBounds();
}

-keep class sun.java2d.opengl.CGLGraphicsConfig$1 {
	*** val$ids;
}

-keep class sun.java2d.opengl.CGLGraphicsConfig$CGLGCDisposerRecord {
	*** pCfgInfo;
}

-keep class sun.java2d.opengl.CGLGraphicsConfig$CGLImageCaps {
	sun.java2d.opengl.CGLGraphicsConfig$CGLImageCaps();
}

-keep class sun.java2d.opengl.CGLSurfaceData {
	*** createData(sun.java2d.opengl.CGLGraphicsConfig,int,int,java.awt.image.ColorModel,java.awt.Image,int);
	*** createData(sun.java2d.opengl.CGLLayer);
	*** createData(sun.lwawt.macosx.CPlatformView);
}

-keep class sun.java2d.opengl.CGLSurfaceData$CGLVSyncOffScreenSurfaceData {
	*** getFlipSurface();
}

-keep class sun.java2d.opengl.OGLAnyCompositeBlit {
	*** dstTmp;
}

-keep class sun.java2d.opengl.OGLBlitLoops {
	*** Blit(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region,java.awt.geom.AffineTransform,int,int,int,int,int,double,double,double,double,int,boolean);
	*** IsoBlit(sun.java2d.SurfaceData,sun.java2d.SurfaceData,java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,java.awt.Composite,sun.java2d.pipe.Region,java.awt.geom.AffineTransform,int,int,int,int,int,double,double,double,double,boolean);
	*** createPackedParams(boolean,boolean,boolean,boolean,int,int);
	*** enqueueBlit(sun.java2d.pipe.RenderQueue,sun.java2d.SurfaceData,sun.java2d.SurfaceData,int,int,int,int,int,double,double,double,double);
	*** register();
}

-keep class sun.java2d.opengl.OGLBufImgOps {
	*** renderImageWithOp(sun.java2d.SunGraphics2D,java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int);
}

-keep class sun.java2d.opengl.OGLContext {
	*** config;
	*** getOGLIdString();
	*** invalidateCurrentContext();
	*** setScratchSurface(long);
	*** setScratchSurface(sun.java2d.opengl.OGLGraphicsConfig);
}

-keep class sun.java2d.opengl.OGLGeneralBlit {
	*** performop;
	*** srcTmp;
}

-keep class sun.java2d.opengl.OGLGraphicsConfig {
	*** getContext();
	*** getNativeConfigInfo();
	*** isCapPresent(int);
}

-keep class sun.java2d.opengl.OGLMaskBlit {
	*** register();
}

-keep class sun.java2d.opengl.OGLMaskFill {
	*** register();
}

-keep class sun.java2d.opengl.OGLPaints {
	*** isValid(sun.java2d.SunGraphics2D);
}

-keep class sun.java2d.opengl.OGLRenderQueue {
	*** flusher;
	*** theInstance;
	*** access$000(sun.java2d.opengl.OGLRenderQueue);
	*** access$100(sun.java2d.opengl.OGLRenderQueue);
	*** disposeGraphicsConfig(long);
	*** flushAndInvokeNow(java.lang.Runnable);
	*** flushBuffer();
	*** flushBuffer(long,int);
	*** flushNow();
	*** getInstance();
}

-keep class sun.java2d.opengl.OGLRenderQueue$1 {
	*** this$0;
	*** run();
}

-keep class sun.java2d.opengl.OGLRenderQueue$QueueFlusher {
	*** error;
	*** needsFlush;
	*** task;
	*** this$0;
	*** flushAndInvokeNow(java.lang.Runnable);
	*** flushNow();
}

-keep class sun.java2d.opengl.OGLRenderer {
	*** copyArea(sun.java2d.SunGraphics2D,int,int,int,int,int,int);
}

-keep class sun.java2d.opengl.OGLSurfaceData {
	*** OpenGLSurface;
	*** OpenGLSurfaceRTT;
	*** OpenGLTexture;
	*** graphicsConfig;
	*** isBIOpShaderEnabled;
	*** isFBObjectEnabled;
	*** isGradShaderEnabled;
	*** isLCDShaderEnabled;
	*** nativeHeight;
	*** nativeWidth;
	*** oglAAPgramPipe;
	*** oglImagePipe;
	*** oglRenderPipe;
	*** oglTextPipe;
	*** oglTxRenderPipe;
	*** type;
	*** getContext();
	*** getCustomSurfaceType(int);
	*** getOGLGraphicsConfig();
	*** getTextureID();
	*** getTextureID(long);
	*** getTextureTarget(long);
	*** getType();
	*** initFBObject(long,boolean,boolean,boolean,int,int);
	*** initFlipBackbuffer(long);
	*** initPbuffer(long,long,boolean,int,int);
	*** initSurfaceNow(int,int);
	*** initTexture(long,boolean,boolean,boolean,int,int);
	*** isOnScreen();
	*** isTexNonPow2Available();
	*** isTexRectAvailable();
	*** swapBuffers(long);
}

-keep class sun.java2d.opengl.OGLSurfaceDataProxy {
	*** createProxy(sun.java2d.SurfaceData,sun.java2d.opengl.OGLGraphicsConfig);
}

-keep class sun.java2d.opengl.OGLSurfaceToSwBlit {
	*** typeval;
}

-keep class sun.java2d.opengl.OGLSwToSurfaceBlit {
	*** typeval;
}

-keep class sun.java2d.opengl.OGLSwToSurfaceScale {
	*** typeval;
}

-keep class sun.java2d.opengl.OGLSwToSurfaceTransform {
	*** typeval;
}

-keep class sun.java2d.opengl.OGLSwToTextureBlit {
	*** typeval;
}

-keep class sun.java2d.opengl.OGLTextRenderer {
	*** traceWrap();
}

-keep class sun.java2d.pipe.AAShapePipe {
	*** outpipe;
	*** renderengine;
	*** theTile;
	*** computeBBox(double,double,double,double);
	*** dropAlphaTile(byte[]);
	*** getAlphaTile(int);
	*** renderPath(sun.java2d.SunGraphics2D,java.awt.Shape,java.awt.BasicStroke);
	*** renderTiles(sun.java2d.SunGraphics2D,java.awt.Shape,sun.java2d.pipe.AATileGenerator,int[]);
}

-keep class sun.java2d.pipe.AATileGenerator {
	*** dispose();
	*** getAlpha(byte[],int,int);
	*** getTileHeight();
	*** getTileWidth();
	*** getTypicalAlpha();
	*** nextTile();
}

-keep class sun.java2d.pipe.AlphaPaintPipe {
	*** cachedLastColorModel;
	*** cachedLastData;
	*** cachedLastRaster;
}

-keep class sun.java2d.pipe.AlphaPaintPipe$TileContext {
	*** dstData;
	*** lastBlit;
	*** lastData;
	*** lastMask;
	*** lastRaster;
	*** paintCtxt;
	*** paintModel;
	*** sunG2D;
}

-keep class sun.java2d.pipe.BufferedBufImgOps {
	*** disableBufImgOp(sun.java2d.pipe.RenderQueue,java.awt.image.BufferedImageOp);
	*** enableBufImgOp(sun.java2d.pipe.RenderQueue,sun.java2d.SurfaceData,java.awt.image.BufferedImage,java.awt.image.BufferedImageOp);
}

-keep class sun.java2d.pipe.BufferedContext {
	*** buf;
	*** currentContext;
	*** isValidatedPaintJustAColor;
	*** rq;
	*** transform;
	*** validatedClip;
	*** validatedComp;
	*** validatedDstData;
	*** validatedFlags;
	*** validatedPaint;
	*** validatedRGB;
	*** validatedSrcData;
	*** xformInUse;
	sun.java2d.pipe.BufferedContext(sun.java2d.pipe.RenderQueue);
	*** invalidateContext();
	*** invalidateSurfaces();
	*** resetClip();
	*** resetComposite();
	*** resetTransform();
	*** setClip(sun.java2d.pipe.Region);
	*** setComposite(java.awt.Composite,int);
	*** setSurfaces(sun.java2d.pipe.hw.AccelSurface,sun.java2d.pipe.hw.AccelSurface);
	*** setTransform(java.awt.geom.AffineTransform);
	*** validate(sun.java2d.pipe.hw.AccelSurface,sun.java2d.pipe.hw.AccelSurface,sun.java2d.pipe.Region,java.awt.Composite,java.awt.geom.AffineTransform,java.awt.Paint,sun.java2d.SunGraphics2D,int);
	*** validateContext(sun.java2d.pipe.hw.AccelSurface);
	*** validateContext(sun.java2d.pipe.hw.AccelSurface,sun.java2d.pipe.hw.AccelSurface,sun.java2d.pipe.Region,java.awt.Composite,java.awt.geom.AffineTransform,java.awt.Paint,sun.java2d.SunGraphics2D,int);
}

-keep class sun.java2d.pipe.BufferedMaskBlit {
	*** blitop;
	*** rq;
	*** srcTypeVal;
	sun.java2d.pipe.BufferedMaskBlit(sun.java2d.pipe.RenderQueue,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** enqueueTile(long,int,sun.java2d.SurfaceData,long,int,byte[],int,int,int,int,int,int,int,int,int);
	*** validateContext(sun.java2d.SurfaceData,java.awt.Composite,sun.java2d.pipe.Region);
}

-keep class sun.java2d.pipe.BufferedMaskFill {
	*** rq;
	sun.java2d.pipe.BufferedMaskFill(sun.java2d.pipe.RenderQueue,sun.java2d.loops.SurfaceType,sun.java2d.loops.CompositeType,sun.java2d.loops.SurfaceType);
	*** validateContext(sun.java2d.SunGraphics2D,java.awt.Composite,int);
}

-keep class sun.java2d.pipe.BufferedPaints {
	*** resetPaint(sun.java2d.pipe.RenderQueue);
	*** setPaint(sun.java2d.pipe.RenderQueue,sun.java2d.SunGraphics2D,java.awt.Paint,int);
}

-keep class sun.java2d.pipe.BufferedRenderPipe {
	*** aapgrampipe;
	*** buf;
	*** drawHandler;
	*** rq;
	sun.java2d.pipe.BufferedRenderPipe(sun.java2d.pipe.RenderQueue);
	*** draw(sun.java2d.SunGraphics2D,java.awt.Shape);
	*** drawLine(sun.java2d.SunGraphics2D,int,int,int,int);
	*** drawPath(sun.java2d.SunGraphics2D,java.awt.geom.Path2D$Float,int,int);
	*** drawPoly(sun.java2d.SunGraphics2D,int[],int[],int,boolean);
	*** drawPolygon(sun.java2d.SunGraphics2D,int[],int[],int);
	*** fill(sun.java2d.SunGraphics2D,java.awt.Shape);
	*** fillPath(sun.java2d.SunGraphics2D,java.awt.geom.Path2D$Float,int,int);
	*** fillSpans(sun.java2d.SunGraphics2D,sun.java2d.pipe.SpanIterator,int,int);
	*** fillSpans(sun.java2d.pipe.RenderQueue,long,int,int,sun.java2d.pipe.SpanIterator,long,int,int);
	*** getAAParallelogramPipe();
	*** validateContext(sun.java2d.SunGraphics2D);
	*** validateContextAA(sun.java2d.SunGraphics2D);
}

-keep class sun.java2d.pipe.BufferedRenderPipe$AAParallelogramPipe {
	*** this$0;
	sun.java2d.pipe.BufferedRenderPipe$AAParallelogramPipe(sun.java2d.pipe.BufferedRenderPipe);
}

-keep class sun.java2d.pipe.BufferedRenderPipe$BufferedDrawHandler {
	*** remainingScanlines;
	*** scanlineCount;
	*** scanlineCountIndex;
	*** this$0;
	*** endFillPath();
	*** resetFillPath();
	*** startFillPath();
	*** updateScanlineCount();
	*** validate(sun.java2d.SunGraphics2D);
}

-keep class sun.java2d.pipe.BufferedTextPipe {
	*** rq;
	sun.java2d.pipe.BufferedTextPipe(sun.java2d.pipe.RenderQueue);
	*** createPackedParams(sun.java2d.SunGraphics2D,sun.font.GlyphList);
	*** enqueueGlyphList(sun.java2d.SunGraphics2D,sun.font.GlyphList);
	*** validateContext(sun.java2d.SunGraphics2D,java.awt.Composite);
}

-keep class sun.java2d.pipe.CompositePipe {
	*** endSequence(java.lang.Object);
	*** needTile(java.lang.Object,int,int,int,int);
	*** renderPathTile(java.lang.Object,byte[],int,int,int,int,int,int);
	*** skipTile(java.lang.Object,int,int);
	*** startSequence(sun.java2d.SunGraphics2D,java.awt.Shape,java.awt.Rectangle,int[]);
}

-keep class sun.java2d.pipe.DrawImage {
	sun.java2d.pipe.DrawImage();
	*** blitSurfaceData(sun.java2d.SunGraphics2D,sun.java2d.pipe.Region,sun.java2d.SurfaceData,sun.java2d.SurfaceData,sun.java2d.loops.SurfaceType,sun.java2d.loops.SurfaceType,int,int,int,int,int,int,java.awt.Color);
	*** closeToInteger(int,double);
	*** copyImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,int,int,java.awt.Color);
	*** copyImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,java.awt.Color);
	*** getBufferedImage(java.awt.Image);
	*** imageReady(sun.awt.image.ToolkitImage,java.awt.image.ImageObserver);
	*** isBgOperation(sun.java2d.SurfaceData,java.awt.Color);
	*** isSimpleTranslate(sun.java2d.SunGraphics2D);
	*** makeBufferedImage(java.awt.Image,java.awt.Color,int,int,int,int,int);
	*** renderImageCopy(sun.java2d.SunGraphics2D,java.awt.Image,java.awt.Color,int,int,int,int,int,int);
	*** renderImageScale(sun.java2d.SunGraphics2D,java.awt.Image,java.awt.Color,int,int,int,int,int,double,double,double,double);
	*** renderImageXform(sun.java2d.SunGraphics2D,java.awt.Image,java.awt.geom.AffineTransform,int,int,int,int,int,java.awt.Color);
	*** scaleImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color);
	*** scaleImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,java.awt.Color);
	*** scaleSurfaceData(sun.java2d.SunGraphics2D,sun.java2d.pipe.Region,sun.java2d.SurfaceData,sun.java2d.SurfaceData,sun.java2d.loops.SurfaceType,sun.java2d.loops.SurfaceType,int,int,int,int,double,double,double,double);
	*** transformImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,java.awt.geom.AffineTransform,int);
	*** transformImage(sun.java2d.SunGraphics2D,java.awt.Image,java.awt.geom.AffineTransform,int,int,int,int,int,java.awt.Color);
	*** tryCopyOrScale(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,java.awt.Color,int,double[]);
}

-keep class sun.java2d.pipe.DrawImagePipe {
	*** copyImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** copyImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** scaleImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** scaleImage(sun.java2d.SunGraphics2D,java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver);
	*** transformImage(sun.java2d.SunGraphics2D,java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver);
	*** transformImage(sun.java2d.SunGraphics2D,java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int);
}

-keep class sun.java2d.pipe.GeneralCompositePipe$TileContext {
	*** compCtxt;
	*** paintCtxt;
	*** sunG2D;
}

-keep class sun.java2d.pipe.GlyphListLoopPipe {
	sun.java2d.pipe.GlyphListLoopPipe();
}

-keep class sun.java2d.pipe.GlyphListPipe {
	sun.java2d.pipe.GlyphListPipe();
	*** drawGlyphList(sun.java2d.SunGraphics2D,sun.font.GlyphList);
	*** drawGlyphList(sun.java2d.SunGraphics2D,sun.font.GlyphList,int);
}

-keep class sun.java2d.pipe.LoopPipe {
	*** RenderEngine;
	*** fill(sun.java2d.SunGraphics2D,java.awt.Shape);
	*** fillSpans(sun.java2d.SunGraphics2D,sun.java2d.pipe.SpanIterator);
	*** getFillSSI(sun.java2d.SunGraphics2D);
	*** getStrokeSpans(sun.java2d.SunGraphics2D,java.awt.Shape);
}

-keep class sun.java2d.pipe.OutlineTextRenderer {
	*** drawString(sun.java2d.SunGraphics2D,java.lang.String,double,double);
}

-keep class sun.java2d.pipe.ParallelogramPipe {
	*** drawParallelogram(sun.java2d.SunGraphics2D,double,double,double,double,double,double,double,double,double,double,double,double);
	*** fillParallelogram(sun.java2d.SunGraphics2D,double,double,double,double,double,double,double,double,double,double);
}

-keep class sun.java2d.pipe.PixelDrawPipe {
	*** drawArc(sun.java2d.SunGraphics2D,int,int,int,int,int,int);
	*** drawLine(sun.java2d.SunGraphics2D,int,int,int,int);
	*** drawOval(sun.java2d.SunGraphics2D,int,int,int,int);
	*** drawPolygon(sun.java2d.SunGraphics2D,int[],int[],int);
	*** drawPolyline(sun.java2d.SunGraphics2D,int[],int[],int);
	*** drawRect(sun.java2d.SunGraphics2D,int,int,int,int);
	*** drawRoundRect(sun.java2d.SunGraphics2D,int,int,int,int,int,int);
}

-keep class sun.java2d.pipe.PixelFillPipe {
	*** fillArc(sun.java2d.SunGraphics2D,int,int,int,int,int,int);
	*** fillOval(sun.java2d.SunGraphics2D,int,int,int,int);
	*** fillPolygon(sun.java2d.SunGraphics2D,int[],int[],int);
	*** fillRect(sun.java2d.SunGraphics2D,int,int,int,int);
	*** fillRoundRect(sun.java2d.SunGraphics2D,int,int,int,int,int,int);
}

-keep class sun.java2d.pipe.PixelToParallelogramConverter {
	*** adjustfill;
	*** minPenSize;
	*** normPosition;
	*** normRoundingBias;
	*** outrenderer;
	sun.java2d.pipe.PixelToParallelogramConverter(sun.java2d.pipe.ShapeDrawPipe,sun.java2d.pipe.ParallelogramPipe,double,double,boolean);
	*** drawGeneralLine(sun.java2d.SunGraphics2D,double,double,double,double);
	*** drawLine(sun.java2d.SunGraphics2D,int,int,int,int);
	*** drawRectangle(sun.java2d.SunGraphics2D,double,double,double,double,double);
	*** fillOuterParallelogram(sun.java2d.SunGraphics2D,double,double,double,double,double,double,double,double,double,double,double,double,double,double);
	*** fillRectangle(sun.java2d.SunGraphics2D,double,double,double,double);
	*** len(double,double);
	*** normalize(double);
}

-keep class sun.java2d.pipe.PixelToShapeConverter {
	*** outpipe;
	sun.java2d.pipe.PixelToShapeConverter(sun.java2d.pipe.ShapeDrawPipe);
	*** drawLine(sun.java2d.SunGraphics2D,int,int,int,int);
	*** drawRect(sun.java2d.SunGraphics2D,int,int,int,int);
	*** makePoly(int[],int[],int,boolean);
}

-keep class sun.java2d.pipe.Region {
	*** EMPTY_REGION;
	*** WHOLE_REGION;
	*** bands;
	*** endIndex;
	*** hix;
	*** hiy;
	*** lox;
	*** loy;
	sun.java2d.pipe.Region(int,int,int,int);
	*** appendSpan(int[]);
	*** appendSpans(sun.java2d.pipe.SpanIterator);
	*** calcBBox();
	*** clipAdd(int,int);
	*** clipBoxToBounds(int[]);
	*** clipScale(int,double);
	*** dimAdd(int,int);
	*** encompasses(sun.java2d.pipe.Region);
	*** encompassesXYXY(int,int,int,int);
	*** endRow(int[]);
	*** equals(java.lang.Object);
	*** filter(sun.java2d.pipe.SpanIterator);
	*** filterSpans(sun.java2d.pipe.Region,sun.java2d.pipe.Region,int);
	*** getBoundsIntersectionXYWH(int,int,int,int);
	*** getBoundsIntersectionXYXY(int,int,int,int);
	*** getDifference(sun.java2d.pipe.Region);
	*** getHeight();
	*** getHiX();
	*** getHiY();
	*** getInstance(int[]);
	*** getInstance(java.awt.Shape,java.awt.geom.AffineTransform);
	*** getInstance(sun.java2d.pipe.Region,boolean,java.awt.Shape,java.awt.geom.AffineTransform);
	*** getInstanceXYWH(int,int,int,int);
	*** getInstanceXYXY(int,int,int,int);
	*** getIntersection(java.awt.Rectangle);
	*** getIntersection(sun.java2d.pipe.Region);
	*** getIntersectionXYWH(int,int,int,int);
	*** getIntersectionXYXY(int,int,int,int);
	*** getIterator();
	*** getLoX();
	*** getLoY();
	*** getSafeTranslatedRegion(int,int);
	*** getScaledRegion(double,double);
	*** getSpanIterator();
	*** getSpanIterator(int[]);
	*** getTranslatedRegion(int,int);
	*** getUnion(sun.java2d.pipe.Region);
	*** getWidth();
	*** initIDs();
	*** intersectsQuickCheck(sun.java2d.pipe.Region);
	*** intersectsQuickCheckXYXY(int,int,int,int);
	*** isEmpty();
	*** isInsideQuickCheck(sun.java2d.pipe.Region);
	*** isInsideXYXY(int,int,int,int);
	*** isRectangular();
	*** needSpace(int);
	*** setOutputAreaXYWH(int,int,int,int);
	*** setOutputAreaXYXY(int,int,int,int);
}

-keep class sun.java2d.pipe.RegionIterator {
	*** curIndex;
	*** numXbands;
	*** region;
	*** createCopy();
}

-keep class sun.java2d.pipe.RenderBuffer {
	*** baseAddress;
	*** capacity;
	*** curAddress;
	*** endAddress;
	*** unsafe;
	*** allocate(int);
	*** capacity();
	*** clear();
	*** getAddress();
	*** position();
	*** position(long);
	*** put(byte[]);
	*** put(byte[],int,int);
	*** put(float[],int,int);
	*** put(int[],int,int);
	*** put(long[],int,int);
	*** put(short[],int,int);
	*** putByte(byte);
	*** putDouble(double);
	*** putFloat(float);
	*** putInt(int);
	*** putInt(int,int);
	*** putLong(long);
	*** putShort(short);
	*** remaining();
}

-keep class sun.java2d.pipe.RenderQueue {
	*** buf;
	*** refSet;
	sun.java2d.pipe.RenderQueue();
	*** addReference(java.lang.Object);
	*** ensureAlignment(int);
	*** ensureCapacity(int);
	*** ensureCapacityAndAlignment(int,int);
	*** flushAndInvokeNow(java.lang.Runnable);
	*** flushNow();
	*** getBuffer();
	*** lock();
	*** tryLock();
	*** unlock();
}

-keep class sun.java2d.pipe.RenderingEngine {
	*** reImpl;
	sun.java2d.pipe.RenderingEngine();
	*** createStrokedShape(java.awt.Shape,float,int,int,float,float[],float);
	*** feedConsumer(java.awt.geom.PathIterator,sun.awt.geom.PathConsumer2D);
	*** getAATileGenerator(double,double,double,double,double,double,double,double,sun.java2d.pipe.Region,int[]);
	*** getAATileGenerator(java.awt.Shape,java.awt.geom.AffineTransform,sun.java2d.pipe.Region,java.awt.BasicStroke,boolean,boolean,int[]);
	*** getInstance();
	*** getMinimumAAPenSize();
	*** strokeTo(java.awt.Shape,java.awt.geom.AffineTransform,java.awt.BasicStroke,boolean,boolean,boolean,sun.awt.geom.PathConsumer2D);
}

-keep class sun.java2d.pipe.ShapeDrawPipe {
	*** draw(sun.java2d.SunGraphics2D,java.awt.Shape);
	*** fill(sun.java2d.SunGraphics2D,java.awt.Shape);
}

-keep class sun.java2d.pipe.ShapeSpanIterator {
	*** appendPath(java.awt.geom.PathIterator);
	*** appendPoly(int[],int[],int,int,int);
	*** dispose();
	*** getPathBox(int[]);
	*** intersectClipBox(int,int,int,int);
	*** setOutputArea(sun.java2d.pipe.Region);
	*** setOutputAreaXYXY(int,int,int,int);
	*** setRule(int);
}

-keep class sun.java2d.pipe.SpanClipRenderer {
	*** RegionClass;
	*** RegionIteratorClass;
	*** outpipe;
	*** eraseTile(sun.java2d.pipe.RegionIterator,byte[],int,int,int[]);
	*** fillTile(sun.java2d.pipe.RegionIterator,byte[],int,int,int[]);
	*** initIDs(java.lang.Class,java.lang.Class);
	*** renderPathTile(java.lang.Object,byte[],int,int,int,int,int,int);
}

-keep class sun.java2d.pipe.SpanClipRenderer$SCRcontext {
	*** band;
	*** iterator;
	*** outcontext;
	*** tile;
}

-keep class sun.java2d.pipe.SpanIterator {
	*** getNativeIterator();
	*** intersectClipBox(int,int,int,int);
	*** nextSpan(int[]);
}

-keep class sun.java2d.pipe.SpanShapeRenderer {
	*** RenderEngine;
	sun.java2d.pipe.SpanShapeRenderer();
	*** endSequence(java.lang.Object);
	*** fill(sun.java2d.SunGraphics2D,java.awt.Shape);
	*** renderBox(java.lang.Object,int,int,int,int);
	*** renderRect(sun.java2d.SunGraphics2D,java.awt.geom.Rectangle2D);
	*** renderSpans(sun.java2d.SunGraphics2D,sun.java2d.pipe.Region,java.awt.Shape,sun.java2d.pipe.ShapeSpanIterator);
	*** spanClipLoop(java.lang.Object,sun.java2d.pipe.SpanIterator,sun.java2d.pipe.Region,int[]);
	*** startSequence(sun.java2d.SunGraphics2D,java.awt.Shape,java.awt.Rectangle,int[]);
}

-keep class sun.java2d.pipe.SpanShapeRenderer$Composite {
	*** comppipe;
}

-keep class sun.java2d.pipe.TextPipe {
	*** drawChars(sun.java2d.SunGraphics2D,char[],int,int,int,int);
	*** drawGlyphVector(sun.java2d.SunGraphics2D,java.awt.font.GlyphVector,float,float);
	*** drawString(sun.java2d.SunGraphics2D,java.lang.String,double,double);
}

-keep class sun.java2d.pipe.TextRenderer {
	*** outpipe;
}

-keep class sun.java2d.pipe.ValidatePipe {
	*** validate(sun.java2d.SunGraphics2D);
}

-keep class sun.java2d.pipe.hw.AccelDeviceEventNotifier {
	*** addListener(sun.java2d.pipe.hw.AccelDeviceEventListener,int);
	*** removeListener(sun.java2d.pipe.hw.AccelDeviceEventListener);
}

-keep class sun.java2d.pipe.hw.AccelSurface {
	*** getNativeOps();
	*** getType();
	*** isSurfaceLost();
	*** isValid();
	*** markDirty();
}

-keep class sun.java2d.pipe.hw.BufferedContextProvider {
	*** getContext();
}

-keep class sun.java2d.pipe.hw.ContextCapabilities {
	*** adapterId;
	*** caps;
	sun.java2d.pipe.hw.ContextCapabilities(int,java.lang.String);
	*** getCaps();
	*** toString();
}

-keep class sun.java2d.pisces.PiscesRenderingEngine {
	sun.java2d.pisces.PiscesRenderingEngine();
	*** getAATileGenerator(java.awt.Shape,java.awt.geom.AffineTransform,sun.java2d.pipe.Region,java.awt.BasicStroke,boolean,boolean,int[]);
	*** nearZero(double,int);
	*** pathTo(java.awt.geom.PathIterator,sun.awt.geom.PathConsumer2D);
	*** strokeTo(java.awt.Shape,java.awt.geom.AffineTransform,float,sun.java2d.pisces.PiscesRenderingEngine$NormMode,int,int,float,float[],float,sun.awt.geom.PathConsumer2D);
	*** strokeTo(java.awt.Shape,java.awt.geom.AffineTransform,java.awt.BasicStroke,boolean,sun.java2d.pisces.PiscesRenderingEngine$NormMode,boolean,sun.awt.geom.PathConsumer2D);
	*** userSpaceLineWidth(java.awt.geom.AffineTransform,float);
}

-keep class sun.java2d.pisces.PiscesRenderingEngine$NormMode {
	*** OFF;
	*** ON_NO_AA;
	*** ON_WITH_AA;
}

-keep class sun.java2d.pisces.PiscesTileGenerator {
	*** getBbox(int[]);
}

-keep class sun.java2d.pisces.Renderer {
	*** MAX_AA_ALPHA;
	*** closePath();
	*** endRendering();
	*** lineTo(float,float);
	*** moveTo(float,float);
	*** pathDone();
}

-keep class sun.java2d.pisces.TransformingPathConsumer2D {
	*** deltaTransformConsumer(sun.awt.geom.PathConsumer2D,java.awt.geom.AffineTransform);
	*** inverseDeltaTransformConsumer(sun.awt.geom.PathConsumer2D,java.awt.geom.AffineTransform);
	*** transformConsumer(sun.awt.geom.PathConsumer2D,java.awt.geom.AffineTransform);
}

-keep class sun.launcher.LauncherHelper {
	*** $VALUES;
	*** INSTANCE;
	*** encoding;
	*** isCharsetSupported;
	*** outBuf;
	*** trace;
	*** abort(java.io.PrintStream,java.lang.Throwable,java.lang.String,java.lang.Object[]);
	*** expandArgs(java.util.List);
	*** getLocalizedMessage(java.lang.String,java.lang.Object[]);
	*** getMainClassFromJar(java.io.PrintStream,java.lang.String);
	*** getMainMethod(java.io.PrintStream,java.lang.Class);
	*** isPath(java.lang.String);
	*** printLocale(java.io.PrintStream);
	*** printLocales(java.io.PrintStream);
	*** printProperties(java.io.PrintStream);
	*** printPropertyValue(java.io.PrintStream,java.lang.String,java.lang.String);
	*** printVmSettings(java.io.PrintStream,long,long,long,boolean);
}

-keep class sun.launcher.LauncherHelper$ResourceBundleHolder {
	*** access$000();
}

-keep class sun.launcher.LauncherHelper$SizePrefix {
	*** scaleValue(long);
}

-keep class sun.launcher.LauncherHelper$StdArg {
	*** arg;
	*** needsExpansion;
}

-keep class sun.lwawt.LWComponentPeer {
	*** initialize();
}

-keep class sun.lwawt.LWKeyboardFocusManagerPeer {
	*** focusOwner;
	*** focusedWindow;
	*** inst;
	*** getInstance();
}

-keep class sun.lwawt.LWToolkit {
	*** clipboard;
	*** mouseInfoPeer;
	*** runState;
	sun.lwawt.LWToolkit();
	*** createCPrinterDialog(sun.lwawt.macosx.CPrinterDialog);
	*** createDelegatedPeer(java.awt.Window,sun.lwawt.PlatformComponent,sun.lwawt.PlatformWindow,sun.lwawt.LWWindowPeer$PeerType);
	*** createFileDialogPeer(java.awt.FileDialog);
	*** createMouseInfoPeerImpl();
	*** createPlatformClipboard();
	*** createPlatformComponent();
	*** createPlatformWindow(sun.lwawt.LWWindowPeer$PeerType);
	*** getPrintJob(java.awt.Frame,java.lang.String,java.awt.JobAttributes,java.awt.PageAttributes);
	*** getRunState();
	*** platformCleanup();
	*** platformInit();
	*** platformRunMessage();
	*** platformShutdown();
	*** setRunState(int);
	*** targetToPeer(java.lang.Object);
	*** waitForRunState(int);
}

-keep class sun.lwawt.LWWindowPeer {
	*** grab();
	*** ungrab(boolean);
	*** updateSecurityWarningVisibility();
}

-keep class sun.lwawt.LWWindowPeer$PeerType {
	*** DIALOG;
	*** EMBEDDED_FRAME;
	*** FRAME;
	*** SIMPLEWINDOW;
	*** VIEW_EMBEDDED_FRAME;
}

-keep class sun.lwawt.macosx.CCursorManager {
	*** getInstance();
}

-keep class sun.lwawt.macosx.CCustomCursor {
	*** getBestCursorSize(int,int);
}

-keep class sun.lwawt.macosx.CDragSourceContextPeer {
	*** createDragSourceContextPeer(java.awt.dnd.DragGestureEvent);
}

-keep class sun.lwawt.macosx.CImage {
	*** getCreator();
}

-keep class sun.lwawt.macosx.CImage$Creator {
	*** createImageFromFile(java.lang.String,double,double);
	*** createImageFromName(java.lang.String);
	*** createImageOfFile(java.lang.String,int,int);
	*** createSystemImageFromSelector(java.lang.String,int,int);
}

-keep class sun.lwawt.macosx.CInputMethod {
	*** getNativeLocale();
	*** mapInputMethodHighlight(java.awt.im.InputMethodHighlight);
}

-keep class sun.lwawt.macosx.CPlatformView {
	*** drawImageOnPeer(java.awt.image.VolatileImage,int,int,int,int);
	*** getAWTView();
}

-keep class sun.lwawt.macosx.CThreading {
	*** $assertionsDisabled;
	*** APPKIT_THREAD_NAME;
	*** isAppKit();
	*** isEventQueue();
}

-keep class sun.lwawt.macosx.LWCToolkit {
	*** $assertionsDisabled;
	*** appleColors;
	*** areExtraMouseButtonsEnabled;
	*** sInputMethodDescriptor;
	*** sunAwtDisableCALayers;
	*** access$000();
	*** checkForNSImage(java.lang.String);
	*** createAWTRunLoopMediator();
	*** doAWTRunLoop(long,boolean);
	*** getAppleColor(int);
	*** getSystemEventQueueForInvokeAndWait();
	*** initIDs();
	*** invokeAndWait(java.lang.Runnable,java.awt.Component);
	*** isCapsLockOn();
	*** loadNativeColors(int[],int[]);
	*** nativeSyncQueue(long);
}

-keep class sun.lwawt.macosx.LWCToolkit$AppleSpecificColor {
	*** index;
}

-keep class sun.lwawt.macosx.LWCToolkit$CallableWrapper {
	*** getResult();
}

-keep class sun.management.ManagementFactoryHelper {
	*** bufferPools;
	*** classMBean;
	*** compileMBean;
	*** hsClassMBean;
	*** hsCompileMBean;
	*** hsDiagMBean;
	*** hsMemoryMBean;
	*** hsRuntimeMBean;
	*** hsThreadMBean;
	*** jvm;
	*** memoryMBean;
	*** osMBean;
	*** runtimeMBean;
	*** threadMBean;
	*** addMBean(javax.management.MBeanServer,java.lang.Object,java.lang.String);
	*** createBufferPoolMXBean(sun.misc.JavaNioAccess$BufferPool);
	*** getClassLoadingMXBean();
	*** getCompilationMXBean();
	*** getGarbageCollectorMXBeans();
	*** getHotspotClassLoadingMBean();
	*** getHotspotCompilationMBean();
	*** getHotspotMemoryMBean();
	*** getHotspotRuntimeMBean();
	*** getHotspotThreadMBean();
	*** getMemoryMXBean();
	*** getMemoryManagerMXBeans();
	*** getMemoryPoolMXBeans();
	*** getOperatingSystemMXBean();
	*** getRuntimeMXBean();
	*** getThreadMXBean();
	*** unregisterMBean(javax.management.MBeanServer,java.lang.String);
}

-keep class sun.management.ManagementFactoryHelper$PlatformLoggingImpl {
	*** instance;
}

-keep class sun.management.MemoryImpl {
	*** jvm;
	*** mgrs;
	*** notifInfo;
	*** notifMsgs;
	*** notifTypes;
	*** pools;
	*** seqNumber;
	*** getMemoryManagers();
	*** getMemoryManagers0();
	*** getMemoryPools();
	*** getMemoryPools0();
	*** getMemoryUsage0(boolean);
	*** getNextSeqNumber();
	*** getNotifMsg(java.lang.String);
	*** getObjectName();
	*** setVerboseGC(boolean);
}

-keep class sun.management.MemoryNotifInfoCompositeData {
	*** toCompositeData(java.lang.management.MemoryNotificationInfo);
}

-keep class sun.management.NotificationEmitterSupport {
	*** listenerList;
	*** listenerLock;
	sun.management.NotificationEmitterSupport();
	*** hasListeners();
	*** sendNotification(javax.management.Notification);
}

-keep class sun.management.NotificationEmitterSupport$ListenerInfo {
	*** filter;
	*** handback;
	*** listener;
}

-keep class sun.management.OperatingSystemImpl {
	*** jvm;
	*** loadavg;
	*** unsafe;
	sun.management.OperatingSystemImpl(sun.management.VMManagement);
}

-keep class sun.management.Util {
	*** checkControlAccess();
	*** newException(java.lang.Exception);
	*** newObjectName(java.lang.String);
}

-keep class sun.management.VMManagement {
	*** getAvailableProcessors();
	*** getCompilerName();
	*** getOsArch();
	*** getOsName();
	*** getOsVersion();
	*** getVerboseGC();
}

-keep class sun.management.VMManagementImpl {
	*** bootClassPathSupport;
	*** compTimeMonitoringSupport;
	*** currentThreadCpuTimeSupport;
	*** gcNotificationSupport;
	*** noPerfData;
	*** objectMonitorUsageSupport;
	*** otherThreadCpuTimeSupport;
	*** perfInstr;
	*** synchronizerUsageSupport;
	*** threadAllocatedMemorySupport;
	*** threadContentionMonitoringSupport;
	*** version;
	*** vmArgs;
	*** getPerfInstrumentation();
	*** getProcessId();
	*** getTotalClassCount();
	*** getUnloadedClassCount();
	*** getVersion0();
	*** getVmArguments0();
	*** initOptionalSupportFields();
}

-keep class sun.management.counter.perf.PerfInstrumentation {
	*** findByPattern(java.lang.String);
}

-keep class sun.misc.ASCIICaseInsensitiveComparator {
	*** CASE_INSENSITIVE_ORDER;
	*** lowerCaseHashCode(java.lang.String);
}

-keep class sun.misc.BASE64Decoder {
	*;
}

-keep class sun.misc.CEStreamExhausted {
	*;
}

-keep class sun.misc.CharacterDecoder {
	*** decodeBuffer(java.lang.String);
}

-keep class sun.misc.CharacterEncoder {
	*** encodeBuffer(byte[]);
	*** encodeBuffer(byte[],java.io.OutputStream);
	*** encodeBuffer(java.io.InputStream,java.io.OutputStream);
	*** encodeBuffer(java.nio.ByteBuffer,java.io.OutputStream);
}

-keep class sun.misc.Cleaner {
	*** clean();
	*** create(java.lang.Object,java.lang.Runnable);
}

-keep class sun.misc.CompoundEnumeration {
	*;
}

-keep class sun.misc.FDBigInt {
	*;
}

-keep class sun.misc.FloatingDecimal {
	*;
}

-keep class sun.misc.FloatingDecimal$1 {
	*;
}

-keep class sun.misc.FormattedFloatingDecimal {
	*** getChars(char[]);
	*** getExponent();
	*** getExponentRounded();
}

-keep class sun.misc.FormattedFloatingDecimal$Form {
	*** DECIMAL_FLOAT;
	*** GENERAL;
	*** SCIENTIFIC;
}

-keep class sun.misc.FpUtils {
	*** copySign(double,double);
	*** copySign(float,float);
	*** getExponent(double);
	*** getExponent(float);
	*** isFinite(double);
	*** nextAfter(double,double);
	*** nextAfter(float,double);
	*** nextUp(double);
	*** nextUp(float);
	*** rawCopySign(double,double);
	*** scalb(double,int);
	*** scalb(float,int);
	*** signum(double);
	*** signum(float);
	*** ulp(double);
	*** ulp(float);
}

-keep class sun.misc.Hashing {
	*;
}

-keep class sun.misc.HexDumpEncoder {
	*;
}

-keep class sun.misc.IOUtils {
	*** readFully(java.io.InputStream,int,boolean);
}

-keep class sun.misc.IoTrace {
	*** fileReadBegin(java.lang.String);
	*** fileReadEnd(java.lang.Object,long);
	*** fileWriteBegin(java.lang.String);
	*** fileWriteEnd(java.lang.Object,long);
	*** socketReadBegin();
	*** socketReadEnd(java.lang.Object,java.net.InetAddress,int,int,long);
	*** socketWriteBegin();
	*** socketWriteEnd(java.lang.Object,java.net.InetAddress,int,long);
}

-keep class sun.misc.JavaAWTAccess {
	*** get(java.lang.Object);
	*** get(java.lang.Object,java.lang.Object);
	*** getContext();
	*** getExecutionContext();
	*** isDisposed();
	*** isMainAppContext();
	*** put(java.lang.Object,java.lang.Object);
	*** put(java.lang.Object,java.lang.Object,java.lang.Object);
}

-keep class sun.misc.JavaIOFileDescriptorAccess {
	*** get(java.io.FileDescriptor);
	*** set(java.io.FileDescriptor,int);
}

-keep class sun.misc.JavaLangAccess {
	*** blockedOn(java.lang.Thread,sun.nio.ch.Interruptible);
	*** getEnumConstantsShared(java.lang.Class);
	*** getStackTraceDepth(java.lang.Throwable);
	*** getStackTraceElement(java.lang.Throwable,int);
	*** registerShutdownHook(int,boolean,java.lang.Runnable);
}

-keep class sun.misc.JavaNetAccess {
	*;
}

-keep class sun.misc.JavaNioAccess {
	*** getDirectBufferPool();
}

-keep class sun.misc.JavaSecurityAccess {
	*** doIntersectionPrivilege(java.security.PrivilegedAction,java.security.AccessControlContext,java.security.AccessControlContext);
}

-keep class sun.misc.JavaSecurityProtectionDomainAccess {
	*** getProtectionDomainCache();
}

-keep class sun.misc.JavaSecurityProtectionDomainAccess$ProtectionDomainCache {
	*** get(java.security.ProtectionDomain);
	*** put(java.security.ProtectionDomain,java.security.PermissionCollection);
}

-keep class sun.misc.Launcher {
	*** getClassLoader();
	*** getLauncher();
}

-keep class sun.misc.Launcher$AppClassLoader {
	*;
}

-keep class sun.misc.Launcher$AppClassLoader$1 {
	*;
}

-keep class sun.misc.Launcher$ExtClassLoader {
	*;
}

-keep class sun.misc.Launcher$ExtClassLoader$1 {
	*;
}

-keep class sun.misc.Launcher$Factory {
	*;
}

-keep class sun.misc.MetaIndex {
	*;
}

-keep class sun.misc.NativeSignalHandler {
	*;
}

-keep class sun.misc.OSEnvironment {
	*;
}

-keep class sun.misc.Perf {
	*** attach(int,java.lang.String);
}

-keep class sun.misc.PerformanceLogger {
	*** loggingEnabled();
	*** setTime(java.lang.String);
}

-keep class sun.misc.PerformanceLogger$TimeData {
	*;
}

-keep class sun.misc.ProxyGenerator {
	*;
}

-keep class sun.misc.ProxyGenerator$1 {
	*;
}

-keep class sun.misc.ProxyGenerator$ConstantPool {
	*;
}

-keep class sun.misc.ProxyGenerator$ConstantPool$Entry {
	*;
}

-keep class sun.misc.ProxyGenerator$ConstantPool$IndirectEntry {
	*;
}

-keep class sun.misc.ProxyGenerator$ConstantPool$ValueEntry {
	*;
}

-keep class sun.misc.ProxyGenerator$ExceptionTableEntry {
	*;
}

-keep class sun.misc.ProxyGenerator$FieldInfo {
	*;
}

-keep class sun.misc.ProxyGenerator$MethodInfo {
	*;
}

-keep class sun.misc.ProxyGenerator$PrimitiveTypeInfo {
	*;
}

-keep class sun.misc.ProxyGenerator$ProxyMethod {
	*;
}

-keep class sun.misc.RegexpPool {
	*** add(java.lang.String,java.lang.Object);
	*** match(java.lang.String);
}

-keep class sun.misc.Resource {
	*** getURL();
}

-keep class sun.misc.SharedSecrets {
	*** getJavaAWTAccess();
	*** getJavaIOFileDescriptorAccess();
	*** getJavaLangAccess();
	*** getJavaNioAccess();
	*** getJavaSecurityAccess();
	*** getJavaSecurityProtectionDomainAccess();
	*** setJavaAWTAccess(sun.misc.JavaAWTAccess);
}

-keep class sun.misc.Signal {
	*;
}

-keep class sun.misc.SignalHandler {
	*;
}

-keep class sun.misc.SoftCache {
	*** get(java.lang.Object);
	*** put(java.lang.Object,java.lang.Object);
}

-keep class sun.misc.URLClassPath {
	*** checkURL(java.net.URL);
	*** getResource(java.lang.String,boolean);
}

-keep class sun.misc.URLClassPath$1 {
	*;
}

-keep class sun.misc.URLClassPath$2 {
	*;
}

-keep class sun.misc.URLClassPath$FileLoader {
	*;
}

-keep class sun.misc.URLClassPath$FileLoader$1 {
	*;
}

-keep class sun.misc.Unsafe {
	*** ARRAY_BYTE_BASE_OFFSET;
	*** ARRAY_FLOAT_BASE_OFFSET;
	*** ARRAY_INT_BASE_OFFSET;
	*** ARRAY_LONG_BASE_OFFSET;
	*** ARRAY_SHORT_BASE_OFFSET;
	*** addressSize();
	*** allocateMemory(long);
	*** arrayBaseOffset(java.lang.Class);
	*** arrayIndexScale(java.lang.Class);
	*** compareAndSwapInt(java.lang.Object,long,int,int);
	*** compareAndSwapLong(java.lang.Object,long,long,long);
	*** compareAndSwapObject(java.lang.Object,long,java.lang.Object,java.lang.Object);
	*** copyMemory(java.lang.Object,long,java.lang.Object,long,long);
	*** copyMemory(long,long,long);
	*** ensureClassInitialized(java.lang.Class);
	*** freeMemory(long);
	*** getByte(long);
	*** getChar(long);
	*** getDouble(long);
	*** getFloat(long);
	*** getInt(java.lang.Object,long);
	*** getInt(long);
	*** getIntVolatile(java.lang.Object,long);
	*** getLoadAverage(double[],int);
	*** getLong(java.lang.Object,long);
	*** getLong(long);
	*** getLongVolatile(java.lang.Object,long);
	*** getObject(java.lang.Object,long);
	*** getObjectVolatile(java.lang.Object,long);
	*** getShort(long);
	*** getUnsafe();
	*** objectFieldOffset(java.lang.reflect.Field);
	*** pageSize();
	*** park(boolean,long);
	*** putByte(long,byte);
	*** putChar(long,char);
	*** putDouble(long,double);
	*** putFloat(long,float);
	*** putInt(java.lang.Object,long,int);
	*** putInt(long,int);
	*** putIntVolatile(java.lang.Object,long,int);
	*** putLong(long,long);
	*** putLongVolatile(java.lang.Object,long,long);
	*** putObject(java.lang.Object,long,java.lang.Object);
	*** putObjectVolatile(java.lang.Object,long,java.lang.Object);
	*** putOrderedInt(java.lang.Object,long,int);
	*** putOrderedLong(java.lang.Object,long,long);
	*** putOrderedObject(java.lang.Object,long,java.lang.Object);
	*** putShort(long,short);
	*** setMemory(long,long,byte);
	*** throwException(java.lang.Throwable);
	*** unpark(java.lang.Object);
}

-keep class sun.misc.VM {
	*** getFinalRefCount();
	*** getSavedProperty(java.lang.String);
	*** isBooted();
	*** latestUserDefinedLoader();
	*** toThreadState(int);
}

-keep class sun.misc.VMNotification {
	*;
}

-keep class sun.misc.Version {
	*;
}

-keep class sun.net.ApplicationProxy {
	*** create(java.net.Proxy);
}

-keep class sun.net.InetAddressCachePolicy {
	*** cachePolicy;
	*** negativeCachePolicy;
	*** propertyNegativeSet;
	*** propertySet;
	*** checkValue(int,int);
	*** get();
	*** getNegative();
}

-keep class sun.net.InetAddressCachePolicy$1 {
	*** run();
}

-keep class sun.net.InetAddressCachePolicy$2 {
	*** run();
}

-keep class sun.net.NetHooks {
	*** provider;
	*** beforeTcpBind(java.io.FileDescriptor,java.net.InetAddress,int);
	*** beforeTcpConnect(java.io.FileDescriptor,java.net.InetAddress,int);
}

-keep class sun.net.NetHooks$Provider {
	sun.net.NetHooks$Provider();
	*** implBeforeTcpBind(java.io.FileDescriptor,java.net.InetAddress,int);
	*** implBeforeTcpConnect(java.io.FileDescriptor,java.net.InetAddress,int);
}

-keep class sun.net.NetProperties {
	*** props;
	*** access$000();
	*** get(java.lang.String);
	*** getBoolean(java.lang.String);
	*** getInteger(java.lang.String,int);
	*** loadDefaultProperties();
}

-keep class sun.net.NetProperties$1 {
	*** run();
}

-keep class sun.net.RegisteredDomain {
	*** getRegisteredDomain(java.lang.String);
}

-keep class sun.net.ResourceManager {
	*** maxSockets;
	*** numSockets;
	*** afterUdpClose();
	*** beforeUdpCreate();
}

-keep class sun.net.SocksProxy {
	*** create(java.net.SocketAddress,int);
	*** protocolVersion();
}

-keep class sun.net.sdp.SdpProvider {
	*** enabled;
	*** log;
	*** rules;
	*** convertTcpToSdpIfMatch(java.io.FileDescriptor,sun.net.sdp.SdpProvider$Action,java.net.InetAddress,int);
	*** fail(java.lang.String,java.lang.Object[]);
	*** loadRulesFromFile(java.lang.String);
	*** parsePortRange(java.lang.String);
}

-keep class sun.net.sdp.SdpProvider$Action {
	*** BIND;
	*** CONNECT;
	*** values();
}

-keep class sun.net.sdp.SdpProvider$Rule {
	*** match(sun.net.sdp.SdpProvider$Action,java.net.InetAddress,int);
}

-keep class sun.net.sdp.SdpSupport {
	*** convertSocket(java.io.FileDescriptor);
}

-keep class sun.net.spi.DefaultProxySelector {
	*** hasSystemProxies;
	*** props;
	*** access$000();
	*** access$100(sun.net.spi.DefaultProxySelector,java.lang.String,java.lang.String);
	*** access$200(sun.net.spi.DefaultProxySelector,java.lang.String);
	*** defaultPort(java.lang.String);
	*** getSystemProxy(java.lang.String,java.lang.String);
	*** init();
}

-keep class sun.net.spi.DefaultProxySelector$1 {
	*** run();
}

-keep class sun.net.spi.DefaultProxySelector$2 {
	*** this$0;
	*** val$nprop;
	*** val$proto;
	*** val$urlhost;
	*** run();
}

-keep class sun.net.spi.DefaultProxySelector$NonProxyInfo {
	*** defaultVal;
	*** ftpNonProxyInfo;
	*** hostsPool;
	*** hostsSource;
	*** httpNonProxyInfo;
	*** property;
}

-keep class sun.net.spi.nameservice.NameService {
	*** getHostByAddr(byte[]);
	*** lookupAllHostAddr(java.lang.String);
}

-keep class sun.net.util.IPAddressUtil {
	*** convertFromIPv4MappedAddress(byte[]);
	*** isIPv4LiteralAddress(java.lang.String);
	*** isIPv4MappedAddress(byte[]);
	*** isIPv6LiteralAddress(java.lang.String);
	*** textToNumericFormatV4(java.lang.String);
	*** textToNumericFormatV6(java.lang.String);
}

-keep class sun.net.www.MimeEntry {
	*** action;
	*** actionKeywords;
	*** command;
	*** description;
	*** fileExtensions;
	*** imageFileName;
	*** starred;
	*** tempFileNameTemplate;
	*** typeName;
	sun.net.www.MimeEntry(java.lang.String,int,java.lang.String,java.lang.String,java.lang.String[]);
	*** getAction();
	*** getDescription();
	*** getExtensions();
	*** getExtensionsAsList();
	*** getImageFileName();
	*** getLaunchString();
	*** getType();
	*** isStarred(java.lang.String);
	*** matches(java.lang.String);
	*** setAction(int);
	*** setCommand(java.lang.String);
	*** setDescription(java.lang.String);
	*** setExtensions(java.lang.String);
	*** setImageFileName(java.lang.String);
	*** toProperty();
}

-keep class sun.net.www.MimeTable {
	*** entries;
	*** extensionMap;
	*** mailcapLocations;
	*** tempFileTemplate;
	*** access$002(java.lang.String);
	*** add(sun.net.www.MimeEntry);
	*** elements();
	*** fill(sun.net.www.MimeEntry,java.lang.String,java.lang.String);
	*** find(java.lang.String);
	*** findByExt(java.lang.String);
	*** findByFileName(java.lang.String);
	*** getActionCode(java.lang.String);
	*** getAsProperties();
	*** getDefaultTable();
	*** getTempFileTemplate();
	*** load();
	*** parse(java.lang.String,java.lang.String);
	*** parse(java.lang.String,sun.net.www.MimeEntry);
	*** parse(java.util.Properties);
	*** remove(sun.net.www.MimeEntry);
	*** saveAsProperties(java.io.File);
}

-keep class sun.net.www.MimeTable$1 {
	*** run();
}

-keep class sun.net.www.MimeTable$DefaultInstanceHolder {
	*** defaultInstance;
	*** getDefaultInstance();
}

-keep class sun.net.www.MimeTable$DefaultInstanceHolder$1 {
	*** run();
}

-keep class sun.net.www.ParseUtil {
	*** decode(java.lang.String);
	*** encodePath(java.lang.String);
	*** fileToEncodedURL(java.io.File);
}

-keep class sun.net.www.URLConnection {
	*** isProxiedHost(java.lang.String);
}

-keep class sun.net.www.protocol.file.Handler {
	*;
}

-keep class sun.net.www.protocol.http.Handler {
	*** proxy;
	*** proxyPort;
	*** openConnection(java.net.URL,java.net.Proxy);
}

-keep class sun.net.www.protocol.jar.Handler {
	*;
}

-keep class sun.nio.ch.AllocatedNativeObject {
	*** free();
}

-keep class sun.nio.ch.DatagramChannelImpl {
	*** $assertionsDisabled;
	*** cachedSenderInetAddress;
	*** cachedSenderPort;
	*** family;
	*** fd;
	*** fdVal;
	*** isReuseAddress;
	*** localAddress;
	*** nd;
	*** readLock;
	*** readerThread;
	*** registry;
	*** remoteAddress;
	*** reuseAddressEmulated;
	*** sender;
	*** socket;
	*** state;
	*** stateLock;
	*** writeLock;
	*** writerThread;
	*** bind(java.net.SocketAddress);
	*** connect(java.net.SocketAddress);
	*** disconnect();
	*** disconnect0(java.io.FileDescriptor,boolean);
	*** ensureOpen();
	*** ensureOpenAndUnconnected();
	*** getLocalAddress();
	*** getOption(java.net.SocketOption);
	*** initIDs();
	*** innerJoin(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress);
	*** isConnected();
	*** kill();
	*** localAddress();
	*** receive(java.io.FileDescriptor,java.nio.ByteBuffer);
	*** receive(java.nio.ByteBuffer);
	*** receive0(java.io.FileDescriptor,long,int,boolean);
	*** receiveIntoNativeBuffer(java.io.FileDescriptor,java.nio.ByteBuffer,int,int);
	*** remoteAddress();
	*** send(java.io.FileDescriptor,java.nio.ByteBuffer,java.net.InetSocketAddress);
	*** send(java.nio.ByteBuffer,java.net.SocketAddress);
	*** send0(boolean,java.io.FileDescriptor,long,int,java.net.InetAddress,int);
	*** sendFromNativeBuffer(java.io.FileDescriptor,java.nio.ByteBuffer,java.net.InetSocketAddress);
	*** setOption(java.net.SocketOption,java.lang.Object);
	*** supportedOptions();
	*** translateReadyOps(int,int,sun.nio.ch.SelectionKeyImpl);
	*** write(java.nio.ByteBuffer);
}

-keep class sun.nio.ch.DatagramChannelImpl$DefaultOptionsHolder {
	*** defaultOptions;
	*** defaultOptions();
}

-keep class sun.nio.ch.DatagramDispatcher {
	*** read0(java.io.FileDescriptor,long,int);
	*** readv0(java.io.FileDescriptor,long,int);
	*** write0(java.io.FileDescriptor,long,int);
	*** writev0(java.io.FileDescriptor,long,int);
}

-keep class sun.nio.ch.DatagramSocketAdaptor {
	*** dc;
	*** dummyDatagramSocket;
	*** timeout;
	*** connectInternal(java.net.SocketAddress);
	*** create(sun.nio.ch.DatagramChannelImpl);
	*** getBooleanOption(java.net.SocketOption);
	*** getIntOption(java.net.SocketOption);
	*** isClosed();
	*** isConnected();
	*** receive(java.nio.ByteBuffer);
	*** setBooleanOption(java.net.SocketOption,boolean);
	*** setIntOption(java.net.SocketOption,int);
}

-keep class sun.nio.ch.DefaultSelectorProvider {
	*** create();
}

-keep class sun.nio.ch.DirectBuffer {
	*** address();
	*** cleaner();
}

-keep class sun.nio.ch.ExtendedSocketOption {
	*** SO_OOBINLINE;
}

-keep class sun.nio.ch.ExtendedSocketOption$1 {
	*** name();
}

-keep class sun.nio.ch.FileChannelImpl {
	*** $assertionsDisabled;
	*** allocationGranularity;
	*** append;
	*** fd;
	*** fileLockTable;
	*** fileSupported;
	*** isSharedFileLockTable;
	*** nd;
	*** parent;
	*** path;
	*** pipeSupported;
	*** positionLock;
	*** propertyChecked;
	*** readable;
	*** threads;
	*** transferSupported;
	*** writable;
	*** access$000(long,long);
	*** ensureOpen();
	*** fileLockTable();
	*** getMappedBufferPool();
	*** initIDs();
	*** isSharedFileLockTable();
	*** map(java.nio.channels.FileChannel$MapMode,long,long);
	*** map0(int,long,long);
	*** position();
	*** position(long);
	*** position0(java.io.FileDescriptor,long);
	*** read(java.nio.ByteBuffer,long);
	*** readInternal(java.nio.ByteBuffer,long);
	*** size();
	*** transferFromArbitraryChannel(java.nio.channels.ReadableByteChannel,long,long);
	*** transferFromFileChannel(sun.nio.ch.FileChannelImpl,long,long);
	*** transferTo0(int,long,long,int);
	*** transferToArbitraryChannel(long,int,java.nio.channels.WritableByteChannel);
	*** transferToDirectly(long,int,java.nio.channels.WritableByteChannel);
	*** transferToTrustedChannel(long,long,java.nio.channels.WritableByteChannel);
	*** truncate(long);
	*** unmap(java.nio.MappedByteBuffer);
	*** unmap0(long,long);
	*** write(java.nio.ByteBuffer,long);
	*** writeInternal(java.nio.ByteBuffer,long);
}

-keep class sun.nio.ch.FileChannelImpl$Unmapper {
	*** $assertionsDisabled;
	*** address;
	*** cap;
	*** count;
	*** fd;
	*** nd;
	*** size;
	*** totalCapacity;
	*** totalSize;
	sun.nio.ch.FileChannelImpl$Unmapper(long,long,int,java.io.FileDescriptor);
}

-keep class sun.nio.ch.FileDispatcher {
	sun.nio.ch.FileDispatcher();
	*** duplicateForMapping(java.io.FileDescriptor);
	*** force(java.io.FileDescriptor,boolean);
	*** lock(java.io.FileDescriptor,boolean,long,long,boolean);
	*** release(java.io.FileDescriptor,long,long);
	*** size(java.io.FileDescriptor);
	*** truncate(java.io.FileDescriptor,long);
}

-keep class sun.nio.ch.FileDispatcherImpl {
	*** close0(java.io.FileDescriptor);
	*** closeIntFD(int);
	*** force0(java.io.FileDescriptor,boolean);
	*** init();
	*** lock0(java.io.FileDescriptor,boolean,long,long,boolean);
	*** preClose0(java.io.FileDescriptor);
	*** pread0(java.io.FileDescriptor,long,int,long);
	*** pwrite0(java.io.FileDescriptor,long,int,long);
	*** read0(java.io.FileDescriptor,long,int);
	*** readv0(java.io.FileDescriptor,long,int);
	*** release0(java.io.FileDescriptor,long,long);
	*** size0(java.io.FileDescriptor);
	*** truncate0(java.io.FileDescriptor,long);
	*** write0(java.io.FileDescriptor,long,int);
	*** writev0(java.io.FileDescriptor,long,int);
}

-keep class sun.nio.ch.FileLockImpl {
	*** invalidate();
}

-keep class sun.nio.ch.FileLockTable {
	*** add(java.nio.channels.FileLock);
	*** newSharedFileLockTable(java.nio.channels.Channel,java.io.FileDescriptor);
	*** remove(java.nio.channels.FileLock);
	*** removeAll();
	*** replace(java.nio.channels.FileLock,java.nio.channels.FileLock);
}

-keep class sun.nio.ch.IOStatus {
	*** check(int);
	*** check(long);
	*** checkAll(long);
	*** normalize(int);
	*** normalize(long);
}

-keep class sun.nio.ch.IOUtil {
	*** $assertionsDisabled;
	*** IOV_MAX;
	*** configureBlocking(java.io.FileDescriptor,boolean);
	*** drain(int);
	*** fdVal(java.io.FileDescriptor);
	*** initIDs();
	*** iovMax();
	*** makePipe(boolean);
	*** newFD(int);
	*** read(java.io.FileDescriptor,java.nio.ByteBuffer,long,sun.nio.ch.NativeDispatcher);
	*** read(java.io.FileDescriptor,java.nio.ByteBuffer[],int,int,sun.nio.ch.NativeDispatcher);
	*** readIntoNativeBuffer(java.io.FileDescriptor,java.nio.ByteBuffer,long,sun.nio.ch.NativeDispatcher);
	*** setfdVal(java.io.FileDescriptor,int);
	*** write(java.io.FileDescriptor,java.nio.ByteBuffer,long,sun.nio.ch.NativeDispatcher);
	*** write(java.io.FileDescriptor,java.nio.ByteBuffer[],int,int,sun.nio.ch.NativeDispatcher);
	*** writeFromNativeBuffer(java.io.FileDescriptor,java.nio.ByteBuffer,long,sun.nio.ch.NativeDispatcher);
}

-keep class sun.nio.ch.IOVecWrapper {
	*** LEN_OFFSET;
	*** SIZE_IOVEC;
	*** address;
	*** addressSize;
	*** buf;
	*** cached;
	*** position;
	*** remaining;
	*** shadow;
	*** size;
	*** vecArray;
	*** clearRefs(int);
	*** get(int);
	*** getBuffer(int);
	*** getPosition(int);
	*** getRemaining(int);
	*** getShadow(int);
	*** putBase(int,long);
	*** putLen(int,long);
	*** setBuffer(int,java.nio.ByteBuffer,int,int);
	*** setShadow(int,java.nio.ByteBuffer);
}

-keep class sun.nio.ch.IOVecWrapper$Deallocator {
	*** obj;
}

-keep class sun.nio.ch.Interruptible {
	*** interrupt(java.lang.Thread);
}

-keep class sun.nio.ch.KQueueArrayWrapper {
	*** $assertionsDisabled;
	*** EVFILT_READ;
	*** EVFILT_WRITE;
	*** FD_OFFSET;
	*** FILTER_OFFSET;
	*** SIZEOF_KEVENT;
	*** incomingInterruptFD;
	*** is64bit;
	*** keventArray;
	*** keventArrayAddress;
	*** kq;
	*** outgoingInterruptFD;
	*** updateList;
	*** close();
	*** getDescriptor(int);
	*** getReventOps(int);
	*** init();
	*** initInterrupt(int,int);
	*** initStructSizes();
	*** interrupt();
	*** interrupt(int);
	*** kevent0(int,long,int,long);
	*** poll(long);
	*** register0(int,int,int,int);
	*** release(sun.nio.ch.SelChImpl);
	*** setInterest(sun.nio.ch.SelChImpl,int);
	*** updateRegistrations();
}

-keep class sun.nio.ch.KQueueArrayWrapper$Update {
	*** channel;
	*** events;
}

-keep class sun.nio.ch.KQueueSelectorImpl {
	*** closed;
	*** fd0;
	*** fd1;
	*** fdMap;
	*** interruptLock;
	*** interruptTriggered;
	*** kqueueWrapper;
	*** totalChannels;
	*** updateCount;
	*** updateSelectedKeys(int);
}

-keep class sun.nio.ch.KQueueSelectorImpl$MapEntry {
	*** ski;
	*** updateCount;
}

-keep class sun.nio.ch.MembershipKeyImpl {
	*** channel();
	*** group();
	*** invalidate();
	*** isValid();
	*** sourceAddress();
}

-keep class sun.nio.ch.MembershipKeyImpl$Type4 {
	*** groupAddress();
	*** interfaceAddress();
	*** source();
}

-keep class sun.nio.ch.MembershipKeyImpl$Type6 {
	*** groupAddress();
	*** index();
	*** source();
}

-keep class sun.nio.ch.MembershipRegistry {
	*** add(sun.nio.ch.MembershipKeyImpl);
	*** checkMembership(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress);
	*** invalidateAll();
	*** remove(sun.nio.ch.MembershipKeyImpl);
}

-keep class sun.nio.ch.NativeDispatcher {
	sun.nio.ch.NativeDispatcher();
	*** close(java.io.FileDescriptor);
	*** needsPositionLock();
	*** preClose(java.io.FileDescriptor);
	*** pread(java.io.FileDescriptor,long,int,long);
	*** pwrite(java.io.FileDescriptor,long,int,long);
	*** read(java.io.FileDescriptor,long,int);
	*** readv(java.io.FileDescriptor,long,int);
	*** write(java.io.FileDescriptor,long,int);
	*** writev(java.io.FileDescriptor,long,int);
}

-keep class sun.nio.ch.NativeObject {
	*** $assertionsDisabled;
	*** address;
	*** allocationAddress;
	*** byteOrder;
	*** pageSize;
	*** unsafe;
	sun.nio.ch.NativeObject(int,boolean);
	*** address();
	*** addressSize();
	*** getInt(int);
	*** getLong(int);
	*** getShort(int);
	*** pageSize();
	*** putInt(int,int);
	*** putLong(int,long);
}

-keep class sun.nio.ch.NativeThread {
	*** current();
	*** init();
	*** signal(long);
}

-keep class sun.nio.ch.NativeThreadSet {
	*** $assertionsDisabled;
	*** elts;
	*** used;
	*** waitingToEmpty;
	*** add();
	*** remove(int);
	*** signalAndWait();
}

-keep class sun.nio.ch.Net {
	*** UNSPEC;
	*** checkedIPv6;
	*** exclusiveBind;
	*** isIPv6Available;
	*** propRevealLocalAddress;
	*** revealLocalAddress;
	*** anyInet4Address(java.net.NetworkInterface);
	*** asInetSocketAddress(java.net.SocketAddress);
	*** bind(java.io.FileDescriptor,java.net.InetAddress,int);
	*** bind(java.net.ProtocolFamily,java.io.FileDescriptor,java.net.InetAddress,int);
	*** bind0(java.io.FileDescriptor,boolean,boolean,java.net.InetAddress,int);
	*** block4(java.io.FileDescriptor,int,int,int);
	*** block6(java.io.FileDescriptor,byte[],int,byte[]);
	*** blockOrUnblock4(boolean,java.io.FileDescriptor,int,int,int);
	*** blockOrUnblock6(boolean,java.io.FileDescriptor,byte[],int,byte[]);
	*** canIPv6SocketJoinIPv4Group();
	*** canIPv6SocketJoinIPv4Group0();
	*** canJoin6WithIPv4Group();
	*** canJoin6WithIPv4Group0();
	*** checkAddress(java.net.SocketAddress);
	*** connect(java.io.FileDescriptor,java.net.InetAddress,int);
	*** connect(java.net.ProtocolFamily,java.io.FileDescriptor,java.net.InetAddress,int);
	*** connect0(boolean,java.io.FileDescriptor,java.net.InetAddress,int);
	*** drop4(java.io.FileDescriptor,int,int,int);
	*** drop6(java.io.FileDescriptor,byte[],int,byte[]);
	*** getIntOption0(java.io.FileDescriptor,boolean,int,int);
	*** getInterface4(java.io.FileDescriptor);
	*** getInterface6(java.io.FileDescriptor);
	*** getLoopbackAddress(int);
	*** getRevealLocalAddress();
	*** getRevealedLocalAddress(java.net.InetSocketAddress);
	*** getRevealedLocalAddressAsString(java.net.InetSocketAddress);
	*** getSocketOption(java.io.FileDescriptor,java.net.ProtocolFamily,java.net.SocketOption);
	*** inet4AsInt(java.net.InetAddress);
	*** inet4FromInt(int);
	*** inet6AsByteArray(java.net.InetAddress);
	*** initIDs();
	*** isExclusiveBindAvailable();
	*** isIPv6Available();
	*** isIPv6Available0();
	*** join4(java.io.FileDescriptor,int,int,int);
	*** join6(java.io.FileDescriptor,byte[],int,byte[]);
	*** joinOrDrop4(boolean,java.io.FileDescriptor,int,int,int);
	*** joinOrDrop6(boolean,java.io.FileDescriptor,byte[],int,byte[]);
	*** listen(java.io.FileDescriptor,int);
	*** localAddress(java.io.FileDescriptor);
	*** localInetAddress(java.io.FileDescriptor);
	*** localPort(java.io.FileDescriptor);
	*** remoteInetAddress(java.io.FileDescriptor);
	*** remotePort(java.io.FileDescriptor);
	*** serverSocket(boolean);
	*** setIntOption0(java.io.FileDescriptor,boolean,int,int,int);
	*** setInterface4(java.io.FileDescriptor,int);
	*** setInterface6(java.io.FileDescriptor,int);
	*** setSocketOption(java.io.FileDescriptor,java.net.ProtocolFamily,java.net.SocketOption,java.lang.Object);
	*** shutdown(java.io.FileDescriptor,int);
	*** socket(boolean);
	*** socket(java.net.ProtocolFamily,boolean);
	*** socket0(boolean,boolean,boolean);
	*** translateException(java.lang.Exception);
	*** translateException(java.lang.Exception,boolean);
	*** translateToSocketException(java.lang.Exception);
	*** unblock4(java.io.FileDescriptor,int,int,int);
	*** unblock6(java.io.FileDescriptor,byte[],int,byte[]);
	*** useExclusiveBind();
}

-keep class sun.nio.ch.OptionKey {
	*** level;
	*** name;
	*** level();
	*** name();
}

-keep class sun.nio.ch.SelChImpl {
	*** getFD();
	*** getFDVal();
	*** kill();
	*** translateAndSetInterestOps(int,sun.nio.ch.SelectionKeyImpl);
	*** translateAndSetReadyOps(int,sun.nio.ch.SelectionKeyImpl);
	*** translateAndUpdateReadyOps(int,sun.nio.ch.SelectionKeyImpl);
}

-keep class sun.nio.ch.SelectionKeyImpl {
	*** channel;
	*** index;
	*** interestOps;
	*** readyOps;
	*** selector;
	*** channel();
	*** ensureValid();
	*** interestOps(int);
	*** nioInterestOps();
	*** nioInterestOps(int);
	*** nioReadyOps();
	*** nioReadyOps(int);
}

-keep class sun.nio.ch.SelectorImpl {
	*** keys;
	*** publicKeys;
	*** publicSelectedKeys;
	*** selectedKeys;
	sun.nio.ch.SelectorImpl(java.nio.channels.spi.SelectorProvider);
	*** doSelect(long);
	*** implClose();
	*** implDereg(sun.nio.ch.SelectionKeyImpl);
	*** implRegister(sun.nio.ch.SelectionKeyImpl);
	*** lockAndDoSelect(long);
	*** processDeregisterQueue();
	*** putEventOps(sun.nio.ch.SelectionKeyImpl,int);
	*** select(long);
	*** wakeup();
}

-keep class sun.nio.ch.SelectorProviderImpl {
	sun.nio.ch.SelectorProviderImpl();
}

-keep class sun.nio.ch.ServerSocketAdaptor {
	*** $assertionsDisabled;
	*** ssc;
	*** timeout;
	*** bind(java.net.SocketAddress,int);
	*** create(sun.nio.ch.ServerSocketChannelImpl);
	*** getInetAddress();
	*** getLocalPort();
	*** isBound();
}

-keep class sun.nio.ch.ServerSocketChannelImpl {
	*** $assertionsDisabled;
	*** fd;
	*** fdVal;
	*** isReuseAddress;
	*** localAddress;
	*** lock;
	*** nd;
	*** socket;
	*** state;
	*** stateLock;
	*** thread;
	*** accept();
	*** accept0(java.io.FileDescriptor,java.io.FileDescriptor,java.net.InetSocketAddress[]);
	*** bind(java.net.SocketAddress,int);
	*** getOption(java.net.SocketOption);
	*** initIDs();
	*** isBound();
	*** kill();
	*** localAddress();
	*** setOption(java.net.SocketOption,java.lang.Object);
	*** supportedOptions();
	*** translateReadyOps(int,int,sun.nio.ch.SelectionKeyImpl);
}

-keep class sun.nio.ch.ServerSocketChannelImpl$DefaultOptionsHolder {
	*** defaultOptions;
	*** defaultOptions();
}

-keep class sun.nio.ch.SocketAdaptor {
	*** $assertionsDisabled;
	*** sc;
	*** socketInputStream;
	*** timeout;
	*** connect(java.net.SocketAddress,int);
	*** create(sun.nio.ch.SocketChannelImpl);
	*** getBooleanOption(java.net.SocketOption);
	*** getInetAddress();
	*** getIntOption(java.net.SocketOption);
	*** getLocalPort();
	*** getPort();
	*** setBooleanOption(java.net.SocketOption,boolean);
	*** setIntOption(java.net.SocketOption,int);
}

-keep class sun.nio.ch.SocketChannelImpl {
	*** $assertionsDisabled;
	*** fd;
	*** fdVal;
	*** isInputOpen;
	*** isOutputOpen;
	*** isReuseAddress;
	*** localAddress;
	*** nd;
	*** readLock;
	*** readerThread;
	*** readyToConnect;
	*** remoteAddress;
	*** socket;
	*** state;
	*** stateLock;
	*** writeLock;
	*** writerThread;
	*** bind(java.net.SocketAddress);
	*** checkConnect(java.io.FileDescriptor,boolean,boolean);
	*** connect(java.net.SocketAddress);
	*** ensureOpenAndUnconnected();
	*** ensureReadOpen();
	*** ensureWriteOpen();
	*** finishConnect();
	*** getOption(java.net.SocketOption);
	*** isConnected();
	*** isInputOpen();
	*** isOutputOpen();
	*** kill();
	*** localAddress();
	*** readerCleanup();
	*** remoteAddress();
	*** sendOutOfBandData(byte);
	*** sendOutOfBandData(java.io.FileDescriptor,byte);
	*** setOption(java.net.SocketOption,java.lang.Object);
	*** shutdownInput();
	*** shutdownOutput();
	*** supportedOptions();
	*** translateReadyOps(int,int,sun.nio.ch.SelectionKeyImpl);
	*** writerCleanup();
}

-keep class sun.nio.ch.SocketChannelImpl$DefaultOptionsHolder {
	*** defaultOptions;
	*** defaultOptions();
}

-keep class sun.nio.ch.SocketOptionRegistry {
	*** findOption(java.net.SocketOption,java.net.ProtocolFamily);
}

-keep class sun.nio.ch.SocketOptionRegistry$LazyInitialization {
	*** options;
	*** options();
}

-keep class sun.nio.ch.SocketOptionRegistry$RegistryKey {
	*** family;
	*** name;
}

-keep class sun.nio.ch.ThreadPool {
	*** wrap(java.util.concurrent.ExecutorService,int);
}

-keep class sun.nio.ch.Util {
	*** $assertionsDisabled;
	*** TEMP_BUF_POOL_SIZE;
	*** bufferCache;
	*** bugLevel;
	*** directByteBufferConstructor;
	*** directByteBufferRConstructor;
	*** loaded;
	*** localSelector;
	*** localSelectorWrapper;
	*** pageSize;
	*** unsafe;
	*** access$000();
	*** access$402(java.lang.reflect.Constructor);
	*** atBugLevel(java.lang.String);
	*** erase(java.nio.ByteBuffer);
	*** free(java.nio.ByteBuffer);
	*** getTemporaryDirectBuffer(int);
	*** getTemporarySelector(java.nio.channels.SelectableChannel);
	*** initDBBConstructor();
	*** initDBBRConstructor();
	*** load();
	*** newMappedByteBuffer(int,long,java.io.FileDescriptor,java.lang.Runnable);
	*** newMappedByteBufferR(int,long,java.io.FileDescriptor,java.lang.Runnable);
	*** offerFirstTemporaryDirectBuffer(java.nio.ByteBuffer);
	*** offerLastTemporaryDirectBuffer(java.nio.ByteBuffer);
	*** releaseTemporaryDirectBuffer(java.nio.ByteBuffer);
	*** releaseTemporarySelector(java.nio.channels.Selector);
	*** ungrowableSet(java.util.Set);
	*** unsafe();
}

-keep class sun.nio.ch.Util$1 {
	*** initialValue();
}

-keep class sun.nio.ch.Util$2 {
	*** val$s;
}

-keep class sun.nio.ch.Util$4 {
	*** run();
}

-keep class sun.nio.ch.Util$BufferCache {
	*** $assertionsDisabled;
	*** buffers;
	*** count;
	*** start;
	*** get(int);
	*** isEmpty();
	*** next(int);
	*** offerFirst(java.nio.ByteBuffer);
	*** offerLast(java.nio.ByteBuffer);
	*** removeFirst();
}

-keep class sun.nio.ch.Util$SelectorWrapper {
	*** get();
}

-keep class sun.nio.cs.ArrayDecoder {
	*;
}

-keep class sun.nio.cs.ArrayEncoder {
	*;
}

-keep class sun.nio.cs.FastCharsetProvider {
	*;
}

-keep class sun.nio.cs.HistoricallyNamedCharset {
	*;
}

-keep class sun.nio.cs.ISO_8859_1$Decoder {
	*** $assertionsDisabled;
	sun.nio.cs.ISO_8859_1$Decoder(java.nio.charset.Charset);
	*** decodeArrayLoop(java.nio.ByteBuffer,java.nio.CharBuffer);
	*** decodeBufferLoop(java.nio.ByteBuffer,java.nio.CharBuffer);
}

-keep class sun.nio.cs.ISO_8859_1$Encoder {
	*** $assertionsDisabled;
	*** repl;
	*** sgp;
	sun.nio.cs.ISO_8859_1$Encoder(java.nio.charset.Charset);
	*** encodeArrayLoop(java.nio.CharBuffer,java.nio.ByteBuffer);
	*** encodeBufferLoop(java.nio.CharBuffer,java.nio.ByteBuffer);
}

-keep class sun.nio.cs.StandardCharsets {
	*;
}

-keep class sun.nio.cs.StandardCharsets$Aliases {
	*;
}

-keep class sun.nio.cs.StandardCharsets$Cache {
	*;
}

-keep class sun.nio.cs.StandardCharsets$Classes {
	*;
}

-keep class sun.nio.cs.StreamDecoder {
	*;
}

-keep class sun.nio.cs.StreamEncoder {
	*;
}

-keep class sun.nio.cs.Surrogate {
	*** $assertionsDisabled;
}

-keep class sun.nio.cs.Surrogate$Parser {
	*** $assertionsDisabled;
	*** character;
	*** error;
	*** isPair;
	*** error();
	*** parse(char,char[],int,int);
	*** parse(char,java.nio.CharBuffer);
	*** unmappableResult();
}

-keep class sun.nio.cs.ThreadLocalCoders {
	*** decoderCache;
	*** encoderCache;
	*** decoderFor(java.lang.Object);
	*** encoderFor(java.lang.Object);
}

-keep class sun.nio.cs.ThreadLocalCoders$1 {
	*** $assertionsDisabled;
}

-keep class sun.nio.cs.ThreadLocalCoders$2 {
	*** $assertionsDisabled;
}

-keep class sun.nio.cs.ThreadLocalCoders$Cache {
	*** cache;
	*** size;
	sun.nio.cs.ThreadLocalCoders$Cache(int);
	*** create(java.lang.Object);
	*** forName(java.lang.Object);
	*** hasName(java.lang.Object,java.lang.Object);
	*** moveToFront(java.lang.Object[],int);
}

-keep class sun.nio.cs.US_ASCII$Decoder {
	*** $assertionsDisabled;
	*** repl;
	sun.nio.cs.US_ASCII$Decoder(java.nio.charset.Charset);
	*** decodeArrayLoop(java.nio.ByteBuffer,java.nio.CharBuffer);
	*** decodeBufferLoop(java.nio.ByteBuffer,java.nio.CharBuffer);
}

-keep class sun.nio.cs.US_ASCII$Encoder {
	*** $assertionsDisabled;
	*** repl;
	*** sgp;
	sun.nio.cs.US_ASCII$Encoder(java.nio.charset.Charset);
	*** encodeArrayLoop(java.nio.CharBuffer,java.nio.ByteBuffer);
	*** encodeBufferLoop(java.nio.CharBuffer,java.nio.ByteBuffer);
}

-keep class sun.nio.cs.UTF_8 {
	*;
}

-keep class sun.nio.cs.UTF_8$Decoder {
	*;
}

-keep class sun.nio.cs.UTF_8$Encoder {
	*;
}

-keep class sun.nio.cs.Unicode {
	*;
}

-keep class sun.nio.fs.AbstractFileSystemProvider {
	sun.nio.fs.AbstractFileSystemProvider();
	*** getFileAttributeView(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption[]);
	*** implDelete(java.nio.file.Path,boolean);
	*** split(java.lang.String);
}

-keep class sun.nio.fs.AbstractPath {
	sun.nio.fs.AbstractPath();
	*** resolveSibling(java.nio.file.Path);
}

-keep class sun.nio.fs.AbstractWatchService {
	*** register(java.nio.file.Path,java.nio.file.WatchEvent$Kind[],java.nio.file.WatchEvent$Modifier[]);
}

-keep class sun.nio.fs.BsdFileSystem {
	sun.nio.fs.BsdFileSystem(sun.nio.fs.UnixFileSystemProvider,java.lang.String);
}

-keep class sun.nio.fs.BsdFileSystem$SupportedFileFileAttributeViewsHolder {
	*** supportedFileAttributeViews;
}

-keep class sun.nio.fs.BsdFileSystemProvider {
	sun.nio.fs.BsdFileSystemProvider();
	*** getFileStore(sun.nio.fs.UnixPath);
	*** newFileSystem(java.lang.String);
}

-keep class sun.nio.fs.BsdNativeDispatcher {
	*** endfsstat(long);
	*** fsstatEntry(long,sun.nio.fs.UnixMountEntry);
	*** getfsstat();
}

-keep class sun.nio.fs.DefaultFileSystemProvider {
	*** create();
	*** createProvider(java.lang.String);
}

-keep class sun.nio.fs.DefaultFileSystemProvider$1 {
	*** val$cn;
	*** run();
}

-keep class sun.nio.fs.DynamicFileAttributeView {
	*** readAttributes(java.lang.String[]);
	*** setAttribute(java.lang.String,java.lang.Object);
}

-keep class sun.nio.fs.Globs {
	*** toUnixRegexPattern(java.lang.String);
}

-keep class sun.nio.fs.MacOSXFileSystemProvider {
	*** newFileSystem(java.lang.String);
}

-keep class sun.nio.fs.MacOSXNativeDispatcher {
	*** normalizepath(char[],int);
}

-keep class sun.nio.fs.NativeBuffer {
	*** address;
	*** cleaner;
	*** owner;
	*** size;
	*** unsafe;
	*** access$000();
	*** address();
	*** cleaner();
	*** owner();
	*** release();
	*** setOwner(java.lang.Object);
	*** size();
}

-keep class sun.nio.fs.NativeBuffer$Deallocator {
	*** address;
}

-keep class sun.nio.fs.NativeBuffers {
	*** $assertionsDisabled;
	*** threadLocal;
	*** unsafe;
	*** allocNativeBuffer(int);
	*** asNativeBuffer(byte[]);
	*** copyCStringToNativeBuffer(byte[],sun.nio.fs.NativeBuffer);
	*** getNativeBuffer(int);
	*** getNativeBufferFromCache(int);
	*** releaseNativeBuffer(sun.nio.fs.NativeBuffer);
}

-keep class sun.nio.fs.UnixChannelFactory {
	*** newAsynchronousFileChannel(sun.nio.fs.UnixPath,java.util.Set,int,sun.nio.ch.ThreadPool);
	*** newFileChannel(sun.nio.fs.UnixPath,java.util.Set,int);
}

-keep class sun.nio.fs.UnixCopyFile {
	*** copy(sun.nio.fs.UnixPath,sun.nio.fs.UnixPath,java.nio.file.CopyOption[]);
	*** move(sun.nio.fs.UnixPath,sun.nio.fs.UnixPath,java.nio.file.CopyOption[]);
}

-keep class sun.nio.fs.UnixException {
	*** errno();
	*** getMessage();
	*** rethrowAsIOException(sun.nio.fs.UnixPath);
	*** rethrowAsIOException(sun.nio.fs.UnixPath,sun.nio.fs.UnixPath);
	*** setError(int);
}

-keep class sun.nio.fs.UnixFileAttributeViews {
	*** createBasicView(sun.nio.fs.UnixPath,boolean);
	*** createOwnerView(sun.nio.fs.UnixPath,boolean);
	*** createPosixView(sun.nio.fs.UnixPath,boolean);
	*** createUnixView(sun.nio.fs.UnixPath,boolean);
}

-keep class sun.nio.fs.UnixFileAttributes {
	*** group;
	*** key;
	*** owner;
	*** st_atime;
	*** st_ctime;
	*** st_dev;
	*** st_gid;
	*** st_ino;
	*** st_mode;
	*** st_mtime;
	*** st_nlink;
	*** st_rdev;
	*** st_size;
	*** st_uid;
	*** fileKey();
	*** get(sun.nio.fs.UnixPath,boolean);
	*** isDirectory();
	*** isSameFile(sun.nio.fs.UnixFileAttributes);
	*** isSymbolicLink();
	*** lastModifiedTime();
}

-keep class sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes {
	*** unwrap();
	*** wrap(sun.nio.fs.UnixFileAttributes);
}

-keep class sun.nio.fs.UnixFileModeAttribute {
	*** toUnixMode(int,java.nio.file.attribute.FileAttribute[]);
}

-keep class sun.nio.fs.UnixFileStoreAttributes {
	*** f_bavail;
	*** f_bfree;
	*** f_blocks;
	*** f_frsize;
}

-keep class sun.nio.fs.UnixFileSystem {
	*** defaultDirectory;
	*** needToResolveAgainstDefaultDirectory;
	*** provider;
	*** rootDirectory;
	sun.nio.fs.UnixFileSystem(sun.nio.fs.UnixFileSystemProvider,java.lang.String);
	*** compilePathMatchPattern(java.lang.String);
	*** defaultDirectory();
	*** isSolaris();
	*** needToResolveAgainstDefaultDirectory();
	*** normalizeJavaPath(java.lang.String);
	*** normalizeNativePath(char[]);
	*** rootDirectory();
}

-keep class sun.nio.fs.UnixFileSystem$LookupService {
	*** instance;
}

-keep class sun.nio.fs.UnixFileSystemProvider {
	*** theFileSystem;
	sun.nio.fs.UnixFileSystemProvider();
	*** checkPath(java.nio.file.Path);
	*** checkUri(java.net.URI);
	*** getFileAttributeView(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption[]);
	*** getFileStore(sun.nio.fs.UnixPath);
	*** getScheme();
	*** newFileSystem(java.lang.String);
}

-keep class sun.nio.fs.UnixFileSystemProvider$2 {
	*** $SwitchMap$java$nio$file$AccessMode;
}

-keep class sun.nio.fs.UnixMountEntry {
	*** dev;
	*** dir;
	*** fstype;
	*** fstypeAsString;
	*** name;
	*** optionsAsString;
	*** opts;
	*** hasOption(java.lang.String);
}

-keep class sun.nio.fs.UnixNativeDispatcher {
	*** hasAtSysCalls;
	*** access(sun.nio.fs.UnixPath,int);
	*** access0(long,int);
	*** chmod0(long,int);
	*** chown0(long,int,int);
	*** close(int);
	*** copyToNativeBuffer(sun.nio.fs.UnixPath);
	*** dup(int);
	*** fdopendir(int);
	*** fopen0(long,long);
	*** fstat(int,sun.nio.fs.UnixFileAttributes);
	*** fstatat(int,byte[],int,sun.nio.fs.UnixFileAttributes);
	*** fstatat0(int,long,int,sun.nio.fs.UnixFileAttributes);
	*** getcwd();
	*** getgrnam0(long);
	*** getpwnam0(long);
	*** init();
	*** lchown0(long,int,int);
	*** link(sun.nio.fs.UnixPath,sun.nio.fs.UnixPath);
	*** link0(long,long);
	*** lstat(sun.nio.fs.UnixPath,sun.nio.fs.UnixFileAttributes);
	*** lstat0(long,sun.nio.fs.UnixFileAttributes);
	*** mkdir(sun.nio.fs.UnixPath,int);
	*** mkdir0(long,int);
	*** mknod0(long,int,long);
	*** open(sun.nio.fs.UnixPath,int,int);
	*** open0(long,int,int);
	*** openat0(int,long,int,int);
	*** opendir(sun.nio.fs.UnixPath);
	*** opendir0(long);
	*** pathconf0(long,int);
	*** readlink(sun.nio.fs.UnixPath);
	*** readlink0(long);
	*** realpath(sun.nio.fs.UnixPath);
	*** realpath0(long);
	*** rename0(long,long);
	*** renameat0(int,long,int,long);
	*** rmdir(sun.nio.fs.UnixPath);
	*** rmdir0(long);
	*** stat(sun.nio.fs.UnixPath,sun.nio.fs.UnixFileAttributes);
	*** stat0(long,sun.nio.fs.UnixFileAttributes);
	*** statvfs(sun.nio.fs.UnixPath,sun.nio.fs.UnixFileStoreAttributes);
	*** statvfs0(long,sun.nio.fs.UnixFileStoreAttributes);
	*** supportsAtSysCalls();
	*** supportsNoFollowLinks();
	*** symlink(byte[],sun.nio.fs.UnixPath);
	*** symlink0(long,long);
	*** unlink(sun.nio.fs.UnixPath);
	*** unlink0(long);
	*** unlinkat0(int,long,int);
	*** utimes0(long,long,long);
}

-keep class sun.nio.fs.UnixNativeDispatcher$1 {
	*** run();
}

-keep class sun.nio.fs.UnixPath {
	*** $assertionsDisabled;
	*** encoder;
	*** fs;
	*** hash;
	*** offsets;
	*** path;
	*** stringValue;
	sun.nio.fs.UnixPath(sun.nio.fs.UnixFileSystem,byte[]);
	*** asByteArray();
	*** checkDelete();
	*** checkNotNul(java.lang.String,char);
	*** checkRead();
	*** checkWrite();
	*** compareTo(java.nio.file.Path);
	*** emptyPath();
	*** encode(sun.nio.fs.UnixFileSystem,java.lang.String);
	*** equals(java.lang.Object);
	*** getByteArrayForSysCalls();
	*** getFileName();
	*** getFileSystem();
	*** getName(int);
	*** getNameCount();
	*** getParent();
	*** getPathForExceptionMessage();
	*** getPathForPermissionCheck();
	*** getRoot();
	*** initOffsets();
	*** isAbsolute();
	*** isEmpty();
	*** normalize(java.lang.String,int,int);
	*** normalizeAndCheck(java.lang.String);
	*** relativize(java.nio.file.Path);
	*** resolve(byte[],byte[]);
	*** resolve(java.nio.file.Path);
	*** subpath(int,int);
	*** toAbsolutePath();
	*** toString();
	*** toUnixPath(java.nio.file.Path);
}

-keep class sun.nio.fs.UnixUriUtils {
	*** fromUri(sun.nio.fs.UnixFileSystem,java.net.URI);
	*** toUri(sun.nio.fs.UnixPath);
}

-keep class sun.nio.fs.UnixUserPrincipals {
	*** fromGid(int);
	*** fromUid(int);
}

-keep class sun.nio.fs.Util {
	*** followLinks(java.nio.file.LinkOption[]);
	*** split(java.lang.String,char);
}

-keep class sun.print.PrintJob2D {
	*** printDialog();
}

-keep class sun.print.ProxyGraphics2D {
	*** getDelegate();
}

-keep class sun.print.ProxyPrintGraphics {
	*** getGraphics();
}

-keep class sun.reflect.AccessorGenerator {
	*;
}

-keep class sun.reflect.BootstrapConstructorAccessorImpl {
	*;
}

-keep class sun.reflect.ByteVector {
	*;
}

-keep class sun.reflect.ByteVectorFactory {
	*;
}

-keep class sun.reflect.ByteVectorImpl {
	*;
}

-keep class sun.reflect.CallerSensitive {
	*;
}

-keep class sun.reflect.ClassDefiner {
	*;
}

-keep class sun.reflect.ClassDefiner$1 {
	*;
}

-keep class sun.reflect.ClassFileAssembler {
	*;
}

-keep class sun.reflect.ClassFileConstants {
	*;
}

-keep class sun.reflect.ConstantPool {
	*;
}

-keep class sun.reflect.ConstructorAccessor {
	*;
}

-keep class sun.reflect.ConstructorAccessorImpl {
	*;
}

-keep class sun.reflect.DelegatingClassLoader {
	*;
}

-keep class sun.reflect.DelegatingConstructorAccessorImpl {
	*;
}

-keep class sun.reflect.DelegatingMethodAccessorImpl {
	*;
}

-keep class sun.reflect.FieldAccessor {
	*;
}

-keep class sun.reflect.FieldAccessorImpl {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor1 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor10 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor11 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor12 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor13 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor14 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor15 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor16 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor17 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor18 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor19 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor2 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor20 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor21 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor22 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor23 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor24 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor25 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor26 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor27 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor28 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor29 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor3 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor30 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor31 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor32 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor33 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor34 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor35 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor36 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor37 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor38 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor39 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor4 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor40 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor41 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor42 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor43 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor44 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor45 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor46 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor47 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor48 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor49 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor5 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor50 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor51 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor52 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor53 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor54 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor55 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor56 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor57 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor58 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor59 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor6 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor60 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor61 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor62 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor63 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor64 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor7 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor8 {
	*;
}

-keep class sun.reflect.GeneratedConstructorAccessor9 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor1 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor10 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor100 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor101 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor102 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor103 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor104 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor105 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor106 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor107 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor108 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor109 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor11 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor110 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor111 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor112 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor113 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor114 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor115 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor116 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor117 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor118 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor119 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor12 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor120 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor121 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor122 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor123 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor124 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor125 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor126 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor127 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor128 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor129 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor13 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor130 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor131 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor132 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor133 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor134 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor135 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor136 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor137 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor138 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor139 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor14 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor140 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor141 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor142 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor143 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor144 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor145 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor146 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor147 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor148 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor149 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor15 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor150 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor151 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor152 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor153 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor154 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor155 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor156 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor157 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor158 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor159 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor16 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor160 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor161 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor162 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor163 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor164 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor165 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor166 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor167 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor168 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor169 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor17 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor170 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor171 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor172 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor173 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor174 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor175 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor176 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor177 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor178 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor179 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor18 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor180 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor181 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor182 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor183 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor184 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor185 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor186 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor187 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor188 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor189 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor19 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor190 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor191 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor192 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor193 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor194 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor195 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor196 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor197 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor198 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor199 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor2 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor20 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor200 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor201 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor202 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor203 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor21 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor22 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor23 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor24 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor25 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor26 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor27 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor28 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor29 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor3 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor30 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor31 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor32 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor33 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor34 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor35 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor36 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor37 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor38 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor39 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor4 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor40 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor41 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor42 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor43 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor44 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor45 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor46 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor47 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor48 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor49 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor5 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor50 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor51 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor52 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor53 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor54 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor55 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor56 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor57 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor58 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor59 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor6 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor60 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor61 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor62 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor63 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor64 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor65 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor66 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor67 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor68 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor69 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor7 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor70 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor71 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor72 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor73 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor74 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor75 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor76 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor77 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor78 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor79 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor8 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor80 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor81 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor82 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor83 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor84 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor85 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor86 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor87 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor88 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor89 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor9 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor90 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor91 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor92 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor93 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor94 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor95 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor96 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor97 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor98 {
	*;
}

-keep class sun.reflect.GeneratedMethodAccessor99 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor1 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor2 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor3 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor4 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor5 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor6 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor7 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor8 {
	*;
}

-keep class sun.reflect.GeneratedSerializationConstructorAccessor9 {
	*;
}

-keep class sun.reflect.Label {
	*;
}

-keep class sun.reflect.Label$PatchInfo {
	*;
}

-keep class sun.reflect.LangReflectAccess {
	*;
}

-keep class sun.reflect.MagicAccessorImpl {
	*;
}

-keep class sun.reflect.MethodAccessor {
	*;
}

-keep class sun.reflect.MethodAccessorGenerator {
	*;
}

-keep class sun.reflect.MethodAccessorGenerator$1 {
	*;
}

-keep class sun.reflect.MethodAccessorImpl {
	*;
}

-keep class sun.reflect.NativeConstructorAccessorImpl {
	*;
}

-keep class sun.reflect.NativeMethodAccessorImpl {
	*;
}

-keep class sun.reflect.Reflection {
	*** getCallerClass();
	*** getCallerClass(int);
}

-keep class sun.reflect.ReflectionFactory {
	*** getReflectionFactory();
	*** newConstructorForSerialization(java.lang.Class,java.lang.reflect.Constructor);
}

-keep class sun.reflect.ReflectionFactory$1 {
	*;
}

-keep class sun.reflect.ReflectionFactory$GetReflectionFactoryAction {
	*;
}

-keep class sun.reflect.SerializationConstructorAccessorImpl {
	*;
}

-keep class sun.reflect.UTF8 {
	*;
}

-keep class sun.reflect.UnsafeFieldAccessorFactory {
	*;
}

-keep class sun.reflect.UnsafeFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeIntegerFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeLongFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeObjectFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeQualifiedBooleanFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeQualifiedFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeQualifiedObjectFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeQualifiedStaticFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeQualifiedStaticIntegerFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeQualifiedStaticObjectFieldAccessorImpl {
	*;
}

-keep class sun.reflect.UnsafeStaticFieldAccessorImpl {
	*;
}

-keep class sun.reflect.annotation.AnnotationInvocationHandler {
	*;
}

-keep class sun.reflect.annotation.AnnotationParser {
	*;
}

-keep class sun.reflect.annotation.AnnotationType {
	*;
}

-keep class sun.reflect.annotation.AnnotationType$1 {
	*;
}

-keep class sun.reflect.annotation.AnnotationTypeMismatchExceptionProxy {
	*;
}

-keep class sun.reflect.annotation.ExceptionProxy {
	*;
}

-keep class sun.reflect.generics.factory.CoreReflectionFactory {
	*;
}

-keep class sun.reflect.generics.factory.GenericsFactory {
	*;
}

-keep class sun.reflect.generics.parser.SignatureParser {
	*;
}

-keep class sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl {
	*** make(java.lang.reflect.Type);
}

-keep class sun.reflect.generics.reflectiveObjects.LazyReflectiveObjectGenerator {
	*;
}

-keep class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl {
	*** make(java.lang.Class,java.lang.reflect.Type[],java.lang.reflect.Type);
}

-keep class sun.reflect.generics.reflectiveObjects.TypeVariableImpl {
	*;
}

-keep class sun.reflect.generics.reflectiveObjects.WildcardTypeImpl {
	*;
}

-keep class sun.reflect.generics.repository.AbstractRepository {
	*;
}

-keep class sun.reflect.generics.repository.ClassRepository {
	*;
}

-keep class sun.reflect.generics.repository.ConstructorRepository {
	*;
}

-keep class sun.reflect.generics.repository.FieldRepository {
	*;
}

-keep class sun.reflect.generics.repository.GenericDeclRepository {
	*;
}

-keep class sun.reflect.generics.repository.MethodRepository {
	*;
}

-keep class sun.reflect.generics.scope.AbstractScope {
	*;
}

-keep class sun.reflect.generics.scope.ClassScope {
	*;
}

-keep class sun.reflect.generics.scope.ConstructorScope {
	*;
}

-keep class sun.reflect.generics.scope.MethodScope {
	*;
}

-keep class sun.reflect.generics.scope.Scope {
	*;
}

-keep class sun.reflect.generics.tree.ArrayTypeSignature {
	*;
}

-keep class sun.reflect.generics.tree.BaseType {
	*;
}

-keep class sun.reflect.generics.tree.BooleanSignature {
	*;
}

-keep class sun.reflect.generics.tree.BottomSignature {
	*;
}

-keep class sun.reflect.generics.tree.ClassSignature {
	*;
}

-keep class sun.reflect.generics.tree.ClassTypeSignature {
	*;
}

-keep class sun.reflect.generics.tree.FieldTypeSignature {
	*;
}

-keep class sun.reflect.generics.tree.FormalTypeParameter {
	*;
}

-keep class sun.reflect.generics.tree.IntSignature {
	*;
}

-keep class sun.reflect.generics.tree.MethodTypeSignature {
	*;
}

-keep class sun.reflect.generics.tree.ReturnType {
	*;
}

-keep class sun.reflect.generics.tree.Signature {
	*;
}

-keep class sun.reflect.generics.tree.SimpleClassTypeSignature {
	*;
}

-keep class sun.reflect.generics.tree.Tree {
	*;
}

-keep class sun.reflect.generics.tree.TypeArgument {
	*;
}

-keep class sun.reflect.generics.tree.TypeSignature {
	*;
}

-keep class sun.reflect.generics.tree.TypeTree {
	*;
}

-keep class sun.reflect.generics.tree.TypeVariableSignature {
	*;
}

-keep class sun.reflect.generics.tree.VoidDescriptor {
	*;
}

-keep class sun.reflect.generics.tree.Wildcard {
	*;
}

-keep class sun.reflect.generics.visitor.Reifier {
	*;
}

-keep class sun.reflect.generics.visitor.TypeTreeVisitor {
	*;
}

-keep class sun.reflect.misc.MethodUtil {
	*** invoke(java.lang.reflect.Method,java.lang.Object,java.lang.Object[]);
}

-keep class sun.reflect.misc.MethodUtil$1 {
	*;
}

-keep class sun.reflect.misc.ReflectUtil {
	*** checkPackageAccess(java.lang.Class);
	*** checkPackageAccess(java.lang.String);
	*** checkProxyPackageAccess(java.lang.ClassLoader,java.lang.Class[]);
	*** ensureMemberAccess(java.lang.Class,java.lang.Class,java.lang.Object,int);
	*** isPackageAccessible(java.lang.Class);
}

-keep class sun.reflect.misc.Trampoline {
	*;
}

-keep class sun.security.action.GetBooleanAction {
	*** theProp;
	*** run();
}

-keep class sun.security.action.GetBooleanSecurityPropertyAction {
	*** theProp;
	*** run();
}

-keep class sun.security.action.GetIntegerAction {
	*** defaultSet;
	*** defaultVal;
	*** theProp;
	*** run();
}

-keep class sun.security.action.GetPropertyAction {
	*;
}

-keep class sun.security.action.LoadLibraryAction {
	*** theLib;
	*** run();
}

-keep class sun.security.ec.ECDHKeyAgreement {
	*** privateKey;
	*** publicValue;
	*** secretLen;
	*** deriveKey(byte[],byte[],byte[]);
	*** engineGenerateSecret();
	*** engineInit(java.security.Key,java.security.SecureRandom);
}

-keep class sun.security.ec.ECDSASignature {
	*** messageDigest;
	*** needsReset;
	*** privateKey;
	*** publicKey;
	*** random;
	sun.security.ec.ECDSASignature();
	sun.security.ec.ECDSASignature(java.lang.String);
	*** decodeSignature(byte[]);
	*** encodeSignature(byte[]);
	*** engineInitSign(java.security.PrivateKey,java.security.SecureRandom);
	*** getDigestValue();
	*** resetDigest();
	*** signDigest(byte[],byte[],byte[],byte[]);
	*** trimZeroes(byte[]);
	*** verifySignedDigest(byte[],byte[],byte[],byte[]);
}

-keep class sun.security.ec.ECDSASignature$Raw {
	*** offset;
	*** precomputedDigest;
}

-keep class sun.security.ec.ECKeyFactory {
	*** INSTANCE;
	*** ecInternalProvider;
	*** checkKey(java.security.interfaces.ECKey);
	*** engineTranslateKey(java.security.Key);
	*** implGeneratePrivate(java.security.spec.KeySpec);
	*** implGeneratePublic(java.security.spec.KeySpec);
	*** implTranslatePrivateKey(java.security.PrivateKey);
	*** implTranslatePublicKey(java.security.PublicKey);
	*** toECKey(java.security.Key);
}

-keep class sun.security.ec.ECKeyFactory$2 {
	*** val$p;
	*** run();
}

-keep class sun.security.ec.ECKeyPairGenerator {
	*** keySize;
	*** params;
	*** random;
	*** checkKeySize(int);
	*** generateECKeyPair(int,byte[],byte[]);
	*** getEncodedBytes(long);
	*** initialize(int,java.security.SecureRandom);
}

-keep class sun.security.ec.ECParameters {
	*** paramSpec;
	*** decodeParameters(byte[]);
	*** decodePoint(byte[],java.security.spec.EllipticCurve);
	*** encodeParameters(java.security.spec.ECParameterSpec);
	*** encodePoint(java.security.spec.ECPoint,java.security.spec.EllipticCurve);
	*** engineGetEncoded();
	*** engineInit(byte[]);
	*** getAlgorithmParameters(java.security.spec.ECParameterSpec);
	*** getCurveName(java.security.spec.ECParameterSpec);
	*** getNamedCurve(java.security.spec.ECParameterSpec);
	*** trimZeroes(byte[]);
}

-keep class sun.security.ec.ECPrivateKeyImpl {
	*** params;
	*** s;
}

-keep class sun.security.ec.ECPublicKeyImpl {
	*** params;
	*** w;
	*** getAlgorithm();
	*** getEncodedPublicValue();
}

-keep class sun.security.ec.NamedCurve {
	*** SPLIT_PATTERN;
	*** encoded;
	*** lengthMap;
	*** name;
	*** nameMap;
	*** oid;
	*** oidMap;
	*** add(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int);
	*** bi(java.lang.String);
	*** getECParameterSpec(int);
	*** getECParameterSpec(java.lang.String);
	*** getECParameterSpec(sun.security.util.ObjectIdentifier);
	*** getEncoded();
	*** getObjectIdentifier();
	*** knownECParameterSpecs();
}

-keep class sun.security.ec.SunEC {
	*** useFullImplementation;
}

-keep class sun.security.ec.SunEC$1 {
	*** run();
}

-keep class sun.security.ec.SunECEntries {
	*** putEntries(java.util.Map,boolean);
}

-keep class sun.security.internal.interfaces.TlsMasterSecret {
	*** getMajorVersion();
	*** getMinorVersion();
}

-keep class sun.security.internal.spec.TlsKeyMaterialParameterSpec {
	*** cipherAlgorithm;
	*** cipherKeyLength;
	*** clientRandom;
	*** expandedCipherKeyLength;
	*** ivLength;
	*** macKeyLength;
	*** majorVersion;
	*** masterSecret;
	*** minorVersion;
	*** prfBlockSize;
	*** prfHashAlg;
	*** prfHashLength;
	*** serverRandom;
	*** checkSign(int);
	*** getCipherAlgorithm();
	*** getCipherKeyLength();
	*** getClientRandom();
	*** getExpandedCipherKeyLength();
	*** getIvLength();
	*** getMacKeyLength();
	*** getMajorVersion();
	*** getMasterSecret();
	*** getMinorVersion();
	*** getPRFBlockSize();
	*** getPRFHashAlg();
	*** getPRFHashLength();
	*** getServerRandom();
}

-keep class sun.security.internal.spec.TlsKeyMaterialSpec {
	*** clientCipherKey;
	*** clientIv;
	*** clientMacKey;
	*** serverCipherKey;
	*** serverIv;
	*** serverMacKey;
	sun.security.internal.spec.TlsKeyMaterialSpec(javax.crypto.SecretKey,javax.crypto.SecretKey,javax.crypto.SecretKey,javax.crypto.spec.IvParameterSpec,javax.crypto.SecretKey,javax.crypto.spec.IvParameterSpec);
	*** getClientCipherKey();
	*** getClientIv();
	*** getClientMacKey();
	*** getServerCipherKey();
	*** getServerIv();
	*** getServerMacKey();
}

-keep class sun.security.internal.spec.TlsMasterSecretParameterSpec {
	*** clientRandom;
	*** majorVersion;
	*** minorVersion;
	*** premasterSecret;
	*** prfBlockSize;
	*** prfHashAlg;
	*** prfHashLength;
	*** serverRandom;
	*** checkVersion(int);
	*** getClientRandom();
	*** getMajorVersion();
	*** getMinorVersion();
	*** getPRFBlockSize();
	*** getPRFHashAlg();
	*** getPRFHashLength();
	*** getPremasterSecret();
	*** getServerRandom();
}

-keep class sun.security.internal.spec.TlsPrfParameterSpec {
	*** label;
	*** outputLength;
	*** prfBlockSize;
	*** prfHashAlg;
	*** prfHashLength;
	*** secret;
	*** seed;
	*** getLabel();
	*** getOutputLength();
	*** getPRFBlockSize();
	*** getPRFHashAlg();
	*** getPRFHashLength();
	*** getSecret();
	*** getSeed();
}

-keep class sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec {
	*** majorVersion;
	*** minorVersion;
	*** getMajorVersion();
	*** getMinorVersion();
}

-keep class sun.security.jca.GetInstance {
	*** checkSuperClass(java.security.Provider$Service,java.lang.Class,java.lang.Class);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.lang.Object);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.lang.Object,java.lang.String);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.lang.Object,java.security.Provider);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.lang.String);
	*** getInstance(java.lang.String,java.lang.Class,java.lang.String,java.security.Provider);
	*** getInstance(java.security.Provider$Service,java.lang.Class);
	*** getInstance(java.security.Provider$Service,java.lang.Class,java.lang.Object);
	*** getService(java.lang.String,java.lang.String,java.lang.String);
	*** getService(java.lang.String,java.lang.String,java.security.Provider);
	*** getServices(java.lang.String,java.lang.String);
	*** getServices(java.util.List);
}

-keep class sun.security.jca.GetInstance$Instance {
	*** impl;
	*** provider;
	sun.security.jca.GetInstance$Instance(java.security.Provider,java.lang.Object);
	*** toArray();
}

-keep class sun.security.jca.JCAUtil {
	*** LOCK;
	*** secureRandom;
	*** getSecureRandom();
	*** getTempArraySize(int);
}

-keep class sun.security.jca.ProviderConfig {
	*** CL_STRING;
	*** argument;
	*** className;
	*** debug;
	*** isLoading;
	*** provider;
	*** tries;
	sun.security.jca.ProviderConfig(java.lang.String,java.lang.String);
	*** access$000();
	*** access$100(sun.security.jca.ProviderConfig);
	*** access$200(sun.security.jca.ProviderConfig);
	*** access$300();
	*** access$400(sun.security.jca.ProviderConfig);
	*** access$500(sun.security.jca.ProviderConfig);
	*** checkSunPKCS11Solaris();
	*** disableLoad();
	*** doLoadProvider();
	*** equals(java.lang.Object);
	*** expand(java.lang.String);
	*** getProvider();
	*** hasArgument();
	*** isLoaded();
	*** shouldLoad();
}

-keep class sun.security.jca.ProviderConfig$2 {
	*** this$0;
	*** run();
}

-keep class sun.security.jca.ProviderList {
	*** EMPTY;
	*** EMPTY_PROVIDER;
	*** P0;
	*** PC0;
	*** allLoaded;
	*** configs;
	*** debug;
	*** userList;
	sun.security.jca.ProviderList();
	*** access$100(sun.security.jca.ProviderList);
	*** fromSecurityProperties();
	*** getIndex(java.lang.String);
	*** getJarList(java.lang.String[]);
	*** getProvider(int);
	*** getProvider(java.lang.String);
	*** getProviderConfig(java.lang.String);
	*** getService(java.lang.String,java.lang.String);
	*** getServices(java.lang.String,java.lang.String);
	*** getServices(java.lang.String,java.util.List);
	*** getServices(java.util.List);
	*** insertAt(sun.security.jca.ProviderList,java.security.Provider,int);
	*** loadAll();
	*** newList(java.security.Provider[]);
	*** providers();
	*** remove(sun.security.jca.ProviderList,java.lang.String);
	*** removeInvalid();
	*** size();
	*** toArray();
}

-keep class sun.security.jca.ProviderList$2 {
	*** run();
}

-keep class sun.security.jca.ProviderList$3 {
	*** this$0;
	*** get(int);
}

-keep class sun.security.jca.ProviderList$ServiceList {
	*** algorithm;
	*** firstService;
	*** ids;
	*** providerIndex;
	*** services;
	*** this$0;
	*** type;
	*** access$200(sun.security.jca.ProviderList$ServiceList,int);
	*** addService(java.security.Provider$Service);
	*** get(int);
	*** tryGet(int);
}

-keep class sun.security.jca.ProviderList$ServiceList$1 {
	*** index;
	*** this$1;
	*** next();
}

-keep class sun.security.jca.Providers {
	*** jarVerificationProviders;
	*** providerList;
	*** threadLists;
	*** threadListsUsed;
	*** beginThreadProviderList(sun.security.jca.ProviderList);
	*** changeThreadProviderList(sun.security.jca.ProviderList);
	*** endThreadProviderList(sun.security.jca.ProviderList);
	*** getFullProviderList();
	*** getProviderList();
	*** getSunProvider();
	*** getSystemProviderList();
	*** getThreadProviderList();
	*** setProviderList(sun.security.jca.ProviderList);
	*** setSystemProviderList(sun.security.jca.ProviderList);
	*** startJarVerification();
	*** stopJarVerification(java.lang.Object);
}

-keep class sun.security.jca.ServiceId {
	*** algorithm;
	*** type;
}

-keep class sun.security.jgss.SunProvider {
	*** INSTANCE;
}

-keep class sun.security.jgss.SunProvider$1 {
	*** this$0;
	*** run();
}

-keep class sun.security.krb5.Config {
	*** getDefault(java.lang.String,java.lang.String);
	*** getDefaultRealm();
	*** getInstance();
}

-keep class sun.security.krb5.KrbException {
	*** getMessage();
}

-keep class sun.security.krb5.PrincipalName {
	*** nameRealm;
	*** nameStrings;
	*** nameType;
	*** salt;
	sun.security.krb5.PrincipalName(java.lang.String,int);
	sun.security.krb5.PrincipalName(java.lang.String[],int);
	*** equals(sun.security.krb5.PrincipalName);
	*** equalsWithoutRealm(sun.security.krb5.PrincipalName);
	*** getRealmString();
	*** mapHostToRealm(java.lang.String);
	*** parseName(java.lang.String);
	*** toString();
}

-keep class sun.security.krb5.Realm {
	*** clone();
	*** equals(java.lang.Object);
	*** parseRealmAtSeparator(java.lang.String);
	*** toString();
}

-keep class sun.security.krb5.internal.util.KerberosString {
	*** toDerValue();
	*** toString();
}

-keep class sun.security.krb5.internal.util.KrbDataOutputStream {
	*** write32(int);
}

-keep class sun.security.pkcs.ContentInfo {
	*** DATA_OID;
	*** DIGESTED_DATA_OID;
	*** ENCRYPTED_DATA_OID;
	*** ENVELOPED_DATA_OID;
	*** NETSCAPE_CERT_SEQUENCE_OID;
	*** OLD_DATA;
	*** OLD_DATA_OID;
	*** OLD_SDATA;
	*** OLD_SIGNED_DATA_OID;
	*** PKCS7_OID;
	*** SIGNED_AND_ENVELOPED_DATA_OID;
	*** SIGNED_DATA_OID;
	*** TIMESTAMP_TOKEN_INFO_OID;
	*** content;
	*** contentType;
	*** crdata;
	*** data;
	*** ddata;
	*** edata;
	*** nsdata;
	*** pkcs7;
	*** sdata;
	*** sedata;
	*** tstInfo;
	sun.security.pkcs.ContentInfo(sun.security.util.DerInputStream,boolean);
	*** encode(sun.security.util.DerOutputStream);
	*** getContent();
	*** getContentBytes();
	*** getData();
}

-keep class sun.security.pkcs.EncryptedPrivateKeyInfo {
	*** algid;
	*** encoded;
	*** encryptedData;
	*** getAlgorithm();
	*** getEncoded();
	*** getEncryptedData();
}

-keep class sun.security.pkcs.PKCS7 {
	*** certIssuerNames;
	*** certificates;
	*** contentInfo;
	*** contentType;
	*** crls;
	*** digestAlgorithmIds;
	*** oldStyle;
	*** signerInfos;
	*** version;
	sun.security.pkcs.PKCS7(sun.security.x509.AlgorithmId[],sun.security.pkcs.ContentInfo,java.security.cert.X509Certificate[],java.security.cert.X509CRL[],sun.security.pkcs.SignerInfo[]);
	*** encodeSignedData(sun.security.util.DerOutputStream);
	*** getCRLs();
	*** getCertificate(java.math.BigInteger,sun.security.x509.X500Name);
	*** getCertificates();
	*** getContentInfo();
	*** isOldStyle();
	*** parse(sun.security.util.DerInputStream);
	*** parse(sun.security.util.DerInputStream,boolean);
	*** parseNetscapeCertChain(sun.security.util.DerValue);
	*** parseOldSignedData(sun.security.util.DerValue);
	*** parseSignedData(sun.security.util.DerValue);
	*** populateCertIssuerNames();
	*** verify(byte[]);
	*** verify(sun.security.pkcs.SignerInfo,byte[]);
}

-keep class sun.security.pkcs.PKCS8Key {
	*** algid;
	*** encodedKey;
	*** key;
	*** version;
	sun.security.pkcs.PKCS8Key();
	*** buildPKCS8Key(sun.security.x509.AlgorithmId,byte[]);
	*** decode(byte[]);
	*** decode(java.io.InputStream);
	*** encode();
	*** encode(sun.security.util.DerOutputStream);
	*** encode(sun.security.util.DerOutputStream,sun.security.x509.AlgorithmId,byte[]);
	*** getAlgorithm();
	*** getEncoded();
	*** getFormat();
	*** parseKey(sun.security.util.DerValue);
	*** parseKeyBits();
}

-keep class sun.security.pkcs.PKCS9Attribute {
	*** BYTE_ARRAY_CLASS;
	*** CHALLENGE_PASSWORD_OID;
	*** CONTENT_TYPE_OID;
	*** COUNTERSIGNATURE_OID;
	*** EMAIL_ADDRESS_OID;
	*** EXTENDED_CERTIFICATE_ATTRIBUTES_OID;
	*** EXTENSION_REQUEST_OID;
	*** ISSUER_SERIALNUMBER_OID;
	*** MESSAGE_DIGEST_OID;
	*** NAME_OID_TABLE;
	*** OID_NAME_TABLE;
	*** PKCS9_OIDS;
	*** PKCS9_VALUE_TAGS;
	*** SIGNATURE_TIMESTAMP_TOKEN_OID;
	*** SIGNING_CERTIFICATE_OID;
	*** SIGNING_TIME_OID;
	*** SINGLE_VALUED;
	*** SMIME_CAPABILITY_OID;
	*** UNSTRUCTURED_ADDRESS_OID;
	*** UNSTRUCTURED_NAME_OID;
	*** VALUE_CLASSES;
	*** debug;
	*** index;
	*** oid;
	*** value;
	*** getName();
	*** getOID(java.lang.String);
	*** getValue();
	*** indexOf(java.lang.Object,java.lang.Object[],int);
	*** init(sun.security.util.ObjectIdentifier,java.lang.Object);
	*** throwSingleValuedException();
	*** throwTagException(java.lang.Byte);
}

-keep class sun.security.pkcs.PKCS9Attributes {
	*** encode(byte,java.io.OutputStream);
	*** getAttribute(java.lang.String);
	*** getAttributeValue(sun.security.util.ObjectIdentifier);
	*** getDerEncoding();
}

-keep class sun.security.pkcs.SignerInfo {
	*** authenticatedAttributes;
	*** certificateSerialNumber;
	*** digestAlgorithmId;
	*** digestEncryptionAlgorithmId;
	*** encryptedDigest;
	*** issuerName;
	*** unauthenticatedAttributes;
	*** version;
	sun.security.pkcs.SignerInfo(sun.security.util.DerInputStream,boolean);
	*** convertToStandardName(java.lang.String);
	*** derEncode(java.io.OutputStream);
	*** getCertificate(sun.security.pkcs.PKCS7);
	*** getCertificateChain(sun.security.pkcs.PKCS7);
	*** getDigestAlgorithmId();
	*** getDigestEncryptionAlgorithmId();
	*** getEncryptedDigest();
	*** getUnauthenticatedAttributes();
	*** verify(sun.security.pkcs.PKCS7,byte[]);
}

-keep class sun.security.provider.ByteArrayAccess {
	*** bigEndian;
	*** byteArrayOfs;
	*** littleEndianUnaligned;
	*** unsafe;
	*** b2iBig(byte[],int,int[],int,int);
	*** b2iBig64(byte[],int,int[]);
	*** b2iLittle(byte[],int,int[],int,int);
	*** b2iLittle64(byte[],int,int[]);
	*** b2lBig(byte[],int,long[],int,int);
	*** i2bBig(int[],int,byte[],int,int);
	*** i2bBig4(int,byte[],int);
	*** i2bLittle(int[],int,byte[],int,int);
	*** i2bLittle4(int,byte[],int);
	*** unaligned();
}

-keep class sun.security.provider.DSA {
	*** Kseed;
	*** KseedAsByteArray;
	*** params;
	*** presetG;
	*** presetP;
	*** presetQ;
	*** presetX;
	*** presetY;
	*** previousKseed;
	*** signingRandom;
	sun.security.provider.DSA();
	*** SHA_7(int[],int[]);
	*** byteArray2IntArray(byte[]);
	*** debug(java.lang.String);
	*** engineVerify(byte[],int,int);
	*** generateK(int[],java.math.BigInteger);
	*** generateK(java.math.BigInteger);
	*** generateR(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger);
	*** generateS(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger);
	*** generateV(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger);
	*** generateW(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger);
	*** getDigest();
	*** getSigningRandom();
	*** initialize(java.security.interfaces.DSAParams);
	*** resetDigest();
	*** setParams(java.security.interfaces.DSAParams);
	*** toString();
}

-keep class sun.security.provider.DSA$SHA1withDSA {
	*** dataSHA;
}

-keep class sun.security.provider.DSAKeyFactory {
	*** SERIAL_INTEROP;
	*** engineGeneratePrivate(java.security.spec.KeySpec);
	*** engineGeneratePublic(java.security.spec.KeySpec);
	*** engineGetKeySpec(java.security.Key,java.lang.Class);
}

-keep class sun.security.provider.DSAParameters {
	*** g;
	*** p;
	*** q;
	*** engineGetEncoded();
	*** engineInit(byte[]);
}

-keep class sun.security.provider.DSAPublicKey {
	*** y;
	sun.security.provider.DSAPublicKey(byte[]);
	sun.security.provider.DSAPublicKey(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger);
}

-keep class sun.security.provider.DigestBase {
	*** algorithm;
	*** blockSize;
	*** bufOfs;
	*** buffer;
	*** bytesProcessed;
	*** digestLength;
	*** oneByte;
	*** padding;
	sun.security.provider.DigestBase(java.lang.String,int,int);
	sun.security.provider.DigestBase(sun.security.provider.DigestBase);
	*** engineDigest(byte[],int,int);
	*** engineReset();
	*** engineUpdate(byte[],int,int);
	*** implCompress(byte[],int);
	*** implDigest(byte[],int);
	*** implReset();
}

-keep class sun.security.provider.JavaKeyStore {
	*** entries;
	sun.security.provider.JavaKeyStore();
	*** convertAlias(java.lang.String);
	*** engineAliases();
	*** engineContainsAlias(java.lang.String);
	*** engineDeleteEntry(java.lang.String);
	*** engineGetCertificate(java.lang.String);
	*** engineGetCertificateAlias(java.security.cert.Certificate);
	*** engineGetCertificateChain(java.lang.String);
	*** engineGetCreationDate(java.lang.String);
	*** engineGetKey(java.lang.String,char[]);
	*** engineIsCertificateEntry(java.lang.String);
	*** engineIsKeyEntry(java.lang.String);
	*** engineLoad(java.io.InputStream,char[]);
	*** engineSetCertificateEntry(java.lang.String,java.security.cert.Certificate);
	*** engineSetKeyEntry(java.lang.String,byte[],java.security.cert.Certificate[]);
	*** engineSetKeyEntry(java.lang.String,java.security.Key,char[],java.security.cert.Certificate[]);
	*** engineSize();
	*** engineStore(java.io.OutputStream,char[]);
	*** getPreKeyedHash(char[]);
}

-keep class sun.security.provider.JavaKeyStore$KeyEntry {
	*** chain;
	*** date;
	*** protectedPrivKey;
	sun.security.provider.JavaKeyStore$KeyEntry();
}

-keep class sun.security.provider.JavaKeyStore$TrustedCertEntry {
	*** cert;
	*** date;
	sun.security.provider.JavaKeyStore$TrustedCertEntry();
}

-keep class sun.security.provider.KeyProtector {
	*** md;
	*** passwdBytes;
	*** protect(java.security.Key);
	*** recover(sun.security.pkcs.EncryptedPrivateKeyInfo);
}

-keep class sun.security.provider.MD5 {
	*** state;
	*** x;
	*** FF(int,int,int,int,int,int,int);
	*** GG(int,int,int,int,int,int,int);
	*** HH(int,int,int,int,int,int,int);
	*** II(int,int,int,int,int,int,int);
	*** implCompress(byte[],int);
	*** implReset();
}

-keep class sun.security.provider.NativePRNG {
	*** INSTANCE;
	*** initIO();
	*** isAvailable();
}

-keep class sun.security.provider.NativePRNG$1 {
	*** run();
}

-keep class sun.security.provider.NativePRNG$RandomIO {
	*** LOCK_GET_BYTES;
	*** LOCK_GET_SEED;
	*** LOCK_SET_SEED;
	*** buffered;
	*** lastRead;
	*** mixRandom;
	*** randomIn;
	*** randomOut;
	*** randomOutInitialized;
	*** urandomBuffer;
	*** urandomIn;
	sun.security.provider.NativePRNG$RandomIO(java.io.File,java.io.File);
	*** access$100(sun.security.provider.NativePRNG$RandomIO,byte[]);
	*** access$200(sun.security.provider.NativePRNG$RandomIO,byte[]);
	*** access$300(sun.security.provider.NativePRNG$RandomIO,int);
	*** ensureBufferValid();
	*** getMixRandom();
	*** implGenerateSeed(int);
	*** implNextBytes(byte[]);
	*** implSetSeed(byte[]);
	*** readFully(java.io.InputStream,byte[]);
}

-keep class sun.security.provider.PolicyFile {
	*** PARAMS0;
	*** PARAMS1;
	*** PARAMS2;
	*** allowSystemProperties;
	*** constructed;
	*** debug;
	*** expandProperties;
	*** ignoreIdentityScope;
	*** notUtf8;
	*** policyInfo;
	*** url;
	*** access$002(sun.security.provider.PolicyFile,boolean);
	*** access$102(sun.security.provider.PolicyFile,boolean);
	*** access$200(sun.security.provider.PolicyFile);
	*** access$202(sun.security.provider.PolicyFile,boolean);
	*** access$302(sun.security.provider.PolicyFile,boolean);
	*** access$400(sun.security.provider.PolicyFile,java.net.URL,sun.security.provider.PolicyFile$PolicyInfo);
	*** access$600();
	*** addGrantEntry(sun.security.provider.PolicyParser$GrantEntry,java.security.KeyStore,sun.security.provider.PolicyFile$PolicyInfo);
	*** addPermissions(java.security.Permissions,java.security.CodeSource,java.security.Principal[],sun.security.provider.PolicyFile$PolicyEntry);
	*** addPerms(java.security.Permissions,java.security.Principal[],sun.security.provider.PolicyFile$PolicyEntry);
	*** canonPath(java.lang.String);
	*** canonicalizeCodebase(java.security.CodeSource,boolean);
	*** checkEntryPs(java.security.Principal[],sun.security.provider.PolicyParser$PrincipalEntry);
	*** checkForTrustedIdentity(java.security.cert.Certificate,sun.security.provider.PolicyFile$PolicyInfo);
	*** expandPermissionName(sun.security.provider.PolicyParser$PermissionEntry,java.security.KeyStore);
	*** expandSelf(sun.security.provider.PolicyFile$SelfPermission,java.util.List,java.security.Principal[],java.security.Permissions);
	*** getCertificates(java.security.KeyStore,java.lang.String,sun.security.provider.PolicyFile$PolicyInfo);
	*** getCodeSource(sun.security.provider.PolicyParser$GrantEntry,java.security.KeyStore,sun.security.provider.PolicyFile$PolicyInfo);
	*** getDN(java.lang.String,java.security.KeyStore);
	*** getInstance(java.lang.String,java.lang.String,java.lang.String);
	*** getKnownInstance(java.lang.Class,java.lang.String,java.lang.String);
	*** getPermissions(java.security.Permissions,java.security.CodeSource);
	*** getPermissions(java.security.Permissions,java.security.CodeSource,java.security.Principal[]);
	*** getPermissions(java.security.Permissions,java.security.ProtectionDomain);
	*** getPermissions(java.security.ProtectionDomain);
	*** getPrincipalInfo(sun.security.provider.PolicyParser$PrincipalEntry,java.security.Principal[]);
	*** getSignerCertificates(java.security.CodeSource);
	*** init(java.net.URL);
	*** init(java.net.URL,sun.security.provider.PolicyFile$PolicyInfo);
	*** initPolicyFile(java.lang.String,java.lang.String,sun.security.provider.PolicyFile$PolicyInfo);
	*** initPolicyFile(sun.security.provider.PolicyFile$PolicyInfo,java.net.URL);
	*** initStaticPolicy(sun.security.provider.PolicyFile$PolicyInfo);
	*** printPD(java.security.ProtectionDomain);
	*** replacePrincipals(java.util.List,java.security.KeyStore);
}

-keep class sun.security.provider.PolicyFile$1 {
	*** this$0;
	*** run();
}

-keep class sun.security.provider.PolicyFile$3 {
	*** this$0;
	*** val$newInfo;
	*** val$propname;
	*** val$urlname;
	*** run();
}

-keep class sun.security.provider.PolicyFile$PolicyEntry {
	*** codesource;
	*** permissions;
	*** principals;
	sun.security.provider.PolicyFile$PolicyEntry(java.security.CodeSource,java.util.List);
	*** add(java.security.Permission);
	*** getCodeSource();
	*** getPrincipals();
}

-keep class sun.security.provider.PolicyFile$PolicyInfo {
	*** aliasMapping;
	*** identityPolicyEntries;
	*** pdMapping;
	*** policyEntries;
	*** random;
	*** getPdMapping();
}

-keep class sun.security.provider.PolicyFile$SelfPermission {
	*** getCerts();
	*** getSelfActions();
	*** getSelfName();
	*** getSelfType();
}

-keep class sun.security.provider.PolicyParser {
	*** debug;
	*** expandProp;
	*** grantEntries;
	*** keyStoreProvider;
	*** keyStoreType;
	*** keyStoreUrlString;
	*** lookahead;
	*** st;
	*** storePassURL;
	sun.security.provider.PolicyParser();
	*** add(sun.security.provider.PolicyParser$GrantEntry);
	*** expand(java.lang.String);
	*** expand(java.lang.String,boolean);
	*** getKeyStoreProvider();
	*** getKeyStoreType();
	*** getKeyStoreUrl();
	*** getStorePassURL();
	*** grantElements();
	*** match(java.lang.String);
	*** parseExtDirs(java.lang.String,int);
	*** parseGrantEntry();
	*** parseKeyStoreEntry();
	*** parsePermissionEntry();
	*** parseStorePassURL();
	*** peek(java.lang.String);
	*** peekAndMatch(java.lang.String);
	*** read(java.io.Reader);
	*** skipEntry();
	*** write(java.io.Writer);
	*** writeKeyStoreEntry(java.io.PrintWriter);
	*** writeStorePassURL(java.io.PrintWriter);
}

-keep class sun.security.provider.PolicyParser$GrantEntry {
	*** codeBase;
	*** permissionEntries;
	*** principals;
	*** signedBy;
	*** add(sun.security.provider.PolicyParser$PermissionEntry);
	*** clone();
	*** permissionElements();
	*** write(java.io.PrintWriter);
}

-keep class sun.security.provider.PolicyParser$ParsingException {
	*** i18nMessage;
	*** getLocalizedMessage();
}

-keep class sun.security.provider.PolicyParser$PermissionEntry {
	*** action;
	*** name;
	*** permission;
	*** signedBy;
	*** write(java.io.PrintWriter);
}

-keep class sun.security.provider.PolicyParser$PrincipalEntry {
	*** principalClass;
	*** principalName;
	*** toString();
	*** write(java.io.PrintWriter);
}

-keep class sun.security.provider.SHA {
	*** W;
	*** state;
	*** implCompress(byte[],int);
	*** implReset();
}

-keep class sun.security.provider.SHA2 {
	*** ROUND_CONSTS;
	*** W;
	*** state;
	*** implCompress(byte[],int);
	*** implReset();
	*** lf_R(int,int);
	*** lf_S(int,int);
	*** lf_ch(int,int,int);
	*** lf_delta0(int);
	*** lf_delta1(int);
	*** lf_maj(int,int,int);
	*** lf_sigma0(int);
	*** lf_sigma1(int);
}

-keep class sun.security.provider.SecureRandom {
	*** digest;
	*** remCount;
	*** remainder;
	*** state;
	sun.security.provider.SecureRandom(byte[]);
	*** engineNextBytes(byte[]);
	*** engineSetSeed(byte[]);
	*** init(byte[]);
	*** updateState(byte[],byte[]);
}

-keep class sun.security.provider.SecureRandom$SeederHolder {
	*** access$100();
}

-keep class sun.security.provider.SeedGenerator {
	*** generateSeed(byte[]);
}

-keep class sun.security.provider.SunEntries {
	*** seedSource;
	*** putEntries(java.util.Map);
}

-keep class sun.security.provider.SunEntries$1 {
	*** run();
}

-keep class sun.security.provider.X509Factory {
	*** certCache;
	*** crlCache;
	*** addToCache(sun.security.util.Cache,byte[],java.lang.Object);
	*** checkHeaderFooter(java.lang.String,java.lang.String);
	*** getFromCache(sun.security.util.Cache,byte[]);
	*** intern(java.security.cert.X509Certificate);
	*** parseX509orPKCS7CRL(java.io.InputStream);
	*** parseX509orPKCS7Cert(java.io.InputStream);
	*** readBERInternal(java.io.InputStream,java.io.ByteArrayOutputStream,int);
	*** readFully(java.io.InputStream,java.io.ByteArrayOutputStream,int);
	*** readOneBlock(java.io.InputStream);
}

-keep class sun.security.provider.certpath.AdaptableX509CertSelector {
	*** endDate;
	*** isSKIDSensitive;
	*** isSNSensitive;
	*** startDate;
	*** match(java.security.cert.Certificate);
	*** parseAuthorityKeyIdentifierExtension(sun.security.x509.AuthorityKeyIdentifierExtension);
	*** setValidityPeriod(java.util.Date,java.util.Date);
}

-keep class sun.security.provider.certpath.AdjacencyList {
	*** mOrigList;
	*** mStepList;
	*** buildList(java.util.List,int,sun.security.provider.certpath.BuildStep);
}

-keep class sun.security.provider.certpath.AlgorithmChecker {
	*** SIGNATURE_PRIMITIVE_SET;
	*** certPathDefaultConstraints;
	*** constraints;
	*** prevPubKey;
	*** trustedPubKey;
	sun.security.provider.certpath.AlgorithmChecker(java.security.cert.TrustAnchor,java.security.AlgorithmConstraints);
	*** check(java.security.PublicKey,sun.security.x509.AlgorithmId);
	*** check(java.security.cert.Certificate,java.util.Collection);
	*** init(boolean);
	*** trySetTrustAnchor(java.security.cert.TrustAnchor);
}

-keep class sun.security.provider.certpath.BasicChecker {
	*** caName;
	*** debug;
	*** prevPubKey;
	*** prevSubject;
	*** sigOnly;
	*** sigProvider;
	*** testDate;
	*** trustedPubKey;
	*** getPublicKey();
	*** init(boolean);
	*** makeInheritedParamsKey(java.security.PublicKey,java.security.PublicKey);
	*** updateState(java.security.cert.X509Certificate);
	*** verifyNameChaining(java.security.cert.X509Certificate,javax.security.auth.x500.X500Principal);
	*** verifySignature(java.security.cert.X509Certificate,java.security.PublicKey,java.lang.String);
	*** verifyTimestamp(java.security.cert.X509Certificate,java.util.Date);
}

-keep class sun.security.provider.certpath.BuildStep {
	*** cert;
	*** debug;
	*** result;
	*** throwable;
	*** vertex;
	*** getResult();
	*** getVertex();
	*** resultToString(int);
}

-keep class sun.security.provider.certpath.Builder {
	*** USE_AIA;
	*** buildParams;
	*** date;
	*** debug;
	*** matchingPolicies;
	*** targetCertConstraints;
	*** targetSubjectDN;
	sun.security.provider.certpath.Builder(java.security.cert.PKIXBuilderParameters,javax.security.auth.x500.X500Principal);
	*** addMatchingCerts(java.security.cert.X509CertSelector,java.util.Collection,java.util.Collection,boolean);
	*** distance(sun.security.x509.GeneralNameInterface,sun.security.x509.GeneralNameInterface,int);
	*** getMatchingPolicies();
	*** hops(sun.security.x509.GeneralNameInterface,sun.security.x509.GeneralNameInterface,int);
	*** isLocalCertStore(java.security.cert.CertStore);
}

-keep class sun.security.provider.certpath.CertPathHelper {
	*** instance;
	sun.security.provider.certpath.CertPathHelper();
	*** implSetDateAndTime(java.security.cert.X509CRLSelector,java.util.Date,long);
	*** implSetPathToNames(java.security.cert.X509CertSelector,java.util.Set);
	*** setDateAndTime(java.security.cert.X509CRLSelector,java.util.Date,long);
	*** setPathToNames(java.security.cert.X509CertSelector,java.util.Set);
}

-keep class sun.security.provider.certpath.CollectionCertStore {
	*** coll;
}

-keep class sun.security.provider.certpath.ConstraintsChecker {
	*** certPathLength;
	*** debug;
	*** i;
	*** maxPathLength;
	*** prevNC;
	*** supportedExts;
	*** checkBasicConstraints(java.security.cert.X509Certificate);
	*** init(boolean);
	*** mergeNameConstraints(java.security.cert.X509Certificate,sun.security.x509.NameConstraintsExtension);
	*** verifyNameConstraints(java.security.cert.X509Certificate);
}

-keep class sun.security.provider.certpath.CrlRevocationChecker {
	*** ALL_REASONS;
	*** debug;
	*** mAnchor;
	*** mApprovedCRLs;
	*** mCRLSignFlag;
	*** mCrlSignUsage;
	*** mCurrentTime;
	*** mOnlyEECert;
	*** mParams;
	*** mPossibleCRLs;
	*** mPrevPubKey;
	*** mSigProvider;
	*** mStores;
	sun.security.provider.certpath.CrlRevocationChecker(java.security.cert.TrustAnchor,java.security.cert.PKIXParameters,java.util.Collection);
	sun.security.provider.certpath.CrlRevocationChecker(java.security.cert.TrustAnchor,java.security.cert.PKIXParameters,java.util.Collection,boolean);
	*** buildToNewKey(java.security.cert.X509Certificate,java.security.PublicKey,java.util.Set);
	*** certCanSignCrl(java.security.cert.X509Certificate);
	*** check(java.security.cert.X509Certificate,java.security.PublicKey,boolean);
	*** init(boolean);
	*** verifyPossibleCRLs(java.util.Set,java.security.cert.X509Certificate,boolean,java.security.PublicKey,boolean[],java.util.Set);
	*** verifyRevocationStatus(java.security.cert.X509Certificate,java.security.PublicKey,boolean,boolean);
	*** verifyRevocationStatus(java.security.cert.X509Certificate,java.security.PublicKey,boolean,boolean,java.util.Set,java.util.Set);
	*** verifyWithSeparateSigningKey(java.security.cert.X509Certificate,java.security.PublicKey,boolean,java.util.Set);
}

-keep class sun.security.provider.certpath.DistributionPointFetcher {
	*** getCRLs(java.security.cert.X509CRLSelector,boolean,java.security.PublicKey,java.lang.String,java.util.List,boolean[],java.util.Set,java.util.Date);
	*** verifyCRL(sun.security.x509.X509CertImpl,sun.security.x509.DistributionPoint,java.security.cert.X509CRL,boolean[],boolean,java.security.PublicKey,java.lang.String,java.util.Set,java.util.List,java.util.Date);
}

-keep class sun.security.provider.certpath.ForwardBuilder {
	*** caSelector;
	*** caTargetSelector;
	*** comparator;
	*** debug;
	*** eeSelector;
	*** onlyEECert;
	*** searchAllCertStores;
	*** trustAnchor;
	*** trustAnchors;
	*** trustedCerts;
	*** trustedSubjectDNs;
	*** access$000();
	*** addCertToPath(java.security.cert.X509Certificate,java.util.LinkedList);
	*** getCerts(sun.security.x509.AuthorityInfoAccessExtension,java.util.Collection);
	*** getMatchingCACerts(sun.security.provider.certpath.ForwardState,java.util.List,java.util.Collection);
	*** getMatchingCerts(sun.security.provider.certpath.State,java.util.List);
	*** getMatchingEECerts(sun.security.provider.certpath.ForwardState,java.util.List,java.util.Collection);
	*** isPathCompleted(java.security.cert.X509Certificate);
	*** removeFinalCertFromPath(java.util.LinkedList);
	*** verifyCert(java.security.cert.X509Certificate,sun.security.provider.certpath.State,java.util.List);
}

-keep class sun.security.provider.certpath.ForwardBuilder$PKIXCertComparator {
	*** trustedSubjectDNs;
	*** compare(java.security.cert.X509Certificate,java.security.cert.X509Certificate);
}

-keep class sun.security.provider.certpath.ForwardState {
	*** cert;
	*** crlChecker;
	*** debug;
	*** forwardCheckers;
	*** init;
	*** issuerDN;
	*** keyParamsNeededFlag;
	*** subjectNamesTraversed;
	*** traversedCACerts;
	*** untrustedChecker;
	*** clone();
	*** initState(java.util.List);
	*** isInitial();
	*** keyParamsNeeded();
	*** toString();
	*** updateState(java.security.cert.X509Certificate);
}

-keep class sun.security.provider.certpath.KeyChecker {
	*** certPathLen;
	*** debug;
	*** remainingCerts;
	*** supportedExts;
	*** targetConstraints;
	*** init(boolean);
	*** verifyCAKeyUsage(java.security.cert.X509Certificate);
}

-keep class sun.security.provider.certpath.OCSP {
	*** check(java.util.List,java.net.URI,java.util.List,java.util.Date);
}

-keep class sun.security.provider.certpath.OCSP$RevocationStatus {
	*** getCertStatus();
	*** getRevocationReason();
	*** getRevocationTime();
	*** getSingleExtensions();
}

-keep class sun.security.provider.certpath.OCSP$RevocationStatus$CertStatus {
	*** REVOKED;
	*** UNKNOWN;
}

-keep class sun.security.provider.certpath.OCSPChecker {
	*** DEBUG;
	*** certs;
	*** cp;
	*** onlyEECert;
	*** pkixParams;
	*** remainingCerts;
	sun.security.provider.certpath.OCSPChecker(java.security.cert.CertPath,java.security.cert.PKIXParameters,boolean);
	*** getKeyId(java.security.cert.X509Certificate);
	*** getOCSPProperties();
	*** getOCSPServerURI(sun.security.x509.X509CertImpl,java.lang.String);
	*** init(boolean);
	*** stripOutSeparators(java.lang.String);
}

-keep class sun.security.provider.certpath.OCSPResponse {
	*** getSingleResponse(sun.security.provider.certpath.CertId);
}

-keep class sun.security.provider.certpath.PKIXCertPathValidator {
	*** basicChecker;
	*** debug;
	*** ocspEnabled;
	*** onlyEECert;
	*** sigProvider;
	*** testDate;
	*** userCheckers;
	*** doValidate(java.security.cert.TrustAnchor,java.security.cert.CertPath,java.util.ArrayList,java.security.cert.PKIXParameters,sun.security.provider.certpath.PolicyNodeImpl);
	*** isWorthTrying(java.security.cert.X509Certificate,java.security.cert.X509Certificate);
	*** populateVariables(java.security.cert.PKIXParameters);
}

-keep class sun.security.provider.certpath.PKIXMasterCertPathValidator {
	*** certPathCheckers;
	*** debug;
	*** isRevocationCheck(java.security.cert.PKIXCertPathChecker,int,java.util.List);
	*** validate(java.security.cert.CertPath,java.util.List);
}

-keep class sun.security.provider.certpath.PolicyChecker {
	*** anyPolicyInhibited;
	*** certIndex;
	*** certPathLen;
	*** debug;
	*** expPolicyRequired;
	*** explicitPolicy;
	*** inhibitAnyPolicy;
	*** initPolicies;
	*** polMappingInhibited;
	*** policyMapping;
	*** rejectPolicyQualifiers;
	*** rootNode;
	*** supportedExts;
	*** checkPolicy(java.security.cert.X509Certificate);
	*** getPolicyTree();
	*** init(boolean);
	*** mergeExplicitPolicy(int,sun.security.x509.X509CertImpl,boolean);
	*** mergeInhibitAnyPolicy(int,sun.security.x509.X509CertImpl);
	*** mergePolicyMapping(int,sun.security.x509.X509CertImpl);
	*** processParents(int,boolean,boolean,sun.security.provider.certpath.PolicyNodeImpl,java.lang.String,java.util.Set,boolean);
	*** processPolicies(int,java.util.Set,int,int,int,boolean,sun.security.provider.certpath.PolicyNodeImpl,sun.security.x509.X509CertImpl,boolean);
	*** processPolicyMappings(sun.security.x509.X509CertImpl,int,int,sun.security.provider.certpath.PolicyNodeImpl,boolean,java.util.Set);
	*** removeInvalidNodes(sun.security.provider.certpath.PolicyNodeImpl,int,java.util.Set,sun.security.x509.CertificatePoliciesExtension);
	*** rewriteLeafNodes(int,java.util.Set,sun.security.provider.certpath.PolicyNodeImpl);
}

-keep class sun.security.provider.certpath.PolicyNodeImpl {
	*** isImmutable;
	*** mChildren;
	*** mCriticalityIndicator;
	*** mDepth;
	*** mExpectedPolicySet;
	*** mOriginalExpectedPolicySet;
	*** mParent;
	*** mQualifierSet;
	*** mValidPolicy;
	sun.security.provider.certpath.PolicyNodeImpl(sun.security.provider.certpath.PolicyNodeImpl,java.lang.String,java.util.Set,boolean,java.util.Set,boolean);
	*** addChild(sun.security.provider.certpath.PolicyNodeImpl);
	*** addExpectedPolicy(java.lang.String);
	*** asString();
	*** copyTree();
	*** copyTree(sun.security.provider.certpath.PolicyNodeImpl);
	*** deleteChild(java.security.cert.PolicyNode);
	*** getChildren();
	*** getDepth();
	*** getExpectedPolicies();
	*** getParent();
	*** getPolicyNodes(int);
	*** getPolicyNodes(int,java.util.Set);
	*** getPolicyNodesExpected(int,java.lang.String,boolean);
	*** getPolicyNodesExpectedHelper(int,java.lang.String,boolean);
	*** getPolicyNodesValid(int,java.lang.String);
	*** getPolicyQualifiers();
	*** getValidPolicy();
	*** isCritical();
	*** policyToString(java.lang.String);
	*** prune(int);
	*** setImmutable();
}

-keep class sun.security.provider.certpath.ReverseBuilder {
	*** addCertToPath(java.security.cert.X509Certificate,java.util.LinkedList);
	*** getMatchingCerts(sun.security.provider.certpath.State,java.util.List);
	*** isPathCompleted(java.security.cert.X509Certificate);
	*** removeFinalCertFromPath(java.util.LinkedList);
	*** verifyCert(java.security.cert.X509Certificate,sun.security.provider.certpath.State,java.util.List);
}

-keep class sun.security.provider.certpath.ReverseState {
	*** algorithmChecker;
	*** crlChecker;
	*** pubKey;
	*** rootNode;
	*** trustAnchor;
	*** untrustedChecker;
	*** clone();
	*** initState(int,boolean,boolean,boolean,java.util.List);
	*** isInitial();
	*** toString();
	*** updateState(java.security.cert.TrustAnchor);
	*** updateState(java.security.cert.X509Certificate);
}

-keep class sun.security.provider.certpath.SunCertPathBuilder {
	*** buildParams;
	*** cf;
	*** debug;
	*** finalPublicKey;
	*** onlyEECert;
	*** orderedCertStores;
	*** pathCompleted;
	*** policyTreeResult;
	*** targetSel;
	*** targetSubjectDN;
	*** trustAnchor;
	*** addVertices(java.util.Collection,java.util.List);
	*** anchorIsTarget(java.security.cert.TrustAnchor,java.security.cert.X509CertSelector);
	*** buildCertPath(boolean,boolean,java.util.List);
	*** buildForward(java.util.List,java.util.LinkedList,boolean);
	*** buildReverse(java.util.List,java.util.LinkedList);
	*** depthFirstSearchForward(javax.security.auth.x500.X500Principal,sun.security.provider.certpath.ForwardState,sun.security.provider.certpath.ForwardBuilder,java.util.List,java.util.LinkedList);
	*** depthFirstSearchReverse(javax.security.auth.x500.X500Principal,sun.security.provider.certpath.ReverseState,sun.security.provider.certpath.ReverseBuilder,java.util.List,java.util.LinkedList);
	*** getTargetSubjectDN(java.util.List,java.security.cert.X509CertSelector);
}

-keep class sun.security.provider.certpath.SunCertPathBuilder$CertStoreComparator {
	sun.security.provider.certpath.SunCertPathBuilder$CertStoreComparator();
	*** compare(java.security.cert.CertStore,java.security.cert.CertStore);
}

-keep class sun.security.provider.certpath.SunCertPathBuilderException {
	*** adjList;
	sun.security.provider.certpath.SunCertPathBuilderException(java.lang.String);
	sun.security.provider.certpath.SunCertPathBuilderException(java.lang.String,java.lang.Throwable);
}

-keep class sun.security.provider.certpath.SunCertPathBuilderParameters {
	*** buildForward;
	*** getBuildForward();
	*** setBuildForward(boolean);
}

-keep class sun.security.provider.certpath.URICertStore {
	*** getInstance(sun.security.x509.AccessDescription);
}

-keep class sun.security.provider.certpath.UntrustedChecker {
	*** debug;
	*** check(java.security.cert.Certificate,java.util.Collection);
}

-keep class sun.security.provider.certpath.Vertex {
	*** cert;
	*** debug;
	*** index;
	*** throwable;
	*** certToString();
	*** getCertificate();
	*** getIndex();
	*** getThrowable();
	*** indexToString();
	*** moreToString();
	*** setIndex(int);
	*** setThrowable(java.lang.Throwable);
	*** throwableToString();
	*** toString();
}

-keep class sun.security.provider.certpath.X509CertPath {
	*** certs;
	*** encodingList;
	sun.security.provider.certpath.X509CertPath(java.io.InputStream,java.lang.String);
	*** encodePKCS7();
	*** encodePKIPATH();
	*** getEncodingsStatic();
	*** parsePKCS7(java.io.InputStream);
	*** parsePKIPATH(java.io.InputStream);
	*** readAllBytes(java.io.InputStream);
}

-keep class sun.security.provider.certpath.X509CertificatePair {
	*** clearCache();
}

-keep class sun.security.rsa.RSACore {
	*** $assertionsDisabled;
	*** blindingCache;
	*** convert(byte[],int,int);
	*** crtCrypt(byte[],java.security.interfaces.RSAPrivateCrtKey);
	*** crypt(byte[],java.math.BigInteger,java.math.BigInteger);
	*** getBlindingParameters(java.security.interfaces.RSAPrivateCrtKey);
	*** getByteLength(java.math.BigInteger);
	*** getByteLength(java.security.interfaces.RSAKey);
	*** parseMsg(byte[],java.math.BigInteger);
	*** rsa(byte[],java.security.interfaces.RSAPrivateKey);
	*** rsa(byte[],java.security.interfaces.RSAPublicKey);
	*** toByteArray(java.math.BigInteger,int);
}

-keep class sun.security.rsa.RSACore$BlindingParameters {
	*** e;
	*** rInv;
	*** re;
	*** remainingUses;
	*** valid(java.math.BigInteger);
}

-keep class sun.security.rsa.RSAKeyFactory {
	*** INSTANCE;
	*** pkcs8KeySpecClass;
	*** restrictExpLen;
	*** rsaPrivateCrtKeySpecClass;
	*** rsaPrivateKeySpecClass;
	*** rsaPublicKeySpecClass;
	*** x509KeySpecClass;
	*** checkKeyLengths(int,java.math.BigInteger,int,int);
	*** checkRSAProviderKeyLengths(int,java.math.BigInteger);
	*** engineTranslateKey(java.security.Key);
	*** generatePrivate(java.security.spec.KeySpec);
	*** generatePublic(java.security.spec.KeySpec);
	*** toRSAKey(java.security.Key);
	*** translatePrivateKey(java.security.PrivateKey);
	*** translatePublicKey(java.security.PublicKey);
}

-keep class sun.security.rsa.RSAPadding {
	*** emptyHashes;
	*** lHash;
	*** maxDataSize;
	*** md;
	*** mgfMd;
	*** paddedSize;
	*** random;
	*** type;
	*** getInitialHash(java.security.MessageDigest,byte[]);
	*** getInstance(int,int,java.security.SecureRandom);
	*** getInstance(int,int,java.security.SecureRandom,javax.crypto.spec.OAEPParameterSpec);
	*** getMaxDataSize();
	*** mgf1(byte[],int,int,byte[],int,int);
	*** pad(byte[]);
	*** pad(byte[],int,int);
	*** padOAEP(byte[]);
	*** padV15(byte[]);
	*** unpad(byte[]);
	*** unpadOAEP(byte[]);
	*** unpadV15(byte[]);
}

-keep class sun.security.rsa.RSAPrivateCrtKeyImpl {
	*** coeff;
	*** d;
	*** e;
	*** n;
	*** p;
	*** pe;
	*** q;
	*** qe;
	*** rsaId;
	*** getBigInteger(sun.security.util.DerInputStream);
	*** getModulus();
	*** getPrivateExponent();
	*** getPublicExponent();
	*** newKey(byte[]);
}

-keep class sun.security.rsa.RSAPrivateKeyImpl {
	*** d;
	*** n;
}

-keep class sun.security.rsa.RSAPublicKeyImpl {
	*** e;
	*** n;
	*** getAlgorithm();
}

-keep class sun.security.rsa.RSASignature {
	*** digestOID;
	*** digestReset;
	*** encodedLength;
	*** md;
	*** padding;
	*** privateKey;
	*** publicKey;
	sun.security.rsa.RSASignature(java.lang.String,sun.security.util.ObjectIdentifier,int);
	*** decodeSignature(sun.security.util.ObjectIdentifier,byte[]);
	*** encodeSignature(sun.security.util.ObjectIdentifier,byte[]);
	*** engineInitSign(java.security.PrivateKey,java.security.SecureRandom);
	*** getDigestValue();
	*** initCommon(java.security.interfaces.RSAKey,java.security.SecureRandom);
	*** resetDigest();
}

-keep class sun.security.rsa.SunRsaSignEntries {
	*** putEntries(java.util.Map);
}

-keep class sun.security.smartcardio.SunPCSC$1 {
	*** this$0;
	*** run();
}

-keep class sun.security.ssl.AbstractTrustManagerWrapper {
	*** tm;
	*** checkAdditionalTrust(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket,boolean);
	*** checkAdditionalTrust(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine,boolean);
	*** checkAlgorithmConstraints(java.security.cert.X509Certificate[],java.security.AlgorithmConstraints);
}

-keep class sun.security.ssl.Alerts {
	*** alertDescription(byte);
	*** getSSLException(byte,java.lang.String);
	*** getSSLException(byte,java.lang.Throwable,java.lang.String);
}

-keep class sun.security.ssl.AppInputStream {
	*** SKIP_ARRAY;
	*** c;
	*** oneByte;
	*** r;
	*** read(byte[],int,int);
}

-keep class sun.security.ssl.AppOutputStream {
	*** c;
	*** oneByte;
	*** r;
	*** write(byte[],int,int);
}

-keep class sun.security.ssl.BaseSSLSocketImpl {
	*** requireCloseNotify;
	*** self;
	sun.security.ssl.BaseSSLSocketImpl();
	sun.security.ssl.BaseSSLSocketImpl(java.net.Socket);
	*** bind(java.net.SocketAddress);
	*** getInetAddress();
	*** getLocalPort();
	*** getLocalSocketAddress();
	*** getPort();
	*** getRemoteSocketAddress();
	*** getSoLinger();
	*** getTcpNoDelay();
	*** setPerformancePreferences(int,int,int);
}

-keep class sun.security.ssl.ByteBufferInputStream {
	*** bb;
	*** read(byte[],int,int);
}

-keep class sun.security.ssl.CipherBox {
	*** NULL;
	*** blockSize;
	*** cipher;
	*** debug;
	*** isCBCMode;
	*** masks;
	*** protocolVersion;
	*** random;
	*** addPadding(byte[],int,int,int);
	*** addPadding(java.nio.ByteBuffer,int);
	*** checkPadding(byte[],int,int,byte);
	*** checkPadding(java.nio.ByteBuffer,byte);
	*** decrypt(byte[],int,int,int);
	*** decrypt(java.nio.ByteBuffer,int);
	*** dispose();
	*** encrypt(byte[],int,int);
	*** encrypt(java.nio.ByteBuffer);
	*** getFixedMask(int);
	*** isCBCMode();
	*** isNullCipher();
	*** newCipherBox(sun.security.ssl.ProtocolVersion,sun.security.ssl.CipherSuite$BulkCipher,javax.crypto.SecretKey,javax.crypto.spec.IvParameterSpec,java.security.SecureRandom,boolean);
	*** removePadding(byte[],int,int,int,int,sun.security.ssl.ProtocolVersion);
	*** removePadding(java.nio.ByteBuffer,int,int,sun.security.ssl.ProtocolVersion);
	*** sanityCheck(int,int);
}

-keep class sun.security.ssl.CipherSuite {
	*** ALLOW_ECC;
	*** B_3DES;
	*** B_AES_128;
	*** B_AES_256;
	*** B_DES;
	*** B_DES_40;
	*** B_IDEA;
	*** B_NULL;
	*** B_RC2_40;
	*** B_RC4_128;
	*** B_RC4_40;
	*** C_NULL;
	*** C_SCSV;
	*** M_MD5;
	*** M_NULL;
	*** M_SHA;
	*** M_SHA256;
	*** M_SHA384;
	*** allowed;
	*** cipher;
	*** exportable;
	*** id;
	*** idMap;
	*** keyExchange;
	*** macAlg;
	*** name;
	*** nameMap;
	*** obsoleted;
	*** prfAlg;
	*** priority;
	*** supported;
	*** access$000();
	*** add(java.lang.String,int);
	*** add(java.lang.String,int,int,sun.security.ssl.CipherSuite$KeyExchange,sun.security.ssl.CipherSuite$BulkCipher,boolean);
	*** add(java.lang.String,int,int,sun.security.ssl.CipherSuite$KeyExchange,sun.security.ssl.CipherSuite$BulkCipher,boolean,int);
	*** add(java.lang.String,int,int,sun.security.ssl.CipherSuite$KeyExchange,sun.security.ssl.CipherSuite$BulkCipher,boolean,int,int,sun.security.ssl.CipherSuite$PRF);
	*** allowedCipherSuites();
	*** isAvailable();
	*** isNegotiable();
	*** valueOf(int,int);
	*** valueOf(java.lang.String);
}

-keep class sun.security.ssl.CipherSuite$BulkCipher {
	*** algorithm;
	*** allowed;
	*** availableCache;
	*** description;
	*** expandedKeySize;
	*** exportable;
	*** isCBCMode;
	*** ivSize;
	*** keySize;
	*** transformation;
	*** clearAvailableCache();
	*** isAvailable();
	*** isAvailable(sun.security.ssl.CipherSuite$BulkCipher);
	*** newCipher(sun.security.ssl.ProtocolVersion,javax.crypto.SecretKey,javax.crypto.spec.IvParameterSpec,java.security.SecureRandom,boolean);
}

-keep class sun.security.ssl.CipherSuite$KeyExchange {
	*** $VALUES;
	*** K_DHE_DSS;
	*** K_DHE_RSA;
	*** K_DH_ANON;
	*** K_DH_DSS;
	*** K_DH_RSA;
	*** K_ECDHE_ECDSA;
	*** K_ECDHE_RSA;
	*** K_ECDH_ANON;
	*** K_ECDH_ECDSA;
	*** K_ECDH_RSA;
	*** K_KRB5;
	*** K_KRB5_EXPORT;
	*** K_NULL;
	*** K_RSA;
	*** K_RSA_EXPORT;
	*** K_SCSV;
	*** allowed;
	*** alwaysAvailable;
	*** name;
	*** isAvailable();
	*** values();
}

-keep class sun.security.ssl.CipherSuite$MacAlg {
	*** hashBlockSize;
	*** minimalPaddingSize;
	*** name;
	*** size;
	*** newMac(sun.security.ssl.ProtocolVersion,javax.crypto.SecretKey);
}

-keep class sun.security.ssl.CipherSuite$PRF {
	*** $VALUES;
	*** P_NONE;
	*** P_SHA256;
	*** P_SHA384;
	*** P_SHA512;
	*** prfBlockSize;
	*** prfHashAlg;
	*** prfHashLength;
	*** getPRFBlockSize();
	*** getPRFHashAlg();
	*** getPRFHashLength();
}

-keep class sun.security.ssl.CipherSuiteList {
	*** cipherSuites;
	*** containsEC;
	*** suiteNames;
	*** clearAvailableCache();
	*** collection();
	*** contains(sun.security.ssl.CipherSuite);
	*** containsEC();
	*** send(sun.security.ssl.HandshakeOutStream);
	*** size();
	*** toStringArray();
}

-keep class sun.security.ssl.CipherSuiteList$1 {
	*** $SwitchMap$sun$security$ssl$CipherSuite$KeyExchange;
}

-keep class sun.security.ssl.ClientHandshaker {
	*** certRequest;
	*** dh;
	*** ecdh;
	*** enableSNIExtension;
	*** ephemeralServerKey;
	*** maxProtocolVersion;
	*** serverDH;
	*** serverKey;
	*** serverKeyExchangeReceived;
	*** sendChangeCipherAndFinish(boolean);
	*** serverCertificate(sun.security.ssl.HandshakeMessage$CertificateMsg);
	*** serverFinished(sun.security.ssl.HandshakeMessage$Finished);
	*** serverHello(sun.security.ssl.HandshakeMessage$ServerHello);
	*** serverHelloDone(sun.security.ssl.HandshakeMessage$ServerHelloDone);
	*** serverHelloRequest(sun.security.ssl.HandshakeMessage$HelloRequest);
	*** serverKeyExchange(sun.security.ssl.HandshakeMessage$DH_ServerKeyExchange);
	*** serverKeyExchange(sun.security.ssl.HandshakeMessage$ECDH_ServerKeyExchange);
	*** serverKeyExchange(sun.security.ssl.HandshakeMessage$RSA_ServerKeyExchange);
}

-keep class sun.security.ssl.ClientHandshaker$2 {
	*** $SwitchMap$sun$security$ssl$CipherSuite$KeyExchange;
}

-keep class sun.security.ssl.CloneableDigest {
	*** digests;
	*** checkState();
	*** digestReset();
	*** getDigest(java.lang.String,int);
}

-keep class sun.security.ssl.DHClientKeyExchange {
	*** getClientPublicKey();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.DHCrypt {
	*** getAgreedSecret(java.math.BigInteger,boolean);
	*** getPublicKey();
}

-keep class sun.security.ssl.Debug {
	*** args;
	*** prefix;
	*** Help();
	*** getBooleanProperty(java.lang.String,boolean);
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.lang.String);
	*** isOn(java.lang.String);
	*** println(java.io.PrintStream,java.lang.String,byte[]);
	*** toString(byte[]);
}

-keep class sun.security.ssl.DummyX509KeyManager {
	*** INSTANCE;
}

-keep class sun.security.ssl.DummyX509TrustManager {
	*** INSTANCE;
}

-keep class sun.security.ssl.ECDHClientKeyExchange {
	*** encodedPoint;
	*** getEncodedPoint();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.ECDHCrypt {
	*** privateKey;
	*** publicKey;
	*** getAgreedSecret(byte[]);
	*** getAgreedSecret(java.security.PublicKey);
	*** getPublicKey();
}

-keep class sun.security.ssl.EngineArgs {
	*** $assertionsDisabled;
	*** appData;
	*** appLims;
	*** appPoss;
	*** appRemaining;
	*** len;
	*** netData;
	*** netLim;
	*** netPos;
	*** offset;
	*** wrapMethod;
	*** deltaApp();
	*** deltaNet();
	*** gather(int);
	*** getAppRemaining();
	*** init(java.nio.ByteBuffer,java.nio.ByteBuffer[],int,int);
	*** resetLim();
	*** resetPos();
	*** scatter(java.nio.ByteBuffer);
}

-keep class sun.security.ssl.EngineInputRecord {
	*** $assertionsDisabled;
	*** engine;
	*** internalData;
	*** tmpBB;
	*** bytesInCompletePacket(java.nio.ByteBuffer);
	*** checkMacTags(byte,java.nio.ByteBuffer,sun.security.ssl.MAC,boolean);
	*** compareMacTags(java.nio.ByteBuffer,byte[]);
	*** contentType();
	*** decrypt(sun.security.ssl.MAC,sun.security.ssl.CipherBox,java.nio.ByteBuffer);
	*** read(java.nio.ByteBuffer);
}

-keep class sun.security.ssl.EngineOutputRecord {
	*** $assertionsDisabled;
	*** engine;
	*** finishedMsg;
	*** writer;
	*** addMAC(sun.security.ssl.MAC,java.nio.ByteBuffer);
	*** encrypt(sun.security.ssl.CipherBox,java.nio.ByteBuffer);
	*** isFinishedMsg();
	*** recordSize(byte);
	*** setFinishedMsg();
	*** write(sun.security.ssl.EngineArgs,sun.security.ssl.MAC,sun.security.ssl.CipherBox);
	*** write(sun.security.ssl.EngineArgs,sun.security.ssl.MAC,sun.security.ssl.CipherBox,int);
	*** write(sun.security.ssl.MAC,sun.security.ssl.CipherBox);
}

-keep class sun.security.ssl.EngineWriter {
	*** $assertionsDisabled;
	*** debug;
	*** outboundClosed;
	*** outboundList;
	*** closeOutbound();
	*** dumpPacket(sun.security.ssl.EngineArgs,boolean);
	*** getOutboundData(java.nio.ByteBuffer);
	*** hasOutboundData();
	*** hasOutboundDataInternal();
	*** isOutboundDone();
	*** putOutboundData(java.nio.ByteBuffer);
	*** putOutboundDataSync(java.nio.ByteBuffer);
	*** writeRecord(sun.security.ssl.EngineOutputRecord,sun.security.ssl.EngineArgs,sun.security.ssl.MAC,sun.security.ssl.CipherBox);
	*** writeRecord(sun.security.ssl.EngineOutputRecord,sun.security.ssl.MAC,sun.security.ssl.CipherBox);
}

-keep class sun.security.ssl.EphemeralKeyManager {
	*** keys;
	*** getRSAKeyPair(boolean,java.security.SecureRandom);
}

-keep class sun.security.ssl.EphemeralKeyManager$EphemeralKeyPair {
	*** expirationTime;
	*** keyPair;
	*** uses;
	sun.security.ssl.EphemeralKeyManager$EphemeralKeyPair(java.security.KeyPair);
	*** access$100(sun.security.ssl.EphemeralKeyManager$EphemeralKeyPair);
	*** getKeyPair();
	*** isValid();
}

-keep class sun.security.ssl.ExtensionType {
	*** EXT_CERT_TYPE;
	*** EXT_CLIENT_CERTIFICATE_URL;
	*** EXT_EC_POINT_FORMATS;
	*** EXT_ELLIPTIC_CURVES;
	*** EXT_MAX_FRAGMENT_LENGTH;
	*** EXT_RENEGOTIATION_INFO;
	*** EXT_SERVER_NAME;
	*** EXT_SIGNATURE_ALGORITHMS;
	*** EXT_SRP;
	*** EXT_STATUS_REQUEST;
	*** EXT_TRUNCATED_HMAC;
	*** EXT_TRUSTED_CA_KEYS;
	*** EXT_USER_MAPPING;
	*** id;
	*** knownExtensions;
	*** name;
	*** e(int,java.lang.String);
	*** get(int);
}

-keep class sun.security.ssl.HandshakeHash {
	*** clonesNeeded;
	*** cvAlg;
	*** cvAlgDetermined;
	*** data;
	*** finMD;
	*** isServer;
	*** md5;
	*** sha;
	*** version;
	*** cloneDigest(java.security.MessageDigest);
	*** getAllHandshakeMessages();
	*** getFinishedHash();
	*** getMD5Clone();
	*** getSHAClone();
	*** normalizeAlgName(java.lang.String);
	*** protocolDetermined(sun.security.ssl.ProtocolVersion);
	*** reset();
	*** restrictCertificateVerifyAlgs(java.util.Set);
	*** setCertificateVerifyAlg(java.lang.String);
	*** setFinishedAlg(java.lang.String);
	*** update(byte[],int,int);
}

-keep class sun.security.ssl.HandshakeInStream {
	*** r;
	*** available();
	*** digestNow();
	*** getBytes16();
	*** getBytes24();
	*** getBytes8();
	*** getInt16();
	*** getInt24();
	*** getInt8();
	*** ignore(int);
	*** incomingRecord(sun.security.ssl.InputRecord);
	*** mark(int);
	*** read();
	*** read(byte[],int,int);
	*** reset();
	*** verifyLength(int);
}

-keep class sun.security.ssl.HandshakeMessage {
	*** MD5_pad1;
	*** MD5_pad2;
	*** SHA_pad1;
	*** SHA_pad2;
	*** debug;
	sun.security.ssl.HandshakeMessage();
	*** genPad(int,int);
	*** messageLength();
	*** messageType();
	*** print(java.io.PrintStream);
	*** send(sun.security.ssl.HandshakeOutStream);
	*** write(sun.security.ssl.HandshakeOutStream);
}

-keep class sun.security.ssl.HandshakeMessage$CertificateMsg {
	*** chain;
	*** encodedChain;
	*** messageLength;
	*** getCertificateChain();
	*** messageLength();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$CertificateRequest {
	*** TYPES_ECC;
	*** TYPES_NO_ECC;
	*** algorithms;
	*** algorithmsLen;
	*** authorities;
	*** protocolVersion;
	*** types;
	*** getAuthorities();
	*** getSignAlgorithms();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$CertificateVerify {
	*** NULL_OBJECT;
	*** delegate;
	*** methodCache;
	*** preferableSignatureAlgorithm;
	*** protocolVersion;
	*** signature;
	*** spiField;
	*** access$000(java.security.MessageDigest,byte[],byte[],javax.crypto.SecretKey);
	*** digestKey(java.security.MessageDigest,javax.crypto.SecretKey);
	*** getPreferableSignatureAlgorithm();
	*** getSignature(sun.security.ssl.ProtocolVersion,java.lang.String);
	*** makeAccessible(java.lang.reflect.AccessibleObject);
	*** print(java.io.PrintStream);
	*** updateDigest(java.security.MessageDigest,byte[],byte[],javax.crypto.SecretKey);
	*** updateSignature(java.security.Signature,sun.security.ssl.ProtocolVersion,sun.security.ssl.HandshakeHash,java.lang.String,javax.crypto.SecretKey);
	*** verify(sun.security.ssl.ProtocolVersion,sun.security.ssl.HandshakeHash,java.security.PublicKey,javax.crypto.SecretKey);
}

-keep class sun.security.ssl.HandshakeMessage$CertificateVerify$1 {
	*** val$o;
}

-keep class sun.security.ssl.HandshakeMessage$ClientHello {
	*** NULL_COMPRESSION;
	*** cipherSuites;
	*** clnt_random;
	*** compression_methods;
	*** extensions;
	*** protocolVersion;
	*** sessionId;
	*** addRenegotiationInfoExtension(byte[]);
	*** addServerNameIndicationExtension(java.lang.String);
	*** addSignatureAlgorithmsExtension(java.util.Collection);
	*** getCipherSuites();
	*** messageLength();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$DH_ServerKeyExchange {
	*** getBase();
	*** getModulus();
	*** getServerPublicKey();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$DistinguishedName {
	*** name;
	*** getX500Principal();
	*** length();
	*** print(java.io.PrintStream);
	*** send(sun.security.ssl.HandshakeOutStream);
}

-keep class sun.security.ssl.HandshakeMessage$ECDH_ServerKeyExchange {
	*** curveId;
	*** pointBytes;
	*** preferableSignatureAlgorithm;
	*** protocolVersion;
	*** publicKey;
	*** signatureBytes;
	*** getPublicKey();
	*** getSignature(java.lang.String);
	*** print(java.io.PrintStream);
	*** updateSignature(java.security.Signature,byte[],byte[]);
}

-keep class sun.security.ssl.HandshakeMessage$Finished {
	*** SSL_CLIENT;
	*** SSL_SERVER;
	*** cipherSuite;
	*** protocolVersion;
	*** verifyData;
	*** getFinished(sun.security.ssl.HandshakeHash,int,javax.crypto.SecretKey);
	*** getVerifyData();
	*** print(java.io.PrintStream);
	*** updateDigest(java.security.MessageDigest,byte[],byte[],byte[],javax.crypto.SecretKey);
	*** verify(sun.security.ssl.HandshakeHash,int,javax.crypto.SecretKey);
}

-keep class sun.security.ssl.HandshakeMessage$HelloRequest {
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$RSA_ServerKeyExchange {
	*** getPublicKey();
	*** print(java.io.PrintStream);
	*** verify(java.security.PublicKey,sun.security.ssl.RandomCookie,sun.security.ssl.RandomCookie);
}

-keep class sun.security.ssl.HandshakeMessage$ServerHello {
	*** cipherSuite;
	*** compression_method;
	*** extensions;
	*** protocolVersion;
	*** sessionId;
	*** svr_random;
	*** messageLength();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$ServerHelloDone {
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.HandshakeMessage$ServerKeyExchange {
	sun.security.ssl.HandshakeMessage$ServerKeyExchange();
}

-keep class sun.security.ssl.HandshakeOutStream {
	*** $assertionsDisabled;
	*** engine;
	*** r;
	*** socket;
	*** checkOverflow(int,int);
	*** doHashes();
	*** flush();
	*** init(sun.security.ssl.ProtocolVersion,sun.security.ssl.ProtocolVersion,sun.security.ssl.HandshakeHash);
	*** putBytes16(byte[]);
	*** putBytes24(byte[]);
	*** putBytes8(byte[]);
	*** putInt16(int);
	*** putInt24(int);
	*** putInt8(int);
	*** setFinishedMsg();
	*** write(byte[],int,int);
	*** write(int);
}

-keep class sun.security.ssl.Handshaker {
	*** activeCipherSuites;
	*** activeProtocolVersion;
	*** activeProtocols;
	*** algorithmConstraints;
	*** allowLegacyHelloMessages;
	*** allowUnsafeRenegotiation;
	*** cipherSuite;
	*** clientVerifyData;
	*** clntMacSecret;
	*** clntWriteIV;
	*** clntWriteKey;
	*** clnt_random;
	*** conn;
	*** debug;
	*** delegatedTask;
	*** enableNewSession;
	*** enabledCipherSuites;
	*** enabledProtocols;
	*** engine;
	*** handshakeHash;
	*** identificationProtocol;
	*** input;
	*** invalidated;
	*** isClient;
	*** isInitialHandshake;
	*** keyExchange;
	*** localSupportedSignAlgs;
	*** needCertVerify;
	*** output;
	*** peerSupportedSignAlgs;
	*** protocolVersion;
	*** resumingSession;
	*** secureRenegotiation;
	*** serverVerifyData;
	*** session;
	*** sslContext;
	*** state;
	*** svrMacSecret;
	*** svrWriteIV;
	*** svrWriteKey;
	*** svr_random;
	*** taskDelegated;
	*** thrown;
	*** thrownLock;
	sun.security.ssl.Handshaker(sun.security.ssl.SSLEngineImpl,sun.security.ssl.SSLContextImpl,sun.security.ssl.ProtocolList,boolean,boolean,sun.security.ssl.ProtocolVersion,boolean,boolean,byte[],byte[]);
	sun.security.ssl.Handshaker(sun.security.ssl.SSLSocketImpl,sun.security.ssl.SSLContextImpl,sun.security.ssl.ProtocolList,boolean,boolean,sun.security.ssl.ProtocolVersion,boolean,boolean,byte[],byte[]);
	*** access$002(sun.security.ssl.Handshaker,java.lang.Exception);
	*** access$102(sun.security.ssl.Handshaker,sun.security.ssl.Handshaker$DelegatedTask);
	*** access$202(sun.security.ssl.Handshaker,boolean);
	*** activate(sun.security.ssl.ProtocolVersion);
	*** activated();
	*** calculateConnectionKeys(javax.crypto.SecretKey);
	*** calculateKeys(javax.crypto.SecretKey,sun.security.ssl.ProtocolVersion);
	*** calculateMasterSecret(javax.crypto.SecretKey,sun.security.ssl.ProtocolVersion);
	*** checkThrown();
	*** delegateTask(java.security.PrivilegedExceptionAction);
	*** fatalSE(byte,java.lang.String);
	*** fatalSE(byte,java.lang.String,java.lang.Throwable);
	*** fatalSE(byte,java.lang.Throwable);
	*** getAccSE();
	*** getActiveCipherSuites();
	*** getActiveProtocols();
	*** getClientVerifyData();
	*** getHostAddressSE();
	*** getHostSE();
	*** getKickstartMessage();
	*** getLocalPortSE();
	*** getLocalSupportedSignAlgs();
	*** getPortSE();
	*** getRawHostnameSE();
	*** getServerVerifyData();
	*** getSession();
	*** getTask();
	*** handshakeAlert(byte);
	*** init(sun.security.ssl.SSLContextImpl,sun.security.ssl.ProtocolList,boolean,boolean,sun.security.ssl.ProtocolVersion,boolean,boolean,byte[],byte[]);
	*** isDone();
	*** isLoopbackSE();
	*** isNegotiable(sun.security.ssl.CipherSuite);
	*** isNegotiable(sun.security.ssl.ProtocolVersion);
	*** isSecureRenegotiation();
	*** kickstart();
	*** newReadCipher();
	*** newReadMAC();
	*** newWriteCipher();
	*** newWriteMAC();
	*** printHex(sun.misc.HexDumpEncoder,byte[]);
	*** processLoop();
	*** processMessage(byte,int);
	*** process_record(sun.security.ssl.InputRecord,boolean);
	*** selectProtocolVersion(sun.security.ssl.ProtocolVersion);
	*** sendChangeCipherSpec(sun.security.ssl.HandshakeMessage$Finished,boolean);
	*** setAlgorithmConstraints(java.security.AlgorithmConstraints);
	*** setCipherSuite(sun.security.ssl.CipherSuite);
	*** setEnableSessionCreation(boolean);
	*** setEnabledCipherSuites(sun.security.ssl.CipherSuiteList);
	*** setEnabledProtocols(sun.security.ssl.ProtocolList);
	*** setHandshakeSessionSE(sun.security.ssl.SSLSessionImpl);
	*** setIdentificationProtocol(java.lang.String);
	*** setPeerSupportedSignAlgs(java.util.Collection);
	*** setVersion(sun.security.ssl.ProtocolVersion);
	*** setVersionSE(sun.security.ssl.ProtocolVersion);
	*** started();
	*** taskOutstanding();
	*** throwSSLException(java.lang.String,java.lang.Throwable);
	*** warningSE(byte);
}

-keep class sun.security.ssl.Handshaker$1 {
	*** this$0;
	*** run();
}

-keep class sun.security.ssl.Handshaker$DelegatedTask {
	*** pea;
	*** this$0;
}

-keep class sun.security.ssl.HelloExtension {
	*** type;
	sun.security.ssl.HelloExtension(sun.security.ssl.ExtensionType);
	*** length();
	*** send(sun.security.ssl.HandshakeOutStream);
	*** toString();
}

-keep class sun.security.ssl.HelloExtensions {
	*** encodedLength;
	*** extensions;
	*** add(sun.security.ssl.HelloExtension);
	*** get(sun.security.ssl.ExtensionType);
	*** length();
	*** list();
	*** print(java.io.PrintStream);
	*** send(sun.security.ssl.HandshakeOutStream);
}

-keep class sun.security.ssl.InputRecord {
	*** appDataValid;
	*** debug;
	*** exlen;
	*** formatVerified;
	*** handshakeHash;
	*** helloVersion;
	*** isClosed;
	*** lastHashed;
	*** v2Buf;
	*** v2NoCipher;
	sun.security.ssl.InputRecord();
	*** V2toV3ClientHello(byte[]);
	*** calculateRemainingLen(sun.security.ssl.MAC,int,int);
	*** checkMacTags(byte,byte[],int,int,sun.security.ssl.MAC,boolean);
	*** close();
	*** compareMacTags(byte[],int,byte[]);
	*** contentName(int);
	*** contentType();
	*** decrypt(sun.security.ssl.MAC,sun.security.ssl.CipherBox);
	*** doHashes();
	*** enableFormatChecks();
	*** getHandshakeHash();
	*** getHelloVersion();
	*** handleUnknownRecord(java.io.InputStream,java.io.OutputStream);
	*** hashInternal(byte[],int,int);
	*** ignore(int);
	*** isAppDataValid();
	*** queueHandshake(sun.security.ssl.InputRecord);
	*** read(java.io.InputStream,java.io.OutputStream);
	*** readFully(java.io.InputStream,byte[],int,int);
	*** readV3Record(java.io.InputStream,java.io.OutputStream);
	*** setAppDataValid(boolean);
	*** setHandshakeHash(sun.security.ssl.HandshakeHash);
	*** setHelloVersion(sun.security.ssl.ProtocolVersion);
	*** writeBuffer(java.io.OutputStream,byte[],int,int);
}

-keep class sun.security.ssl.JsseJce {
	*** debug;
	*** ecAvailable;
	*** fipsProviderList;
	*** kerberosAvailable;
	*** beginFipsProvider();
	*** clearEcAvailable();
	*** decodePoint(byte[],java.security.spec.EllipticCurve);
	*** encodePoint(java.security.spec.ECPoint,java.security.spec.EllipticCurve);
	*** endFipsProvider(java.lang.Object);
	*** getCipher(java.lang.String);
	*** getECParameterSpec(java.lang.String);
	*** getKeyAgreement(java.lang.String);
	*** getKeyFactory(java.lang.String);
	*** getKeyGenerator(java.lang.String);
	*** getKeyPairGenerator(java.lang.String);
	*** getMD5();
	*** getMac(java.lang.String);
	*** getMessageDigest(java.lang.String);
	*** getNamedCurveOid(java.security.spec.ECParameterSpec);
	*** getRSAKeyLength(java.security.PublicKey);
	*** getRSAPublicKeySpec(java.security.PublicKey);
	*** getSHA();
	*** getSecureRandom();
	*** getSignature(java.lang.String);
	*** isEcAvailable();
	*** isKerberosAvailable();
}

-keep class sun.security.ssl.JsseJce$1 {
	*** run();
}

-keep class sun.security.ssl.KerberosClientKeyExchange {
	*** getLocalPrincipal();
	*** getPeerPrincipal();
	*** getUnencryptedPreMasterSecret();
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.KeyManagerFactoryImpl {
	*** isInitialized;
	*** keyManager;
	sun.security.ssl.KeyManagerFactoryImpl();
}

-keep class sun.security.ssl.Krb5Helper {
	*** getServerPrincipalName(javax.crypto.SecretKey);
	*** getServicePermission(java.lang.String,java.lang.String);
}

-keep class sun.security.ssl.MAC {
	*** NULL;
	*** block;
	*** mac;
	*** macAlg;
	*** macSize;
	*** nullMAC;
	*** MAClen();
	*** compute(byte,byte[],int,int,boolean);
	*** compute(byte,java.nio.ByteBuffer,boolean);
	*** compute(byte,java.nio.ByteBuffer,byte[],int,int,boolean);
	*** hashBlockLen();
	*** incrementSequenceNumber();
	*** minimalPaddingLen();
	*** seqNumIsHuge();
	*** seqNumOverflow();
}

-keep class sun.security.ssl.OutputRecord {
	*** $assertionsDisabled;
	*** V3toV2CipherMap1;
	*** V3toV2CipherMap3;
	*** contentType;
	*** debug;
	*** firstMessage;
	*** handshakeHash;
	*** helloVersion;
	*** lastHashed;
	*** protocolVersion;
	sun.security.ssl.OutputRecord(byte,int);
	*** V3toV2CipherSuite(byte,byte);
	*** V3toV2ClientHello(byte[]);
	*** addMAC(sun.security.ssl.MAC);
	*** availableDataBytes();
	*** contentType();
	*** doHashes();
	*** encrypt(sun.security.ssl.CipherBox);
	*** ensureCapacity(int);
	*** hashInternal(byte[],int,int);
	*** isAlert(byte);
	*** isEmpty();
	*** recordSize(byte);
	*** reset();
	*** setHandshakeHash(sun.security.ssl.HandshakeHash);
	*** setHelloVersion(sun.security.ssl.ProtocolVersion);
	*** setVersion(sun.security.ssl.ProtocolVersion);
	*** useV2Hello();
	*** write(java.io.OutputStream,boolean,java.io.ByteArrayOutputStream);
	*** writeBuffer(java.io.OutputStream,byte[],int,int,int);
}

-keep class sun.security.ssl.ProtocolList {
	*** helloVersion;
	*** max;
	*** min;
	*** protocolNames;
	*** protocols;
	sun.security.ssl.ProtocolList(java.util.ArrayList);
	*** collection();
	*** contains(sun.security.ssl.ProtocolVersion);
	*** convert(java.lang.String[]);
	*** selectProtocolVersion(sun.security.ssl.ProtocolVersion);
	*** toStringArray();
}

-keep class sun.security.ssl.ProtocolVersion {
	*** DEFAULT;
	*** DEFAULT_HELLO;
	*** FIPS;
	*** MAX;
	*** MIN;
	*** NONE;
	*** SSL20Hello;
	*** SSL30;
	*** TLS10;
	*** TLS11;
	*** TLS12;
	*** major;
	*** minor;
	*** name;
	*** v;
	*** compareTo(sun.security.ssl.ProtocolVersion);
	*** valueOf(int);
	*** valueOf(int,int);
	*** valueOf(java.lang.String);
}

-keep class sun.security.ssl.RSAClientKeyExchange {
	*** encrypted;
	*** preMaster;
	*** protocolVersion;
	*** rsaPreMasterSecretFix;
	*** generateDummySecret(sun.security.ssl.ProtocolVersion);
	*** polishPreMasterSecretKey(sun.security.ssl.ProtocolVersion,sun.security.ssl.ProtocolVersion,java.security.SecureRandom,javax.crypto.SecretKey,java.lang.Exception);
	*** print(java.io.PrintStream);
}

-keep class sun.security.ssl.RSASignature {
	*** isReset;
	*** md5;
	*** rawRsa;
	*** sha;
	*** checkNull(java.security.Key);
	*** engineInitSign(java.security.PrivateKey,java.security.SecureRandom);
	*** engineVerify(byte[],int,int);
	*** getDigest();
	*** getInstance();
	*** getInternalInstance();
	*** initDigests();
	*** reset();
	*** setHashes(java.security.Signature,java.security.MessageDigest,java.security.MessageDigest);
}

-keep class sun.security.ssl.RandomCookie {
	*** random_bytes;
	*** print(java.io.PrintStream);
	*** send(sun.security.ssl.HandshakeOutStream);
}

-keep class sun.security.ssl.Record {
	*** enableCBCProtection;
}

-keep class sun.security.ssl.RenegotiationInfoExtension {
	*** renegotiated_connection;
	*** getRenegotiatedConnection();
	*** isEmpty();
}

-keep class sun.security.ssl.SSLAlgorithmConstraints {
	*** enabledX509DisabledAlgConstraints;
	*** peerAlgConstraints;
	*** tlsDisabledAlgConstraints;
	*** userAlgConstraints;
	*** x509DisabledAlgConstraints;
}

-keep class sun.security.ssl.SSLAlgorithmConstraints$1 {
	*** $SwitchMap$sun$security$ssl$CipherSuite$KeyExchange;
}

-keep class sun.security.ssl.SSLAlgorithmConstraints$BasicDisabledAlgConstraints {
	sun.security.ssl.SSLAlgorithmConstraints$BasicDisabledAlgConstraints(java.lang.String);
	*** decomposes(sun.security.ssl.CipherSuite$BulkCipher);
	*** decomposes(sun.security.ssl.CipherSuite$KeyExchange,boolean);
	*** decomposes(sun.security.ssl.CipherSuite$MacAlg);
}

-keep class sun.security.ssl.SSLContextImpl {
	*** clientCache;
	*** debug;
	*** defaultAlgorithmConstraints;
	*** defaultClientCipherSuiteList;
	*** defaultClientProtocolList;
	*** defaultServerCipherSuiteList;
	*** defaultServerProtocolList;
	*** ephemeralKeyManager;
	*** isInitialized;
	*** keyManager;
	*** secureRandom;
	*** serverCache;
	*** supportedCipherSuiteList;
	*** supportedProtocolList;
	*** trustManager;
	sun.security.ssl.SSLContextImpl();
	*** access$100();
	*** chooseKeyManager(javax.net.ssl.KeyManager[]);
	*** chooseTrustManager(javax.net.ssl.TrustManager[]);
	*** clearAvailableCache();
	*** engineGetClientSessionContext();
	*** engineGetServerSessionContext();
	*** engineInit(javax.net.ssl.KeyManager[],javax.net.ssl.TrustManager[],java.security.SecureRandom);
	*** getApplicableCipherSuiteList(sun.security.ssl.ProtocolList,boolean);
	*** getDefaultCipherSuiteList(boolean);
	*** getDefaultClientSSLParams();
	*** getDefaultProtocolList(boolean);
	*** getDefaultServerSSLParams();
	*** getEphemeralKeyManager();
	*** getSecureRandom();
	*** getSuportedProtocolList();
	*** getSupportedCipherSuiteList();
	*** getSupportedSSLParams();
	*** getX509KeyManager();
	*** getX509TrustManager();
	*** isDefaultProtocolList(sun.security.ssl.ProtocolList);
}

-keep class sun.security.ssl.SSLContextImpl$ConservativeSSLContext {
	*** defaultClientSSLParams;
	*** defaultServerSSLParams;
	*** supportedSSLParams;
	sun.security.ssl.SSLContextImpl$ConservativeSSLContext();
	sun.security.ssl.SSLContextImpl$ConservativeSSLContext(sun.security.ssl.SSLContextImpl$1);
}

-keep class sun.security.ssl.SSLContextImpl$DefaultSSLContext {
	*** defaultImpl;
	*** defaultKeyManagers;
	*** defaultTrustManagers;
	*** getDefaultImpl();
	*** getDefaultKeyManager();
	*** getDefaultTrustManager();
}

-keep class sun.security.ssl.SSLContextImpl$DefaultSSLContext$1 {
	*** val$props;
}

-keep class sun.security.ssl.SSLEngineImpl {
	*** $assertionsDisabled;
	*** acc;
	*** algorithmConstraints;
	*** clientVerifyData;
	*** closeReason;
	*** connectionState;
	*** debug;
	*** doClientAuth;
	*** enableSessionCreation;
	*** enabledCipherSuites;
	*** enabledProtocols;
	*** expectingFinished;
	*** handshakeSession;
	*** handshaker;
	*** identificationProtocol;
	*** inboundDone;
	*** inputRecord;
	*** isFirstAppOutputRecord;
	*** outputRecord;
	*** protocolVersion;
	*** readCipher;
	*** readMAC;
	*** recvCN;
	*** roleIsServer;
	*** secureRenegotiation;
	*** serverModeSet;
	*** serverVerifyData;
	*** sess;
	*** sslContext;
	*** unwrapLock;
	*** wrapLock;
	*** writeCipher;
	*** writeLock;
	*** writeMAC;
	*** writer;
	*** beginHandshake();
	*** changeReadCiphers();
	*** changeWriteCiphers();
	*** checkSequenceNumber(sun.security.ssl.MAC,byte);
	*** checkTaskThrown();
	*** closeInboundInternal();
	*** closeOutboundInternal();
	*** fatal(byte,java.lang.String);
	*** fatal(byte,java.lang.String,java.lang.Throwable);
	*** fatal(byte,java.lang.Throwable);
	*** getAcc();
	*** getConnectionState();
	*** getHSStatus(javax.net.ssl.SSLEngineResult$HandshakeStatus);
	*** getSession();
	*** init(sun.security.ssl.SSLContextImpl);
	*** initHandshaker();
	*** isInboundDone();
	*** isOutboundDone();
	*** kickstartHandshake();
	*** needToSplitPayload(sun.security.ssl.CipherBox,sun.security.ssl.ProtocolVersion);
	*** readNetRecord(sun.security.ssl.EngineArgs);
	*** readRecord(sun.security.ssl.EngineArgs);
	*** recvAlert();
	*** sendAlert(byte,byte);
	*** setHandshakeSession(sun.security.ssl.SSLSessionImpl);
	*** setVersion(sun.security.ssl.ProtocolVersion);
	*** threadName();
	*** warning(byte);
	*** writeAppRecord(sun.security.ssl.EngineArgs);
	*** writeRecord(sun.security.ssl.EngineOutputRecord);
	*** writeRecord(sun.security.ssl.EngineOutputRecord,sun.security.ssl.EngineArgs);
}

-keep class sun.security.ssl.SSLServerSocketFactoryImpl {
	*** context;
}

-keep class sun.security.ssl.SSLServerSocketImpl {
	*** algorithmConstraints;
	*** checkedEnabled;
	*** doClientAuth;
	*** enableSessionCreation;
	*** enabledCipherSuites;
	*** enabledProtocols;
	*** identificationProtocol;
	*** sslContext;
	*** useServerMode;
	*** initServer(sun.security.ssl.SSLContextImpl);
}

-keep class sun.security.ssl.SSLSessionContextImpl {
	*** cacheLimit;
	*** debug;
	*** sessionCache;
	*** sessionHostPortCache;
	*** timeout;
	*** get(byte[]);
	*** get(java.lang.String,int);
	*** getDefaultCacheLimit();
	*** getKey(java.lang.String,int);
	*** getSession(byte[]);
	*** isTimedout(javax.net.ssl.SSLSession);
	*** put(sun.security.ssl.SSLSessionImpl);
	*** remove(sun.security.ssl.SessionId);
}

-keep class sun.security.ssl.SSLSessionContextImpl$1 {
	*** this$0;
	*** run();
}

-keep class sun.security.ssl.SSLSessionContextImpl$SessionCacheVisitor {
	*** getSessionIds();
}

-keep class sun.security.ssl.SSLSessionImpl {
	*** acceptLargeFragments;
	*** cipherSuite;
	*** compressionMethod;
	*** context;
	*** counter;
	*** creationTime;
	*** debug;
	*** defaultRejoinable;
	*** host;
	*** invalidated;
	*** lastUsedTime;
	*** localCerts;
	*** localPrincipal;
	*** localPrivateKey;
	*** localSupportedSignAlgs;
	*** masterSecret;
	*** nullSession;
	*** peerCerts;
	*** peerPrincipal;
	*** peerSupportedSignAlgs;
	*** port;
	*** protocolVersion;
	*** sessionCount;
	*** sessionId;
	*** table;
	sun.security.ssl.SSLSessionImpl(sun.security.ssl.ProtocolVersion,sun.security.ssl.CipherSuite,java.util.Collection,sun.security.ssl.SessionId,java.lang.String,int);
	*** expandBufferSizes();
	*** getCipherSuite();
	*** getCompression();
	*** getLocalPrincipal();
	*** getMasterSecret();
	*** getPacketBufferSize();
	*** getPeerCertificates();
	*** getPeerHost();
	*** getPeerPort();
	*** getPeerPrincipal();
	*** getProtocolVersion();
	*** getSessionId();
	*** getSuite();
	*** getValueNames();
	*** invalidate();
	*** isLocalAuthenticationValid();
	*** isRejoinable();
	*** removeValue(java.lang.String);
	*** setContext(sun.security.ssl.SSLSessionContextImpl);
	*** setLastAccessedTime(long);
	*** setLocalCertificates(java.security.cert.X509Certificate[]);
	*** setLocalPrincipal(java.security.Principal);
	*** setLocalPrivateKey(java.security.PrivateKey);
	*** setMasterSecret(javax.crypto.SecretKey);
	*** setPeerCertificates(java.security.cert.X509Certificate[]);
	*** setPeerPrincipal(java.security.Principal);
	*** setPeerSupportedSignatureAlgorithms(java.util.Collection);
	*** setSuite(sun.security.ssl.CipherSuite);
}

-keep class sun.security.ssl.SSLSocketFactoryImpl {
	*** context;
}

-keep class sun.security.ssl.SSLSocketImpl {
	*** $assertionsDisabled;
	*** acc;
	*** algorithmConstraints;
	*** autoClose;
	*** clientVerifyData;
	*** closeReason;
	*** connectionState;
	*** debug;
	*** doClientAuth;
	*** enableSessionCreation;
	*** enabledCipherSuites;
	*** enabledProtocols;
	*** expectingFinished;
	*** handshakeListeners;
	*** handshakeLock;
	*** handshakeSession;
	*** handshaker;
	*** heldRecordBuffer;
	*** host;
	*** identificationProtocol;
	*** input;
	*** inrec;
	*** isFirstAppOutputRecord;
	*** output;
	*** protocolVersion;
	*** rawHostname;
	*** readCipher;
	*** readLock;
	*** readMAC;
	*** roleIsServer;
	*** secureRenegotiation;
	*** serverVerifyData;
	*** sess;
	*** sockInput;
	*** sockOutput;
	*** sslContext;
	*** writeCipher;
	*** writeLock;
	*** writeMAC;
	*** bind(java.net.SocketAddress);
	*** changeReadCiphers();
	*** changeWriteCiphers();
	*** checkEOF();
	*** checkSequenceNumber(sun.security.ssl.MAC,byte);
	*** checkWrite();
	*** close();
	*** closeInternal(boolean);
	*** closeSocket();
	*** closeSocket(boolean);
	*** connect(java.net.SocketAddress,int);
	*** disposeCiphers();
	*** doneConnect();
	*** fatal(byte,java.lang.String);
	*** fatal(byte,java.lang.String,java.lang.Throwable);
	*** fatal(byte,java.lang.Throwable);
	*** getAcc();
	*** getAppInputStream();
	*** getAppOutputStream();
	*** getConnectionState();
	*** getHost();
	*** getRawHostname();
	*** handleException(java.lang.Exception);
	*** handleException(java.lang.Exception,boolean);
	*** init(sun.security.ssl.SSLContextImpl,boolean);
	*** initHandshaker();
	*** isClosed();
	*** kickstartHandshake();
	*** needToSplitPayload();
	*** performInitialHandshake();
	*** readDataRecord(sun.security.ssl.InputRecord);
	*** readRecord(sun.security.ssl.InputRecord,boolean);
	*** recvAlert(sun.security.ssl.InputRecord);
	*** sendAlert(byte,byte);
	*** setConnectionState(int);
	*** setHandshakeSession(sun.security.ssl.SSLSessionImpl);
	*** setVersion(sun.security.ssl.ProtocolVersion);
	*** startHandshake();
	*** startHandshake(boolean);
	*** threadName();
	*** waitForClose(boolean);
	*** warning(byte);
	*** writeRecord(sun.security.ssl.OutputRecord);
	*** writeRecord(sun.security.ssl.OutputRecord,boolean);
	*** writeRecordInternal(sun.security.ssl.OutputRecord,boolean);
}

-keep class sun.security.ssl.SSLSocketImpl$NotifyHandshakeThread {
	*** event;
	*** targets;
	*** access$000(sun.security.ssl.SSLSocketImpl$NotifyHandshakeThread);
}

-keep class sun.security.ssl.SSLSocketImpl$NotifyHandshakeThread$1 {
	*** this$0;
	*** val$l;
	*** run();
}

-keep class sun.security.ssl.SecureKey {
	*** appKey;
	*** nullObject;
	*** securityCtx;
	*** getAppKey();
	*** getCurrentSecurityContext();
	*** getSecurityContext();
}

-keep class sun.security.ssl.ServerHandshaker {
	*** certs;
	*** clientRequestedVersion;
	*** dh;
	*** doClientAuth;
	*** ecdh;
	*** kerberosKeys;
	*** needClientVerify;
	*** preferableSignatureAlgorithm;
	*** privateKey;
	*** supportedCurves;
	*** tempPrivateKey;
	*** tempPublicKey;
	*** chooseCipherSuite(sun.security.ssl.HandshakeMessage$ClientHello);
	*** clientCertificate(sun.security.ssl.HandshakeMessage$CertificateMsg);
	*** clientCertificateVerify(sun.security.ssl.HandshakeMessage$CertificateVerify);
	*** clientFinished(sun.security.ssl.HandshakeMessage$Finished);
	*** clientHello(sun.security.ssl.HandshakeMessage$ClientHello);
	*** clientKeyExchange(sun.security.ssl.DHClientKeyExchange);
	*** clientKeyExchange(sun.security.ssl.ECDHClientKeyExchange);
	*** clientKeyExchange(sun.security.ssl.KerberosClientKeyExchange);
	*** clientKeyExchange(sun.security.ssl.RSAClientKeyExchange);
	*** sendChangeCipherAndFinish(boolean);
	*** setClientAuth(byte);
	*** setupEphemeralDHKeys(boolean);
	*** setupEphemeralECDHKeys();
	*** setupEphemeralRSAKeys(boolean);
	*** setupKerberosKeys();
	*** setupPrivateKeyAndChain(java.lang.String);
	*** setupStaticECDHKeys();
	*** trySetCipherSuite(sun.security.ssl.CipherSuite);
}

-keep class sun.security.ssl.ServerHandshaker$3 {
	*** $SwitchMap$sun$security$ssl$CipherSuite$KeyExchange;
}

-keep class sun.security.ssl.ServerNameExtension {
	*** listLength;
	*** names;
}

-keep class sun.security.ssl.ServerNameExtension$ServerName {
	*** data;
	*** hostname;
	*** length;
	*** type;
}

-keep class sun.security.ssl.SessionId {
	*** sessionId;
	*** equals(java.lang.Object);
	*** getId();
	*** hashCode();
	*** length();
}

-keep class sun.security.ssl.SignatureAlgorithmsExtension {
	*** getSignAlgorithms();
}

-keep class sun.security.ssl.SignatureAndHashAlgorithm {
	*** SIGNATURE_PRIMITIVE_SET;
	*** algorithm;
	*** hash;
	*** id;
	*** priority;
	*** priorityMap;
	*** signature;
	*** supportedMap;
	*** getAlgorithmName();
	*** getAlgorithmNames(java.util.Collection);
	*** getHashAlgorithmName(sun.security.ssl.SignatureAndHashAlgorithm);
	*** getHashAlgorithmNames(java.util.Collection);
	*** getHashValue();
	*** getPreferableAlgorithm(java.util.Collection,java.lang.String);
	*** getPreferableAlgorithm(java.util.Collection,java.lang.String,java.security.PrivateKey);
	*** getSignatureValue();
	*** getSupportedAlgorithms(java.security.AlgorithmConstraints);
	*** getSupportedAlgorithms(java.util.Collection);
	*** sizeInRecord();
	*** supports(sun.security.ssl.SignatureAndHashAlgorithm$HashAlgorithm,sun.security.ssl.SignatureAndHashAlgorithm$SignatureAlgorithm,java.lang.String,int);
	*** valueOf(int,int,int);
}

-keep class sun.security.ssl.SignatureAndHashAlgorithm$HashAlgorithm {
	*** $VALUES;
	*** MD5;
	*** NONE;
	*** SHA1;
	*** SHA224;
	*** SHA256;
	*** SHA384;
	*** SHA512;
	*** UNDEFINED;
	*** length;
	*** name;
	*** standardName;
	*** value;
	*** valueOf(int);
}

-keep class sun.security.ssl.SignatureAndHashAlgorithm$SignatureAlgorithm {
	*** $VALUES;
	*** ANONYMOUS;
	*** DSA;
	*** ECDSA;
	*** RSA;
	*** UNDEFINED;
	*** name;
	*** value;
	*** valueOf(int);
}

-keep class sun.security.ssl.SunJSSE {
	*** cryptoProvider;
	*** fips;
	*** fipsInfo;
	*** info;
	sun.security.ssl.SunJSSE();
	sun.security.ssl.SunJSSE(java.lang.String);
	sun.security.ssl.SunJSSE(java.security.Provider);
	sun.security.ssl.SunJSSE(java.security.Provider,java.lang.String);
	*** access$000(sun.security.ssl.SunJSSE,boolean);
	*** checkNull(java.lang.Object);
	*** doRegister(boolean);
	*** ensureFIPS(java.security.Provider);
	*** isFIPS();
	*** registerAlgorithms(boolean);
	*** subclassCheck();
}

-keep class sun.security.ssl.SunJSSE$1 {
	*** this$0;
	*** val$isfips;
}

-keep class sun.security.ssl.SunX509KeyManagerImpl {
	*** STRING0;
	*** credentialsMap;
	*** debug;
	*** serverAliasCache;
	*** chooseClientAlias(java.lang.String[],java.security.Principal[],java.net.Socket);
	*** chooseServerAlias(java.lang.String,java.security.Principal[],java.net.Socket);
	*** convertPrincipals(java.security.Principal[]);
	*** getAliases(java.lang.String,java.security.Principal[]);
	*** getClientAliases(java.lang.String,java.security.Principal[]);
	*** getServerAliases(java.lang.String,java.security.Principal[]);
}

-keep class sun.security.ssl.SunX509KeyManagerImpl$X509Credentials {
	*** certificates;
	*** issuerX500Principals;
	*** privateKey;
	*** getIssuerX500Principals();
}

-keep class sun.security.ssl.SupportedEllipticCurvesExtension {
	*** DEFAULT;
	*** NAMED_CURVE_OID_TABLE;
	*** curveIds;
	*** curveIndices;
	*** fips;
	*** contains(int);
	*** curveIds();
	*** getCurveIndex(java.security.spec.ECParameterSpec);
	*** getCurveOid(int);
	*** isSupported(int);
}

-keep class sun.security.ssl.SupportedEllipticPointFormatsExtension {
	*** DEFAULT;
	*** formats;
	*** toString(byte);
}

-keep class sun.security.ssl.TrustManagerFactoryImpl {
	*** debug;
	*** isInitialized;
	*** trustManager;
	sun.security.ssl.TrustManagerFactoryImpl();
	*** getCacertsKeyStore(java.lang.String);
	*** getFileInputStream(java.io.File);
	*** getInstance(java.security.KeyStore);
	*** getInstance(javax.net.ssl.ManagerFactoryParameters);
}

-keep class sun.security.ssl.TrustManagerFactoryImpl$1 {
	*** val$file;
	*** run();
}

-keep class sun.security.ssl.TrustManagerFactoryImpl$2 {
	*** val$props;
	*** run();
}

-keep class sun.security.ssl.X509TrustManagerImpl {
	*** clientValidator;
	*** debug;
	*** pkixParams;
	*** serverValidator;
	*** trustedCerts;
	*** validatorType;
	*** checkIdentity(java.lang.String,java.security.cert.X509Certificate,java.lang.String);
	*** checkTrusted(java.security.cert.X509Certificate[],java.lang.String,java.net.Socket,boolean);
	*** checkTrusted(java.security.cert.X509Certificate[],java.lang.String,javax.net.ssl.SSLEngine,boolean);
	*** checkTrustedInit(java.security.cert.X509Certificate[],java.lang.String,boolean);
	*** getValidator(java.lang.String);
	*** showTrustedCerts();
	*** validate(sun.security.validator.Validator,java.security.cert.X509Certificate[],java.security.AlgorithmConstraints,java.lang.String);
}

-keep class sun.security.timestamp.TimestampToken {
	*** getDate();
	*** getHashAlgorithm();
	*** getHashedMessage();
	*** getSerialNumber();
}

-keep class sun.security.util.BitArray {
	*** NYBBLE;
	*** length;
	*** repn;
	*** clone();
	*** get(int);
	*** length();
	*** position(int);
	*** set(int,boolean);
	*** subscript(int);
	*** toBooleanArray();
	*** toByteArray();
	*** truncate();
}

-keep class sun.security.util.ByteArrayLexOrder {
	*** compare(byte[],byte[]);
}

-keep class sun.security.util.ByteArrayTagOrder {
	*** compare(byte[],byte[]);
}

-keep class sun.security.util.Cache {
	sun.security.util.Cache();
	*** accept(sun.security.util.Cache$CacheVisitor);
	*** clear();
	*** get(java.lang.Object);
	*** newSoftMemoryCache(int);
	*** newSoftMemoryCache(int,int);
	*** put(java.lang.Object,java.lang.Object);
	*** remove(java.lang.Object);
	*** setCapacity(int);
	*** setTimeout(int);
}

-keep class sun.security.util.Cache$CacheVisitor {
	*** visit(java.util.Map);
}

-keep class sun.security.util.Cache$EqualByteArray {
	*** b;
	*** hash;
}

-keep class sun.security.util.Debug {
	*** getInstance(java.lang.String);
	*** getInstance(java.lang.String,java.lang.String);
	*** isOn(java.lang.String);
	*** println();
	*** println(java.lang.String);
	*** toHexString(java.math.BigInteger);
	*** toString(byte[]);
}

-keep class sun.security.util.DerEncoder {
	*** derEncode(java.io.OutputStream);
}

-keep class sun.security.util.DerIndefLenConverter {
	*** data;
	*** dataPos;
	*** dataSize;
	*** index;
	*** ndefsList;
	*** newData;
	*** newDataPos;
	*** numOfTotalLenBytes;
	*** unresolved;
	*** convert(byte[]);
	*** getLengthBytes(int);
	*** isEOC(int);
	*** isIndefinite(int);
	*** isLongForm(int);
	*** parseLength();
	*** parseTag();
	*** parseValue(int);
	*** writeLength(int);
	*** writeLengthAndValue();
	*** writeTag();
	*** writeValue(int);
}

-keep class sun.security.util.DerInputBuffer {
	*** dup();
	*** equals(sun.security.util.DerInputBuffer);
	*** getBigInteger(int,boolean);
	*** getBitString();
	*** getBitString(int);
	*** getGeneralizedTime(int);
	*** getInteger(int);
	*** getTime(int,boolean);
	*** getUTCTime(int);
	*** getUnalignedBitString();
	*** peek();
	*** toByteArray();
	*** truncate(int);
}

-keep class sun.security.util.DerInputStream {
	*** buffer;
	*** tag;
	*** available();
	*** getBigInteger();
	*** getByte();
	*** getBytes(byte[]);
	*** getDerValue();
	*** getGeneralizedTime();
	*** getInteger();
	*** getLength();
	*** getLength(int,java.io.InputStream);
	*** getLength(java.io.InputStream);
	*** getOID();
	*** getOctetString();
	*** getSequence(int);
	*** getSet(int);
	*** getSet(int,boolean);
	*** getUTCTime();
	*** getUnalignedBitString();
	*** init(byte[],int,int);
	*** mark(int);
	*** peekByte();
	*** readString(byte,java.lang.String,java.lang.String);
	*** readVector(int);
	*** reset();
	*** subStream(int,boolean);
	*** toByteArray();
}

-keep class sun.security.util.DerOutputStream {
	*** lexOrder;
	*** tagOrder;
	*** putBitString(byte[]);
	*** putBoolean(boolean);
	*** putDerValue(sun.security.util.DerValue);
	*** putGeneralizedTime(java.util.Date);
	*** putIA5String(java.lang.String);
	*** putInteger(int);
	*** putInteger(java.math.BigInteger);
	*** putIntegerContents(int);
	*** putLength(int);
	*** putNull();
	*** putOID(sun.security.util.ObjectIdentifier);
	*** putOctetString(byte[]);
	*** putOrderedSet(byte,sun.security.util.DerEncoder[],java.util.Comparator);
	*** putOrderedSetOf(byte,sun.security.util.DerEncoder[]);
	*** putPrintableString(java.lang.String);
	*** putSequence(sun.security.util.DerValue[]);
	*** putTime(java.util.Date,byte);
	*** putTruncatedUnalignedBitString(sun.security.util.BitArray);
	*** putUTCTime(java.util.Date);
	*** putUnalignedBitString(sun.security.util.BitArray);
	*** write(byte,byte[]);
	*** write(byte,sun.security.util.DerOutputStream);
	*** writeImplicit(byte,sun.security.util.DerOutputStream);
	*** writeString(java.lang.String,byte,java.lang.String);
}

-keep class sun.security.util.DerValue {
	*** buffer;
	*** data;
	*** length;
	*** tag;
	*** append(byte[],byte[]);
	*** createTag(byte,boolean,byte);
	*** doEquals(sun.security.util.DerValue,sun.security.util.DerValue);
	*** encode(sun.security.util.DerOutputStream);
	*** equals(sun.security.util.DerValue);
	*** getAsString();
	*** getBMPString();
	*** getBigInteger();
	*** getBitString();
	*** getBoolean();
	*** getData();
	*** getDataBytes();
	*** getGeneralString();
	*** getIA5String();
	*** getInteger();
	*** getOID();
	*** getOctetString();
	*** getPositiveBigInteger();
	*** getPrintableString();
	*** getT61String();
	*** getTag();
	*** getUTF8String();
	*** getUnalignedBitString();
	*** init(boolean,java.io.InputStream);
	*** init(byte,java.lang.String);
	*** isConstructed();
	*** isConstructed(byte);
	*** isContextSpecific();
	*** isContextSpecific(byte);
	*** isPrintableStringChar(char);
	*** length();
	*** resetTag(byte);
	*** toByteArray();
	*** toDerInputStream();
	*** toString();
}

-keep class sun.security.util.DisabledAlgorithmConstraints {
	*** disabledAlgorithms;
	*** disabledAlgorithmsMap;
	*** keySizeConstraints;
	*** keySizeConstraintsMap;
	sun.security.util.DisabledAlgorithmConstraints(java.lang.String);
	*** checkConstraints(java.util.Set,java.lang.String,java.security.Key,java.security.AlgorithmParameters);
	*** decomposes(java.lang.String);
	*** loadDisabledAlgorithmsMap(java.lang.String);
	*** permits(java.util.Set,java.lang.String,java.security.AlgorithmParameters);
	*** permits(java.util.Set,java.lang.String,java.security.Key,java.security.AlgorithmParameters);
}

-keep class sun.security.util.DisabledAlgorithmConstraints$1 {
	*** val$propertyName;
	*** run();
}

-keep class sun.security.util.DisabledAlgorithmConstraints$2 {
	*** $SwitchMap$sun$security$util$DisabledAlgorithmConstraints$KeySizeConstraint$Operator;
}

-keep class sun.security.util.DisabledAlgorithmConstraints$KeySizeConstraint {
	*** maxSize;
	*** minSize;
	*** prohibitedSize;
	*** disables(java.security.Key);
}

-keep class sun.security.util.DisabledAlgorithmConstraints$KeySizeConstraint$Operator {
	*** $VALUES;
	*** EQ;
	*** GE;
	*** GT;
	*** LE;
	*** LT;
	*** NE;
	*** of(java.lang.String);
	*** values();
}

-keep class sun.security.util.DisabledAlgorithmConstraints$KeySizeConstraints {
	*** constraintsMap;
	*** pattern;
	*** disables(java.security.Key);
}

-keep class sun.security.util.HostnameChecker {
	*** getInstance(byte);
	*** match(java.lang.String,java.security.cert.X509Certificate);
}

-keep class sun.security.util.KeyUtil {
	*** getKeySize(java.security.Key);
	*** validateDHPublicKey(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger);
	*** validateDHPublicKey(javax.crypto.interfaces.DHPublicKey);
	*** validateDHPublicKey(javax.crypto.spec.DHPublicKeySpec);
}

-keep class sun.security.util.Length {
	*** length();
}

-keep class sun.security.util.ManifestDigester {
	*** entries;
	*** rawBytes;
	*** findSection(int,sun.security.util.ManifestDigester$Position);
	*** get(java.lang.String,boolean);
	*** isNameAttr(byte[],int);
	*** manifestDigest(java.security.MessageDigest);
}

-keep class sun.security.util.ManifestDigester$Entry {
	*** length;
	*** lengthWithBlankLine;
	*** offset;
	*** oldStyle;
	*** rawBytes;
	*** digest(java.security.MessageDigest);
	*** digestWorkaround(java.security.MessageDigest);
	*** doOldStyle(java.security.MessageDigest,byte[],int,int);
}

-keep class sun.security.util.ManifestDigester$Position {
	*** endOfFirstLine;
	*** endOfSection;
	*** startOfNext;
}

-keep class sun.security.util.ManifestEntryVerifier {
	*** createdDigests;
	*** debug;
	*** decoder;
	*** digests;
	*** entry;
	*** hexc;
	*** man;
	*** manifestHashes;
	*** name;
	*** signers;
	*** skip;
	*** getEntry();
	*** setEntry(java.lang.String,java.util.jar.JarEntry);
	*** toHex(byte[]);
	*** update(byte);
	*** update(byte[],int,int);
	*** verify(java.util.Hashtable,java.util.Hashtable);
}

-keep class sun.security.util.ManifestEntryVerifier$SunProviderHolder {
	*** instance;
	*** access$000();
}

-keep class sun.security.util.MemoryCache {
	*** cacheMap;
	*** lifetime;
	*** maxSize;
	*** queue;
	sun.security.util.MemoryCache(boolean,int,int);
	*** emptyQueue();
	*** expungeExpiredEntries();
	*** getCachedEntries();
	*** newEntry(java.lang.Object,java.lang.Object,long,java.lang.ref.ReferenceQueue);
}

-keep class sun.security.util.MemoryCache$CacheEntry {
	*** getKey();
	*** getValue();
	*** invalidate();
	*** isValid(long);
}

-keep class sun.security.util.MemoryCache$SoftCacheEntry {
	*** expirationTime;
	*** key;
	*** invalidate();
}

-keep class sun.security.util.NullCache {
	*** INSTANCE;
}

-keep class sun.security.util.ObjectIdentifier {
	*** $assertionsDisabled;
	*** componentLen;
	*** components;
	*** componentsCalculated;
	*** encoding;
	*** stringForm;
	*** check(byte[]);
	*** checkCount(int);
	*** checkFirstComponent(int);
	*** checkFirstComponent(java.math.BigInteger);
	*** checkOtherComponent(int,int);
	*** checkOtherComponent(int,java.math.BigInteger);
	*** checkSecondComponent(int,int);
	*** checkSecondComponent(int,java.math.BigInteger);
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object);
	*** equals(sun.security.util.ObjectIdentifier);
	*** hashCode();
	*** init(int[],int);
	*** newInternal(int[]);
	*** pack(byte[],int,int,int,int);
	*** pack7Oid(byte[],int,int,byte[],int);
	*** pack7Oid(int,byte[],int);
	*** pack7Oid(java.math.BigInteger,byte[],int);
	*** toIntArray();
	*** toString();
}

-keep class sun.security.util.ObjectIdentifier$HugeOidNotSupportedByOldJDK {
	*** theOne;
}

-keep class sun.security.util.Password {
	*** readPassword(java.io.InputStream);
}

-keep class sun.security.util.PolicyUtil {
	*** getInputStream(java.net.URL);
	*** getKeyStore(java.net.URL,java.lang.String,java.lang.String,java.lang.String,java.lang.String,sun.security.util.Debug);
}

-keep class sun.security.util.PropertyExpander {
	*** expand(java.lang.String);
	*** expand(java.lang.String,boolean);
}

-keep class sun.security.util.ResourcesMgr {
	*** getString(java.lang.String);
}

-keep class sun.security.util.SecurityConstants {
	*** ALL_PERMISSION;
	*** CHECK_MEMBER_ACCESS_PERMISSION;
	*** CREATE_ACC_PERMISSION;
	*** CREATE_CLASSLOADER_PERMISSION;
	*** GET_CLASSLOADER_PERMISSION;
	*** GET_COMBINER_PERMISSION;
	*** GET_COOKIEHANDLER_PERMISSION;
	*** GET_PD_PERMISSION;
	*** GET_POLICY_PERMISSION;
	*** GET_PROXYSELECTOR_PERMISSION;
	*** GET_RESPONSECACHE_PERMISSION;
	*** GET_STACK_TRACE_PERMISSION;
	*** LOCAL_LISTEN_PERMISSION;
	*** MODIFY_THREADGROUP_PERMISSION;
	*** MODIFY_THREAD_PERMISSION;
	*** SET_COOKIEHANDLER_PERMISSION;
	*** SET_PROXYSELECTOR_PERMISSION;
	*** SET_RESPONSECACHE_PERMISSION;
	*** SPECIFY_HANDLER_PERMISSION;
	*** STOP_THREAD_PERMISSION;
}

-keep class sun.security.util.SecurityConstants$AWT {
	*** ALL_AWT_EVENTS_PERMISSION;
	*** SET_WINDOW_ALWAYS_ON_TOP_PERMISSION;
	*** TOOLKIT_MODALITY_PERMISSION;
}

-keep class sun.security.util.SignatureFileVerifier {
	*** ATTR_DIGEST;
	*** block;
	*** certificateFactory;
	*** createdDigests;
	*** debug;
	*** hexc;
	*** md;
	*** name;
	*** sfBytes;
	*** signerCache;
	*** workaround;
	*** contains(java.security.CodeSigner[],java.security.CodeSigner);
	*** getDigest(java.lang.String);
	*** getSigners(sun.security.pkcs.SignerInfo[],sun.security.pkcs.PKCS7);
	*** getTimestamp(sun.security.pkcs.SignerInfo);
	*** isBlockOrSF(java.lang.String);
	*** isSubSet(java.security.CodeSigner[],java.security.CodeSigner[]);
	*** matches(java.security.CodeSigner[],java.security.CodeSigner[],java.security.CodeSigner[]);
	*** needSignatureFile(java.lang.String);
	*** needSignatureFileBytes();
	*** process(java.util.Hashtable,java.util.List);
	*** processImpl(java.util.Hashtable,java.util.List);
	*** setSignatureFile(byte[]);
	*** toHex(byte[]);
	*** updateSigners(java.security.CodeSigner[],java.util.Hashtable,java.lang.String);
	*** verifyManifestHash(java.util.jar.Manifest,sun.security.util.ManifestDigester,sun.misc.BASE64Decoder,java.util.List);
	*** verifyManifestMainAttrs(java.util.jar.Manifest,sun.security.util.ManifestDigester,sun.misc.BASE64Decoder);
	*** verifySection(java.util.jar.Attributes,java.lang.String,sun.security.util.ManifestDigester,sun.misc.BASE64Decoder);
	*** verifyTimestamp(sun.security.timestamp.TimestampToken,byte[]);
}

-keep class sun.security.util.UntrustedCertificates {
	*** untrustedCerts;
	*** add(java.lang.String,java.lang.String);
	*** isUntrusted(java.security.cert.X509Certificate);
}

-keep class sun.security.validator.EndEntityChecker {
	*** KU_SERVER_ENCRYPTION;
	*** KU_SERVER_KEY_AGREEMENT;
	*** KU_SERVER_SIGNATURE;
	*** type;
	*** variant;
	*** check(java.security.cert.X509Certificate,java.lang.Object);
	*** checkCodeSigning(java.security.cert.X509Certificate);
	*** checkEKU(java.security.cert.X509Certificate,java.util.Set,java.lang.String);
	*** checkKeyUsage(java.security.cert.X509Certificate,int);
	*** checkRemainingExtensions(java.util.Set);
	*** checkTLSClient(java.security.cert.X509Certificate);
	*** checkTLSServer(java.security.cert.X509Certificate,java.lang.String);
	*** checkTSAServer(java.security.cert.X509Certificate);
	*** getCriticalExtensions(java.security.cert.X509Certificate);
	*** getInstance(java.lang.String,java.lang.String);
}

-keep class sun.security.validator.KeyStores {
	*** getTrustedCerts(java.security.KeyStore);
}

-keep class sun.security.validator.PKIXValidator {
	*** certPathLength;
	*** checkTLSRevocation;
	*** factory;
	*** parameterTemplate;
	*** plugin;
	*** trustedCerts;
	*** trustedSubjects;
	*** doBuild(java.security.cert.X509Certificate[],java.util.Collection,java.security.cert.PKIXBuilderParameters);
	*** doValidate(java.security.cert.X509Certificate[],java.security.cert.PKIXBuilderParameters);
	*** isSignatureValid(java.util.List,java.security.cert.X509Certificate);
	*** setDate(java.security.cert.PKIXBuilderParameters);
	*** setDefaultParameters(java.lang.String);
	*** toArray(java.security.cert.CertPath,java.security.cert.TrustAnchor);
}

-keep class sun.security.validator.SimpleValidator {
	*** OBJID_NETSCAPE_CERT_TYPE;
	*** trustedCerts;
	*** trustedX500Principals;
	*** buildTrustedChain(java.security.cert.X509Certificate[]);
	*** checkBasicConstraints(java.security.cert.X509Certificate,java.util.Set,int);
	*** checkExtensions(java.security.cert.X509Certificate,int);
	*** checkKeyUsage(java.security.cert.X509Certificate,java.util.Set);
	*** checkNetscapeCertType(java.security.cert.X509Certificate,java.util.Set);
	*** getNetscapeCertTypeBit(java.security.cert.X509Certificate,java.lang.String);
	*** getTrustedCertificate(java.security.cert.X509Certificate);
}

-keep class sun.security.validator.Validator {
	*** CHAIN0;
	*** endEntityChecker;
	*** validationDate;
	*** variant;
	sun.security.validator.Validator(java.lang.String,java.lang.String);
	*** engineValidate(java.security.cert.X509Certificate[],java.util.Collection,java.security.AlgorithmConstraints,java.lang.Object);
	*** getInstance(java.lang.String,java.lang.String,java.security.cert.PKIXBuilderParameters);
	*** getInstance(java.lang.String,java.lang.String,java.util.Collection);
	*** getTrustedCertificates();
	*** validate(java.security.cert.X509Certificate[],java.util.Collection,java.lang.Object);
	*** validate(java.security.cert.X509Certificate[],java.util.Collection,java.security.AlgorithmConstraints,java.lang.Object);
}

-keep class sun.security.validator.ValidatorException {
	*** T_ALGORITHM_DISABLED;
	*** T_CA_EXTENSIONS;
	*** T_CERT_EXPIRED;
	*** T_EE_EXTENSIONS;
	*** T_NAME_CHAINING;
	*** T_NO_TRUST_ANCHOR;
	*** T_SIGNATURE_ERROR;
	*** T_UNTRUSTED_CERT;
	*** cert;
	*** type;
	sun.security.validator.ValidatorException(java.lang.Object,java.security.cert.X509Certificate);
	sun.security.validator.ValidatorException(java.lang.String,java.lang.Object,java.security.cert.X509Certificate);
}

-keep class sun.security.x509.AVA {
	*** PRESERVE_OLD_DC_ENCODING;
	*** debug;
	*** oid;
	*** value;
	sun.security.x509.AVA(java.io.Reader,int);
	sun.security.x509.AVA(java.io.Reader,int,java.util.Map);
	sun.security.x509.AVA(sun.security.util.DerValue);
	*** derEncode(java.io.OutputStream);
	*** getEmbeddedHexPair(int,java.io.Reader);
	*** getEmbeddedHexString(java.util.List);
	*** getObjectIdentifier();
	*** getValueString();
	*** isDerString(sun.security.util.DerValue,boolean);
	*** isTerminator(int,int);
	*** parseHexString(java.io.Reader,int);
	*** parseQuotedString(java.io.Reader,java.lang.StringBuilder);
	*** parseString(java.io.Reader,int,int,java.lang.StringBuilder);
	*** readChar(java.io.Reader,java.lang.String);
	*** toKeyword(int,java.util.Map);
	*** toKeywordValueString(java.lang.String);
	*** toRFC1779String(java.util.Map);
	*** toRFC2253CanonicalString();
	*** toRFC2253String(java.util.Map);
	*** toString();
	*** trailingSpace(java.io.Reader);
}

-keep class sun.security.x509.AVAComparator {
	*** getInstance();
}

-keep class sun.security.x509.AVAKeyword {
	*** keyword;
	*** keywordMap;
	*** oid;
	*** oidMap;
	*** rfc1779Compliant;
	*** rfc2253Compliant;
	*** getKeyword(sun.security.util.ObjectIdentifier,int,java.util.Map);
	*** getOID(java.lang.String,int,java.util.Map);
	*** hasKeyword(sun.security.util.ObjectIdentifier,int);
	*** isCompliant(int);
}

-keep class sun.security.x509.AccessDescription {
	*** Ad_CAISSUERS_Id;
	*** Ad_CAREPOSITORY_Id;
	*** Ad_OCSP_Id;
	*** Ad_TIMESTAMPING_Id;
	*** accessLocation;
	*** accessMethod;
	*** myhash;
	*** encode(sun.security.util.DerOutputStream);
	*** getAccessLocation();
	*** getAccessMethod();
}

-keep class sun.security.x509.AlgorithmId {
	*** DH_PKIX_data;
	*** DH_PKIX_oid;
	*** DH_data;
	*** DH_oid;
	*** DSA_OIW_data;
	*** DSA_OIW_oid;
	*** DSA_PKIX_data;
	*** DSA_oid;
	*** EC_oid;
	*** MD2_oid;
	*** MD5_oid;
	*** RSAEncryption_data;
	*** RSAEncryption_oid;
	*** RSA_data;
	*** RSA_oid;
	*** SHA256_oid;
	*** SHA384_oid;
	*** SHA512_oid;
	*** SHA_oid;
	*** algParams;
	*** algid;
	*** constructedFromDer;
	*** dsaWithSHA1_PKIX_data;
	*** initOidTable;
	*** md2WithRSAEncryption_data;
	*** md2WithRSAEncryption_oid;
	*** md5WithRSAEncryption_data;
	*** md5WithRSAEncryption_oid;
	*** nameTable;
	*** oidTable;
	*** params;
	*** pbeWithMD5AndDES_oid;
	*** pbeWithMD5AndRC2_oid;
	*** pbeWithSHA1AndDES_oid;
	*** pbeWithSHA1AndDESede_oid;
	*** pbeWithSHA1AndRC2_40_oid;
	*** pbeWithSHA1AndRC2_oid;
	*** sha1WithDSA_OIW_data;
	*** sha1WithDSA_OIW_oid;
	*** sha1WithDSA_oid;
	*** sha1WithECDSA_oid;
	*** sha1WithRSAEncryption_OIW_data;
	*** sha1WithRSAEncryption_OIW_oid;
	*** sha1WithRSAEncryption_data;
	*** sha1WithRSAEncryption_oid;
	*** sha224WithECDSA_oid;
	*** sha256WithECDSA_oid;
	*** sha256WithRSAEncryption_data;
	*** sha256WithRSAEncryption_oid;
	*** sha384WithECDSA_oid;
	*** sha384WithRSAEncryption_data;
	*** sha384WithRSAEncryption_oid;
	*** sha512WithECDSA_oid;
	*** sha512WithRSAEncryption_data;
	*** sha512WithRSAEncryption_oid;
	*** shaWithDSA_OIW_data;
	*** shaWithDSA_OIW_oid;
	*** specifiedWithECDSA_oid;
	*** algOID(java.lang.String);
	*** decodeParams();
	*** derEncode(java.io.OutputStream);
	*** encode(sun.security.util.DerOutputStream);
	*** equals(sun.security.util.ObjectIdentifier);
	*** equals(sun.security.x509.AlgorithmId);
	*** get(java.lang.String);
	*** getEncAlgFromSigAlg(java.lang.String);
	*** getEncodedParams();
	*** getName();
	*** getOID();
	*** getParameters();
	*** makeSigAlg(java.lang.String,java.lang.String);
	*** oid(int[]);
	*** paramsToString();
	*** parse(sun.security.util.DerValue);
	*** toString();
}

-keep class sun.security.x509.AuthorityInfoAccessExtension {
	*** accessDescriptions;
	*** encodeThis();
	*** getAccessDescriptions();
}

-keep class sun.security.x509.AuthorityKeyIdentifierExtension {
	*** id;
	*** names;
	*** serialNum;
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.BasicConstraintsExtension {
	*** ca;
	*** pathLen;
	sun.security.x509.BasicConstraintsExtension(java.lang.Boolean,boolean,int);
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.CRLDistributionPointsExtension {
	*** distributionPoints;
	*** extensionName;
	sun.security.x509.CRLDistributionPointsExtension(boolean,java.util.List);
	sun.security.x509.CRLDistributionPointsExtension(sun.security.util.ObjectIdentifier,boolean,java.util.List,java.lang.String);
	sun.security.x509.CRLDistributionPointsExtension(sun.security.util.ObjectIdentifier,java.lang.Boolean,java.lang.Object,java.lang.String);
	*** encode(java.io.OutputStream,sun.security.util.ObjectIdentifier,boolean);
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.CertAttrSet {
	*** encode(java.io.OutputStream);
	*** getName();
}

-keep class sun.security.x509.CertificateAlgorithmId {
	*** algId;
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificateExtensions {
	*** PARAMS;
	*** debug;
	*** map;
	*** unparseableExtensions;
	*** unsupportedCritExt;
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** encode(java.io.OutputStream,boolean);
	*** get(java.lang.String);
	*** getAllExtensions();
	*** getExtension(java.lang.String);
	*** getUnparseableExtensions();
	*** hasUnsupportedCriticalExtension();
	*** init(sun.security.util.DerInputStream);
	*** parseExtension(sun.security.x509.Extension);
	*** set(java.lang.String,java.lang.Object);
}

-keep class sun.security.x509.CertificateIssuerName {
	*** dnName;
	*** dnPrincipal;
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificateIssuerUniqueIdentity {
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificatePoliciesExtension {
	*** certPolicies;
	sun.security.x509.CertificatePoliciesExtension(java.lang.Boolean,java.util.List);
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.CertificatePolicyId {
	*** id;
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object);
	*** getIdentifier();
	*** hashCode();
	*** toString();
}

-keep class sun.security.x509.CertificatePolicyMap {
	*** issuerDomain;
	*** subjectDomain;
	*** encode(sun.security.util.DerOutputStream);
	*** getIssuerIdentifier();
	*** getSubjectIdentifier();
}

-keep class sun.security.x509.CertificatePolicySet {
	*** getCertPolicyIds();
	*** toString();
}

-keep class sun.security.x509.CertificateSerialNumber {
	*** serial;
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificateSubjectName {
	*** dnName;
	*** dnPrincipal;
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificateSubjectUniqueIdentity {
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificateValidity {
	*** notAfter;
	*** notBefore;
	*** construct(sun.security.util.DerValue);
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** getNotAfter();
	*** getNotBefore();
	*** set(java.lang.String,java.lang.Object);
	*** toString();
	*** valid(java.util.Date);
}

-keep class sun.security.x509.CertificateVersion {
	*** version;
	*** compare(int);
	*** construct(sun.security.util.DerValue);
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** getVersion();
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.CertificateX509Key {
	*** key;
	*** delete(java.lang.String);
	*** encode(java.io.OutputStream);
	*** get(java.lang.String);
	*** set(java.lang.String,java.lang.Object);
	*** toString();
}

-keep class sun.security.x509.DNSName {
	*** name;
	*** constrains(sun.security.x509.GeneralNameInterface);
	*** getName();
	*** subtreeDepth();
}

-keep class sun.security.x509.DistributionPoint {
	*** REASON_STRINGS;
	*** crlIssuer;
	*** fullName;
	*** hashCode;
	*** reasonFlags;
	*** relativeName;
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object,java.lang.Object);
	*** reasonToString(int);
}

-keep class sun.security.x509.ExtendedKeyUsageExtension {
	*** OCSPSigningOidData;
	*** anyExtendedKeyUsageOidData;
	*** clientAuthOidData;
	*** codeSigningOidData;
	*** emailProtectionOidData;
	*** ipsecEndSystemOidData;
	*** ipsecTunnelOidData;
	*** ipsecUserOidData;
	*** keyUsages;
	*** map;
	*** serverAuthOidData;
	*** timeStampingOidData;
	sun.security.x509.ExtendedKeyUsageExtension(java.lang.Boolean,java.util.Vector);
	*** encodeThis();
	*** get(java.lang.String);
	*** getExtendedKeyUsage();
}

-keep class sun.security.x509.Extension {
	*** critical;
	*** extensionId;
	*** extensionValue;
	sun.security.x509.Extension();
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object);
	*** getExtensionId();
	*** getExtensionValue();
	*** isCritical();
	*** toString();
}

-keep class sun.security.x509.GeneralName {
	*** name;
	sun.security.x509.GeneralName(sun.security.util.DerValue,boolean);
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object);
	*** getName();
	*** getType();
	*** hashCode();
	*** toString();
}

-keep class sun.security.x509.GeneralNameInterface {
	*** constrains(sun.security.x509.GeneralNameInterface);
	*** encode(sun.security.util.DerOutputStream);
	*** getType();
	*** subtreeDepth();
}

-keep class sun.security.x509.GeneralNames {
	*** names;
	sun.security.x509.GeneralNames();
	*** add(sun.security.x509.GeneralName);
	*** encode(sun.security.util.DerOutputStream);
	*** get(int);
	*** hashCode();
	*** isEmpty();
	*** iterator();
	*** names();
	*** size();
	*** toString();
}

-keep class sun.security.x509.GeneralSubtree {
	*** maximum;
	*** minimum;
	*** myhash;
	*** name;
	*** encode(sun.security.util.DerOutputStream);
	*** getMaximum();
	*** getMinimum();
	*** getName();
}

-keep class sun.security.x509.GeneralSubtrees {
	*** trees;
	sun.security.x509.GeneralSubtrees();
	*** add(sun.security.x509.GeneralSubtree);
	*** clone();
	*** contains(sun.security.x509.GeneralSubtree);
	*** createWidestSubtree(sun.security.x509.GeneralNameInterface);
	*** encode(sun.security.util.DerOutputStream);
	*** get(int);
	*** getGeneralNameInterface(int);
	*** getGeneralNameInterface(sun.security.x509.GeneralSubtree);
	*** intersect(sun.security.x509.GeneralSubtrees);
	*** iterator();
	*** minimize();
	*** reduce(sun.security.x509.GeneralSubtrees);
	*** remove(int);
	*** size();
	*** toString();
	*** union(sun.security.x509.GeneralSubtrees);
}

-keep class sun.security.x509.IPAddressName {
	*** getName();
}

-keep class sun.security.x509.InhibitAnyPolicyExtension {
	*** get(java.lang.String);
}

-keep class sun.security.x509.IssuerAlternativeNameExtension {
	*** names;
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.KeyIdentifier {
	*** octetString;
	*** encode(sun.security.util.DerOutputStream);
	*** getIdentifier();
	*** toString();
}

-keep class sun.security.x509.KeyUsageExtension {
	*** bitString;
	*** encodeThis();
	*** get(java.lang.String);
	*** getBits();
	*** isSet(int);
	*** set(int,boolean);
	*** set(java.lang.String,java.lang.Object);
}

-keep class sun.security.x509.NameConstraintsExtension {
	*** excluded;
	*** hasMax;
	*** hasMin;
	*** minMaxValid;
	*** permitted;
	*** calcMinMax();
	*** clone();
	*** encodeThis();
	*** get(java.lang.String);
	*** merge(sun.security.x509.NameConstraintsExtension);
	*** toString();
	*** verify(java.security.cert.X509Certificate);
	*** verify(sun.security.x509.GeneralNameInterface);
	*** verifyRFC822SpecialCase(sun.security.x509.X500Name);
}

-keep class sun.security.x509.NetscapeCertTypeExtension {
	*** CertType_data;
	*** NetscapeCertType_Id;
	*** bitString;
	*** mAttributeNames;
	*** mMapData;
	*** encodeThis();
	*** get(java.lang.String);
	*** getPosition(java.lang.String);
	*** isSet(int);
	*** set(int,boolean);
}

-keep class sun.security.x509.NetscapeCertTypeExtension$MapEntry {
	*** mName;
	*** mPosition;
}

-keep class sun.security.x509.OIDMap {
	*** NetscapeCertType_data;
	*** nameMap;
	*** oidMap;
	*** addInternal(java.lang.String,sun.security.util.ObjectIdentifier,java.lang.String);
	*** getClass(sun.security.util.ObjectIdentifier);
	*** getName(sun.security.util.ObjectIdentifier);
}

-keep class sun.security.x509.OIDMap$OIDInfo {
	*** className;
	*** clazz;
	*** name;
	*** oid;
	*** getClazz();
}

-keep class sun.security.x509.OIDName {
	*** getOID();
}

-keep class sun.security.x509.OtherName {
	*** getOID();
}

-keep class sun.security.x509.PKIXExtensions {
	*** AuthInfoAccess_Id;
	*** AuthInfoAccess_data;
	*** AuthorityKey_Id;
	*** AuthorityKey_data;
	*** BasicConstraints_Id;
	*** BasicConstraints_data;
	*** CRLDistributionPoints_Id;
	*** CRLDistributionPoints_data;
	*** CRLNumber_Id;
	*** CRLNumber_data;
	*** CertificateIssuer_Id;
	*** CertificateIssuer_data;
	*** CertificatePolicies_Id;
	*** CertificatePolicies_data;
	*** DeltaCRLIndicator_Id;
	*** DeltaCRLIndicator_data;
	*** ExtendedKeyUsage_Id;
	*** ExtendedKeyUsage_data;
	*** FreshestCRL_Id;
	*** FreshestCRL_data;
	*** HoldInstructionCode_Id;
	*** HoldInstructionCode_data;
	*** InhibitAnyPolicy_Id;
	*** InhibitAnyPolicy_data;
	*** InvalidityDate_Id;
	*** InvalidityDate_data;
	*** IssuerAlternativeName_Id;
	*** IssuerAlternativeName_data;
	*** IssuingDistributionPoint_Id;
	*** IssuingDistributionPoint_data;
	*** KeyUsage_Id;
	*** KeyUsage_data;
	*** NameConstraints_Id;
	*** NameConstraints_data;
	*** OCSPNoCheck_Id;
	*** OCSPNoCheck_data;
	*** PolicyConstraints_Id;
	*** PolicyConstraints_data;
	*** PolicyMappings_Id;
	*** PolicyMappings_data;
	*** PrivateKeyUsage_Id;
	*** PrivateKeyUsage_data;
	*** ReasonCode_Id;
	*** ReasonCode_data;
	*** SubjectAlternativeName_Id;
	*** SubjectAlternativeName_data;
	*** SubjectDirectoryAttributes_Id;
	*** SubjectDirectoryAttributes_data;
	*** SubjectInfoAccess_Id;
	*** SubjectInfoAccess_data;
	*** SubjectKey_Id;
	*** SubjectKey_data;
}

-keep class sun.security.x509.PolicyConstraintsExtension {
	*** get(java.lang.String);
}

-keep class sun.security.x509.PolicyInformation {
	*** policyIdentifier;
	*** policyQualifiers;
	*** encode(sun.security.util.DerOutputStream);
	*** getPolicyIdentifier();
	*** getPolicyQualifiers();
	*** toString();
}

-keep class sun.security.x509.PolicyMappingsExtension {
	*** maps;
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.PrivateKeyUsageExtension {
	*** notAfter;
	*** notBefore;
	*** encodeThis();
	*** get(java.lang.String);
	*** valid(java.util.Date);
}

-keep class sun.security.x509.RDN {
	*** assertion;
	*** avaList;
	*** canonicalString;
	sun.security.x509.RDN(java.lang.String,java.lang.String,java.util.Map);
	sun.security.x509.RDN(java.lang.String,java.util.Map);
	*** avas();
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object);
	*** findAttribute(sun.security.util.ObjectIdentifier);
	*** hashCode();
	*** toRFC1779String(java.util.Map);
	*** toRFC2253String(boolean);
	*** toRFC2253String(java.util.Map);
	*** toRFC2253StringInternal(boolean,java.util.Map);
	*** toString();
}

-keep class sun.security.x509.RFC822Name {
	*** name;
	*** getName();
	*** parseName(java.lang.String);
}

-keep class sun.security.x509.SerialNumber {
	*** serialNum;
	*** construct(sun.security.util.DerValue);
	*** encode(sun.security.util.DerOutputStream);
	*** getNumber();
	*** toString();
}

-keep class sun.security.x509.SubjectAlternativeNameExtension {
	*** names;
	sun.security.x509.SubjectAlternativeNameExtension(java.lang.Boolean,sun.security.x509.GeneralNames);
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.SubjectKeyIdentifierExtension {
	*** id;
	*** encodeThis();
	*** get(java.lang.String);
}

-keep class sun.security.x509.URIName {
	*** host;
	*** hostDNS;
	*** hostIP;
	*** uri;
	sun.security.x509.URIName(java.lang.String);
	*** getHost();
	*** getHostObject();
	*** getName();
	*** getURI();
	*** nameConstraint(sun.security.util.DerValue);
}

-keep class sun.security.x509.UniqueIdentity {
	*** getId();
}

-keep class sun.security.x509.X500Name {
	*** DNQUALIFIER_DATA;
	*** DNQUALIFIER_OID;
	*** DOMAIN_COMPONENT_DATA;
	*** DOMAIN_COMPONENT_OID;
	*** GENERATIONQUALIFIER_DATA;
	*** GENERATIONQUALIFIER_OID;
	*** GIVENNAME_DATA;
	*** GIVENNAME_OID;
	*** INITIALS_DATA;
	*** INITIALS_OID;
	*** SERIALNUMBER_DATA;
	*** SERIALNUMBER_OID;
	*** SURNAME_DATA;
	*** SURNAME_OID;
	*** allAvaList;
	*** canonicalDn;
	*** commonName_data;
	*** commonName_oid;
	*** countryName_data;
	*** countryName_oid;
	*** dn;
	*** encoded;
	*** internedOIDs;
	*** ipAddress_data;
	*** ipAddress_oid;
	*** localityName_data;
	*** localityName_oid;
	*** names;
	*** orgName_data;
	*** orgName_oid;
	*** orgUnitName_data;
	*** orgUnitName_oid;
	*** principalConstructor;
	*** principalField;
	*** rdnList;
	*** rfc1779Dn;
	*** rfc2253Dn;
	*** stateName_data;
	*** stateName_oid;
	*** streetAddress_data;
	*** streetAddress_oid;
	*** title_data;
	*** title_oid;
	*** userid_data;
	*** userid_oid;
	*** x500Principal;
	sun.security.x509.X500Name(java.lang.String,java.util.Map);
	sun.security.x509.X500Name(sun.security.util.DerInputStream);
	*** allAvas();
	*** asX500Name(javax.security.auth.x500.X500Principal);
	*** asX500Principal();
	*** commonAncestor(sun.security.x509.X500Name);
	*** countQuotes(java.lang.String,int,int);
	*** encode(sun.security.util.DerOutputStream);
	*** equals(java.lang.Object);
	*** escaped(int,int,java.lang.String);
	*** findAttribute(sun.security.util.ObjectIdentifier);
	*** generateDN();
	*** generateRFC1779DN(java.util.Map);
	*** generateRFC2253DN(java.util.Map);
	*** getEncoded();
	*** getEncodedInternal();
	*** getRFC1779Name();
	*** getRFC1779Name(java.util.Map);
	*** getRFC2253CanonicalName();
	*** getRFC2253Name();
	*** getRFC2253Name(java.util.Map);
	*** getString(sun.security.util.DerValue);
	*** hashCode();
	*** intern(sun.security.util.ObjectIdentifier);
	*** isEmpty();
	*** isWithinSubtree(sun.security.x509.X500Name);
	*** parseDER(sun.security.util.DerInputStream);
	*** parseDN(java.lang.String,java.util.Map);
	*** parseRFC2253DN(java.lang.String);
	*** subtreeDepth();
	*** toString();
}

-keep class sun.security.x509.X500Name$1 {
	*** run();
}

-keep class sun.security.x509.X509AttributeName {
	*** prefix;
	*** suffix;
	*** getPrefix();
	*** getSuffix();
}

-keep class sun.security.x509.X509CRLEntryImpl {
	*** getCriticalExtensionOIDs();
	*** getExtensions();
	*** getRevocationDate();
	*** getRevocationReason();
	*** toImpl(java.security.cert.X509CRLEntry);
	*** toString();
}

-keep class sun.security.x509.X509CRLImpl {
	*** getEncodedInternal();
	*** getSigAlgId();
	*** toImpl(java.security.cert.X509CRL);
}

-keep class sun.security.x509.X509CertImpl {
	*** algId;
	*** extKeyUsage;
	*** info;
	*** issuerAlternativeNames;
	*** readOnly;
	*** signature;
	*** signedCert;
	*** subjectAlternativeNames;
	*** verificationResult;
	*** verifiedProvider;
	*** verifiedPublicKey;
	*** checkValidity(java.util.Date);
	*** cloneAltNames(java.util.Collection);
	*** get(java.lang.String);
	*** getAuthorityInfoAccessExtension();
	*** getAuthorityKeyIdentifierExtension();
	*** getBasicConstraints();
	*** getCRLDistributionPointsExtension();
	*** getCertificatePoliciesExtension();
	*** getEncodedInternal();
	*** getExtendedKeyUsage(java.security.cert.X509Certificate);
	*** getExtendedKeyUsageExtension();
	*** getExtension(sun.security.util.ObjectIdentifier);
	*** getIssuerAlternativeNameExtension();
	*** getIssuerAlternativeNames(java.security.cert.X509Certificate);
	*** getIssuerDN();
	*** getIssuerKeyIdentifier();
	*** getIssuerUniqueID();
	*** getIssuerX500Principal();
	*** getIssuerX500Principal(java.security.cert.X509Certificate);
	*** getKeyUsage();
	*** getNameConstraintsExtension();
	*** getNotAfter();
	*** getNotBefore();
	*** getPolicyConstraintsExtension();
	*** getPolicyMappingsExtension();
	*** getPrivateKeyUsageExtension();
	*** getPublicKey();
	*** getSerialNumber();
	*** getSerialNumberObject();
	*** getSigAlgName();
	*** getSubjectAlternativeNameExtension();
	*** getSubjectAlternativeNames(java.security.cert.X509Certificate);
	*** getSubjectKeyIdentifier();
	*** getSubjectKeyIdentifierExtension();
	*** getSubjectUniqueID();
	*** getSubjectX500Principal();
	*** getSubjectX500Principal(java.security.cert.X509Certificate);
	*** getX500Principal(java.security.cert.X509Certificate,boolean);
	*** isSelfIssued(java.security.cert.X509Certificate);
	*** isSelfSigned(java.security.cert.X509Certificate,java.lang.String);
	*** makeAltNames(sun.security.x509.GeneralNames);
	*** parse(sun.security.util.DerValue);
	*** readRFC1421Cert(java.io.InputStream);
	*** sign(java.security.PrivateKey,java.lang.String,java.lang.String);
	*** toImpl(java.security.cert.X509Certificate);
	*** verify(java.security.PublicKey,java.lang.String);
}

-keep class sun.security.x509.X509CertInfo {
	*** algId;
	*** extensions;
	*** interval;
	*** issuer;
	*** issuerUniqueId;
	*** map;
	*** pubKey;
	*** rawCertInfo;
	*** serialNum;
	*** subject;
	*** subjectUniqueId;
	*** version;
	*** attributeMap(java.lang.String);
	*** delete(java.lang.String);
	*** emit(sun.security.util.DerOutputStream);
	*** encode(java.io.OutputStream);
	*** equals(sun.security.x509.X509CertInfo);
	*** get(java.lang.String);
	*** getEncodedInfo();
	*** parse(sun.security.util.DerValue);
	*** set(java.lang.String,java.lang.Object);
	*** setAlgorithmId(java.lang.Object);
	*** setExtensions(java.lang.Object);
	*** setIssuer(java.lang.Object);
	*** setIssuerUniqueId(java.lang.Object);
	*** setKey(java.lang.Object);
	*** setSerialNumber(java.lang.Object);
	*** setSubject(java.lang.Object);
	*** setSubjectUniqueId(java.lang.Object);
	*** setValidity(java.lang.Object);
	*** setVersion(java.lang.Object);
	*** toString();
	*** verifyCert(sun.security.x509.CertificateSubjectName,sun.security.x509.CertificateExtensions);
}

-keep class sun.security.x509.X509Key {
	*** algid;
	*** bitStringKey;
	*** encodedKey;
	*** key;
	*** unusedBits;
	sun.security.x509.X509Key();
	*** buildX509Key(sun.security.x509.AlgorithmId,sun.security.util.BitArray);
	*** decode(byte[]);
	*** decode(java.io.InputStream);
	*** encode();
	*** encode(sun.security.util.DerOutputStream);
	*** encode(sun.security.util.DerOutputStream,sun.security.x509.AlgorithmId,sun.security.util.BitArray);
	*** getAlgorithm();
	*** getEncoded();
	*** getEncodedInternal();
	*** getFormat();
	*** getKey();
	*** parse(sun.security.util.DerValue);
	*** parseKeyBits();
	*** setKey(sun.security.util.BitArray);
}

-keep class sun.swing.DefaultLayoutStyle {
	*** getInstance();
}

-keep class sun.swing.DefaultLookup {
	*** DEFAULT_LOOKUP_KEY;
	*** currentDefaultLookup;
	*** currentDefaultThread;
	*** isLookupSet;
	*** get(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String);
	*** getBoolean(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String,boolean);
	*** getBorder(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String,javax.swing.border.Border);
	*** getColor(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String,java.awt.Color);
	*** getDefault(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String);
	*** getIcon(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String,javax.swing.Icon);
	*** getInsets(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String,java.awt.Insets);
	*** getInt(javax.swing.JComponent,javax.swing.plaf.ComponentUI,java.lang.String,int);
	*** setDefaultLookup(sun.swing.DefaultLookup);
}

-keep class sun.swing.PrintColorUIResource {
	*** getPrintColor();
}

-keep class sun.swing.PrintingStatus {
	*** createNotificationPrintable(java.awt.print.Printable);
	*** createPrintingStatus(java.awt.Component,java.awt.print.PrinterJob);
	*** isAborted();
	*** showModal(boolean);
}

-keep class sun.swing.StringUIClientPropertyKey {
	*** key;
}

-keep class sun.swing.SwingAccessor {
	*** setJTextComponentAccessor(sun.swing.SwingAccessor$JTextComponentAccessor);
}

-keep class sun.swing.SwingLazyValue {
	*** args;
	*** className;
	*** methodName;
	sun.swing.SwingLazyValue(java.lang.String,java.lang.String);
	sun.swing.SwingLazyValue(java.lang.String,java.lang.String,java.lang.Object[]);
	*** getClassArray(java.lang.Object[]);
	*** makeAccessible(java.lang.reflect.AccessibleObject);
}

-keep class sun.swing.SwingLazyValue$1 {
	*** this$0;
	*** val$object;
	*** run();
}

-keep class sun.swing.SwingUtilities2 {
	*** $assertionsDisabled;
	*** AA_TEXT_PROPERTY_KEY;
	*** BASICMENUITEMUI_MAX_TEXT_OFFSET;
	*** COMPONENT_UI_PROPERTY_KEY;
	*** DEFAULT_FRC;
	*** LAF_STATE_KEY;
	*** SKIP_CLICK_COUNT;
	*** charsBuffer;
	*** charsBufferLock;
	*** fontCache;
	*** inputEvent_CanAccessSystemClipboard_Field;
	*** nextIndex;
	*** searchKey;
	*** canCurrentEventAccessSystemClipboard(boolean);
	*** canEventAccessSystemClipboard(java.awt.AWTEvent,boolean);
	*** clipString(javax.swing.JComponent,java.awt.FontMetrics,java.lang.String,int);
	*** compositeRequestFocus(java.awt.Component);
	*** createTextLayout(javax.swing.JComponent,java.lang.String,java.awt.Font,java.awt.font.FontRenderContext);
	*** drawString(javax.swing.JComponent,java.awt.Graphics,java.lang.String,int,int);
	*** drawTextAntialiased(javax.swing.JComponent);
	*** execute(java.lang.Runnable);
	*** getFRCProperty(javax.swing.JComponent);
	*** getFontMetrics(javax.swing.JComponent,java.awt.Font);
	*** getFontMetrics(javax.swing.JComponent,java.awt.Graphics);
	*** getFontMetrics(javax.swing.JComponent,java.awt.Graphics,java.awt.Font);
	*** getFontRenderContext(java.awt.Component);
	*** getFontRenderContext(java.awt.Component,java.awt.FontMetrics);
	*** getGraphics2D(java.awt.Graphics);
	*** getLeftSideBearing(javax.swing.JComponent,java.awt.FontMetrics,char);
	*** getLeftSideBearing(javax.swing.JComponent,java.awt.FontMetrics,java.lang.String);
	*** getSystemMnemonicKeyMask();
	*** getUIDefaultsInt(java.lang.Object,int);
	*** getUIDefaultsInt(java.lang.Object,java.util.Locale,int);
	*** inputEvent_canAccessSystemClipboard(java.awt.event.InputEvent);
	*** isAccessClipboardGesture(java.awt.event.InputEvent);
	*** isComplexLayout(char[],int,int);
	*** isFontRenderContextPrintCompatible(java.awt.font.FontRenderContext,java.awt.font.FontRenderContext);
	*** isPrinting(java.awt.Graphics);
	*** isTrustedContext();
	*** liesIn(java.awt.Rectangle,java.awt.Point,boolean,boolean,boolean);
	*** makeIcon(java.lang.Class,java.lang.Class,java.lang.String);
	*** pointIsInActualBounds(javax.swing.JList,int,java.awt.Point);
	*** stringWidth(javax.swing.JComponent,java.awt.FontMetrics,java.lang.String);
	*** syncCharsBuffer(java.lang.String);
}

-keep class sun.swing.SwingUtilities2$2 {
	*** val$baseClass;
	*** val$imageFile;
	*** val$rootClass;
}

-keep class sun.swing.SwingUtilities2$AATextInfo {
	*** aaHint;
	*** frc;
	*** lcdContrastHint;
	*** getAATextInfo(boolean);
	*** getAATextInfoFromMap(java.util.Map);
}

-keep class sun.swing.SwingUtilities2$LSBCacheEntry {
	*** $assertionsDisabled;
	*** font;
	*** frc;
	*** lsbCache;
	*** oneChar;
	*** equals(java.lang.Object);
	*** getLeftSideBearing(char);
	*** reset(java.awt.font.FontRenderContext,java.awt.Font);
}

-keep class sun.swing.SwingUtilities2$Section {
	*** LEADING;
	*** MIDDLE;
	*** TRAILING;
}

-keep class sun.swing.UIAction {
	*** isEnabled(java.lang.Object);
}

-keep class sun.swing.text.TextComponentPrintable {
	*** getPrintable(javax.swing.text.JTextComponent,java.text.MessageFormat,java.text.MessageFormat);
}

-keep class sun.text.normalizer.NormalizerBase {
	*** MAYBE;
	*** NFC;
	*** NFD;
	*** NFKC;
	*** NFKD;
	*** NO;
	*** NONE;
	*** YES;
	*** buffer;
	*** bufferLimit;
	*** bufferPos;
	*** bufferStart;
	*** currentIndex;
	*** mode;
	*** nextIndex;
	*** options;
	*** text;
	sun.text.normalizer.NormalizerBase(java.lang.String,sun.text.normalizer.NormalizerBase$Mode,int);
	sun.text.normalizer.NormalizerBase(java.text.CharacterIterator,sun.text.normalizer.NormalizerBase$Mode,int);
	*** clearBuffer();
	*** compose(java.lang.String,boolean,int);
	*** current();
	*** decompose(java.lang.String,boolean,int);
	*** endIndex();
	*** findNextIterationBoundary(sun.text.normalizer.UCharacterIterator,sun.text.normalizer.NormalizerBase$IsNextBoundary,int,int,char[]);
	*** findPreviousIterationBoundary(sun.text.normalizer.UCharacterIterator,sun.text.normalizer.NormalizerBase$IsPrevBoundary,int,int,char[],int[]);
	*** getCodePointAt(int);
	*** getNextNorm32(sun.text.normalizer.UCharacterIterator,int,int,int[]);
	*** getPrevNorm32(sun.text.normalizer.UCharacterIterator,int,int,char[]);
	*** isNormalized(java.lang.String,java.text.Normalizer$Form);
	*** isNormalized(java.lang.String,java.text.Normalizer$Form,int);
	*** next(sun.text.normalizer.UCharacterIterator,char[],int,int,sun.text.normalizer.NormalizerBase$Mode,boolean,boolean[],int);
	*** nextNormalize();
	*** normalize(char[],int,int,char[],int,int,sun.text.normalizer.NormalizerBase$Mode,int);
	*** normalize(java.lang.String,java.text.Normalizer$Form);
	*** normalize(java.lang.String,java.text.Normalizer$Form,int);
	*** previous(sun.text.normalizer.UCharacterIterator,char[],int,int,sun.text.normalizer.NormalizerBase$Mode,boolean,boolean[],int);
	*** previousNormalize();
	*** reset();
	*** setIndexOnly(int);
}

-keep class sun.text.normalizer.NormalizerBase$1 {
	*** $SwitchMap$java$text$Normalizer$Form;
}

-keep class sun.text.normalizer.NormalizerBase$IsNextBoundary {
	*** isNextBoundary(sun.text.normalizer.UCharacterIterator,int,int,int[]);
}

-keep class sun.text.normalizer.NormalizerBase$IsPrevBoundary {
	*** isPrevBoundary(sun.text.normalizer.UCharacterIterator,int,int,char[]);
}

-keep class sun.text.normalizer.NormalizerBase$Mode {
	*** modeValue;
	sun.text.normalizer.NormalizerBase$Mode(int);
	sun.text.normalizer.NormalizerBase$Mode(int,sun.text.normalizer.NormalizerBase$1);
	*** getMask();
	*** getMinC();
	*** getNextBoundary();
	*** getPrevBoundary();
	*** isNFSkippable(int);
	*** normalize(char[],int,int,char[],int,int,int);
	*** normalize(char[],int,int,char[],int,int,sun.text.normalizer.UnicodeSet);
	*** normalize(java.lang.String,int);
	*** quickCheck(char[],int,int,boolean,sun.text.normalizer.UnicodeSet);
}

-keep class sun.text.normalizer.NormalizerBase$NFCMode {
	sun.text.normalizer.NormalizerBase$NFCMode(int);
}

-keep class sun.text.normalizer.NormalizerBase$NFDMode {
	sun.text.normalizer.NormalizerBase$NFDMode(int);
}

-keep class sun.text.normalizer.NormalizerBase$NFKCMode {
	sun.text.normalizer.NormalizerBase$NFKCMode(int);
}

-keep class sun.text.normalizer.NormalizerBase$NFKDMode {
	sun.text.normalizer.NormalizerBase$NFKDMode(int);
}

-keep class sun.text.normalizer.NormalizerBase$QuickCheckResult {
	*** resultValue;
	sun.text.normalizer.NormalizerBase$QuickCheckResult(int);
}

-keep class sun.text.normalizer.NormalizerImpl {
	*** compose(char[],int,int,char[],int,int,int,sun.text.normalizer.UnicodeSet);
	*** convert(java.lang.String);
	*** decompose(char[],int,int,char[],int,int,boolean,int[],sun.text.normalizer.UnicodeSet);
	*** getFromIndexesArr(int);
	*** getNX(int);
	*** getNorm32(char);
	*** getNorm32FromSurrogatePair(long,char);
	*** isNFSkippable(int,sun.text.normalizer.NormalizerBase$Mode,long);
	*** quickCheck(char[],int,int,int,int,int,boolean,sun.text.normalizer.UnicodeSet);
}

-keep class sun.text.normalizer.UCharacterIterator {
	*** clone();
	*** current();
	*** getIndex();
	*** getInstance(java.lang.String);
	*** getInstance(java.text.CharacterIterator);
	*** getLength();
	*** moveIndex(int);
	*** next();
	*** previous();
	*** setIndex(int);
}

-keep class sun.text.normalizer.UCharacterProperty {
	*** getRawSupplementary(char,char);
}

-keep class sun.text.normalizer.UTF16 {
	*** isLeadSurrogate(char);
	*** isSurrogate(char);
	*** isTrailSurrogate(char);
}

-keep class sun.text.normalizer.Utility {
	*** arrayRegionMatches(char[],int,char[],int,int);
}

-keep class sun.util.CoreResourceBundleControl {
	*** excludedJDKLocales;
	*** resourceBundleControlInstance;
	*** getRBControlInstance();
	*** getRBControlInstance(java.lang.String);
}

-keep class sun.util.LocaleDataMetaInfo {
	*** resourceNameToLocales;
	*** getSupportedLocaleString(java.lang.String);
}

-keep class sun.util.LocaleServiceProviderPool {
	*** availableJRELocales;
	*** availableLocales;
	*** locale_ja_JP_JP;
	*** locale_th_TH_TH;
	*** poolOfPools;
	*** providerLocales;
	*** providers;
	*** providersCache;
	*** access$000(sun.util.LocaleServiceProviderPool);
	*** config(java.lang.String);
	*** findProvider(java.util.Locale);
	*** getAvailableLocales();
	*** getJRELocales();
	*** getLocalizedObject(sun.util.LocaleServiceProviderPool$LocalizedObjectGetter,java.util.Locale,java.lang.Object[]);
	*** getLocalizedObject(sun.util.LocaleServiceProviderPool$LocalizedObjectGetter,java.util.Locale,java.lang.String,sun.util.resources.OpenListResourceBundle,java.lang.String,java.lang.Object[]);
	*** getLocalizedObject(sun.util.LocaleServiceProviderPool$LocalizedObjectGetter,java.util.Locale,sun.util.resources.OpenListResourceBundle,java.lang.String,java.lang.Object[]);
	*** getLocalizedObjectImpl(sun.util.LocaleServiceProviderPool$LocalizedObjectGetter,java.util.Locale,boolean,java.lang.String,sun.util.resources.OpenListResourceBundle,java.lang.String,java.lang.Object[]);
	*** getLookupLocale(java.util.Locale);
	*** getLookupLocales(java.util.Locale);
	*** getPool(java.lang.Class);
	*** getProviderLocales();
	*** hasProviders();
	*** isJRESupported(java.util.Locale);
}

-keep class sun.util.LocaleServiceProviderPool$1 {
	*** this$0;
	*** val$c;
}

-keep class sun.util.LocaleServiceProviderPool$AllAvailableLocales {
	*** allAvailableLocales;
}

-keep class sun.util.LocaleServiceProviderPool$LocalizedObjectGetter {
	*** getObject(java.lang.Object,java.util.Locale,java.lang.String,java.lang.Object[]);
}

-keep class sun.util.LocaleServiceProviderPool$NullProvider {
	*** access$300();
}

-keep class sun.util.PreHashedMap {
	*;
}

-keep class sun.util.ResourceBundleEnumeration {
	*** enumeration;
	*** iterator;
	*** next;
	*** set;
	*** hasMoreElements();
	*** nextElement();
}

-keep class sun.util.TimeZoneNameUtility {
	*** cachedBundles;
	*** cachedZoneData;
	*** getBundle(java.util.Locale);
	*** getZoneStrings(java.util.Locale);
	*** loadZoneStrings(java.util.Locale);
	*** retrieveDisplayNames(java.lang.String,java.util.Locale);
	*** retrieveDisplayNames(sun.util.resources.OpenListResourceBundle,java.lang.String,java.util.Locale);
}

-keep class sun.util.TimeZoneNameUtility$TimeZoneNameGetter {
	*** access$000();
}

-keep class sun.util.calendar.AbstractCalendar {
	*** eras;
	sun.util.calendar.AbstractCalendar();
	*** getCalendarDate();
	*** getCalendarDate(long,java.util.TimeZone);
	*** getCalendarDate(long,sun.util.calendar.CalendarDate);
	*** getCalendarDateFromFixedDate(sun.util.calendar.CalendarDate,long);
	*** getDayOfWeekDateAfter(long,int);
	*** getDayOfWeekDateBefore(long,int);
	*** getDayOfWeekDateOnOrBefore(long,int);
	*** getEras();
	*** getFixedDate(sun.util.calendar.CalendarDate);
	*** getTime(sun.util.calendar.CalendarDate);
	*** getTimeOfDay(sun.util.calendar.CalendarDate);
	*** getTimeOfDayValue(sun.util.calendar.CalendarDate);
	*** isLeapYear(sun.util.calendar.CalendarDate);
	*** normalizeTime(sun.util.calendar.CalendarDate);
	*** setTimeOfDay(sun.util.calendar.CalendarDate,int);
	*** validateTime(sun.util.calendar.CalendarDate);
}

-keep class sun.util.calendar.BaseCalendar {
	*** $assertionsDisabled;
	*** ACCUMULATED_DAYS_IN_MONTH;
	*** ACCUMULATED_DAYS_IN_MONTH_LEAP;
	*** DAYS_IN_MONTH;
	*** FIXED_DATES;
	sun.util.calendar.BaseCalendar();
	*** getCalendarDateFromFixedDate(sun.util.calendar.CalendarDate,long);
	*** getDayOfWeek(sun.util.calendar.CalendarDate);
	*** getDayOfWeekFromFixedDate(long);
	*** getDayOfYear(int,int,int);
	*** getDayOfYear(sun.util.calendar.CalendarDate);
	*** getFixedDate(int,int,int,sun.util.calendar.BaseCalendar$Date);
	*** getFixedDate(sun.util.calendar.CalendarDate);
	*** getGregorianYearFromFixedDate(long);
	*** getMonthLength(int,int);
	*** getMonthLength(sun.util.calendar.CalendarDate);
	*** getYearFromFixedDate(long);
	*** getYearLength(sun.util.calendar.CalendarDate);
	*** isLeapYear(int);
	*** normalize(sun.util.calendar.CalendarDate);
	*** normalizeMonth(sun.util.calendar.CalendarDate);
}

-keep class sun.util.calendar.BaseCalendar$Date {
	*** cachedFixedDateJan1;
	*** cachedFixedDateNextJan1;
	*** cachedYear;
	sun.util.calendar.BaseCalendar$Date();
	sun.util.calendar.BaseCalendar$Date(java.util.TimeZone);
	*** getCachedJan1();
	*** getCachedYear();
	*** getNormalizedYear();
	*** hit(int);
	*** hit(long);
	*** setCache(int,long,int);
	*** setNormalizedDate(int,int,int);
	*** setNormalizedYear(int);
}

-keep class sun.util.calendar.CalendarDate {
	*** dayOfMonth;
	*** dayOfWeek;
	*** daylightSaving;
	*** era;
	*** forceStandardTime;
	*** fraction;
	*** hours;
	*** leapYear;
	*** locale;
	*** millis;
	*** minutes;
	*** month;
	*** normalized;
	*** seconds;
	*** year;
	*** zoneOffset;
	*** zoneinfo;
	sun.util.calendar.CalendarDate();
	sun.util.calendar.CalendarDate(java.util.TimeZone);
	*** addDayOfMonth(int);
	*** addHours(int);
	*** addMillis(int);
	*** addMinutes(int);
	*** addMonth(int);
	*** addSeconds(int);
	*** addYear(int);
	*** clone();
	*** getDayOfMonth();
	*** getDayOfWeek();
	*** getDaylightSaving();
	*** getEra();
	*** getHours();
	*** getMillis();
	*** getMinutes();
	*** getMonth();
	*** getSeconds();
	*** getTimeOfDay();
	*** getYear();
	*** getZone();
	*** getZoneOffset();
	*** isDaylightTime();
	*** isLeapYear();
	*** isNormalized();
	*** isStandardTime();
	*** setDate(int,int,int);
	*** setDayOfMonth(int);
	*** setDayOfWeek(int);
	*** setDaylightSaving(int);
	*** setEra(sun.util.calendar.Era);
	*** setHours(int);
	*** setLeapYear(boolean);
	*** setMillis(int);
	*** setMinutes(int);
	*** setMonth(int);
	*** setNormalized(boolean);
	*** setSeconds(int);
	*** setTimeOfDay(int,int,int,int);
	*** setTimeOfDay(long);
	*** setYear(int);
	*** setZone(java.util.TimeZone);
	*** setZoneOffset(int);
}

-keep class sun.util.calendar.CalendarSystem {
	*** GREGORIAN_INSTANCE;
	*** calendars;
	*** initialized;
	*** namePairs;
	*** names;
	sun.util.calendar.CalendarSystem();
	*** forName(java.lang.String);
	*** getCalendarDate(long,java.util.TimeZone);
	*** getCalendarDate(long,sun.util.calendar.CalendarDate);
	*** getGregorianCalendar();
	*** getTime(sun.util.calendar.CalendarDate);
	*** initNames();
	*** newCalendarDate();
	*** newCalendarDate(java.util.TimeZone);
	*** normalize(sun.util.calendar.CalendarDate);
	*** validate(sun.util.calendar.CalendarDate);
}

-keep class sun.util.calendar.CalendarUtils {
	*** floorDivide(int,int);
	*** floorDivide(int,int,int[]);
	*** floorDivide(long,long);
	*** isGregorianLeapYear(int);
	*** isJulianLeapYear(int);
	*** mod(int,int);
	*** mod(long,long);
	*** sprintf0d(java.lang.StringBuffer,int,int);
	*** sprintf0d(java.lang.StringBuilder,int,int);
}

-keep class sun.util.calendar.Era {
	*** equals(java.lang.Object);
	*** getName();
	*** hashCode();
}

-keep class sun.util.calendar.Gregorian {
	*** getCalendarDate();
	*** getCalendarDate(long);
	*** getCalendarDate(long,java.util.TimeZone);
	*** getCalendarDate(long,sun.util.calendar.CalendarDate);
	*** newCalendarDate();
	*** newCalendarDate(java.util.TimeZone);
}

-keep class sun.util.calendar.JulianCalendar {
	*** getCalendarDateFromFixedDate(sun.util.calendar.CalendarDate,long);
	*** getFixedDate(int,int,int,sun.util.calendar.BaseCalendar$Date);
	*** newCalendarDate(java.util.TimeZone);
}

-keep class sun.util.calendar.LocalGregorianCalendar {
	*** getLocalGregorianCalendar(java.lang.String);
}

-keep class sun.util.calendar.TzIDOldMapping {
	*** MAP;
}

-keep class sun.util.calendar.ZoneInfo {
	*** USE_OLDMAPPING;
	*** aliasTable;
	*** checksum;
	*** conflictingIDs;
	*** dirty;
	*** dstSavings;
	*** gcal;
	*** lastRule;
	*** offsets;
	*** rawOffset;
	*** rawOffsetDiff;
	*** simpleTimeZoneParams;
	*** transitions;
	*** willGMTOffsetChange;
	sun.util.calendar.ZoneInfo(java.lang.String,int,int,int,long[],int[],int[],boolean);
	*** clone();
	*** getAliasTable();
	*** getAvailableIDs();
	*** getAvailableIDs(int);
	*** getCachedAliasTable();
	*** getLastRawOffset();
	*** getLastRule();
	*** getLastRuleInstance();
	*** getOffsets(long,int[]);
	*** getOffsets(long,int[],int);
	*** getOffsetsByStandard(long,int[]);
	*** getOffsetsByWall(long,int[]);
	*** getRawOffset();
	*** getTimeZone(java.lang.String);
	*** getTransitionIndex(long,int);
	*** isDirty();
	*** useDaylightTime();
}

-keep class sun.util.calendar.ZoneInfoFile {
	*** GMT;
	*** JAVAZI_LABEL;
	*** JAVAZI_LABEL_LENGTH;
	*** JAVAZM_LABEL;
	*** JAVAZM_LABEL_LENGTH;
	*** excludedIDs;
	*** hasNoExcludeList;
	*** rawOffsetIndices;
	*** rawOffsets;
	*** ziDir;
	*** zoneIDs;
	*** zoneInfoMappings;
	*** zoneInfoObjects;
	*** access$000();
	*** addToCache(java.lang.String,sun.util.calendar.ZoneInfo);
	*** createZoneInfo(java.lang.String);
	*** getCustomTimeZone(java.lang.String,int);
	*** getExcludedZones();
	*** getFileName(java.lang.String);
	*** getFromCache(java.lang.String);
	*** getRawOffsetIndices();
	*** getRawOffsets();
	*** getZoneAliases();
	*** getZoneIDs();
	*** getZoneInfo(java.lang.String);
	*** getZoneInfoMappings();
	*** readZoneInfoFile(java.lang.String);
	*** toCustomID(int);
}

-keep class sun.util.calendar.ZoneInfoFile$1 {
	*** run();
}

-keep class sun.util.calendar.ZoneInfoFile$2 {
	*** val$fileName;
}

-keep class sun.util.locale.BaseLocale {
	*** getLanguage();
	*** getRegion();
	*** getScript();
	*** getVariant();
}

-keep class sun.util.locale.BaseLocale$Cache {
	*;
}

-keep class sun.util.locale.BaseLocale$Key {
	*;
}

-keep class sun.util.locale.Extension {
	*** id;
	*** key;
	*** value;
	sun.util.locale.Extension(char);
	sun.util.locale.Extension(char,java.lang.String);
	*** getID();
	*** getKey();
	*** getValue();
	*** setValue(java.lang.String);
	*** toString();
}

-keep class sun.util.locale.InternalLocaleBuilder {
	*** removePrivateuseVariant(java.lang.String);
}

-keep class sun.util.locale.InternalLocaleBuilder$CaseInsensitiveChar {
	*** value();
}

-keep class sun.util.locale.InternalLocaleBuilder$CaseInsensitiveString {
	*** value();
}

-keep class sun.util.locale.LanguageTag {
	*** isExtensionSingletonChar(char);
	*** isPrivateusePrefixChar(char);
}

-keep class sun.util.locale.LocaleExtensions {
	*** $assertionsDisabled;
	*** CALENDAR_JAPANESE;
	*** NUMBER_THAI;
	*** extensionMap;
	*** id;
	*** toID(java.util.SortedMap);
}

-keep class sun.util.locale.LocaleObjectCache {
	sun.util.locale.LocaleObjectCache();
	*** get(java.lang.Object);
}

-keep class sun.util.locale.LocaleObjectCache$CacheEntry {
	*;
}

-keep class sun.util.locale.LocaleUtils {
	*** isAlphaNumericString(java.lang.String);
	*** isEmpty(java.util.Map);
	*** isEmpty(java.util.Set);
	*** toLower(char);
	*** toLowerString(java.lang.String);
}

-keep class sun.util.locale.UnicodeLocaleExtension {
	*** CA_JAPANESE;
	*** NU_THAI;
	*** attributes;
	*** keywords;
	*** getUnicodeLocaleAttributes();
	*** getUnicodeLocaleKeys();
	*** getUnicodeLocaleType(java.lang.String);
	*** isKey(java.lang.String);
}

-keep class sun.util.logging.LoggingProxy {
	*** getLevel(java.lang.Object);
	*** getLevelName(java.lang.Object);
	*** getLevelValue(java.lang.Object);
	*** getLogger(java.lang.String);
	*** getLoggerLevel(java.lang.String);
	*** getLoggerNames();
	*** getParentLoggerName(java.lang.String);
	*** getProperty(java.lang.String);
	*** isLoggable(java.lang.Object,java.lang.Object);
	*** log(java.lang.Object,java.lang.Object,java.lang.String);
	*** log(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Object[]);
	*** log(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Throwable);
	*** parseLevel(java.lang.String);
	*** setLevel(java.lang.Object,java.lang.Object);
	*** setLoggerLevel(java.lang.String,java.lang.String);
}

-keep class sun.util.logging.LoggingSupport {
	*** proxy;
	*** ensureAvailable();
	*** getLevel(java.lang.Object);
	*** getLevelName(java.lang.Object);
	*** getLevelValue(java.lang.Object);
	*** getLogger(java.lang.String);
	*** getSimpleFormat();
	*** getSimpleFormat(boolean);
	*** isAvailable();
	*** isLoggable(java.lang.Object,java.lang.Object);
	*** log(java.lang.Object,java.lang.Object,java.lang.String);
	*** log(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Object[]);
	*** log(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Throwable);
	*** parseLevel(java.lang.String);
	*** setLevel(java.lang.Object,java.lang.Object);
}

-keep class sun.util.logging.LoggingSupport$1 {
	*** run();
}

-keep class sun.util.logging.LoggingSupport$2 {
	*** run();
}

-keep class sun.util.logging.PlatformLogger {
	*** DEFAULT_LEVEL;
	*** javaLoggerProxy;
	*** loggerProxy;
	*** loggers;
	*** loggingEnabled;
	*** access$000();
	*** config(java.lang.String);
	*** fine(java.lang.String);
	*** fine(java.lang.String,java.lang.Object[]);
	*** fine(java.lang.String,java.lang.Throwable);
	*** finer(java.lang.String);
	*** finer(java.lang.String,java.lang.Object[]);
	*** finest(java.lang.String);
	*** finest(java.lang.String,java.lang.Object[]);
	*** getLogger(java.lang.String);
	*** info(java.lang.String);
	*** info(java.lang.String,java.lang.Throwable);
	*** isLoggable(int);
	*** isLoggable(sun.util.logging.PlatformLogger$Level);
	*** redirectPlatformLoggers();
	*** redirectToJavaLoggerProxy();
	*** warning(java.lang.String);
}

-keep class sun.util.logging.PlatformLogger$1 {
	*** run();
}

-keep class sun.util.logging.PlatformLogger$DefaultLoggerProxy {
	*** date;
	*** effectiveLevel;
	*** formatString;
	*** level;
	*** deriveEffectiveLevel(sun.util.logging.PlatformLogger$Level);
	*** format(sun.util.logging.PlatformLogger$Level,java.lang.String,java.lang.Throwable);
	*** formatMessage(java.lang.String,java.lang.Object[]);
	*** getCallerInfo();
	*** isLoggable(sun.util.logging.PlatformLogger$Level);
	*** outputStream();
}

-keep class sun.util.logging.PlatformLogger$JavaLoggerProxy {
	*** javaLogger;
	sun.util.logging.PlatformLogger$JavaLoggerProxy(java.lang.String,sun.util.logging.PlatformLogger$Level);
	*** isLoggable(sun.util.logging.PlatformLogger$Level);
}

-keep class sun.util.logging.PlatformLogger$Level {
	*** $VALUES;
	*** ALL;
	*** CONFIG;
	*** FINE;
	*** FINER;
	*** FINEST;
	*** INFO;
	*** OFF;
	*** SEVERE;
	*** WARNING;
	*** javaLevel;
	*** levelValues;
	*** intValue();
	*** valueOf(int);
	*** valueOf(java.lang.String);
	*** values();
}

-keep class sun.util.logging.PlatformLogger$LoggerProxy {
	*** name;
	sun.util.logging.PlatformLogger$LoggerProxy(java.lang.String);
	*** doLog(sun.util.logging.PlatformLogger$Level,java.lang.String);
	*** doLog(sun.util.logging.PlatformLogger$Level,java.lang.String,java.lang.Object[]);
	*** doLog(sun.util.logging.PlatformLogger$Level,java.lang.String,java.lang.Throwable);
	*** getLevel();
	*** isEnabled();
	*** isLoggable(sun.util.logging.PlatformLogger$Level);
	*** setLevel(sun.util.logging.PlatformLogger$Level);
}

-keep class sun.util.resources.LocaleData {
	*** createLocaleList();
	*** getAvailableLocales();
	*** getBundle(java.lang.String,java.util.Locale);
	*** getCalendarData(java.util.Locale);
	*** getCurrencyNames(java.util.Locale);
	*** getDateFormatData(java.util.Locale);
	*** getNumberFormatData(java.util.Locale);
	*** getTimeZoneNames(java.util.Locale);
	*** isNonEuroLangSupported();
}

-keep class sun.util.resources.LocaleData$1 {
	*** val$baseName;
	*** val$locale;
	*** run();
}

-keep class sun.util.resources.LocaleData$AvailableLocales {
	*** localeList;
}

-keep class sun.util.resources.LocaleData$LocaleDataResourceBundleControl {
	*** rbControlInstance;
	*** getRBControlInstance();
}

-keep class sun.util.resources.LocaleNamesBundle {
	sun.util.resources.LocaleNamesBundle();
}

-keep class sun.util.resources.OpenListResourceBundle {
	*** lookup;
	sun.util.resources.OpenListResourceBundle();
	*** createMap(int);
	*** getContents();
	*** getKeys();
	*** getParent();
	*** handleGetKeys();
	*** handleGetObject(java.lang.String);
	*** loadLookup();
	*** loadLookupTablesIfNecessary();
}

-keep class sun.util.resources.TimeZoneNamesBundle {
	sun.util.resources.TimeZoneNamesBundle();
}

-keep class udt.UDPEndPoint {
	*** doSend(udt.UDTPacket);
}

-keep class udt.UDTInputStream {
	*** haveNewData(long,byte[]);
}

-keep class udt.UDTPacket {
	*** getControlPacketType();
	*** isControlPacket();
}

-keep class udt.UDTReceiver {
	*** IDLE_TIMEOUT;
	*** ackHistoryWindow;
	*** ackInterval;
	*** ackSequenceNumber;
	*** ackTimerInterval;
	*** bufferSize;
	*** connectionExpiryDisabled;
	*** dataPacketInterval;
	*** dataProcessTime;
	*** dgReceiveInterval;
	*** dropRate;
	*** endpoint;
	*** estimateLinkCapacity;
	*** expCount;
	*** expTimerInterval;
	*** handoffQueue;
	*** largestAcknowledgedAckNumber;
	*** largestReceivedSeqNumber;
	*** lastAckNumber;
	*** lastDataPacketArrivalTime;
	*** logger;
	*** n;
	*** nakTimerInterval;
	*** nextACK;
	*** nextEXP;
	*** nextNAK;
	*** packetArrivalSpeed;
	*** packetHistoryWindow;
	*** packetPairWindow;
	*** processTime;
	*** receiverLossList;
	*** receiverThread;
	*** roundTripTime;
	*** roundTripTimeVar;
	*** session;
	*** sessionUpSince;
	*** statistics;
	*** stopped;
	*** storeStatistics;
	*** buildLightAcknowledgement(long);
	*** initMetrics();
	*** onAck2PacketReceived(udt.packets.Acknowledgment2);
	*** onDataPacketReceived(udt.packets.DataPacket);
	*** onShutdown();
	*** processACKEvent(boolean);
	*** processEXPEvent();
	*** processNAKEvent();
	*** processUDTPacket(udt.UDTPacket);
	*** sendAcknowledgment(long);
	*** sendKeepAlive();
	*** sendLightAcknowledgment(long);
	*** sendNAK(java.util.List);
	*** sendNAK(long);
	*** sendShutdown();
	*** start();
	*** stop();
}

-keep class udt.UDTSender {
	*** haveLostPackets();
	*** putUnacknowledgedPacketsIntoLossList();
}

-keep class udt.UDTSession {
	*** getDestination();
	*** getFlowWindowSize();
	*** getInitialSequenceNumber();
	*** getReceiveBufferSize();
	*** getSocket();
	*** getStatistics();
	*** isReady();
}

-keep class udt.UDTSocket {
	*** close();
	*** getInputStream();
	*** getSender();
}

-keep class udt.packets.Acknowledgement {
	*** setBufferSize(long);
	*** setEstimatedLinkCapacity(long);
	*** setNexttoPrevPktSeqNO(long);
	*** setPacketReceiveRate(long);
	*** setRoundTripTime(long);
	*** setRoundTripTimeVar(long);
}

-keep class udt.packets.ControlPacket {
	*** getAckSequenceNumber();
	*** getControlPacketType();
	*** setAckSequenceNumber(long);
	*** setDestinationID(long);
	*** setSession(udt.UDTSession);
}

-keep class udt.packets.ControlPacket$ControlPacketType {
	*** ACK;
	*** ACK2;
	*** NAK;
}

-keep class udt.packets.DataPacket {
	*** getData();
	*** getPacketSequenceNumber();
}

-keep class udt.packets.Destination {
	*** getSocketID();
}

-keep class udt.packets.NegativeAcknowledgement {
	*** addLossInfo(java.util.List);
	*** addLossInfo(long,long);
}

-keep class udt.receiver.AckHistoryEntry {
	*** getAckNumber();
	*** getAge();
}

-keep class udt.receiver.AckHistoryWindow {
	*** getEntry(long);
	*** getTime(long);
}

-keep class udt.receiver.PacketHistoryWindow {
	*** getPacketArrivalSpeed();
}

-keep class udt.receiver.PacketPairWindow {
	*** getEstimatedLinkCapacity();
}

-keep class udt.receiver.ReceiverLossList {
	*** getFilteredSequenceNumbers(long,boolean);
	*** getFirstEntry();
	*** insert(udt.receiver.ReceiverLossListEntry);
	*** remove(long);
}

-keep class udt.receiver.ReceiverLossListEntry {
	*** getSequenceNumber();
}

-keep class udt.util.CircularArray {
	*** add(java.lang.Object);
}

-keep class udt.util.MeanValue {
	*** begin();
	*** end();
}

-keep class udt.util.UDTStatistics {
	*** addMetric(udt.util.MeanValue);
	*** incNumberOfACKSent();
	*** incNumberOfNAKSent();
	*** incNumberOfReceivedDataPackets();
	*** setPacketArrivalRate(long,long);
	*** setRTT(long,long);
}

-keep class udt.util.UDTThreadFactory {
	*** get();
	*** newThread(java.lang.Runnable);
}

-keep class udt.util.Util {
	*** getCurrentTime();
	*** getSYNTime();
}

