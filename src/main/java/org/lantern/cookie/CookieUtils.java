package org.lantern.cookie; 

import com.google.common.net.HostSpecifier;
import com.google.common.net.InetAddresses;
import com.google.common.net.InternetDomainName;
import java.net.IDN;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import org.jboss.netty.handler.codec.http.Cookie; 
import org.jboss.netty.handler.codec.http.DefaultCookie;
import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpVersion;

/**
 * Utilities related to browser-like cookie logic
 * mostly derived from RFC 6265
 */
public class CookieUtils {

    
    /**
     * @return true if and only if it is legitimate to send the 
     * StoredCookie given to the requestUri given according to 
     * RFC 6265 Section 5.4.1
     */
    public static boolean canBeSent(final StoredCookie cookie, final URI requestUri) {

        final String canonicalHost = canonicalizeHost(requestUri.getHost());
        final String canonicalDomain = canonicalizeHost(cookie.getDomain());

        // RFC 6265 requires ALL of the following be true: 
        
        // *  Either:
        // 
        //       The cookie's host-only-flag is true and the canonicalized
        //       request-host is identical to the cookie's domain.
        // 
        if (cookie.isHostOnly()) {
            if (!canonicalHost.equals(canonicalDomain)) {
                return false;
            }
        }
        //    Or:
        // 
        //       The cookie's host-only-flag is false and the canonicalized
        //       request-host domain-matches the cookie's domain.
        //
        else {
            if (!domainMatches(canonicalDomain, canonicalHost)) {
                return false;
            }
        }

        // 
        // *  The request-uri's path path-matches the cookie's path.
        //
        if (!pathMatches(cookie.getPath(), requestUri.getPath())) {
            return false;
        }

        // 
        // *  If the cookie's secure-only-flag is true, then the request-
        //    uri's scheme must denote a "secure" protocol (as defined by
        //    the user agent).
        // 
        if (cookie.isSecure()) {
            // [ possibly there is something else to think about here, 
            // but in general, if we're able to consider it, 
            // we're doing so on an "insecure" channel. So anything
            // that was marked as secure by whatever means should not be
            // sent by lantern. Actual secure cookies will be invisible to us
            // end-to-end. ] 
            return false; 
        }

        // *  If the cookie's http-only-flag is true, then exclude the
        //    cookie if the cookie-string is being generated for a "non-
        //    HTTP" API (as defined by the user agent).
        
        // [ not sure there is anything to consider here ]

        return true; 
    
    }

    /**
     * @return true if and only if the cookie Domain setting 
     * matches the given hostname according to RFC 6265 Section 5.1.3
     *
     * @param cookieDomain canonical cookie domain
     * @param hostname canonical hostname to path match against cookieDomain
     */
    public static boolean domainMatches(final String cookieDomain, final String hostname) {
        
        // A string domain-matches a given domain string if at least one of the
        // following conditions hold:
        // 
        // o  The domain string and the string are identical.  (Note that both
        //    the domain string and the string will have been canonicalized to
        //    lower case at this point.)        
        if (cookieDomain.equals(hostname)) {
            return true;
        }

        // o  All of the following conditions hold:
        // 
        //    *  The domain string is a suffix of the string.
        // 
        //    *  The last character of the string that is not included in the
        //       domain string is a %x2E (".") character.
        // 
        //    *  The string is a host name (i.e., not an IP address).
        if (!hostname.endsWith(cookieDomain) ||
            hostname.charAt(hostname.length() - cookieDomain.length() - 1) != '.' ||
            InetAddresses.isInetAddress(hostname)) {
            return false;
        }

        return true;    
    }
    
    /**
     * return a canonical form of the hostname given 
     * suitable for matching and domain matching in 
     * RFC6265 as described in Section 5.1.2
     *
     */
    public static String canonicalizeHost(final String host) {

        // TODO RFC6265 Section 5.1.2 
        //        
        // A canonicalized host name is the string generated by the following
        // algorithm:
        // 
        //   1.  Convert the host name to a sequence of individual domain name
        //       labels.
        // 
        //   2.  Convert each label that is not a Non-Reserved LDH (NR-LDH) label,
        //       to an A-label (see Section 2.3.2.1 of [RFC5890] for the former
        //       and latter), or to a "punycode label" (a label resulting from the
        //       "ToASCII" conversion in Section 4 of [RFC3490]), as appropriate
        //       (see Section 6.3 of this specification).
        // 
        //   3.  Concatenate the resulting labels, separated by a %x2E (".")
        //       character.

        // [ java.net.IDN.toASCII supports full hostnames and RFC3490 ]
        return IDN.toASCII(host).toLowerCase();
    }

    /**
     * @return true if and only if the Path setting of the given cookie
     * matches the given request path according to RFC 6265 Section 5.1.4
     *
     */
    public static boolean pathMatches(final String cookiePath, final String requestPath) {
        // A request-path path-matches a given cookie-path if at least one of
        // the following conditions holds:

        // o  The cookie-path and the request-path are identical.
        if (cookiePath.equals(requestPath)) {
            return true; 
        }

        // o  The cookie-path is a prefix of the request-path, and the last
        //    character of the cookie-path is %x2F ("/").
        //
        // o  The cookie-path is a prefix of the request-path, and the first
        //    character of the request-path that is not included in the cookie-
        //    path is a %x2F ("/") character.            
        if (requestPath.startsWith(cookiePath) && 
            (cookiePath.endsWith("/") || requestPath.charAt(cookiePath.length()) == '/')) {
            return true;
        }

        return false;
    }

    /**
     * @return true if and only if the domain given consititues a "public suffix" such as .com .co.uk etc.
     * @see http://publicsuffix.org 
     *
     */
    public static boolean isPublicSuffix(final String domain) {
        // consult guava's implementation of the public suffix list
        try {
            return InternetDomainName.fromLenient(domain).isPublicSuffix();
        }
        catch (IllegalArgumentException e) {
            // not a valid hostname
            return false;
        }
    }

    public static String normalizedSetCookieDomain(final String domain) {
        
        // RFC 6265 Section 5.2.3

        // If the attribute-value is empty, the behavior is undefined.  However,
        // the user agent SHOULD ignore the cookie-av entirely.
        //
        if (domain == null || domain.equals("")) {
            return null;
        }
        
        // If the first character of the attribute-value string is %x2E ("."):
        // 
        //    Let cookie-domain be the attribute-value without the leading %x2E
        //    (".") character.
        // 
        else if (domain.startsWith(".")) {
            return domain.substring(1).toLowerCase();
        }

        //
        // Otherwise:
        // 
        //    Let cookie-domain be the entire attribute-value.
        // 
        // Convert the cookie-domain to lower case.

        else {
            return domain.toLowerCase();
        }
    }

    public static String normalizedSetCookiePath(final String path, final URI originUri) {
        // RFC 6265 Section 5.2.4

        // If the attribute-value is empty or if the first character of the
        // attribute-value is not %x2F ("/"):
        // 
        //    Let cookie-path be the default-path.
        if (path == null || path.equals("") || path.charAt(0) != '/') {
            return defaultSetCookiePath(originUri);
        }

        // 
        // Otherwise:
        // 
        //    Let cookie-path be the attribute-value.
        // 
        return path;
    }
    

    /**
     * Compute the default Path for a cookie sent from the given originUri 
     * according to RFC 6265 Section 5.1.4
     *
     */
    public static String defaultSetCookiePath(final URI requestUri) {

        // 1.  Let uri-path be the path portion of the request-uri if such a
        //     portion exists (and empty otherwise).  For example, if the
        //     request-uri contains just a path (and optional query string),
        //     then the uri-path is that path (without the %x3F ("?") character
        //     or query string), and if the request-uri contains a full
        //     absoluteURI, the uri-path is the path component of that URI.
        final String uriPath = requestUri.getPath();

        // 2.  If the uri-path is empty or if the first character of the uri-
        //     path is not a %x2F ("/") character, output %x2F ("/") and skip
        //     the remaining steps.
        if (uriPath == null || uriPath.equals("") || uriPath.charAt(0) != '/') {
            return "/";
        }

        // 3.  If the uri-path contains no more than one %x2F ("/") character,
        //     output %x2F ("/") and skip the remaining step.
        int lastSlash = uriPath.lastIndexOf('/');
        if (lastSlash <= 0) { // already verified it starts with "/" so this indicates 1 / only. 
            return "/";
        }

        // 4.  Output the characters of the uri-path from the first character up
        //     to, but not including, the right-most %x2F ("/").
        return uriPath.substring(0, lastSlash);        
    }
    
    /**
     * create a URI that may be a URL with unicode in the hostname. 
     * If so, first convert the hostname to A-Labels via RFC 3490.
     * Works around an issue with constructing URIs with urls 
     * containing unicode hostnames.
     */
    public static URI makeSafeURI(final String uri) throws URISyntaxException {
        try {
            final URL url = new URL(uri);
            final String safeHost = IDN.toASCII(url.getHost());
            if (safeHost.equals(url.getHost())) {
                return new URI(uri);
            }
            else {
                // construct a URL String with the IDN.toASCII version 
                // of the host (A-Labels)
                
                // there is no general way to re-construct or modify 
                // a URL or URI other than by completely re-represeting it a
                // String and calling the single String constructor.
                // All other constructors are mainly intended to test the 
                // patience of developers. 
                final StringBuffer newURL = new StringBuffer();
                newURL.append(url.getProtocol());
                newURL.append("://");
                if (url.getUserInfo() != null) {
                    newURL.append(url.getUserInfo());
                    newURL.append("@"); 
                }
                newURL.append(safeHost);
                if (url.getPort() != -1) {
                    newURL.append(":" + url.getPort());
                }
                newURL.append(url.getFile());
                if (url.getRef() != null) {
                    newURL.append("#");
                    newURL.append(url.getRef());
                }
                return new URI(newURL.toString());
            }
        }
        catch (MalformedURLException e) {
            // not a url.. who knows maybe we're making a request to 
            // an isbn number, just do our best...
            return new URI(uri);
        }
    }
    
    /**
     * @return a new HttpRequest with the same basic info as the given request.
     * 
     * includes version, method uri and headers. *This does not copy content* 
     */ 
    public static HttpRequest copyHttpRequestInfo(HttpRequest toCopy) {
        final HttpVersion ver = toCopy.getProtocolVersion();
        final HttpVersion verCopy = new HttpVersion(ver.getText(), ver.isKeepAliveDefault());
        final DefaultHttpRequest request = new DefaultHttpRequest(verCopy, toCopy.getMethod(), toCopy.getUri());
        
        // copy request headers
        for (String headerName : toCopy.getHeaderNames()) {
            request.setHeader(headerName, toCopy.getHeaders(headerName));
        }

        return request;
    }

    public static class RFC6265SetCookieFilter implements CookieFilter {
        
        String canonicalHostname;
        
        public RFC6265SetCookieFilter(HttpRequest context) {
            try {
                final URI requestUri = makeSafeURI(context.getUri());
                canonicalHostname = canonicalizeHost(requestUri.getHost());
            }
            catch (URISyntaxException e) {
                canonicalHostname = null;
            }
        }

        /**
         * @return true if and only if the Cookie given can be legitimately set on a request
         * to the URI of the request context according to the Cookie's domain setting
         * and RFC 6265 Section 5.3
         * 
         * eg you cannot set a Cookie on facebook.com when making a 
         * request to http://malicious.example.com/ etc.
         *
         */
        @Override
        public boolean accepts(final Cookie cookie) {

            //
            // Rejection steps from RFC 6265 Sections 5.3.5-5.3.6
            // 
            // netty / lantern does not exactly follow the parsing and processing model 
            // of RFC 6265, which requires rejecting cookies on certain bases during 
            // parsing.  Instead, those considerations are collected here and make
            // certain equivalent rejections.
            // 
            // Other normalization is expected to have been carried out, minus 
            // the immediate rejection steps, @see StoredCookie.fromSetCookie
            // 
            if (!(cookie instanceof StoredCookie) || canonicalHostname == null) {
                return false; 
            }

            final StoredCookie storedCookie = (StoredCookie) cookie;

            final String canonicalDomain = canonicalizeHost(storedCookie.getDomain());

            // if the cookie is host-only, only exact matches are permitted 
            // between the host. Interestingly, it is allowed to be a public suffix 
            // in this exact match case as, strangely, some are also websites. X_x
            if (storedCookie.isHostOnly()) {
                return canonicalDomain.equals(canonicalHostname);
            }

            // if it is not host-only, it must domain match.
            if (!domainMatches(canonicalDomain, canonicalHostname)) {
                return false;
            }

            // cannot be a public suffix unless host-only.
            if (isPublicSuffix(canonicalDomain)) {
                return false;
            }

            return true;
        }
                
    }

    
    /**
     * creates a cookie filter factory that always returns the same
     * object.
     */
    public static CookieFilter.Factory dummyCookieFilterFactory(final CookieFilter f) {
        return new CookieFilter.Factory() {
            @Override
            public CookieFilter createCookieFilter(final HttpRequest req) {
                return f;
            }
        };
    }
    
}