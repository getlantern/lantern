package context

import (
	"sync"
)

var (
	contexts = make(map[uint64]*Context)
	global   = make(Map)

	allmx sync.RWMutex
)

// Contextual is an interface for anything that maintains its own context.
type Contextual interface {
	// Fill fills the given Map with all of this Contextual's context
	Fill(m Map)
}

// Map is a map of key->value pairs.
type Map map[string]interface{}

// Fill implements the method from the Contextual interface.
func (_m Map) Fill(m Map) {
	for key, value := range _m {
		m[key] = value
	}
}

// Context is a context containing key->value pairs
type Context struct {
	id           uint64
	parent       *Context
	branchedFrom *Context
	data         Map
	mx           sync.RWMutex
}

type dynval struct {
	fn func() interface{}
}

// Enter enters a new level on the current Context stack, creating a new Context
// if necessary.
func Enter() *Context {
	id := curGoroutineID()
	allmx.Lock()
	c := contexts[id]
	if c == nil {
		c = makeContext(id, nil, nil)
		contexts[id] = c
		allmx.Unlock()
		return c
	}
	allmx.Unlock()
	return c.Enter()
}

// Enter enters a new level on this Context stack.
func (c *Context) Enter() *Context {
	c.mx.RLock()
	id := c.id
	c.mx.RUnlock()
	next := makeContext(id, c, nil)
	allmx.Lock()
	contexts[id] = next
	allmx.Unlock()
	return next
}

// Go starts the given function on a new goroutine.
func (c *Context) Go(fn func()) {
	go func() {
		id := curGoroutineID()
		next := makeContext(id, nil, c)
		allmx.Lock()
		contexts[id] = next
		allmx.Unlock()
		fn()
		// Clean up the context
		allmx.Lock()
		delete(contexts, id)
		allmx.Unlock()
	}()
}

// Go starts the given function on a new goroutine but sharing the context of
// the current goroutine (if it has one).
func Go(fn func()) {
	c := currentContext()
	if c != nil {
		c.Go(fn)
	} else {
		go fn()
	}
}

func makeContext(id uint64, parent *Context, branchedFrom *Context) *Context {
	return &Context{
		id:           id,
		parent:       parent,
		branchedFrom: branchedFrom,
		data:         make(Map),
	}
}

// Exit exits the current level on this Context stack.
func (c *Context) Exit() *Context {
	c.mx.RLock()
	id := c.id
	parent := c.parent
	c.mx.RUnlock()
	if parent == nil {
		allmx.Lock()
		delete(contexts, id)
		allmx.Unlock()
		return nil
	}
	allmx.Lock()
	contexts[id] = parent
	allmx.Unlock()
	return parent
}

// Put puts a key->value pair into the current level of the context stack.
func (c *Context) Put(key string, value interface{}) *Context {
	c.mx.Lock()
	c.data[key] = value
	c.mx.Unlock()
	return c
}

// PutGlobal puts the given key->value pair into the globalc context.
func PutGlobal(key string, value interface{}) {
	allmx.Lock()
	global[key] = value
	allmx.Unlock()
}

// PutDynamic puts a key->value pair into the current level of the context stack
// where the value is generated by a function that gets evaluated at every Read.
func (c *Context) PutDynamic(key string, valueFN func() interface{}) *Context {
	value := &dynval{valueFN}
	c.mx.Lock()
	c.data[key] = value
	c.mx.Unlock()
	return c
}

// PutGlobalDynamic puts a key->value pair into the global context wwhere the value is
// generated by a function that gets evaluated at every Read.
func PutGlobalDynamic(key string, valueFN func() interface{}) {
	value := &dynval{valueFN}
	allmx.Lock()
	global[key] = value
	allmx.Unlock()
}

// AsMap returns a map containing all values along the stack.
func (c *Context) AsMap() Map {
	m := make(Map)
	c.fill(m)
	return m
}

func (c *Context) fill(m Map) {
	for ctx := c; ctx != nil; {
		ctx.mx.RLock()
		fill(m, ctx.data)
		next := ctx.parent
		if next == nil {
			next = ctx.branchedFrom
		}
		ctx.mx.RUnlock()
		ctx = next
	}
}

// AsMap returns a map containing all values along the stack, including globals.
func AsMap() Map {
	result := AsMapWithoutGlobals()
	allmx.RLock()
	fill(result, global)
	allmx.RUnlock()
	return result
}

// AsMapWithoutGlobals is like AsMap but doesn't include globals.
func AsMapWithoutGlobals() Map {
	c := currentContext()
	if c == nil {
		return make(Map)
	}
	return c.AsMap()
}

// AsMapWith returns a map containing all values from the supplied Contextrual
// plus any addition values from along the stack, including globals.
func AsMapWith(cl Contextual) Map {
	result := make(Map, 0)
	cl.Fill(result)
	c := currentContext()
	if c != nil {
		c.fill(result)
	}
	allmx.RLock()
	fill(result, global)
	allmx.RUnlock()
	return result
}

func fill(m Map, from Map) {
	if m != nil {
		for key, value := range from {
			_, alreadyRead := m[key]
			if !alreadyRead {
				switch v := value.(type) {
				case *dynval:
					m[key] = v.fn()
				default:
					m[key] = v
				}
			}
		}
	}
}

func currentContext() *Context {
	id := curGoroutineID()
	allmx.RLock()
	c := contexts[id]
	allmx.RUnlock()
	return c
}
